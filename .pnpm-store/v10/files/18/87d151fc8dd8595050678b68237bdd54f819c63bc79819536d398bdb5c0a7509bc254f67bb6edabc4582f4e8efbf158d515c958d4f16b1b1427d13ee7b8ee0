import e from"node:path";const t=({file:e,modulePath:t,symbol:n,symbolFile:r})=>{let i=[],a=[],o={aliases:{},from:t};if(n.meta?.importKind&&(n.meta.importKind===`default`?(o.defaultBinding=n.placeholder,n.meta.kind===`type`&&(o.typeDefaultBinding=!0)):n.meta.importKind===`namespace`&&(o.namespaceBinding=n.placeholder,n.meta.kind===`type`&&(o.typeNamespaceBinding=!0))),n.meta?.importKind===`named`||!i.length&&!o.defaultBinding&&!o.namespaceBinding){let t=n.placeholder,s=e.resolvedNames.get(n.id);if(s){let e=r.resolvedNames.get(n.id);e?e!==s&&(t=e,o.aliases[t]=s):n.name&&s!==n.name&&(t=n.name,o.aliases[t]=n.placeholder)}i.push(t),n.meta?.kind===`type`&&a.push(t)}for(let e of a)i.includes(e)||i.push(e);return o.names=i,o.typeNames=a,o},n=(e,t)=>{e.aliases={...e.aliases,...t.aliases},t.defaultBinding!==void 0&&(e.defaultBinding=t.defaultBinding),e.names=[...new Set([...e.names??[],...t.names??[]])],t.namespaceBinding!==void 0&&(e.namespaceBinding=t.namespaceBinding),t.typeDefaultBinding!==void 0&&(e.typeDefaultBinding=t.typeDefaultBinding),e.typeNames=[...new Set([...e.typeNames??[],...t.typeNames??[]])],t.typeNamespaceBinding!==void 0&&(e.typeNamespaceBinding=t.typeNamespaceBinding)};var r=class{map=new Map;reverse=new Map;delete(e){let t=this.map.get(e);return t!==void 0&&this.reverse.delete(t),this.map.delete(e)}deleteValue(e){let t=this.reverse.get(e);return t!==void 0&&this.map.delete(t),this.reverse.delete(e)}entries(){return this.map.entries()}get(e){return this.map.get(e)}getKey(e){return this.reverse.get(e)}hasKey(e){return this.map.has(e)}hasValue(e){return this.reverse.has(e)}keys(){return this.map.keys()}set(e,t){let n=this.map.get(e);n!==void 0&&n!==t&&this.reverse.delete(n);let r=this.reverse.get(t);return r!==void 0&&r!==e&&this.map.delete(r),this.map.set(e,t),this.reverse.set(t,e),this}get size(){return this.map.size}values(){return this.map.values()}[Symbol.iterator](){return this.map[Symbol.iterator]()}},i=class{_id=0;referenceOrder=new Set;registerOrder=new Set;selectorToId=new Map;values=new Map;get(e){let t=this.idOrSelector(e);if(t.id!==void 0)return this.values.get(t.id);let n=t.selector===void 0?void 0:JSON.stringify(t.selector);if(n){let e=this.selectorToId.get(n);if(e!==void 0)return this.values.get(e)}}get id(){return this._id++}idOrSelector(e){return typeof e==`number`?{id:e}:{selector:e}}isRegistered(e){let t=this.get(e);return t?this.registerOrder.has(t.id):!1}reference(e){let t=this.idOrSelector(e);return this.register(t)}*referenced(){for(let e of this.referenceOrder.values())yield this.values.get(e)}register(e){if(e.id!==void 0){let t=this.values.get(e.id);if(!t)throw Error(`File with ID ${e.id} not found. To register a new file, leave the ID undefined.`);return t}let t=Object.keys(e).some(e=>![`id`,`selector`].includes(e)),n,i=e.selector===void 0?void 0:JSON.stringify(e.selector);if(i){let e=this.selectorToId.get(i);if(e!==void 0){if(n=this.values.get(e),!n)throw Error(`File with ID ${e} not found. The selector ${i} matched an ID, but there was no result. This is likely an issue with the application logic.`);if(!t)return n}}let a=n?.id===void 0?this.id:n.id;return n={...n,...e,id:a,resolvedNames:n?.resolvedNames??new r,symbols:n?.symbols??{body:[],exports:[],imports:[]}},this.values.set(a,n),t?(this.registerOrder.add(a),this.referenceOrder.has(a)&&this.referenceOrder.delete(a)):this.referenceOrder.add(a),i&&this.selectorToId.set(i,a),n}*registered(){for(let e of this.registerOrder.values())yield this.values.get(e)}};const a=e=>`_heyapi_${e}_`,o=e=>e.slice(8,-1),s=()=>new RegExp(a(`\\d+`),`g`),c=(e,t)=>e.replace(s(),e=>t(Number.parseInt(o(e),10))||e);var l=class{_id=0;nodes=new Map;registerOrder=new Set;selectorToId=new Map;values=new Map;get(e){let t=this.idOrSelector(e);if(t.id!==void 0)return this.values.get(t.id);let n=t.selector===void 0?void 0:JSON.stringify(t.selector);if(n){let e=this.selectorToId.get(n);if(e!==void 0)return this.values.get(e)}}getValue(e){return this.nodes.get(e)}hasValue(e){return this.nodes.has(e)}get id(){return this._id++}idOrSelector(e){return typeof e==`number`?{id:e}:{selector:e}}isRegistered(e){let t=this.get(e);return t?this.registerOrder.has(t.id):!1}reference(e){let t=this.idOrSelector(e);return this.register(t)}register(e){if(e.id!==void 0){let t=this.values.get(e.id);if(!t)throw Error(`Symbol with ID ${e.id} not found. To register a new symbol, leave the ID undefined.`);return t}let t=Object.keys(e).some(e=>![`id`,`selector`].includes(e)),n,r=e.selector===void 0?void 0:JSON.stringify(e.selector);if(r){let e=this.selectorToId.get(r);if(e!==void 0){if(n=this.values.get(e),!n)throw Error(`Symbol with ID ${e} not found. The selector ${r} matched an ID, but there was no result. This is likely an issue with the application logic.`);if(!t)return n}}let i=n?.id===void 0?this.id:n.id,o=n?.exportFrom?[...n.exportFrom]:[];return e.exportFrom&&o.push(...e.exportFrom),n={...n,...e,exportFrom:o,id:i,placeholder:n?.placeholder??e.placeholder??a(String(i))},this.values.set(i,n),t&&this.registerOrder.add(i),r&&this.selectorToId.set(r,i),n}*registered(){for(let e of this.registerOrder.values())yield this.values.get(e)}setValue(e,t){return this.nodes.set(e,t)}},u=class{symbolIdToFileIds=new Map;defaultFileName;files=new i;fileName;renderers={};root;symbols=new l;constructor({defaultFileName:e,fileName:t,renderers:n,root:r}){this.defaultFileName=e??`main`,this.fileName=typeof t==`string`?()=>t:t,this.renderers=n,this.root=r}getRenderer(e){return e.extension?this.renderers[e.extension]:void 0}prepareFiles(){for(let e of this.symbols.registered()){let t=this.symbolToFileSelector(e),n=this.files.reference(t);n.symbols.body.push(e.id);let r=this.symbolIdToFileIds.get(e.id)??new Set;r.add(n.id),this.symbolIdToFileIds.set(e.id,r);for(let t of e.exportFrom){let r=[t],i=this.files.reference(r);i.id!==n.id&&i.symbols.exports.push(e.id)}}for(let t of this.files.referenced()){if(!t.selector)continue;if(t.selector[0]===`@`){let n=t.selector[1];if(!n){this.files.register({external:!0,selector:t.selector});continue}let r=e.extname(n);if(!r){this.files.register({external:!0,path:n,selector:t.selector});continue}this.files.register({extension:r,external:!0,path:n,selector:t.selector});continue}let n=t.selector.slice(0,-1),r=t.selector[t.selector.length-1];r=this.fileName?.(r)||r,this.files.register({extension:`.ts`,name:r,path:e.resolve(this.root,...n,`${r}.ts`),selector:t.selector})}}render(e){this.prepareFiles();let t=new Map;for(let n of this.files.registered()){if(n.external||!n.path)continue;let r=this.getRenderer(n);r&&t.set(n.id,{content:r.renderSymbols(n,this,e),path:n.path})}for(let[n,r]of t.entries()){let i=this.files.get(n),a=this.getRenderer(i).renderFile(r.content,i,this,e);a?t.set(i.id,{...r,content:a}):t.delete(i.id)}return Array.from(t.values())}symbolIdToFiles(e){let t=this.symbolIdToFileIds.get(e);return Array.from(t??[]).map(e=>this.files.get(e))}symbolToFileSelector(e){if(e.external)return[`@`,e.external];let t=e.getFilePath?.(e);return t?t.split(`/`):[this.defaultFileName]}};export{u as Project,t as createBinding,n as mergeBindings,c as renderIds};
//# sourceMappingURL=index.js.map