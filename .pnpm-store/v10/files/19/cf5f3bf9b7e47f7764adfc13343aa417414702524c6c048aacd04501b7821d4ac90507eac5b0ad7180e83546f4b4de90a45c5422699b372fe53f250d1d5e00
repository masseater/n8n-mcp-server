{"version":3,"file":"getSpec-CXDbow97.js","names":["__filename","__dirname","path","_config: Config","registryRegExp","getRegistryUrl","parseShorthand","queryParams: string | undefined","registryRegExp","getRegistryUrl","namespace","parseShorthand","defaultWatch: Watch","inputs: Array<Input>","input: Input","logs: Config['logs']","a: Partial<UserConfig>","b: Partial<UserConfig>","merged: UserConfig","valueToObject: ValueToObject","mappers","fields","defaultValue","defaultConfig","Api","meta: Plugin.Name<'@angular/common'>","uniqueItems: Array<IR.SchemaObject>","typeIds: Array<string>","path","result: OperationResponsesMap","errors: Omit<IR.SchemaObject, 'properties'> &\n    Pick<Required<IR.SchemaObject>, 'properties'>","responses: Omit<IR.SchemaObject, 'properties'> &\n    Pick<Required<IR.SchemaObject>, 'properties'>","defaultResponse: IR.ResponseObject | undefined","satisfies: typeof semver.satisfies","base","nodeName","assignment: ObjectAssignment","initializer: ts.Expression | undefined","identifiers","members: Array<ts.EnumMember>","exportType","spans: Array<ts.TemplateLiteralTypeSpan>","namespaceBinding: ImportExportItemObject | undefined","elements: Array<ts.ImportSpecifier>","modifiers: Array<ts.ModifierLike>","heritageClauses: Array<ts.HeritageClause>","path","propertyTypes: Array<ts.TypeNode>","members: Array<ts.TypeElement | ts.MappedTypeNode>","modifiers: readonly ts.Modifier[] | undefined","questionToken: ts.QuestionToken | undefined","type: ts.TypeNode | undefined","modifiers: ReadonlyArray<ts.Modifier> | undefined","nodes: Array<ts.TypeNode>","types.createAnonymousFunction","types.createArrayLiteralExpression","types.createArrowFunction","types.createAsExpression","types.createAssignment","types.createAwaitExpression","transform.createBinaryExpression","types.createBlock","module.createCallExpression","classes.createClassDeclaration","types.createConditionalExpression","module.createConstVariable","classes.createConstructorDeclaration","types.createEnumDeclaration","module.createExportAllDeclaration","module.createNamedExportDeclarations","convert.expressionToStatement","types.createForOfStatement","types.createFunctionTypeNode","types.createGetAccessorDeclaration","utils.createIdentifier","transform.createIfStatement","types.createIndexedAccessTypeNode","utils.isTsNode","types.createKeywordTypeNode","types.createLiteralTypeNode","types.createMappedTypeNode","classes.createMethodDeclaration","module.createNamedImportDeclarations","types.createNamespaceDeclaration","types.createNewExpression","utils.tsNodeToString","types.createNull","types.createObjectType","utils.ots","types.createParameterDeclaration","types.createPropertyAccessExpression","transform.createPropertyAccessExpressions","types.createPropertyAssignment","utils.createPropertyDeclaration","types.createRegularExpressionLiteral","_return.createReturnFunctionCall","_return.createReturnStatement","_return.createReturnVariable","transform.createSafeAccessExpression","types.createStringLiteral","types.createTemplateLiteralType","utils.createThis","transform.createArrayMapTransform","transform.createArrayTransformMutation","transform.createDateTransformMutation","transform.createFunctionTransformMutation","transform.createDateTransformerExpression","types.createTypeAliasDeclaration","typedef.createTypeArrayNode","typedef.createTypeInterfaceNode","typedef.createTypeIntersectionNode","types.createTypeNode","types.createTypeOfExpression","types.createTypeOperatorNode","types.createTypeParameterDeclaration","types.createTypeParenthesizedNode","typedef.createTypeRecordNode","types.createTypeReferenceNode","typedef.createTypeTupleNode","typedef.createTypeUnionNode","types.toExpression","lines: Array<string>","specifiers: Array<ts.ExportSpecifier>","namespaceBinding: string | undefined","finalAlias: string | undefined","name","path","specifiers: Array<ts.ImportSpecifier>","defaultBinding: ts.Identifier | undefined","namedImports: Array<{\n          isTypeOnly: boolean;\n          name: string;\n          propertyName: ts.ModuleExportName | undefined;\n        }>","isTypeOnly","base","imports: Map<string, Binding>","exports: Map<string, Binding>","declIndex: Map<string, number>","walkDeclarations: WalkFn","walkTopological: WalkFn","order: Array<string>","getGroup: GetPointerPriorityFn","walk: WalkFn","matchIrPointerToGroup: MatchPointerToGroupFn<IrTopLevelKind>","patterns: Record<IrTopLevelKind, RegExp>","kind","kindPriority: KindPriority","partial: Partial<KindPriority>","getIrPointerPriority: GetPointerPriorityFn","path","defaultGetKind: Required<Required<Hooks>['operations']>['getKind']","callback: (event: WalkEvent<T>) => void","events: ReadonlyArray<T>","options: WalkOptions<T>","event: WalkEvent | undefined","baseEvent: BaseEvent","symbolIn: SymbolIn","result: EventHooks","base","result: string","path","namespace","keys: Array<string>","regexps: Array<RegExp>","path","filters: Filters","dependencies: Set<string> | undefined","resourceMetadata: ResourceMetadata","path","namespace","base","path","walkSchemas","path","rootEnums: Record<string, unknown>","rootEnumSignatures: Record<string, string>","inlineEnums: Array<{\n    key: string | number | null;\n    node: unknown;\n    parent: unknown;\n    path: ReadonlyArray<string | number>;\n    signature: string;\n  }>","signatureToName: Record<string, string | undefined>","signatureToSchema: Record<string, unknown>","path","childResult: Partial<PointerDependenciesResult>","worklist: Set<string>","graph: Graph","walk","path","deprecated: boolean | undefined","tags: Set<string> | undefined","cache: Cache","path","originals: OriginalSchemas","split: SplitSchemas","deepEqual","walk","path","filterSpec","filtered: typeof spec.definitions","path","contentToSchema","mediaTypeObjects","objects: Array<Content>","values: Array<string>","getSchemaType","parseSchemaJsDoc","parseSchemaMeta","parseArray","schemaItems: Array<IR.SchemaObject>","schemaToIrSchema","parseBoolean","parseNumber","parseObject","schemaProperties: Record<string, IR.SchemaObject>","parseString","initIrSchema","irSchema: IR.SchemaObject","parseAllOf","valueSchemas: ReadonlyArray<IR.SchemaObject>","irDiscriminatorSchema: IR.SchemaObject","parseOneType","nestedItems: Array<IR.SchemaObject>","parseEnum","enumValue","enumType: SchemaType<SchemaObject> | 'null' | undefined","parseRef","irSchema","parseNullableType","typeIrSchema: IR.SchemaObject","parseType","parseUnknown","parseSchema","isPaginationType","paginationField","name","getSchemaType","parseOperationJsDoc","initIrOperation","irOperation: IR.OperationObject","operationToIrOperation","requestBodyObject: IRBodyObject","requestBodyObjectRequired: Array<string>","schema: SchemaObject","mediaTypeObjects","content","paginationField","schemaToIrSchema","contentToSchema","securitySchemeObjects: Map<string, IR.SecurityObject>","irSecuritySchemeObject: IR.SecurityObject | undefined","parsePathOperation","path","defaultExplode","defaultStyle","parametersArrayToObject","parametersObject: IR.ParametersObject","parameterToIrParameter","finalSchema: SchemaObject","paginationField","irParameter: IR.ParameterObject","schemaToIrSchema","errorResponse: Url","path","parseServers","schemes: ReadonlyArray<string>","path","validateOpenApiSpec","issues: Array<ValidatorIssue>","path","validateOpenApiSpec","state: State","path","commonOperation: OperationObject","operationArgs: Omit<\n      Parameters<typeof parsePathOperation>[0],\n      'method'\n    >","parametersArrayToObject","filterSpec","filtered: typeof spec.components.parameters","filtered: typeof spec.components.requestBodies","filtered: typeof spec.components.responses","filtered: typeof spec.components.schemas","path","contentToSchema","mediaTypeObjects","objects: Array<Content>","parseSchemaJsDoc","parseSchemaMeta","parseArray","schemaItems: Array<IR.SchemaObject>","schemaToIrSchema","parseBoolean","parseNumber","parseObject","schemaProperties: Record<string, IR.SchemaObject>","parseString","initIrSchema","irSchema: IR.SchemaObject","parseAllOf","valueSchemas: ReadonlyArray<IR.SchemaObject>","irDiscriminatorSchema: IR.SchemaObject","parseOneType","nestedItems: Array<IR.SchemaObject>","parseAnyOf","parseEnum","enumValue","enumType: SchemaType<SchemaObject> | 'null' | undefined","parseOneOf","parseRef","irSchema","typeIrSchema: IR.SchemaObject","parseType","parseUnknown","parseSchema","isPaginationType","paginationField","refSchema: SchemaObject | ReferenceObject | undefined","mediaTypeObjects","content","name","parseOperationJsDoc","initIrOperation","irOperation: IR.OperationObject","operationToIrOperation","mediaTypeObjects","content","paginationField","schemaToIrSchema","contentToSchema","securitySchemeObjects: Map<string, IR.SecurityObject>","parsePathOperation","path","defaultAllowReserved","defaultExplode","defaultStyle","parametersArrayToObject","parametersObject: IR.ParametersObject","parameterToIrParameter","mediaTypeObjects","content","finalSchema: SchemaObject","paginationField","irParameter: IR.ParameterObject","schemaToIrSchema","parseParameter","requestBodyToIrRequestBody","mediaTypeObjects","content","irRequestBody: IR.RequestBodyObject","schemaToIrSchema","parseRequestBody","parseServers","validateOpenApiSpec","issues: Array<ValidatorIssue>","path","validateOpenApiSpec","state: State","path","operationArgs: Omit<\n      Parameters<typeof parsePathOperation>[0],\n      'method' | 'operation'\n    > & {\n      operation: Omit<\n        Parameters<typeof parsePathOperation>[0]['operation'],\n        'responses'\n      >;\n    }","parametersArrayToObject","filtered: typeof spec.components.parameters","filtered: typeof spec.components.requestBodies","filtered: typeof spec.components.responses","filtered: typeof spec.components.schemas","path","objects: Array<Content>","schemaItems: Array<IR.SchemaObject>","schemaProperties: Record<string, IR.SchemaObject>","patternProperties: Record<string, IR.SchemaObject>","irSchema: IR.SchemaObject","valueSchemas: ReadonlyArray<IR.SchemaObject>","irDiscriminatorSchema: IR.SchemaObject","nestedItems: Array<IR.SchemaObject>","enumValue","enumType: SchemaType<SchemaObject> | undefined","irSchema","irRefSchema: IR.SchemaObject","typeIrSchema: IR.SchemaObject","refSchema: SchemaObject | undefined","content","name","schema","irOperation: IR.OperationObject","content","securitySchemeObjects: Map<string, IR.SecurityObject>","path","parametersObject: IR.ParametersObject","content","finalSchema: SchemaObject","irParameter: IR.ParameterObject","content","irRequestBody: IR.RequestBodyObject","issues: Array<ValidatorIssue>","path","state: Parameters<typeof parseWebhookOperation>[0]['state']","operationArgs: Omit<\n      Parameters<typeof parseWebhookOperation>[0],\n      'method'\n    >","state: State","path","operationArgs: Omit<\n      Parameters<typeof parsePathOperation>[0],\n      'method'\n    >","result: Type","getModelProperties","models: Model[]","getModel","path","getRequiredPropertiesFromComposition","getModel","getModelComposition","composition: ModelComposition","properties: Model[]","getModel","getRequiredPropertiesFromComposition","getModelProperties","getModel","model: Model","getModelComposition","getModelProperties","getModels","types: Client['types']","models: Client['models']","getModel","model","properties: Property[]","result: SetUniqueTypeNameResult","result: UnsetUniqueTypeNameResult","operationResponses","types: Array<'error' | 'success'>","path","getOperationParameter","operationParameterWithoutName: Omit<OperationParameter, 'name'>","model","getModel","allowedIn","getOperationParameters","operationParameters: OperationParameters","getOperationParameter","operationParameters","getOperationResponse","operationResponse: OperationResponse","model","getModel","getOperationResponses","operationResponses: OperationResponse[]","getOperationResponse","getOperation","operationWithoutName: Omit<Operation, 'name'>","getOperationParameters","getOperationResponses","getOperations","operations: Operation[]","path","getOperationParameters","getOperation","getServer","getServer","getModels","getOperations","m2: Dictionary<string>","getModel","models: Model[]","propertyValues: Omit<\n        Model,\n        | '$refs'\n        | 'base'\n        | 'enum'\n        | 'enums'\n        | 'export'\n        | 'imports'\n        | 'isNullable'\n        | 'link'\n        | 'properties'\n        | 'template'\n        | 'type'\n      >","model","getModel","composition: ModelComposition","properties: Model[]","getModel","model","propertiesProperty: Model","model: Model","arrayItems","foundComposition","definition","types: Client['types']","models: Client['models']","operationParameterWithoutName: Omit<OperationParameter, 'name'>","model","operationParameters: OperationParameters","operationParameters","requestBody: OperationParameter","model","operationResponse: OperationResponse","model","operationResponses: OperationResponse[]","operationWithoutName: Omit<Operation, 'name'>","operations: Operation[]","path","parse","parseV3","parseV2","auth: Array<Auth>","className: string | undefined","methodName: string | undefined","classCandidates: Array<string>","path","result: OperationParameters","requestOptions: Array<ObjectValue>","parameterSerializers: Array<ObjectValue>","responseTypeValue: ReturnType<typeof getResponseType> | undefined","statements: Array<ts.Statement>","args: Array<unknown>","config: Array<unknown>","obj: Array<Record<string, unknown>>","headersValue: Array<unknown>","clientExpression: ts.Expression","types: Array<string | ts.StringLiteral>","comments: Array<string>","clientExpression: ts.Expression","createHttpRequests: AngularCommonPlugin['Handler']","methodAccess: ts.Expression","createHttpResources: AngularCommonPlugin['Handler']","handler: AngularCommonPlugin['Handler']","defaultConfig: AngularCommonPlugin['Config']","Api","defineConfig","renamed: Map<string, string> | undefined","dirPath","createClient: PluginHandler","defaultValues: Array<unknown>","Api","meta: Plugin.Name<'@hey-api/client-angular'>","defaultConfig: HeyApiClientAngularPlugin['Config']","Api","defineConfig","defaultConfig","Api","meta: Plugin.Name<'@hey-api/client-axios'>","defaultConfig: HeyApiClientAxiosPlugin['Config']","Api","defineConfig","defaultConfig","Api","meta: Plugin.Name<'@hey-api/client-fetch'>","defaultConfig: HeyApiClientFetchPlugin['Config']","Api","defineConfig","defaultConfig","Api","meta: Plugin.Name<'@hey-api/client-next'>","defaultConfig: HeyApiClientNextPlugin['Config']","Api","defineConfig","defaultConfig","Api","meta: Plugin.Name<'@hey-api/client-nuxt'>","defaultConfig: HeyApiClientNuxtPlugin['Config']","Api","defineConfig","defaultConfig","Api","meta: Plugin.Name<'@hey-api/client-ofetch'>","defaultConfig: HeyApiClientOfetchPlugin['Config']","Api","defineConfig","defaultConfig","defaultConfig: HeyApiClientLegacyAngularPlugin['Config']","defineConfig","defaultConfig","defaultConfig: HeyApiClientLegacyAxiosPlugin['Config']","defineConfig","defaultConfig","defaultConfig: HeyApiClientLegacyFetchPlugin['Config']","defineConfig","defaultConfig","defaultConfig: HeyApiClientLegacyNodePlugin['Config']","defineConfig","defaultConfig","defaultConfig: HeyApiClientLegacyXhrPlugin['Config']","defineConfig","defaultConfig","Api","meta: Plugin.Name<'@hey-api/schemas'>","handler: HeyApiSchemasPlugin['Handler']","output: Array<string>","importsStringArray: Array<string>","handlerLegacy: HeyApiSchemasPlugin['LegacyHandler']","defaultConfig: HeyApiSchemasPlugin['Config']","Api","defineConfig","defaultConfig","Api","meta: Plugin.Name<'@hey-api/sdk'>","params: string[]","obj: ObjectValue[]","obj","obj: Record<string, any>","errors: Record<number | string, string>","throwOnErrorTypeGeneric: FunctionTypeParameter","members: ts.ClassElement[]","_members: Array<ts.ClassElement>","handlerLegacy: HeyApiSdkPlugin['LegacyHandler']","handlerV1: HeyApiSdkPlugin['Handler']","handler: HeyApiSdkPlugin['Handler']","handlerV1","defaultConfig: HeyApiSdkPlugin['Config']","Api","defineConfig","defaultConfig","Api","meta: Plugin.Name<'@hey-api/transformers'>","bigIntExpressions: ExpressionTransformer","dateExpressions: ExpressionTransformer","dataVariableName","nodes: Array<ts.Expression | ts.Statement>","arrayNodes: Array<ts.Expression | ts.Statement>","handler: HeyApiTransformersPlugin['Handler']","emptyModel: Model","properties: Record<string | number, unknown>","comments: Record<string | number, Comments>","comment","pluginTypeScript","processModel","pathsMap: PathsMap","bodyParameters: OperationParameter","headerParameters: OperationParameter","pathParameters: OperationParameter","queryParameters: OperationParameter","path","methodParameters: Model[]","base","reqKey: Model","resKey: Model","handlerLegacy: HeyApiTypeScriptPlugin['LegacyHandler']","onNode: TypesProps['onNode']","model","path","handlerLegacy: HeyApiTransformersPlugin['LegacyHandler']","onNode: TypesProps['onNode']","onRemoveNode: TypesProps['onRemoveNode']","defaultConfig: HeyApiTransformersPlugin['Config']","Api","defineConfig","defaultConfig","types: Array<ts.TypeNode>","comments: Array<string>","typeofItems: Array<\n    | 'bigint'\n    | 'boolean'\n    | 'function'\n    | 'number'\n    | 'object'\n    | 'string'\n    | 'symbol'\n    | 'undefined'\n  >","key: string | undefined","node","type","irSchema: IR.SchemaObject","properties: Record<string, IR.SchemaObject>","required: Array<string>","operationToDataType","data: IR.SchemaObject","dataRequired: Array<string>","irSchemaToAst","type","node","data: IR.SchemaObject","dataRequired: Array<string>","type","irSchemaToAst","node","arrayToAst","itemTypes: Array<ts.TypeNode>","irSchemaToAst","booleanToAst","enumToAst","irSchemaToAst","neverToAst","nullToAst","numberToAst","objectToAst","indexKey: ts.TypeReferenceNode | undefined","indexProperty: Property | undefined","schemaProperties: Array<Property>","indexPropertyItems: Array<IR.SchemaObject>","irSchemaToAst","stringToAst","symbolTypeId","tupleToAst","itemTypes: Array<ts.Expression | ts.TypeNode>","irSchemaToAst","undefinedToAst","unknownToAst","voidToAst","irSchemaWithTypeToAst","arrayToAst","booleanToAst","enumToAst","numberToAst","neverToAst","nullToAst","objectToAst","stringToAst","tupleToAst","undefinedToAst","unknownToAst","voidToAst","irSchemaToAst","irSchemaWithTypeToAst","itemTypes: Array<ts.TypeNode>","handleComponent","handlerV1: HeyApiTypeScriptPlugin['Handler']","servers: Array<IR.ServerObject>","webhookNames: Array<string>","Api","meta: Plugin.Name<'@hey-api/typescript'>","irSchemaToAstV1","handler: HeyApiTypeScriptPlugin['Handler']","handlerV1","defaultConfig: HeyApiTypeScriptPlugin['Config']","Api","defineConfig","defaultConfig","Api","meta: Plugin.Name<'@pinia/colada'>","handleMeta","useTypeData","useTypeError","typeErrorName: string | undefined","useTypeResponse","createMutationOptions","useTypeData","useTypeError","useTypeResponse","fnOptions","statements: Array<ts.Statement>","mutationOptionsObj: Array<{ key: string; value: ts.Expression }>","handleMeta","TOptionsType","optionsIdentifier","createQueryKeyFunction","createQueryKeyLiteral","tagsExpression: Expression | undefined","createQueryKeyType","properties: Array<Property>","queryKeyStatement","useTypeData","optionsParamName","createQueryOptions","keyExpression: ts.Expression","queryKeyStatement","tagsExpr: ts.Expression | undefined","useTypeData","statements: Array<ts.Statement>","queryOptionsObj: Array<{ key: string; value: ts.Expression }>","handleMeta","handler: PiniaColadaPlugin['Handler']","defaultConfig: PiniaColadaPlugin['Config']","Api","handler","defineConfig","defaultConfig","typeErrorName: string | undefined","TOptionsType","createQueryKeyFunction","createQueryKeyLiteral","tagsExpression: Expression | undefined","createQueryKeyType","properties: Array<Property>","createInfiniteParamsFunction","statements: Array<ts.Statement>","infiniteQueryOptionsObj: Array<{ key: string; value: ts.Expression }>","fnOptions","statements: Array<ts.Statement>","mutationOptionsObj: Array<{ key: string; value: ts.Expression }>","mutationOptionsFn","optionsParamName","statements: Array<ts.Statement>","queryOptionsObj: Array<{ key: string; value: ts.Expression }>","handler: PluginHandler","infiniteIdentifier","properties: Property[]","typeError: ImportExportItemObject","typeInfiniteData!: ImportExportItem","queryKeyStatement","paginationField!: Model | OperationParameter","paginationField","fnOptions","Api","meta: Plugin.Name<'@tanstack/angular-query-experimental'>","defaultConfig: TanStackAngularQueryPlugin['Config']","Api","handler","defineConfig","defaultConfig","Api","meta: Plugin.Name<'@tanstack/react-query'>","defaultConfig: TanStackReactQueryPlugin['Config']","Api","handler","defineConfig","defaultConfig","Api","meta: Plugin.Name<'@tanstack/solid-query'>","defaultConfig: TanStackSolidQueryPlugin['Config']","Api","handler","defineConfig","defaultConfig","Api","meta: Plugin.Name<'@tanstack/svelte-query'>","defaultConfig: TanStackSvelteQueryPlugin['Config']","Api","handler","defineConfig","defaultConfig","Api","meta: Plugin.Name<'@tanstack/vue-query'>","defaultConfig: TanStackVueQueryPlugin['Config']","Api","handler","defineConfig","defaultConfig","Api","meta: Plugin.Name<'arktype'>","identifiers","exportAst","inferType","identifiers","nullToAst","result: Partial<Omit<Ast, 'typeName'>>","identifiers","objectToAst","result: Partial<Omit<Ast, 'typeName'>>","properties: Array<ts.PropertyAssignment | ts.GetAccessorDeclaration>","irSchemaToAst","propertyName:\n      | ts.ComputedPropertyName\n      | ts.StringLiteral\n      | ts.NumericLiteral\n      | string","stringToAst","result: Partial<Omit<Ast, 'typeName'>>","identifiers","irSchemaWithTypeToAst","nullToAst","objectToAst","stringToAst","irSchemaToAst","ast: Partial<Ast>","irSchemaWithTypeToAst","handleComponent","handlerV2: ArktypePlugin['Handler']","handler: ArktypePlugin['Handler']","defaultConfig: ArktypePlugin['Config']","Api","fields","defaultValue","defineConfig","defaultConfig","Api","meta: Plugin.Name<'fastify'>","properties: Array<Property>","errorsTypeReference: ts.TypeReferenceNode | undefined","responsesTypeReference: ts.TypeReferenceNode | undefined","handler: FastifyPlugin['Handler']","routeHandlers: Array<Property>","defaultConfig: FastifyPlugin['Config']","Api","defineConfig","defaultConfig","identifiers","identifiers","Api","meta: Plugin.Name<'valibot'>","identifiers","exportAst","identifiers","numberParameter","irOperationToAst","schemaData: IR.SchemaObject","properties: Record<string, IR.SchemaObject>","required: Array<string>","path","irWebhookToAst","schemaData: IR.SchemaObject","properties: Record<string, IR.SchemaObject>","required: Array<string>","unknownToAst","identifiers","arrayToAst","result: Omit<Ast, 'typeName'>","identifiers","unknownToAst","irSchemaToAst","booleanToAst","identifiers","enumToAst","enumMembers: Array<ts.LiteralExpression>","unknownToAst","identifiers","neverToAst","identifiers","nullToAst","identifiers","numberToAst","identifiers","pipes: Array<ts.CallExpression>","numberParameter","objectToAst","result: Partial<Omit<Ast, 'typeName'>>","properties: Array<ts.PropertyAssignment>","irSchemaToAst","identifiers","stringToAst","identifiers","pipes: Array<ts.CallExpression>","expression","tupleToAst","result: Partial<Omit<Ast, 'typeName'>>","identifiers","irSchemaToAst","unknownToAst","undefinedToAst","identifiers","voidToAst","identifiers","irSchemaWithTypeToAst","arrayToAst","booleanToAst","enumToAst","numberToAst","neverToAst","nullToAst","objectToAst","stringToAst","tupleToAst","undefinedToAst","unknownToAst","voidToAst","irSchemaToAst","ast: Ast","identifiers","irSchemaWithTypeToAst","callParameter: ts.Expression | undefined","numberParameter","handleComponent","handlerV1: ValibotPlugin['Handler']","handler: ValibotPlugin['Handler']","defaultConfig: ValibotPlugin['Config']","Api","defineConfig","defaultConfig","meta: Plugin.Name<'zod'>","inferType","schemaData: IR.SchemaObject","properties: Record<string, IR.SchemaObject>","required: Array<string>","path","schemaData: IR.SchemaObject","properties: Record<string, IR.SchemaObject>","required: Array<string>","unknownToAst","result: Partial<Omit<Ast, 'typeName'>>","arrayToAst","result: Partial<Omit<Ast, 'typeName'>>","unknownToAst","irSchemaToAst","intersectionExpression: ts.Expression","checks: Array<ts.Expression>","booleanToAst","result: Partial<Omit<Ast, 'typeName'>>","enumToAst","result: Partial<Omit<Ast, 'typeName'>>","enumMembers: Array<ts.LiteralExpression>","literalMembers: Array<ts.CallExpression>","unknownToAst","neverToAst","result: Partial<Omit<Ast, 'typeName'>>","nullToAst","result: Partial<Omit<Ast, 'typeName'>>","numberToAst","result: Partial<Omit<Ast, 'typeName'>>","checks: Array<ts.Expression>","objectToAst","result: Partial<Omit<Ast, 'typeName'>>","properties: Array<ts.PropertyAssignment | ts.GetAccessorDeclaration>","irSchemaToAst","stringToAst","result: Partial<Omit<Ast, 'typeName'>>","dateTimeOptions: { key: string; value: boolean }[]","checks: Array<ts.Expression>","tupleToAst","result: Partial<Omit<Ast, 'typeName'>>","tupleElements","tupleElements: Array<ts.Expression>","irSchemaToAst","undefinedToAst","result: Partial<Omit<Ast, 'typeName'>>","voidToAst","result: Partial<Omit<Ast, 'typeName'>>","irSchemaWithTypeToAst","arrayToAst","booleanToAst","enumToAst","numberToAst","neverToAst","nullToAst","objectToAst","stringToAst","tupleToAst","undefinedToAst","unknownToAst","voidToAst","irSchemaToAst","ast: Partial<Ast>","irSchemaWithTypeToAst","schema","handleComponent","handlerMini: ZodPlugin['Handler']","unknownToAst","arrayToAst","arrayExpression: ts.CallExpression | undefined","unknownToAst","irSchemaToAst","intersectionExpression: ts.Expression","booleanToAst","enumToAst","enumMembers: Array<ts.LiteralExpression>","literalMembers: Array<ts.CallExpression>","unknownToAst","enumExpression: ts.CallExpression","neverToAst","nullToAst","numberToAst","objectToAst","properties: Array<ts.PropertyAssignment>","irSchemaToAst","stringToAst","dateTimeOptions: { key: string; value: boolean }[]","tupleToAst","tupleElements","tupleElements: Array<ts.Expression>","irSchemaToAst","undefinedToAst","voidToAst","irSchemaWithTypeToAst","arrayToAst","booleanToAst","enumToAst","numberToAst","neverToAst","nullToAst","objectToAst","stringToAst","tupleToAst","undefinedToAst","unknownToAst","voidToAst","irSchemaToAst","ast: Partial<Ast>","irSchemaWithTypeToAst","handleComponent","handlerV3: ZodPlugin['Handler']","result: Partial<Omit<Ast, 'typeName'>>","result: Partial<Omit<Ast, 'typeName'>>","intersectionExpression: ts.Expression","result: Partial<Omit<Ast, 'typeName'>>","result: Partial<Omit<Ast, 'typeName'>>","enumMembers: Array<ts.LiteralExpression>","literalMembers: Array<ts.CallExpression>","result: Partial<Omit<Ast, 'typeName'>>","result: Partial<Omit<Ast, 'typeName'>>","result: Partial<Omit<Ast, 'typeName'>>","result: Partial<Omit<Ast, 'typeName'>>","properties: Array<ts.PropertyAssignment | ts.GetAccessorDeclaration>","result: Partial<Omit<Ast, 'typeName'>>","dateTimeOptions: { key: string; value: boolean }[]","result: Partial<Omit<Ast, 'typeName'>>","tupleElements","tupleElements: Array<ts.Expression>","result: Partial<Omit<Ast, 'typeName'>>","result: Partial<Omit<Ast, 'typeName'>>","ast: Partial<Ast>","schema","handlerV4: ZodPlugin['Handler']","handler: ZodPlugin['Handler']","defaultConfig: ZodPlugin['Config']","fields","defaultValue","defaultConfig","defaultPluginConfigs: {\n  [K in PluginNames]: Plugin.Config<PluginConfigMap[K]>;\n}","angularCommon","heyApiClientAngular","heyApiClientAxios","heyApiClientFetch","heyApiClientNext","heyApiClientNuxt","heyApiClientOfetch","heyApiSchemas","heyApiSdk","heyApiTransformers","heyApiTypeScript","piniaColada","tanStackAngularQuery","tanStackReactQuery","tanStackSolidQuery","tanStackSvelteQuery","tanStackVueQuery","heyApiLegacyAngular","heyApiLegacyAxios","heyApiLegacyFetch","heyApiLegacyNode","heyApiLegacyXhr","plugins: Config['plugins']","context: PluginContext","userPlugin","defaultConfig","defaultPlugin","userPluginsConfig: Config['plugins']","definedPlugins: UserConfig['plugins']","configs: Array<UserConfig>","dependencies: Record<string, string>","configurationFile: string | undefined","results: Array<ArrayOnly<ConfigResult>>","errors: Array<Error>","plugins: Pick<Config, 'plugins' | 'pluginOrder'>","joinedValues","values: string[]","search: string[]","entries: Array<[string, string]>","arrayBuffer: ArrayBuffer | undefined","hasChanged: boolean | undefined","response: Response | undefined"],"sources":["../src/generate/tsConfig.ts","../src/generate/utils.ts","../src/error.ts","../src/plugins/@hey-api/client-core/utils.ts","../src/utils/config.ts","../src/utils/input/heyApi.ts","../src/utils/input/readme.ts","../src/utils/input/scalar.ts","../src/utils/input/index.ts","../src/config/input.ts","../src/config/logs.ts","../src/config/merge.ts","../src/config/utils/config.ts","../src/config/output.ts","../src/config/packages.ts","../src/config/parser.ts","../src/plugins/shared/utils/config.ts","../src/plugins/@angular/common/api.ts","../src/utils/stringCase.ts","../src/openApi/shared/utils/name.ts","../src/ir/parameter.ts","../src/ir/schema.ts","../src/ir/utils.ts","../src/ir/operation.ts","../src/config/utils/package.ts","../src/utils/regexp.ts","../src/openApi/shared/utils/identifier.ts","../src/utils/escape.ts","../src/tsc/utils.ts","../src/tsc/types.ts","../src/tsc/module.ts","../src/tsc/classes.ts","../src/tsc/convert.ts","../src/tsc/return.ts","../src/tsc/transform.ts","../src/tsc/typedef.ts","../src/tsc/index.ts","../src/generate/renderer.ts","../src/utils/minHeap.ts","../src/graph/walk.ts","../src/ir/graph.ts","../src/utils/ref.ts","../src/plugins/shared/utils/instance.ts","../src/ir/context.ts","../src/openApi/common/parser/sanitize.ts","../src/openApi/shared/utils/operation.ts","../src/openApi/shared/utils/filter.ts","../src/openApi/shared/graph/meta.ts","../src/openApi/shared/utils/schema.ts","../src/openApi/shared/utils/schemaChildRelationships.ts","../src/openApi/shared/utils/transforms.ts","../src/openApi/shared/transforms/utils.ts","../src/openApi/shared/transforms/enums.ts","../src/openApi/shared/transforms/propertiesRequiredByDefault.ts","../src/openApi/shared/utils/deepEqual.ts","../src/openApi/shared/utils/graph.ts","../src/openApi/shared/transforms/readWrite.ts","../src/openApi/shared/transforms/index.ts","../src/openApi/shared/utils/parameter.ts","../src/openApi/shared/utils/validator.ts","../src/openApi/2.0.x/parser/filter.ts","../src/ir/mediaType.ts","../src/openApi/2.0.x/parser/mediaType.ts","../src/ir/pagination.ts","../src/openApi/shared/utils/discriminator.ts","../src/openApi/2.0.x/parser/schema.ts","../src/openApi/2.0.x/parser/pagination.ts","../src/openApi/2.0.x/parser/operation.ts","../src/openApi/2.0.x/parser/parameter.ts","../src/utils/url.ts","../src/openApi/2.0.x/parser/server.ts","../src/openApi/2.0.x/parser/validate.ts","../src/openApi/2.0.x/parser/index.ts","../src/openApi/3.0.x/parser/filter.ts","../src/openApi/3.0.x/parser/mediaType.ts","../src/openApi/3.0.x/parser/schema.ts","../src/openApi/3.0.x/parser/pagination.ts","../src/openApi/3.0.x/parser/operation.ts","../src/openApi/3.0.x/parser/parameter.ts","../src/openApi/3.0.x/parser/requestBody.ts","../src/openApi/3.0.x/parser/server.ts","../src/openApi/3.0.x/parser/validate.ts","../src/openApi/3.0.x/parser/index.ts","../src/openApi/3.1.x/parser/filter.ts","../src/openApi/3.1.x/parser/mediaType.ts","../src/openApi/3.1.x/parser/schema.ts","../src/openApi/3.1.x/parser/pagination.ts","../src/openApi/3.1.x/parser/operation.ts","../src/openApi/3.1.x/parser/parameter.ts","../src/openApi/3.1.x/parser/requestBody.ts","../src/openApi/3.1.x/parser/server.ts","../src/openApi/3.1.x/parser/validate.ts","../src/openApi/3.1.x/parser/webhook.ts","../src/openApi/3.1.x/parser/index.ts","../src/openApi/common/parser/service.ts","../src/openApi/v3/parser/inferType.ts","../src/utils/const.ts","../src/utils/transform.ts","../src/openApi/common/parser/stripNamespace.ts","../src/openApi/common/parser/type.ts","../src/utils/unique.ts","../src/openApi/common/parser/getEnums.ts","../src/openApi/common/parser/getPattern.ts","../src/openApi/v2/parser/getModelProperties.ts","../src/openApi/common/parser/getRef.ts","../src/openApi/v2/parser/getRequiredPropertiesFromComposition.ts","../src/openApi/v2/parser/getModelComposition.ts","../src/openApi/v2/parser/getModel.ts","../src/openApi/v2/parser/getModels.ts","../src/utils/sort.ts","../src/utils/enum.ts","../src/utils/meta.ts","../src/utils/type.ts","../src/openApi/common/parser/operation.ts","../src/openApi/common/parser/getDefault.ts","../src/openApi/v2/parser/getOperationParameter.ts","../src/openApi/v2/parser/getOperationParameters.ts","../src/openApi/common/parser/sort.ts","../src/openApi/v2/parser/getOperationResponse.ts","../src/openApi/v2/parser/getOperationResponses.ts","../src/openApi/v2/parser/operation.ts","../src/openApi/v2/parser/getOperations.ts","../src/openApi/v2/parser/getServer.ts","../src/openApi/v2/index.ts","../src/openApi/v3/parser/discriminator.ts","../src/openApi/v3/parser/getModelProperties.ts","../src/openApi/v3/parser/getRequiredPropertiesFromComposition.ts","../src/openApi/v3/parser/getModelComposition.ts","../src/openApi/v3/parser/getModel.ts","../src/openApi/v3/parser/parameter.ts","../src/openApi/v3/parser/getModels.ts","../src/openApi/v3/parser/getOperationParameter.ts","../src/openApi/v3/parser/getOperationParameters.ts","../src/openApi/v3/parser/getContent.ts","../src/openApi/v3/parser/getOperationRequestBody.ts","../src/openApi/v3/parser/getOperationResponse.ts","../src/openApi/v3/parser/getOperationResponses.ts","../src/openApi/v3/parser/operation.ts","../src/openApi/v3/parser/getOperations.ts","../src/openApi/v3/parser/getServer.ts","../src/openApi/v3/index.ts","../src/openApi/index.ts","../src/plugins/@hey-api/sdk/shared/auth.ts","../src/plugins/@hey-api/sdk/shared/constants.ts","../src/plugins/@hey-api/sdk/shared/validator.ts","../src/plugins/@hey-api/sdk/shared/operation.ts","../src/plugins/shared/utils/operation.ts","../src/plugins/@angular/common/httpRequests.ts","../src/plugins/@angular/common/httpResources.ts","../src/plugins/@angular/common/plugin.ts","../src/plugins/@angular/common/config.ts","../src/plugins/@hey-api/client-core/config.ts","../src/generate/client.ts","../src/plugins/@hey-api/client-core/client.ts","../src/plugins/@hey-api/client-core/createClientConfig.ts","../src/plugins/@hey-api/client-core/plugin.ts","../src/plugins/@hey-api/client-angular/api.ts","../src/plugins/@hey-api/client-angular/config.ts","../src/plugins/@hey-api/client-axios/api.ts","../src/plugins/@hey-api/client-axios/config.ts","../src/plugins/@hey-api/client-fetch/api.ts","../src/plugins/@hey-api/client-fetch/config.ts","../src/plugins/@hey-api/client-next/api.ts","../src/plugins/@hey-api/client-next/config.ts","../src/plugins/@hey-api/client-nuxt/api.ts","../src/plugins/@hey-api/client-nuxt/config.ts","../src/plugins/@hey-api/client-ofetch/api.ts","../src/plugins/@hey-api/client-ofetch/config.ts","../src/plugins/@hey-api/legacy-angular/config.ts","../src/plugins/@hey-api/legacy-axios/config.ts","../src/plugins/@hey-api/legacy-fetch/config.ts","../src/plugins/@hey-api/legacy-node/config.ts","../src/plugins/@hey-api/legacy-xhr/config.ts","../src/plugins/@hey-api/schemas/api.ts","../src/plugins/@hey-api/schemas/plugin.ts","../src/generate/file.ts","../src/plugins/@hey-api/schemas/plugin-legacy.ts","../src/plugins/@hey-api/schemas/config.ts","../src/plugins/@hey-api/sdk/api.ts","../src/plugins/@hey-api/sdk/shared/class.ts","../src/plugins/@hey-api/sdk/plugin-legacy.ts","../src/plugins/@hey-api/sdk/shared/functions.ts","../src/plugins/@hey-api/sdk/shared/typeOptions.ts","../src/plugins/@hey-api/sdk/v1/plugin.ts","../src/plugins/@hey-api/sdk/plugin.ts","../src/plugins/@hey-api/sdk/config.ts","../src/plugins/@hey-api/transformers/api.ts","../src/plugins/@hey-api/transformers/expressions.ts","../src/plugins/@hey-api/transformers/plugin.ts","../src/plugins/@hey-api/typescript/plugin-legacy.ts","../src/plugins/@hey-api/transformers/plugin-legacy.ts","../src/plugins/@hey-api/transformers/config.ts","../src/plugins/shared/utils/refs.ts","../src/plugins/@hey-api/typescript/shared/clientOptions.ts","../src/plugins/shared/utils/schema.ts","../src/plugins/@hey-api/typescript/shared/export.ts","../src/plugins/@hey-api/typescript/shared/operation.ts","../src/plugins/@hey-api/typescript/shared/webhook.ts","../src/plugins/@hey-api/typescript/shared/webhooks.ts","../src/plugins/@hey-api/typescript/v1/toAst/array.ts","../src/plugins/@hey-api/typescript/v1/toAst/boolean.ts","../src/plugins/@hey-api/typescript/v1/toAst/enum.ts","../src/plugins/@hey-api/typescript/v1/toAst/never.ts","../src/plugins/@hey-api/typescript/v1/toAst/null.ts","../src/plugins/@hey-api/typescript/v1/toAst/number.ts","../src/plugins/shared/utils/case.ts","../src/plugins/@hey-api/typescript/v1/toAst/object.ts","../src/plugins/@hey-api/typescript/v1/toAst/string.ts","../src/plugins/@hey-api/typescript/v1/toAst/tuple.ts","../src/plugins/@hey-api/typescript/v1/toAst/undefined.ts","../src/plugins/@hey-api/typescript/v1/toAst/unknown.ts","../src/plugins/@hey-api/typescript/v1/toAst/void.ts","../src/plugins/@hey-api/typescript/v1/toAst/index.ts","../src/plugins/@hey-api/typescript/v1/plugin.ts","../src/plugins/@hey-api/typescript/api.ts","../src/plugins/@hey-api/typescript/plugin.ts","../src/plugins/@hey-api/typescript/config.ts","../src/plugins/@pinia/colada/api.ts","../src/plugins/@pinia/colada/meta.ts","../src/plugins/@pinia/colada/useType.ts","../src/plugins/@pinia/colada/utils.ts","../src/plugins/@pinia/colada/mutationOptions.ts","../src/plugins/@pinia/colada/queryKey.ts","../src/plugins/@pinia/colada/queryOptions.ts","../src/plugins/@pinia/colada/plugin.ts","../src/plugins/@pinia/colada/config.ts","../src/plugins/@tanstack/query-core/meta.ts","../src/plugins/@tanstack/query-core/useType.ts","../src/plugins/@tanstack/query-core/queryKey.ts","../src/plugins/@tanstack/query-core/infiniteQueryOptions.ts","../src/plugins/@tanstack/query-core/mutationOptions.ts","../src/plugins/@tanstack/query-core/queryOptions.ts","../src/plugins/@tanstack/query-core/useQuery.ts","../src/plugins/@tanstack/query-core/plugin.ts","../src/plugins/@tanstack/query-core/plugin-legacy.ts","../src/plugins/@tanstack/angular-query-experimental/api.ts","../src/plugins/@tanstack/angular-query-experimental/config.ts","../src/plugins/@tanstack/react-query/api.ts","../src/plugins/@tanstack/react-query/config.ts","../src/plugins/@tanstack/solid-query/api.ts","../src/plugins/@tanstack/solid-query/config.ts","../src/plugins/@tanstack/svelte-query/api.ts","../src/plugins/@tanstack/svelte-query/config.ts","../src/plugins/@tanstack/vue-query/api.ts","../src/plugins/@tanstack/vue-query/config.ts","../src/plugins/arktype/v2/api.ts","../src/plugins/arktype/api.ts","../src/plugins/arktype/constants.ts","../src/plugins/arktype/shared/export.ts","../src/plugins/arktype/v2/toAst/null.ts","../src/plugins/arktype/v2/toAst/object.ts","../src/plugins/arktype/v2/toAst/string.ts","../src/plugins/arktype/v2/toAst/index.ts","../src/plugins/arktype/v2/plugin.ts","../src/plugins/arktype/plugin.ts","../src/plugins/arktype/config.ts","../src/plugins/fastify/api.ts","../src/plugins/fastify/plugin.ts","../src/plugins/fastify/config.ts","../src/plugins/valibot/v1/constants.ts","../src/plugins/valibot/v1/api.ts","../src/plugins/valibot/api.ts","../src/plugins/valibot/shared/pipesToAst.ts","../src/plugins/valibot/shared/export.ts","../src/plugins/valibot/shared/numbers.ts","../src/plugins/valibot/shared/operation.ts","../src/plugins/valibot/shared/webhook.ts","../src/plugins/valibot/v1/toAst/unknown.ts","../src/plugins/valibot/v1/toAst/array.ts","../src/plugins/valibot/v1/toAst/boolean.ts","../src/plugins/valibot/v1/toAst/enum.ts","../src/plugins/valibot/v1/toAst/never.ts","../src/plugins/valibot/v1/toAst/null.ts","../src/plugins/valibot/v1/toAst/number.ts","../src/plugins/valibot/v1/toAst/object.ts","../src/plugins/valibot/v1/toAst/string.ts","../src/plugins/valibot/v1/toAst/tuple.ts","../src/plugins/valibot/v1/toAst/undefined.ts","../src/plugins/valibot/v1/toAst/void.ts","../src/plugins/valibot/v1/toAst/index.ts","../src/plugins/valibot/v1/plugin.ts","../src/plugins/valibot/plugin.ts","../src/plugins/valibot/config.ts","../src/plugins/zod/constants.ts","../src/plugins/zod/mini/api.ts","../src/plugins/zod/v3/api.ts","../src/plugins/zod/v4/api.ts","../src/plugins/zod/api.ts","../src/plugins/zod/shared/export.ts","../src/plugins/zod/shared/module.ts","../src/plugins/zod/shared/numbers.ts","../src/plugins/zod/shared/operation.ts","../src/plugins/zod/shared/webhook.ts","../src/plugins/zod/mini/toAst/unknown.ts","../src/plugins/zod/mini/toAst/array.ts","../src/plugins/zod/mini/toAst/boolean.ts","../src/plugins/zod/mini/toAst/enum.ts","../src/plugins/zod/mini/toAst/never.ts","../src/plugins/zod/mini/toAst/null.ts","../src/plugins/zod/mini/toAst/number.ts","../src/plugins/zod/mini/toAst/object.ts","../src/plugins/zod/mini/toAst/string.ts","../src/plugins/zod/mini/toAst/tuple.ts","../src/plugins/zod/mini/toAst/undefined.ts","../src/plugins/zod/mini/toAst/void.ts","../src/plugins/zod/mini/toAst/index.ts","../src/plugins/zod/mini/plugin.ts","../src/plugins/zod/v3/toAst/unknown.ts","../src/plugins/zod/v3/toAst/array.ts","../src/plugins/zod/v3/toAst/boolean.ts","../src/plugins/zod/v3/toAst/enum.ts","../src/plugins/zod/v3/toAst/never.ts","../src/plugins/zod/v3/toAst/null.ts","../src/plugins/zod/v3/toAst/number.ts","../src/plugins/zod/v3/toAst/object.ts","../src/plugins/zod/v3/toAst/string.ts","../src/plugins/zod/v3/toAst/tuple.ts","../src/plugins/zod/v3/toAst/undefined.ts","../src/plugins/zod/v3/toAst/void.ts","../src/plugins/zod/v3/toAst/index.ts","../src/plugins/zod/v3/plugin.ts","../src/plugins/zod/v4/toAst/unknown.ts","../src/plugins/zod/v4/toAst/array.ts","../src/plugins/zod/v4/toAst/boolean.ts","../src/plugins/zod/v4/toAst/enum.ts","../src/plugins/zod/v4/toAst/never.ts","../src/plugins/zod/v4/toAst/null.ts","../src/plugins/zod/v4/toAst/number.ts","../src/plugins/zod/v4/toAst/object.ts","../src/plugins/zod/v4/toAst/string.ts","../src/plugins/zod/v4/toAst/tuple.ts","../src/plugins/zod/v4/toAst/undefined.ts","../src/plugins/zod/v4/toAst/void.ts","../src/plugins/zod/v4/toAst/index.ts","../src/plugins/zod/v4/plugin.ts","../src/plugins/zod/plugin.ts","../src/plugins/zod/config.ts","../src/plugins/config.ts","../src/config/plugins.ts","../src/config/init.ts","../src/plugins/@hey-api/client-core/bundle/params.ts","../src/plugins/@hey-api/client-core/bundle/pathSerializer.ts","../src/plugins/@hey-api/client-fetch/bundle/utils.ts","../src/getSpec.ts"],"sourcesContent":["import fs from 'node:fs';\nimport path from 'node:path';\nimport { fileURLToPath } from 'node:url';\n\nimport ts from 'typescript';\n\nimport type { UserOutput } from '~/types/output';\n\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = path.dirname(__filename);\n\nexport const findPackageJson = (): unknown | undefined => {\n  let dir = __dirname;\n  while (dir !== path.dirname(dir)) {\n    const files = fs.readdirSync(dir);\n    const candidates = files.filter((file) => file === 'package.json');\n\n    if (candidates[0]) {\n      const packageJsonPath = path.join(dir, candidates[0]);\n      return JSON.parse(\n        fs.readFileSync(packageJsonPath, {\n          encoding: 'utf8',\n        }),\n      );\n    }\n\n    dir = path.dirname(dir);\n  }\n\n  return;\n};\n\nexport const loadPackageJson = () => {\n  const packageJson = findPackageJson();\n\n  const safePackage = {\n    bugs: {\n      url: '',\n    },\n    name: '',\n    version: '',\n  };\n\n  if (packageJson && typeof packageJson === 'object') {\n    if ('name' in packageJson && typeof packageJson.name === 'string') {\n      safePackage.name = packageJson.name;\n    }\n\n    if ('version' in packageJson && typeof packageJson.version === 'string') {\n      safePackage.version = packageJson.version;\n    }\n\n    if (\n      'bugs' in packageJson &&\n      packageJson.bugs &&\n      typeof packageJson.bugs === 'object'\n    ) {\n      if (\n        'url' in packageJson.bugs &&\n        typeof packageJson.bugs.url === 'string'\n      ) {\n        safePackage.bugs.url = packageJson.bugs.url;\n        if (safePackage.bugs.url && !safePackage.bugs.url.endsWith('/')) {\n          safePackage.bugs.url += '/';\n        }\n      }\n    }\n  }\n\n  return safePackage;\n};\n\nexport const findTsConfigPath = (\n  tsConfigPath?: UserOutput['tsConfigPath'],\n): string | null => {\n  if (tsConfigPath === null) {\n    return null;\n  }\n\n  if (tsConfigPath) {\n    const resolved = path.isAbsolute(tsConfigPath)\n      ? tsConfigPath\n      : path.resolve(__dirname, tsConfigPath);\n    return fs.existsSync(resolved) ? resolved : null;\n  }\n\n  let dir = __dirname;\n  while (dir !== path.dirname(dir)) {\n    const files = fs.readdirSync(dir);\n    const candidates = files\n      .filter((file) => file.startsWith('tsconfig') && file.endsWith('.json'))\n      .sort((file) => (file === 'tsconfig.json' ? -1 : 1));\n\n    if (candidates[0]) {\n      return path.join(dir, candidates[0]);\n    }\n\n    dir = path.dirname(dir);\n  }\n\n  return null;\n};\n\nexport const loadTsConfig = (\n  configPath: string | null,\n): ts.ParsedCommandLine | null => {\n  if (!configPath) {\n    return null;\n  }\n\n  const raw = ts.readConfigFile(configPath, ts.sys.readFile);\n\n  if (raw.error) {\n    throw new Error(`Couldn't read tsconfig from path: ${configPath}`);\n  }\n\n  return ts.parseJsonConfigFileContent(\n    raw.config,\n    ts.sys,\n    path.dirname(configPath),\n  );\n};\n","import type { PathLike } from 'node:fs';\nimport fs from 'node:fs';\n\nexport const ensureDirSync = (path: PathLike) => {\n  if (!fs.existsSync(path)) {\n    fs.mkdirSync(path, { recursive: true });\n  }\n};\n\nexport const removeDirSync = (path: PathLike) => {\n  if (fs.existsSync(path)) {\n    fs.rmSync(path, { force: true, recursive: true });\n  }\n};\n\n/**\n * Construct a relative import path to modules. This is used for example\n * in plugins to import types or SDK module.\n */\nexport const relativeModulePath = ({\n  moduleOutput,\n  sourceOutput,\n}: {\n  /**\n   * Output path to the imported module.\n   * @example\n   * 'types'\n   */\n  moduleOutput: string;\n  /**\n   * Output path to the source module.\n   * @example\n   * '@tanstack/react-query'\n   */\n  sourceOutput: string;\n}): string => {\n  const outputParts = sourceOutput.split('/');\n  const relativePath =\n    Array.from({ length: outputParts.length }).fill('').join('../') || './';\n  return `${relativePath}${moduleOutput}`;\n};\n","import fs from 'node:fs';\nimport path from 'node:path';\n\nimport colors from 'ansi-colors';\n\nimport { loadPackageJson } from '~/generate/tsConfig';\nimport { ensureDirSync } from '~/generate/utils';\n\ntype IJobError = {\n  error: Error;\n  jobIndex: number;\n};\n\n/**\n * Represents a single configuration error.\n *\n * Used for reporting issues with a specific config instance.\n */\nexport class ConfigError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'ConfigError';\n  }\n}\n\n/**\n * Aggregates multiple config errors with their job indices for reporting.\n */\nexport class ConfigValidationError extends Error {\n  readonly errors: ReadonlyArray<IJobError>;\n\n  constructor(errors: Array<IJobError>) {\n    super(\n      `Found ${errors.length} configuration ${errors.length === 1 ? 'error' : 'errors'}.`,\n    );\n    this.name = 'ConfigValidationError';\n    this.errors = errors;\n  }\n}\n\n/**\n * Represents a runtime error originating from a specific job.\n *\n * Used for reporting job-level failures that are not config validation errors.\n */\nexport class JobError extends Error {\n  readonly originalError: IJobError;\n\n  constructor(message: string, error: IJobError) {\n    super(message);\n    this.name = 'JobError';\n    this.originalError = error;\n  }\n}\n\nexport class HeyApiError extends Error {\n  args: ReadonlyArray<unknown>;\n  event: string;\n  pluginName: string;\n\n  constructor({\n    args,\n    error,\n    event,\n    name,\n    pluginName,\n  }: {\n    args: unknown[];\n    error: Error;\n    event: string;\n    name: string;\n    pluginName: string;\n  }) {\n    const message = error instanceof Error ? error.message : 'Unknown error';\n    super(message);\n\n    this.args = args;\n    this.cause = error.cause;\n    this.event = event;\n    this.name = name || error.name;\n    this.pluginName = pluginName;\n    this.stack = error.stack;\n  }\n}\n\nexport const logCrashReport = (\n  error: unknown,\n  logsDir: string,\n): string | undefined => {\n  if (error instanceof ConfigError || error instanceof ConfigValidationError) {\n    return;\n  }\n\n  if (error instanceof JobError) {\n    error = error.originalError.error;\n  }\n\n  const logName = `openapi-ts-error-${Date.now()}.log`;\n  const fullDir = path.resolve(process.cwd(), logsDir);\n  ensureDirSync(fullDir);\n  const logPath = path.resolve(fullDir, logName);\n\n  let logContent = `[${new Date().toISOString()}] `;\n\n  if (error instanceof HeyApiError) {\n    logContent += `${error.name} during event \"${error.event}\"\\n`;\n    if (error.pluginName) {\n      logContent += `Plugin: ${error.pluginName}\\n`;\n    }\n    logContent += `Arguments: ${JSON.stringify(error.args, null, 2)}\\n\\n`;\n  }\n\n  const message = error instanceof Error ? error.message : String(error);\n  const stack = error instanceof Error ? error.stack : undefined;\n\n  logContent += `Error: ${message}\\n`;\n  if (stack) {\n    logContent += `Stack:\\n${stack}\\n`;\n  }\n\n  fs.writeFileSync(logPath, logContent);\n\n  return logPath;\n};\n\nexport const openGitHubIssueWithCrashReport = async (error: unknown) => {\n  const packageJson = loadPackageJson();\n  if (!packageJson.bugs.url) return;\n\n  if (error instanceof JobError) {\n    error = error.originalError.error;\n  }\n\n  let body = '';\n\n  if (error instanceof HeyApiError) {\n    if (error.pluginName) {\n      body += `**Plugin**: \\`${error.pluginName}\\`\\n`;\n    }\n    body += `**Event**: \\`${error.event}\\`\\n`;\n    body += `**Arguments**:\\n\\`\\`\\`ts\\n${JSON.stringify(error.args, null, 2)}\\n\\`\\`\\`\\n\\n`;\n  }\n\n  const message = error instanceof Error ? error.message : String(error);\n  const stack = error instanceof Error ? error.stack : undefined;\n\n  body += `**Error**: \\`${message}\\`\\n`;\n  if (stack) {\n    body += `\\n**Stack Trace**:\\n\\`\\`\\`\\n${stack}\\n\\`\\`\\``;\n  }\n\n  const search = new URLSearchParams({\n    body,\n    labels: 'bug ',\n    title: 'Crash Report',\n  });\n  const url = `${packageJson.bugs.url}new?${search.toString()}`;\n  const open = (await import('open')).default;\n  await open(url);\n};\n\nexport const printCrashReport = ({\n  error,\n  logPath,\n}: {\n  error: unknown;\n  logPath: string | undefined;\n}) => {\n  if (error instanceof ConfigValidationError && error.errors.length) {\n    const groupByJob = new Map<number, Array<Error>>();\n    for (const { error: err, jobIndex } of error.errors) {\n      if (!groupByJob.has(jobIndex)) {\n        groupByJob.set(jobIndex, []);\n      }\n      groupByJob.get(jobIndex)!.push(err);\n    }\n\n    for (const [jobIndex, errors] of groupByJob.entries()) {\n      const jobPrefix = colors.gray(`[Job ${jobIndex + 1}] `);\n      const count = errors.length;\n      const baseString = colors.red(\n        `Found ${count} configuration ${count === 1 ? 'error' : 'errors'}:`,\n      );\n      console.error(`${jobPrefix} ${baseString}`);\n      errors.forEach((err, index) => {\n        const itemPrefixStr = `  [${index + 1}] `;\n        const itemPrefix = colors.red(itemPrefixStr);\n        console.error(`${jobPrefix}${itemPrefix}${colors.white(err.message)}`);\n      });\n    }\n  } else {\n    let jobPrefix = colors.gray('[root] ');\n    if (error instanceof JobError) {\n      jobPrefix = colors.gray(`[Job ${error.originalError.jobIndex + 1}] `);\n      error = error.originalError.error;\n    }\n\n    const baseString = colors.red('Failed with the message:');\n    console.error(`${jobPrefix} ${baseString}`);\n    const itemPrefixStr = `  `;\n    const itemPrefix = colors.red(itemPrefixStr);\n    console.error(\n      `${jobPrefix}${itemPrefix}${typeof error === 'string' ? error : error instanceof Error ? error.message : 'Unknown error'}`,\n    );\n  }\n\n  if (logPath) {\n    const jobPrefix = colors.gray('[root] ');\n    console.error(\n      `${jobPrefix}${colors.cyan(' Crash log saved to:')} ${colors.gray(logPath)}`,\n    );\n  }\n};\n\nexport const shouldReportCrash = async ({\n  error,\n  isInteractive,\n}: {\n  error: unknown;\n  isInteractive: boolean | undefined;\n}): Promise<boolean> => {\n  if (\n    !isInteractive ||\n    error instanceof ConfigError ||\n    error instanceof ConfigValidationError\n  ) {\n    return false;\n  }\n\n  return new Promise((resolve) => {\n    const jobPrefix = colors.gray('[root] ');\n    console.log(\n      `${jobPrefix}${colors.yellow(' Open a GitHub issue with crash details? (y/N):')}`,\n    );\n    process.stdin.setEncoding('utf8');\n    process.stdin.once('data', (data: string) => {\n      resolve(data.trim().toLowerCase() === 'y');\n    });\n  });\n};\n","import type { PluginClientNames } from '~/plugins/types';\nimport type { Config } from '~/types/config';\n\nexport const getClientBaseUrlKey = (config: Config) => {\n  const client = getClientPlugin(config);\n  if (\n    client.name === '@hey-api/client-axios' ||\n    client.name === '@hey-api/client-nuxt'\n  ) {\n    return 'baseURL';\n  }\n  return 'baseUrl';\n};\n\nexport const getClientPlugin = (\n  config: Config,\n): Config['plugins'][PluginClientNames] & { name: PluginClientNames } => {\n  for (const name of config.pluginOrder) {\n    const plugin = config.plugins[name];\n    if (plugin?.tags?.includes('client')) {\n      return plugin as Config['plugins'][PluginClientNames] & {\n        name: PluginClientNames;\n      };\n    }\n  }\n\n  return {\n    config: {\n      // @ts-expect-error\n      name: '',\n    },\n    // @ts-expect-error\n    name: '',\n  };\n};\n","import { getClientPlugin } from '~/plugins/@hey-api/client-core/utils';\nimport type { Config } from '~/types/config';\n\nlet _config: Config;\n\nexport const getConfig = () => {\n  const config = _config;\n  const plugin = getClientPlugin(config);\n  // patch legacy config to avoid breaking handlebars\n  // @ts-expect-error\n  config.client = plugin;\n  return config;\n};\n\nexport const setConfig = (config: Config) => {\n  _config = config;\n  return getConfig();\n};\n\nexport const isLegacyClient = (config: Config) => {\n  const plugin = getClientPlugin(config);\n  return plugin.name.startsWith('legacy/');\n};\n\n/**\n * Wrap legacy `name` option so we don't use it when not using legacy clients.\n */\nexport const legacyNameFromConfig = (config: Config) => {\n  if (!isLegacyClient(config)) {\n    return;\n  }\n\n  return config.name;\n};\n","import type { Input } from '~/types/input';\n\n// Regular expression to match Hey API Registry input formats:\n//   - {organization}/{project}?{queryParams}\nconst registryRegExp = /^([\\w-]+)\\/([\\w-]+)(?:\\?([\\w=&.-]*))?$/;\n\nexport const heyApiRegistryBaseUrl = 'https://get.heyapi.dev';\n\n/**\n * Creates a full Hey API Registry URL.\n *\n * @param organization - Hey API organization slug\n * @param project - Hey API project slug\n * @param queryParams - Optional query parameters\n * @returns The full Hey API registry URL.\n */\nexport const getRegistryUrl = (\n  organization: string,\n  project: string,\n  queryParams?: string,\n): string =>\n  `${heyApiRegistryBaseUrl}/${organization}/${project}${queryParams ? `?${queryParams}` : ''}`;\n\nexport interface Parsed {\n  organization: string;\n  project: string;\n  queryParams?: string;\n}\n\n/**\n * Parses a Hey API input string and extracts components.\n *\n * @param input - Hey API configuration input\n * @returns Parsed Hey API input components\n * @throws Error if the input format is invalid\n */\nexport const parseShorthand = (\n  input: Input & {\n    path: string;\n  },\n): Parsed => {\n  let organization = input.organization;\n  let project = input.project;\n  let queryParams: string | undefined;\n\n  if (input.path) {\n    const match = input.path.match(registryRegExp);\n\n    if (!match) {\n      throw new Error(\n        `Invalid Hey API shorthand format. Expected \"organization/project?queryParams\" or \"organization/project\", received: ${input.path}`,\n      );\n    }\n\n    organization = match[1];\n    project = match[2];\n    queryParams = match[3];\n  }\n\n  if (!organization) {\n    throw new Error('The Hey API organization cannot be empty.');\n  }\n\n  if (!project) {\n    throw new Error('The Hey API project cannot be empty.');\n  }\n\n  const result: Parsed = {\n    organization,\n    project,\n    queryParams,\n  };\n\n  return result;\n};\n\n/**\n * Transforms a Hey API shorthand string to the corresponding API URL.\n *\n * @param input - Hey API configuration input\n * @returns The Hey API Registry URL\n */\nexport const inputToHeyApiPath = (\n  input: Input & {\n    path: string;\n  },\n): Partial<Input> => {\n  const parsed = parseShorthand(input);\n  return {\n    path: getRegistryUrl(\n      parsed.organization,\n      parsed.project,\n      parsed.queryParams,\n    ),\n    registry: 'hey-api',\n  };\n};\n","import type { Input } from '~/types/input';\n\n// Regular expression to match ReadMe API Registry input formats:\n//   - @{organization}/{project}#{uuid}\n//   - {uuid}\nconst registryRegExp = /^(@([\\w-]+)\\/([\\w\\-.]+)#)?([\\w-]+)$/;\n\n/**\n * Creates a full ReadMe API Registry URL.\n *\n * @param uuid - ReadMe UUID\n * @returns The full ReadMe API registry URL.\n */\nexport const getRegistryUrl = (uuid: string): string =>\n  `https://dash.readme.com/api/v1/api-registry/${uuid}`;\n\nexport interface Parsed {\n  organization?: string;\n  project?: string;\n  uuid: string;\n}\n\nconst namespace = 'readme';\n\n/**\n * Parses a ReadMe input string and extracts components.\n *\n * @param shorthand - ReadMe format string (@org/project#uuid or uuid)\n * @returns Parsed ReadMe input components\n * @throws Error if the input format is invalid\n */\nexport const parseShorthand = (shorthand: string): Parsed => {\n  const match = shorthand.match(registryRegExp);\n\n  if (!match) {\n    throw new Error(\n      `Invalid ReadMe shorthand format. Expected \"${namespace}:@organization/project#uuid\" or \"${namespace}:uuid\", received: ${namespace}:${shorthand}`,\n    );\n  }\n\n  const [, , organization, project, uuid] = match;\n\n  if (!uuid) {\n    throw new Error('The ReadMe UUID cannot be empty.');\n  }\n\n  const result: Parsed = {\n    organization,\n    project,\n    uuid,\n  };\n\n  return result;\n};\n\n/**\n * Transforms a ReadMe shorthand string to the corresponding API URL.\n *\n * @param input - ReadMe format string\n * @returns The ReadMe API Registry URL\n */\nexport const inputToReadmePath = (input: string): Partial<Input> => {\n  const shorthand = input.slice(`${namespace}:`.length);\n  const parsed = parseShorthand(shorthand);\n  return {\n    ...parsed,\n    path: getRegistryUrl(parsed.uuid),\n    registry: 'readme',\n  };\n};\n","import type { Input } from '~/types/input';\n\n// Regular expression to match Scalar API Registry input formats:\n//   - @{organization}/{project}\nconst registryRegExp = /^(@[\\w-]+)\\/([\\w.-]+)$/;\n\n/**\n * Creates a full Scalar API Registry URL.\n *\n * @param organization - Scalar organization slug\n * @param project - Scalar project slug\n * @returns The full Scalar API registry URL.\n */\nexport const getRegistryUrl = (organization: string, project: string): string =>\n  `https://registry.scalar.com/${organization}/apis/${project}/latest?format=json`;\n\nexport interface Parsed {\n  organization: string;\n  project: string;\n}\n\nconst namespace = 'scalar';\n\n/**\n * Parses a Scalar input string and extracts components.\n *\n * @param shorthand - Scalar format string (@org/project)\n * @returns Parsed Scalar input components\n * @throws Error if the input format is invalid\n */\nexport const parseShorthand = (shorthand: string): Parsed => {\n  const match = shorthand.match(registryRegExp);\n\n  if (!match) {\n    throw new Error(\n      `Invalid Scalar shorthand format. Expected \"${namespace}:@organization/project\", received: ${namespace}:${shorthand}`,\n    );\n  }\n\n  const [, organization, project] = match;\n\n  if (!organization) {\n    throw new Error('The Scalar organization cannot be empty.');\n  }\n\n  if (!project) {\n    throw new Error('The Scalar project cannot be empty.');\n  }\n\n  const result: Parsed = {\n    organization,\n    project,\n  };\n\n  return result;\n};\n\n/**\n * Transforms a Scalar shorthand string to the corresponding API URL.\n *\n * @param input - Scalar format string\n * @returns The Scalar API Registry URL\n */\nexport const inputToScalarPath = (input: string): Partial<Input> => {\n  const shorthand = input.slice(`${namespace}:`.length);\n  const parsed = parseShorthand(shorthand);\n  return {\n    ...parsed,\n    path: getRegistryUrl(parsed.organization, parsed.project),\n    registry: 'scalar',\n  };\n};\n","import type { Input } from '~/types/input';\n\nimport { heyApiRegistryBaseUrl, inputToHeyApiPath } from './heyApi';\nimport { inputToReadmePath } from './readme';\nimport { inputToScalarPath } from './scalar';\n\nexport const inputToApiRegistry = (\n  input: Input & {\n    path: string;\n  },\n) => {\n  if (input.path.startsWith('readme:')) {\n    Object.assign(input, inputToReadmePath(input.path));\n    return;\n  }\n\n  if (input.path.startsWith('scalar:')) {\n    Object.assign(input, inputToScalarPath(input.path));\n    return;\n  }\n\n  if (input.path.startsWith('.')) {\n    return;\n  }\n\n  if (input.path.startsWith(heyApiRegistryBaseUrl)) {\n    input.path = input.path.slice(heyApiRegistryBaseUrl.length + 1);\n    Object.assign(input, inputToHeyApiPath(input as Input & { path: string }));\n    return;\n  }\n\n  const parts = input.path.split('/');\n  if (parts.length === 2 && parts.filter(Boolean).length === 2) {\n    Object.assign(input, inputToHeyApiPath(input as Input & { path: string }));\n    return;\n  }\n};\n","import type { Config, UserConfig } from '~/types/config';\nimport type { Input, Watch } from '~/types/input';\nimport { inputToApiRegistry } from '~/utils/input';\nimport { heyApiRegistryBaseUrl } from '~/utils/input/heyApi';\n\nconst defaultWatch: Watch = {\n  enabled: false,\n  interval: 1_000,\n  timeout: 60_000,\n};\n\n// watch only remote files\nconst getWatch = (input: Pick<Input, 'path' | 'watch'>): Watch => {\n  let watch = { ...defaultWatch };\n\n  // we cannot watch spec passed as an object\n  if (typeof input.path !== 'string') {\n    return watch;\n  }\n\n  if (typeof input.watch === 'boolean') {\n    watch.enabled = input.watch;\n  } else if (typeof input.watch === 'number') {\n    watch.enabled = true;\n    watch.interval = input.watch;\n  } else if (input.watch) {\n    watch = {\n      ...watch,\n      ...input.watch,\n    };\n  }\n\n  return watch;\n};\n\nexport const getInput = (userConfig: UserConfig): Config['input'] => {\n  const userInputs =\n    userConfig.input instanceof Array ? userConfig.input : [userConfig.input];\n\n  const inputs: Array<Input> = [];\n\n  for (const userInput of userInputs) {\n    let input: Input = {\n      path: '',\n      watch: defaultWatch,\n    };\n\n    if (typeof userInput === 'string') {\n      input.path = userInput;\n    } else if (\n      userInput &&\n      (userInput.path !== undefined || userInput.organization !== undefined)\n    ) {\n      // @ts-expect-error\n      input = {\n        ...input,\n        path: heyApiRegistryBaseUrl,\n        ...userInput,\n      };\n\n      if (input.watch !== undefined) {\n        input.watch = getWatch(input);\n      }\n    } else {\n      input = {\n        ...input,\n        path: userInput,\n      };\n    }\n\n    if (typeof input.path === 'string') {\n      inputToApiRegistry(input as Input & { path: string });\n    }\n\n    if (\n      userConfig.watch !== undefined &&\n      input.watch.enabled === defaultWatch.enabled &&\n      input.watch.interval === defaultWatch.interval &&\n      input.watch.timeout === defaultWatch.timeout\n    ) {\n      input.watch = getWatch({\n        path: input.path,\n        // @ts-expect-error\n        watch: userConfig.watch,\n      });\n    }\n\n    if (input.path) {\n      inputs.push(input);\n    }\n  }\n\n  return inputs;\n};\n","import type { Config, UserConfig } from '~/types/config';\n\nexport const getLogs = (\n  userConfig: Pick<UserConfig, 'logs'> | undefined,\n): Config['logs'] => {\n  let logs: Config['logs'] = {\n    file: true,\n    level: 'info',\n    path: process.cwd(),\n  };\n\n  if (typeof userConfig?.logs === 'string') {\n    logs.path = userConfig.logs;\n  } else {\n    logs = {\n      ...logs,\n      ...userConfig?.logs,\n    };\n  }\n\n  return logs;\n};\n","import type { UserConfig } from '~/types/config';\n\nconst mergeObjects = (\n  objA: Record<string, unknown> | undefined,\n  objB: Record<string, unknown> | undefined,\n): Record<string, unknown> => {\n  const a = objA || {};\n  const b = objB || {};\n  return {\n    ...a,\n    ...b,\n  };\n};\n\nexport const mergeConfigs = (\n  configA: UserConfig | undefined,\n  configB: UserConfig | undefined,\n): UserConfig => {\n  const a: Partial<UserConfig> = configA || {};\n  const b: Partial<UserConfig> = configB || {};\n  const merged: UserConfig = {\n    ...(a as UserConfig),\n    ...(b as UserConfig),\n  };\n  if (typeof merged.logs === 'object') {\n    merged.logs = mergeObjects(\n      a.logs as Record<string, unknown>,\n      b.logs as Record<string, unknown>,\n    );\n  }\n  return merged;\n};\n","type ObjectType<T> =\n  Extract<T, Record<string, any>> extends never\n    ? Record<string, any>\n    : Extract<T, Record<string, any>>;\n\ntype NotArray<T> = T extends any[] ? never : T;\ntype NotFunction<T> = T extends (...args: any[]) => any ? never : T;\ntype PlainObject<T> = T extends object\n  ? NotFunction<T> extends never\n    ? never\n    : NotArray<T> extends never\n      ? never\n      : T\n  : never;\n\ntype MappersType<T> = {\n  boolean: T extends boolean\n    ? (value: boolean) => Partial<ObjectType<T>>\n    : never;\n  function: T extends (...args: any[]) => any\n    ? (value: (...args: any[]) => any) => Partial<ObjectType<T>>\n    : never;\n  number: T extends number ? (value: number) => Partial<ObjectType<T>> : never;\n  object?: PlainObject<T> extends never\n    ? never\n    : (\n        value: Partial<PlainObject<T>>,\n        defaultValue: PlainObject<T>,\n      ) => Partial<ObjectType<T>>;\n  string: T extends string ? (value: string) => Partial<ObjectType<T>> : never;\n} extends infer U\n  ? { [K in keyof U as U[K] extends never ? never : K]: U[K] }\n  : never;\n\ntype IsObjectOnly<T> = T extends Record<string, any> | undefined\n  ? Extract<\n      T,\n      string | boolean | number | ((...args: any[]) => any)\n    > extends never\n    ? true\n    : false\n  : false;\n\nexport type ValueToObject = <\n  T extends\n    | undefined\n    | string\n    | boolean\n    | number\n    | ((...args: any[]) => any)\n    | Record<string, any>,\n>(\n  args: {\n    defaultValue: ObjectType<T>;\n    value: T;\n  } & (IsObjectOnly<T> extends true\n    ? {\n        mappers?: MappersType<T>;\n      }\n    : {\n        mappers: MappersType<T>;\n      }),\n) => PlainObject<T>;\n\nconst isPlainObject = (value: unknown): value is Record<string, any> =>\n  typeof value === 'object' &&\n  value !== null &&\n  !Array.isArray(value) &&\n  typeof value !== 'function';\n\nconst mergeResult = <T>(\n  result: ObjectType<T>,\n  mapped: Record<string, any>,\n): ObjectType<T> => {\n  for (const [key, value] of Object.entries(mapped)) {\n    if (value !== undefined && value !== '') {\n      (result as Record<string, any>)[key] = value;\n    }\n  }\n  return result;\n};\n\nexport const valueToObject: ValueToObject = ({\n  defaultValue,\n  mappers,\n  value,\n}) => {\n  let result = { ...defaultValue };\n\n  switch (typeof value) {\n    case 'boolean':\n      if (mappers && 'boolean' in mappers) {\n        const mapper = mappers.boolean as (\n          value: boolean,\n        ) => Record<string, any>;\n        result = mergeResult(result, mapper(value));\n      }\n      break;\n    case 'function':\n      if (mappers && 'function' in mappers) {\n        const mapper = mappers.function as (\n          value: (...args: any[]) => any,\n        ) => Record<string, any>;\n        result = mergeResult(result, mapper(value as (...args: any[]) => any));\n      }\n      break;\n    case 'number':\n      if (mappers && 'number' in mappers) {\n        const mapper = mappers.number as (value: number) => Record<string, any>;\n        result = mergeResult(result, mapper(value));\n      }\n      break;\n    case 'string':\n      if (mappers && 'string' in mappers) {\n        const mapper = mappers.string as (value: string) => Record<string, any>;\n        result = mergeResult(result, mapper(value));\n      }\n      break;\n    case 'object':\n      if (isPlainObject(value)) {\n        if (\n          mappers &&\n          'object' in mappers &&\n          typeof mappers.object === 'function'\n        ) {\n          const mapper = mappers.object as (\n            value: Record<string, any>,\n            defaultValue: ObjectType<any>,\n          ) => Partial<ObjectType<any>>;\n          result = mergeResult(result, mapper(value, defaultValue));\n        } else {\n          result = mergeResult(result, value);\n        }\n      }\n      break;\n  }\n\n  return result as any;\n};\n","import ts from 'typescript';\n\nimport { findTsConfigPath, loadTsConfig } from '~/generate/tsConfig';\nimport type { Config, UserConfig } from '~/types/config';\n\nimport { valueToObject } from './utils/config';\n\nexport const getOutput = (userConfig: UserConfig): Config['output'] => {\n  if (userConfig.output instanceof Array) {\n    throw new Error(\n      'Unexpected array of outputs in user configuration. This should have been expanded already.',\n    );\n  }\n\n  const output = valueToObject({\n    defaultValue: {\n      clean: true,\n      fileName: {\n        case: 'preserve',\n        name: '{{name}}',\n        suffix: '.gen',\n      },\n      format: null,\n      indexFile: true,\n      lint: null,\n      path: '',\n    },\n    mappers: {\n      object: (fields, defaultValue) => ({\n        ...fields,\n        fileName: valueToObject({\n          defaultValue: {\n            ...(defaultValue.fileName as Extract<\n              typeof defaultValue.fileName,\n              Record<string, unknown>\n            >),\n          },\n          mappers: {\n            function: (name) => ({ name }),\n            string: (name) => ({ name }),\n          },\n          value: fields.fileName,\n        }),\n      }),\n      string: (path) => ({ path }),\n    },\n    value: userConfig.output,\n  }) as Config['output'];\n  output.tsConfig = loadTsConfig(findTsConfigPath(output.tsConfigPath));\n  if (\n    output.importFileExtension === undefined &&\n    output.tsConfig?.options.moduleResolution ===\n      ts.ModuleResolutionKind.NodeNext\n  ) {\n    output.importFileExtension = '.js';\n  }\n  if (\n    output.importFileExtension &&\n    !output.importFileExtension.startsWith('.')\n  ) {\n    output.importFileExtension = `.${output.importFileExtension}`;\n  }\n  return output;\n};\n","import fs from 'node:fs';\nimport path from 'node:path';\n\n/**\n * Finds and reads the project's package.json file by searching upwards from the config file location,\n * or from process.cwd() if no config file is provided.\n * This ensures we get the correct dependencies even in monorepo setups.\n *\n * @param configFilePath - The path to the configuration file (e.g., openapi-ts.config.ts)\n * @returns An object containing all project dependencies (dependencies, devDependencies, peerDependencies, optionalDependencies)\n */\nexport const getProjectDependencies = (\n  configFilePath?: string,\n): Record<string, string> => {\n  let currentDir = configFilePath\n    ? path.dirname(configFilePath)\n    : process.cwd();\n\n  while (currentDir !== path.dirname(currentDir)) {\n    const packageJsonPath = path.join(currentDir, 'package.json');\n\n    if (fs.existsSync(packageJsonPath)) {\n      try {\n        const packageJson = JSON.parse(\n          fs.readFileSync(packageJsonPath, 'utf8'),\n        );\n        return {\n          ...packageJson.dependencies,\n          ...packageJson.devDependencies,\n          ...packageJson.peerDependencies,\n          ...packageJson.optionalDependencies,\n        };\n      } catch {\n        // Silently ignore JSON parsing errors and continue searching\n      }\n    }\n\n    const parentDir = path.dirname(currentDir);\n    if (parentDir === currentDir) {\n      break;\n    }\n    currentDir = parentDir;\n  }\n\n  return {};\n};\n","import type { Config, UserConfig } from '~/types/config';\n\nimport { valueToObject } from './utils/config';\n\nexport const defaultPaginationKeywords = [\n  'after',\n  'before',\n  'cursor',\n  'offset',\n  'page',\n  'start',\n] as const;\n\nexport const getParser = (userConfig: UserConfig): Config['parser'] => {\n  const parser = valueToObject({\n    defaultValue: {\n      hooks: {},\n      pagination: {\n        keywords: defaultPaginationKeywords,\n      },\n      transforms: {\n        enums: {\n          case: 'PascalCase',\n          enabled: false,\n          mode: 'root',\n          name: '{{name}}Enum',\n        },\n        propertiesRequiredByDefault: false,\n        readWrite: {\n          enabled: true,\n          requests: {\n            case: 'preserve',\n            name: '{{name}}Writable',\n          },\n          responses: {\n            case: 'preserve',\n            name: '{{name}}',\n          },\n        },\n      },\n      validate_EXPERIMENTAL: false,\n    },\n    mappers: {\n      object: (fields, defaultValue) => ({\n        ...fields,\n        pagination: valueToObject({\n          defaultValue: {\n            ...(defaultValue.pagination as Extract<\n              typeof defaultValue.pagination,\n              Record<string, unknown>\n            >),\n          },\n          value: fields.pagination,\n        }),\n        transforms: valueToObject({\n          defaultValue: {\n            ...(defaultValue.transforms as Extract<\n              typeof defaultValue.transforms,\n              Record<string, unknown>\n            >),\n          },\n          mappers: {\n            object: (fields, defaultValue) => ({\n              ...fields,\n              enums: valueToObject({\n                defaultValue: {\n                  ...(defaultValue.enums as Extract<\n                    typeof defaultValue.enums,\n                    Record<string, unknown>\n                  >),\n                  enabled:\n                    fields.enums !== undefined\n                      ? Boolean(fields.enums)\n                      : (\n                          defaultValue.enums as Extract<\n                            typeof defaultValue.enums,\n                            Record<string, unknown>\n                          >\n                        ).enabled,\n                },\n                mappers: {\n                  boolean: (enabled) => ({ enabled }),\n                  string: (mode) => ({ mode }),\n                },\n                value: fields.enums,\n              }),\n              propertiesRequiredByDefault:\n                fields.propertiesRequiredByDefault !== undefined\n                  ? fields.propertiesRequiredByDefault\n                  : defaultValue.propertiesRequiredByDefault,\n              readWrite: valueToObject({\n                defaultValue: {\n                  ...(defaultValue.readWrite as Extract<\n                    typeof defaultValue.readWrite,\n                    Record<string, unknown>\n                  >),\n                  enabled:\n                    fields.readWrite !== undefined\n                      ? Boolean(fields.readWrite)\n                      : (\n                          defaultValue.readWrite as Extract<\n                            typeof defaultValue.readWrite,\n                            Record<string, unknown>\n                          >\n                        ).enabled,\n                },\n                mappers: {\n                  boolean: (enabled) => ({ enabled }),\n                  object: (fields, defaultValue) => ({\n                    ...fields,\n                    requests: valueToObject({\n                      defaultValue: {\n                        ...(defaultValue.requests as Extract<\n                          typeof defaultValue.requests,\n                          Record<string, unknown>\n                        >),\n                      },\n                      mappers: {\n                        function: (name) => ({ name }),\n                        string: (name) => ({ name }),\n                      },\n                      value: fields.requests,\n                    }),\n                    responses: valueToObject({\n                      defaultValue: {\n                        ...(defaultValue.responses as Extract<\n                          typeof defaultValue.responses,\n                          Record<string, unknown>\n                        >),\n                      },\n                      mappers: {\n                        function: (name) => ({ name }),\n                        string: (name) => ({ name }),\n                      },\n                      value: fields.responses,\n                    }),\n                  }),\n                },\n                value: fields.readWrite,\n              }),\n            }),\n          },\n          value: fields.transforms,\n        }),\n        validate_EXPERIMENTAL:\n          fields.validate_EXPERIMENTAL === true\n            ? 'warn'\n            : fields.validate_EXPERIMENTAL,\n      }),\n    },\n    value: userConfig.parser,\n  });\n  return parser as Config['parser'];\n};\n","import type { Plugin } from '~/plugins';\n\nexport const definePluginConfig =\n  <T extends Plugin.Types>(defaultConfig: Plugin.Config<T>) =>\n  (\n    userConfig?: Omit<Plugin.UserConfig<T['config']>, 'name'>,\n  ): Omit<Plugin.Config<T>, 'name'> & {\n    /**\n     * Cast name to `any` so it doesn't throw type error in `plugins` array.\n     * We could allow any `string` as plugin `name` in the object syntax, but\n     * that TypeScript trick would cause all string methods to appear as\n     * suggested auto completions, which is undesirable.\n     */\n    name: any;\n  } => ({\n    ...defaultConfig,\n    config: {\n      ...defaultConfig.config,\n      ...userConfig,\n    },\n  });\n\n/**\n * Reusable mappers for `enabled` and `name` fields.\n */\nexport const mappers = {\n  boolean: (enabled: boolean) => ({ enabled }),\n  function: (name: (...args: any[]) => any) => ({ name }),\n  string: (name: string) => ({ name }),\n} as const;\n","import type { Selector } from '@hey-api/codegen-core';\n\nimport type { Plugin } from '~/plugins';\n\ntype SelectorType =\n  | 'class'\n  | 'httpRequest'\n  | 'httpResource'\n  | 'HttpRequest'\n  | 'inject'\n  | 'Injectable';\n\nexport type IApi = {\n  /**\n   * @param type Selector type.\n   * @param value Depends on `type`:\n   *  - `class`: raw string entry from path\n   *  - `httpRequest`: `operation.id` string\n   *  - `httpResource`: never\n   *  - `HttpRequest`: never\n   *  - `inject`: never\n   *  - `Injectable`: never\n   * @returns Selector array\n   */\n  selector: (type: SelectorType, value?: string) => Selector;\n};\n\nexport class Api implements IApi {\n  constructor(public meta: Plugin.Name<'@angular/common'>) {}\n\n  selector(...args: ReadonlyArray<string | undefined>): Selector {\n    return [this.meta.name, ...(args as Selector)];\n  }\n}\n","import type { StringCase } from '~/types/case';\n\nconst uppercaseRegExp = /[\\p{Lu}]/u;\nconst lowercaseRegExp = /[\\p{Ll}]/u;\nconst identifierRegExp = /([\\p{Alpha}\\p{N}_]|$)/u;\nconst separatorsRegExp = /[_.\\- `\\\\[\\]{}\\\\/]+/;\n\nconst leadingSeparatorsRegExp = new RegExp(`^${separatorsRegExp.source}`);\nconst separatorsAndIdentifierRegExp = new RegExp(\n  `${separatorsRegExp.source}${identifierRegExp.source}`,\n  'gu',\n);\nconst numbersAndIdentifierRegExp = new RegExp(\n  `\\\\d+${identifierRegExp.source}`,\n  'gu',\n);\n\nconst preserveCase = ({\n  case: _case,\n  string,\n}: {\n  readonly case: StringCase;\n  string: string;\n}) => {\n  let isLastCharLower = false;\n  let isLastCharUpper = false;\n  let isLastLastCharUpper = false;\n  let isLastLastCharPreserved = false;\n\n  const separator =\n    _case === 'snake_case' || _case === 'SCREAMING_SNAKE_CASE' ? '_' : '-';\n\n  for (let index = 0; index < string.length; index++) {\n    const character = string[index]!;\n    isLastLastCharPreserved =\n      index > 2 ? string[index - 3] === separator : true;\n\n    let nextIndex = index + 1;\n    let nextCharacter = string[nextIndex];\n    separatorsRegExp.lastIndex = 0;\n    while (nextCharacter && separatorsRegExp.test(nextCharacter)) {\n      nextIndex += 1;\n      nextCharacter = string[nextIndex];\n    }\n    const isSeparatorBeforeNextCharacter = nextIndex !== index + 1;\n\n    lowercaseRegExp.lastIndex = 0;\n    uppercaseRegExp.lastIndex = 0;\n    if (\n      uppercaseRegExp.test(character) &&\n      (isLastCharLower ||\n        (nextCharacter &&\n          !isSeparatorBeforeNextCharacter &&\n          nextCharacter !== 's' &&\n          lowercaseRegExp.test(nextCharacter)))\n    ) {\n      // insert separator behind character\n      string = `${string.slice(0, index)}${separator}${string.slice(index)}`;\n      index++;\n      isLastLastCharUpper = isLastCharUpper;\n      isLastCharLower = false;\n      isLastCharUpper = true;\n    } else if (\n      isLastCharUpper &&\n      isLastLastCharUpper &&\n      lowercaseRegExp.test(character) &&\n      !isLastLastCharPreserved &&\n      // naive detection of plurals\n      !(\n        character === 's' &&\n        (!nextCharacter || nextCharacter.toLocaleLowerCase() !== nextCharacter)\n      )\n    ) {\n      // insert separator 2 characters behind\n      string = `${string.slice(0, index - 1)}${separator}${string.slice(index - 1)}`;\n      isLastLastCharUpper = isLastCharUpper;\n      isLastCharLower = true;\n      isLastCharUpper = false;\n    } else {\n      const characterLower = character.toLocaleLowerCase();\n      const characterUpper = character.toLocaleUpperCase();\n      isLastLastCharUpper = isLastCharUpper;\n      isLastCharLower =\n        characterLower === character && characterUpper !== character;\n      isLastCharUpper =\n        characterUpper === character && characterLower !== character;\n    }\n  }\n\n  return string;\n};\n\nexport const stringCase = ({\n  case: _case,\n  stripLeadingSeparators = true,\n  value,\n}: {\n  readonly case: StringCase | undefined;\n  /**\n   * If leading separators have a semantic meaning, we might not want to\n   * remove them.\n   */\n  stripLeadingSeparators?: boolean;\n  value: string;\n}): string => {\n  let result = value.trim();\n\n  if (!result.length) {\n    return '';\n  }\n\n  if (!_case || _case === 'preserve') {\n    return result;\n  }\n\n  if (result.length === 1) {\n    separatorsRegExp.lastIndex = 0;\n    if (separatorsRegExp.test(result)) {\n      return '';\n    }\n\n    return _case === 'PascalCase' || _case === 'SCREAMING_SNAKE_CASE'\n      ? result.toLocaleUpperCase()\n      : result.toLocaleLowerCase();\n  }\n\n  const hasUpperCase = result !== result.toLocaleLowerCase();\n\n  if (hasUpperCase) {\n    result = preserveCase({ case: _case, string: result });\n  }\n\n  if (stripLeadingSeparators || result[0] !== value[0]) {\n    result = result.replace(leadingSeparatorsRegExp, '');\n  }\n\n  result =\n    _case === 'SCREAMING_SNAKE_CASE'\n      ? result.toLocaleUpperCase()\n      : result.toLocaleLowerCase();\n\n  if (_case === 'PascalCase') {\n    result = `${result.charAt(0).toLocaleUpperCase()}${result.slice(1)}`;\n  }\n\n  if (_case === 'snake_case' || _case === 'SCREAMING_SNAKE_CASE') {\n    result = result.replaceAll(\n      separatorsAndIdentifierRegExp,\n      (match, identifier, offset) => {\n        if (offset === 0 && !stripLeadingSeparators) {\n          return match;\n        }\n        return `_${identifier}`;\n      },\n    );\n\n    if (result[result.length - 1] === '_') {\n      // strip trailing underscore\n      result = result.slice(0, result.length - 1);\n    }\n  } else {\n    separatorsAndIdentifierRegExp.lastIndex = 0;\n    numbersAndIdentifierRegExp.lastIndex = 0;\n\n    result = result.replaceAll(\n      numbersAndIdentifierRegExp,\n      (match, _, offset) => {\n        if (['_', '-', '.'].includes(result.charAt(offset + match.length))) {\n          return match;\n        }\n\n        return match.toLocaleUpperCase();\n      },\n    );\n\n    result = result.replaceAll(\n      separatorsAndIdentifierRegExp,\n      (match, identifier, offset) => {\n        if (\n          offset === 0 &&\n          !stripLeadingSeparators &&\n          match[0] &&\n          value.startsWith(match[0])\n        ) {\n          return match;\n        }\n        return identifier.toLocaleUpperCase();\n      },\n    );\n  }\n\n  return result;\n};\n","import { stringCase } from '~/utils/stringCase';\n\nimport type { StringCase, StringName } from '../../../types/case';\n\nexport const buildName = ({\n  config,\n  name,\n}: {\n  config: {\n    case: StringCase;\n    name?: StringName;\n  };\n  name: string;\n}): string => {\n  if (typeof config.name === 'function') {\n    name = config.name(name);\n  } else if (config.name) {\n    const separator = config.case === 'preserve' ? '' : '-';\n    name = config.name.replace('{{name}}', `${separator}${name}${separator}`);\n  }\n\n  return stringCase({ case: config.case, value: name });\n};\n","import type { Pagination } from './pagination';\nimport type { IR } from './types';\n\nconst getPaginationSchema = ({\n  context,\n  parameter,\n}: {\n  context: IR.Context;\n  parameter: IR.ParameterObject;\n}): IR.SchemaObject | undefined => {\n  if (!parameter.pagination) {\n    return;\n  }\n\n  if (parameter.pagination === true) {\n    return parameter.schema;\n  }\n\n  let schema = parameter.schema;\n  if (schema.$ref) {\n    schema = context.resolveIrRef<IR.SchemaObject>(schema.$ref);\n  }\n\n  return schema.properties![parameter.pagination]!;\n};\n\nexport const hasParameterGroupObjectRequired = (\n  parameterGroup?: Record<string, IR.ParameterObject>,\n): boolean => {\n  for (const name in parameterGroup) {\n    if (parameterGroup[name]!.required) {\n      return true;\n    }\n  }\n\n  return false;\n};\n\nexport const hasParametersObjectRequired = (\n  parameters: IR.ParametersObject | undefined,\n): boolean => {\n  if (!parameters) {\n    return false;\n  }\n\n  if (hasParameterGroupObjectRequired(parameters.cookie)) {\n    return true;\n  }\n\n  if (hasParameterGroupObjectRequired(parameters.header)) {\n    return true;\n  }\n\n  if (hasParameterGroupObjectRequired(parameters.path)) {\n    return true;\n  }\n\n  if (hasParameterGroupObjectRequired(parameters.query)) {\n    return true;\n  }\n\n  return false;\n};\n\nexport const parameterWithPagination = ({\n  context,\n  parameters,\n}: {\n  context: IR.Context;\n  parameters: IR.ParametersObject | undefined;\n}): Pagination | undefined => {\n  if (!parameters) {\n    return;\n  }\n\n  for (const name in parameters.cookie) {\n    const parameter = parameters.cookie[name]!;\n    if (parameter.pagination) {\n      return {\n        in: parameter.location,\n        name:\n          parameter.pagination === true\n            ? parameter.name\n            : `${parameter.name}.${parameter.pagination}`,\n        schema: getPaginationSchema({ context, parameter })!,\n      };\n    }\n  }\n\n  for (const name in parameters.header) {\n    const parameter = parameters.header[name]!;\n    if (parameter.pagination) {\n      return {\n        in: parameter.location,\n        name:\n          parameter.pagination === true\n            ? parameter.name\n            : `${parameter.name}.${parameter.pagination}`,\n        schema: getPaginationSchema({ context, parameter })!,\n      };\n    }\n  }\n\n  for (const name in parameters.path) {\n    const parameter = parameters.path[name]!;\n    if (parameter.pagination) {\n      return {\n        in: parameter.location,\n        name:\n          parameter.pagination === true\n            ? parameter.name\n            : `${parameter.name}.${parameter.pagination}`,\n        schema: getPaginationSchema({ context, parameter })!,\n      };\n    }\n  }\n\n  for (const name in parameters.query) {\n    const parameter = parameters.query[name]!;\n    if (parameter.pagination) {\n      return {\n        in: parameter.location,\n        name:\n          parameter.pagination === true\n            ? parameter.name\n            : `${parameter.name}.${parameter.pagination}`,\n        schema: getPaginationSchema({ context, parameter })!,\n      };\n    }\n  }\n\n  return;\n};\n","import type { IR } from './types';\n\n/**\n * Ensure we don't produce redundant types, e.g. string | string.\n */\nexport const deduplicateSchema = <T extends IR.SchemaObject>({\n  detectFormat = true,\n  schema,\n}: {\n  detectFormat?: boolean;\n  schema: T;\n}): T => {\n  if (!schema.items) {\n    return schema;\n  }\n\n  const uniqueItems: Array<IR.SchemaObject> = [];\n  const typeIds: Array<string> = [];\n\n  for (const item of schema.items) {\n    // skip nested schemas for now, handle if necessary\n    if ((!item.type && item.items) || schema.type === 'tuple') {\n      uniqueItems.push(item);\n      continue;\n    }\n\n    if (\n      // no `type` might still include `$ref` or `const`\n      !item.type ||\n      item.type === 'boolean' ||\n      item.type === 'integer' ||\n      item.type === 'null' ||\n      item.type === 'number' ||\n      item.type === 'string' ||\n      item.type === 'unknown' ||\n      item.type === 'void'\n    ) {\n      // const needs namespace to handle empty string values, otherwise\n      // fallback would equal an actual value and we would skip an item\n      const constant = item.const !== undefined ? `const-${item.const}` : '';\n      const format =\n        item.format !== undefined && detectFormat\n          ? `format-${item.format}`\n          : '';\n\n      // Include validation constraints in the type ID to avoid incorrect deduplication\n      const constraints = [\n        item.minLength !== undefined ? `minLength-${item.minLength}` : '',\n        item.maxLength !== undefined ? `maxLength-${item.maxLength}` : '',\n        item.minimum !== undefined ? `minimum-${item.minimum}` : '',\n        item.maximum !== undefined ? `maximum-${item.maximum}` : '',\n        item.exclusiveMinimum !== undefined\n          ? `exclusiveMinimum-${item.exclusiveMinimum}`\n          : '',\n        item.exclusiveMaximum !== undefined\n          ? `exclusiveMaximum-${item.exclusiveMaximum}`\n          : '',\n        item.minItems !== undefined ? `minItems-${item.minItems}` : '',\n        item.maxItems !== undefined ? `maxItems-${item.maxItems}` : '',\n        item.pattern !== undefined ? `pattern-${item.pattern}` : '',\n      ].join('');\n\n      const typeId = `${item.$ref ?? ''}${item.type ?? ''}${constant}${format}${constraints}`;\n      if (!typeIds.includes(typeId)) {\n        typeIds.push(typeId);\n        uniqueItems.push(item);\n      }\n      continue;\n    }\n\n    uniqueItems.push(item);\n  }\n\n  let result = { ...schema };\n  result.items = uniqueItems;\n\n  if (\n    result.items.length <= 1 &&\n    result.type !== 'array' &&\n    result.type !== 'enum' &&\n    result.type !== 'tuple'\n  ) {\n    // bring the only item up to clean up the schema\n    const liftedSchema = result.items[0];\n    delete result.logicalOperator;\n    delete result.items;\n    result = {\n      ...result,\n      ...liftedSchema,\n    };\n  }\n\n  // exclude unknown if it's the only type left\n  if (result.type === 'unknown') {\n    return {} as T;\n  }\n\n  return result;\n};\n","import type { IR } from './types';\n\n/**\n * Simply adds `items` to the schema. Also handles setting the logical operator\n * and avoids setting it for a single item or tuples.\n */\nexport const addItemsToSchema = ({\n  items,\n  logicalOperator = 'or',\n  mutateSchemaOneItem = false,\n  schema,\n}: {\n  items: Array<IR.SchemaObject>;\n  logicalOperator?: IR.SchemaObject['logicalOperator'];\n  mutateSchemaOneItem?: boolean;\n  schema: IR.SchemaObject;\n}) => {\n  if (!items.length) {\n    return schema;\n  }\n\n  if (schema.type === 'tuple') {\n    schema.items = items;\n    return schema;\n  }\n\n  if (items.length !== 1) {\n    schema.items = items;\n    schema.logicalOperator = logicalOperator;\n    return schema;\n  }\n\n  if (mutateSchemaOneItem) {\n    // bring composition up to avoid extraneous brackets\n    schema = {\n      ...schema,\n      ...items[0],\n    };\n    return schema;\n  }\n\n  schema.items = items;\n  return schema;\n};\n","import type { Pagination } from './pagination';\nimport {\n  hasParametersObjectRequired,\n  parameterWithPagination,\n} from './parameter';\nimport { deduplicateSchema } from './schema';\nimport type { IR } from './types';\nimport { addItemsToSchema } from './utils';\n\nexport const hasOperationDataRequired = (\n  operation: IR.OperationObject,\n): boolean => {\n  if (hasParametersObjectRequired(operation.parameters)) {\n    return true;\n  }\n\n  if (operation.body?.required) {\n    return true;\n  }\n\n  return false;\n};\n\nexport const createOperationKey = ({\n  method,\n  path,\n}: {\n  method: string;\n  path: string;\n}) => `${method.toUpperCase()} ${path}`;\n\nexport const operationPagination = ({\n  context,\n  operation,\n}: {\n  context: IR.Context;\n  operation: IR.OperationObject;\n}): Pagination | undefined => {\n  const body = operation.body;\n\n  if (!body || !body.pagination) {\n    return parameterWithPagination({\n      context,\n      parameters: operation.parameters,\n    });\n  }\n\n  if (body.pagination === true) {\n    return {\n      in: 'body',\n      name: 'body',\n      schema: body.schema,\n    };\n  }\n\n  const schema = body.schema;\n  const resolvedSchema = schema.$ref\n    ? context.resolveIrRef<IR.RequestBodyObject | IR.SchemaObject>(schema.$ref)\n    : schema;\n\n  const finalSchema =\n    'schema' in resolvedSchema ? resolvedSchema.schema : resolvedSchema;\n  const paginationProp = finalSchema?.properties?.[body.pagination];\n\n  if (!paginationProp) {\n    return parameterWithPagination({\n      context,\n      parameters: operation.parameters,\n    });\n  }\n\n  return {\n    in: 'body',\n    name: body.pagination,\n    schema: paginationProp,\n  };\n};\n\ntype StatusGroup = '1XX' | '2XX' | '3XX' | '4XX' | '5XX' | 'default';\n\nexport const statusCodeToGroup = ({\n  statusCode,\n}: {\n  statusCode: string;\n}): StatusGroup => {\n  switch (statusCode) {\n    case '1XX':\n      return '1XX';\n    case '2XX':\n      return '2XX';\n    case '3XX':\n      return '3XX';\n    case '4XX':\n      return '4XX';\n    case '5XX':\n      return '5XX';\n    case 'default':\n      return 'default';\n    default:\n      return `${statusCode[0]}XX` as StatusGroup;\n  }\n};\n\ninterface OperationResponsesMap {\n  /**\n   * A deduplicated union of all error types. Unknown types are omitted.\n   */\n  error?: IR.SchemaObject;\n  /**\n   * An object containing a map of status codes for each error type.\n   */\n  errors?: IR.SchemaObject;\n  /**\n   * A deduplicated union of all response types. Unknown types are omitted.\n   */\n  response?: IR.SchemaObject;\n  /**\n   * An object containing a map of status codes for each response type.\n   */\n  responses?: IR.SchemaObject;\n}\n\nexport const operationResponsesMap = (\n  operation: IR.OperationObject,\n): OperationResponsesMap => {\n  const result: OperationResponsesMap = {};\n\n  if (!operation.responses) {\n    return result;\n  }\n\n  const errors: Omit<IR.SchemaObject, 'properties'> &\n    Pick<Required<IR.SchemaObject>, 'properties'> = {\n    properties: {},\n    type: 'object',\n  };\n\n  const responses: Omit<IR.SchemaObject, 'properties'> &\n    Pick<Required<IR.SchemaObject>, 'properties'> = {\n    properties: {},\n    type: 'object',\n  };\n\n  // store default response to be evaluated last\n  let defaultResponse: IR.ResponseObject | undefined;\n\n  for (const name in operation.responses) {\n    const response = operation.responses[name]!;\n\n    switch (statusCodeToGroup({ statusCode: name })) {\n      case '1XX':\n      case '3XX':\n        // TODO: parser - handle informational and redirection status codes\n        break;\n      case '2XX':\n        responses.properties[name] = response.schema;\n        break;\n      case '4XX':\n      case '5XX':\n        errors.properties[name] = response.schema;\n        break;\n      case 'default':\n        defaultResponse = response;\n        break;\n    }\n  }\n\n  // infer default response type\n  if (defaultResponse) {\n    let inferred = false;\n\n    // assume default is intended for success if none exists yet\n    if (!Object.keys(responses.properties).length) {\n      responses.properties.default = defaultResponse.schema;\n      inferred = true;\n    }\n\n    const description = (\n      defaultResponse.schema.description ?? ''\n    ).toLocaleLowerCase();\n    const $ref = (defaultResponse.schema.$ref ?? '').toLocaleLowerCase();\n\n    // TODO: parser - this could be rewritten using regular expressions\n    const successKeywords = ['success'];\n    if (\n      successKeywords.some(\n        (keyword) => description.includes(keyword) || $ref.includes(keyword),\n      )\n    ) {\n      responses.properties.default = defaultResponse.schema;\n      inferred = true;\n    }\n\n    // TODO: parser - this could be rewritten using regular expressions\n    const errorKeywords = ['error', 'problem'];\n    if (\n      errorKeywords.some(\n        (keyword) => description.includes(keyword) || $ref.includes(keyword),\n      )\n    ) {\n      errors.properties.default = defaultResponse.schema;\n      inferred = true;\n    }\n\n    // if no keyword match, assume default schema is intended for error\n    if (!inferred) {\n      errors.properties.default = defaultResponse.schema;\n    }\n  }\n\n  const errorKeys = Object.keys(errors.properties);\n  if (errorKeys.length) {\n    errors.required = errorKeys;\n    result.errors = errors;\n\n    let errorUnion = addItemsToSchema({\n      items: Object.values(errors.properties),\n      mutateSchemaOneItem: true,\n      schema: {},\n    });\n    errorUnion = deduplicateSchema({ schema: errorUnion });\n    if (Object.keys(errorUnion).length && errorUnion.type !== 'unknown') {\n      result.error = errorUnion;\n    }\n  }\n\n  const responseKeys = Object.keys(responses.properties);\n  if (responseKeys.length) {\n    responses.required = responseKeys;\n    result.responses = responses;\n\n    let responseUnion = addItemsToSchema({\n      items: Object.values(responses.properties),\n      mutateSchemaOneItem: true,\n      schema: {},\n    });\n    responseUnion = deduplicateSchema({ schema: responseUnion });\n    if (Object.keys(responseUnion).length && responseUnion.type !== 'unknown') {\n      result.response = responseUnion;\n    }\n  }\n\n  return result;\n};\n","import type { RangeOptions, SemVer } from 'semver';\nimport * as semver from 'semver';\n\nexport type Package = {\n  /**\n   * Get the installed version of a package.\n   * @param name The name of the package to get the version for.\n   * @returns A SemVer object containing version information, or undefined if the package is not installed\n   *         or the version string is invalid.\n   */\n  getVersion: (name: string) => SemVer | undefined;\n  /**\n   * Check if a given package is installed in the project.\n   * @param name The name of the package to check.\n   */\n  isInstalled: (name: string) => boolean;\n  /**\n   * Check if the installed version of a package or a given SemVer object satisfies a semver range.\n   * @param nameOrVersion The name of the package to check, or a SemVer object.\n   * @param range The semver range to check against.\n   * @returns True if the version satisfies the range, false otherwise.\n   */\n  satisfies: (\n    nameOrVersion: string | SemVer,\n    range: string,\n    optionsOrLoose?: boolean | RangeOptions,\n  ) => boolean;\n};\n\nexport const satisfies: typeof semver.satisfies = (...args) =>\n  semver.satisfies(...args);\n\nexport const packageFactory = (\n  dependencies: Record<string, string>,\n): Package => ({\n  getVersion: (name) => {\n    const version = dependencies[name];\n    if (!version) return;\n    try {\n      let parsed = semver.parse(version);\n      if (parsed) return parsed;\n\n      const min = semver.minVersion(version);\n      if (min) return min;\n\n      parsed = semver.coerce(version);\n      if (parsed) return parsed;\n    } catch {\n      // noop\n    }\n    return;\n  },\n  isInstalled: (name) => Boolean(dependencies[name]),\n  satisfies: (nameOrVersion, range, optionsOrLoose) => {\n    const version =\n      typeof nameOrVersion === 'string'\n        ? dependencies[nameOrVersion]\n        : nameOrVersion;\n    return version ? satisfies(version, range, optionsOrLoose) : false;\n  },\n});\n","/**\n * Matches characters from the start as long as they're not allowed.\n */\nexport const illegalStartCharactersRegExp = /^[^$_\\p{ID_Start}]+/u;\n\n/**\n * Matches string if it contains only digits and optionally decimal point or\n * leading minus sign.\n */\nexport const numberRegExp = /^-?\\d+(\\.\\d+)?$/;\n\nexport const reservedBrowserGlobalsRegExp =\n  /^(document|history|location|navigator|window)$/g;\n\nexport const reservedJavaScriptGlobalsRegExp =\n  /^(console|Array|Date|Error|Function|JSON|Map|Math|Object|Promise|RegExp|Set|WeakMap|WeakSet)$/g;\n\nexport const reservedJavaScriptKeywordsRegExp =\n  /^(arguments|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|eval|export|extends|false|finally|for|from|function|if|implements|import|in|instanceof|interface|let|new|null|package|private|protected|public|return|static|super|switch|this|throw|true|try|typeof|var|void|while|with|yield)$/g;\n\nexport const reservedNodeGlobalsRegExp = /^(global|process|Buffer)$/g;\n\nexport const reservedTypeScriptKeywordsRegExp =\n  /^(any|as|bigint|boolean|namespace|never|null|number|string|symbol|type|undefined|unknown|void)$/g;\n\n/**\n * Javascript identifier regexp pattern retrieved from\n * {@link} https://developer.mozilla.org/docs/Web/JavaScript/Reference/Lexical_grammar#identifiers\n */\nexport const validTypescriptIdentifierRegExp =\n  /^[$_\\p{ID_Start}][$\\u200c\\u200d\\p{ID_Continue}]*$/u;\n","import {\n  illegalStartCharactersRegExp,\n  reservedBrowserGlobalsRegExp,\n  reservedJavaScriptGlobalsRegExp,\n  reservedJavaScriptKeywordsRegExp,\n  reservedNodeGlobalsRegExp,\n  reservedTypeScriptKeywordsRegExp,\n} from '~/utils/regexp';\n\nconst regexps = [\n  reservedJavaScriptKeywordsRegExp,\n  reservedTypeScriptKeywordsRegExp,\n  reservedJavaScriptGlobalsRegExp,\n  reservedNodeGlobalsRegExp,\n  reservedBrowserGlobalsRegExp,\n];\n\nexport const ensureValidIdentifier = (name: string): string => {\n  let identifier = name.replace(/[^$\\u200c\\u200d\\p{ID_Continue}]/gu, '_');\n\n  illegalStartCharactersRegExp.lastIndex = 0;\n  if (illegalStartCharactersRegExp.test(identifier)) {\n    return `_${identifier}`;\n  }\n\n  for (const regexp of regexps) {\n    if (identifier.startsWith('_')) {\n      return identifier;\n    }\n\n    identifier = identifier.replace(regexp, '_$1');\n  }\n\n  return identifier;\n};\n","import { EOL } from 'node:os';\n\nimport { validTypescriptIdentifierRegExp } from './regexp';\n\nexport const escapeName = (value: string): string => {\n  if (value || value === '') {\n    validTypescriptIdentifierRegExp.lastIndex = 0;\n    const validName = validTypescriptIdentifierRegExp.test(value);\n    if (!validName) {\n      return `'${value}'`;\n    }\n  }\n  return value;\n};\n\nexport const unescapeName = (value: string): string => {\n  if (value && value.startsWith(\"'\") && value.endsWith(\"'\")) {\n    return value.slice(1, value.length - 1);\n  }\n  return value;\n};\n\nexport const escapeComment = (value: string) =>\n  value\n    .replace(/\\*\\//g, '*')\n    .replace(/\\/\\*/g, '*')\n    .replace(/\\r?\\n(.*)/g, (_l, w) => EOL + w.trim());\n","import ts from 'typescript';\n\nimport { getConfig } from '~/utils/config';\nimport { unescapeName } from '~/utils/escape';\n\nimport type { AccessLevel } from './types';\nimport { createStringLiteral, syntaxKindKeyword } from './types';\n\nexport interface ImportExportItemObject<\n  Name extends string | undefined = string | undefined,\n  Alias extends string | undefined = undefined,\n> {\n  alias?: Alias;\n  asType?: boolean;\n  name: Name;\n}\n\nconst printer = ts.createPrinter({\n  newLine: ts.NewLineKind.LineFeed,\n  removeComments: false,\n});\n\nexport const createSourceFile = (sourceText: string): ts.SourceFile =>\n  ts.createSourceFile(\n    '',\n    sourceText,\n    ts.ScriptTarget.ESNext,\n    false,\n    ts.ScriptKind.TS,\n  );\n\nconst blankSourceFile = createSourceFile('');\n\nconst unescapeUnicode = (value: string) =>\n  value.replace(/\\\\u([0-9a-fA-F]{4})/g, (_, hex: string) =>\n    String.fromCharCode(Number.parseInt(hex, 16)),\n  );\n\n/**\n * Print a TypeScript node to a string.\n * @param node the node to print\n * @returns string\n */\nexport function tsNodeToString({\n  node,\n  unescape = false,\n}: {\n  node: ts.Node;\n  unescape?: boolean;\n}): string {\n  const result = printer.printNode(\n    ts.EmitHint.Unspecified,\n    node,\n    blankSourceFile,\n  );\n\n  if (!unescape) {\n    return result;\n  }\n\n  try {\n    /**\n     * TypeScript Compiler API escapes unicode characters by default and there\n     * is no way to disable this behavior\n     * {@link https://github.com/microsoft/TypeScript/issues/36174}\n     */\n    return unescapeUnicode(result);\n  } catch {\n    if (getConfig().logs.level === 'debug') {\n      console.warn('Could not decode value:', result);\n    }\n    return result;\n  }\n}\n\nexport const createIdentifier = ({ text }: { text: string }): ts.Identifier =>\n  ts.factory.createIdentifier(text);\n\nexport const createThis = (): ts.ThisExpression => ts.factory.createThis();\n\ntype Modifier = AccessLevel | 'async' | 'export' | 'readonly' | 'static';\n\nexport const createModifier = ({ keyword }: { keyword: Modifier }) => {\n  const kind = syntaxKindKeyword({ keyword });\n  return ts.factory.createModifier(kind);\n};\n\nexport const createPropertyDeclaration = ({\n  initializer,\n  modifier,\n  name,\n  type,\n}: {\n  initializer?: ts.Expression;\n  modifier?: Modifier;\n  name: string | ts.PropertyName;\n  type?: ts.TypeNode;\n}) => {\n  const node = ts.factory.createPropertyDeclaration(\n    modifier ? [createModifier({ keyword: modifier })] : undefined,\n    name,\n    undefined,\n    type,\n    initializer,\n  );\n  return node;\n};\n\n/**\n * ots for @hey-api/openapi-ts are helpers to reduce repetition of basic TypeScript\n * factory functions.\n */\nexport const ots = {\n  /**\n   * Create a boolean expression based on value.\n   */\n  boolean: (value: boolean) =>\n    value ? ts.factory.createTrue() : ts.factory.createFalse(),\n  export: ({ alias, asType = false, name }: ImportExportItemObject) => {\n    const nameNode = createIdentifier({ text: name! });\n    if (alias) {\n      const aliasNode = createIdentifier({ text: alias });\n      return ts.factory.createExportSpecifier(asType, nameNode, aliasNode);\n    }\n    return ts.factory.createExportSpecifier(asType, undefined, nameNode);\n  },\n  import: ({ alias, asType = false, name }: ImportExportItemObject) => {\n    const nameNode = createIdentifier({ text: name! });\n    if (alias) {\n      const aliasNode = createIdentifier({ text: alias });\n      return ts.factory.createImportSpecifier(asType, nameNode, aliasNode);\n    }\n    return ts.factory.createImportSpecifier(asType, undefined, nameNode);\n  },\n  /**\n   * Create a numeric expression, handling negative numbers.\n   */\n  number: (value: number) => {\n    if (value < 0) {\n      return ts.factory.createPrefixUnaryExpression(\n        ts.SyntaxKind.MinusToken,\n        ts.factory.createNumericLiteral(Math.abs(value)),\n      );\n    }\n    return ts.factory.createNumericLiteral(value);\n  },\n  /**\n   * Create a string literal. This handles strings that start with '`' or \"'\".\n   */\n  string: (value: string, unescape = false) => {\n    let text = value;\n    if (unescape) {\n      text = unescapeName(text);\n    }\n    const hasBothQuotes = text.includes(\"'\") && text.includes('\"');\n    const hasNewlines = text.includes('\\n');\n    const hasUnescapedBackticks = text.startsWith('`');\n    const isBacktickEscaped = text.startsWith('\\\\`') && text.endsWith('\\\\`');\n    if (\n      (hasNewlines || hasBothQuotes || hasUnescapedBackticks) &&\n      !isBacktickEscaped\n    ) {\n      text = `\\`${text.replace(/(?<!\\\\)`/g, '\\\\`').replace(/\\${/g, '\\\\${')}\\``;\n    }\n    if (text.startsWith('`')) {\n      return createIdentifier({ text });\n    }\n    return createStringLiteral({ text });\n  },\n};\n\nexport const isTsNode = (node: any): node is ts.Expression =>\n  node !== null &&\n  typeof node === 'object' &&\n  typeof node.kind === 'number' &&\n  typeof node.flags === 'number' &&\n  typeof node.pos === 'number' &&\n  typeof node.end === 'number';\n\nexport const isType = <T>(value: T | undefined): value is T =>\n  value !== undefined;\n\ntype CommentLines = Array<string | null | false | undefined>;\ntype CommentObject = {\n  jsdoc?: boolean;\n  lines: CommentLines;\n};\nexport type Comments = CommentLines | Array<CommentObject>;\n\nconst processCommentObject = ({\n  commentObject,\n  node,\n}: {\n  commentObject: CommentObject;\n  node: ts.Node;\n}) => {\n  const lines = commentObject.lines.filter(\n    (line) => Boolean(line) || line === '',\n  ) as string[];\n  if (!lines.length) {\n    return;\n  }\n\n  if (!commentObject.jsdoc) {\n    for (const line of lines) {\n      ts.addSyntheticLeadingComment(\n        node,\n        ts.SyntaxKind.SingleLineCommentTrivia,\n        ` ${line}`,\n        true,\n      );\n    }\n    return;\n  }\n\n  const jsdocTexts = lines.map((line, index) => {\n    let text = line;\n    if (index !== lines.length) {\n      text = `${text}\\n`;\n    }\n    const jsdocText = ts.factory.createJSDocText(text);\n    return jsdocText;\n  });\n\n  const jsdoc = ts.factory.createJSDocComment(\n    ts.factory.createNodeArray(jsdocTexts),\n    undefined,\n  );\n\n  const cleanedJsdoc = tsNodeToString({ node: jsdoc, unescape: true })\n    .replace('/*', '')\n    .replace('*  */', '');\n\n  ts.addSyntheticLeadingComment(\n    node,\n    ts.SyntaxKind.MultiLineCommentTrivia,\n    cleanedJsdoc,\n    true,\n  );\n};\n\nexport const addLeadingComments = ({\n  comments = [],\n  node,\n}: {\n  comments?: Comments;\n  node: ts.Node;\n}) => {\n  const isObjectStyle = Boolean(\n    comments.find((comment) => typeof comment === 'object' && comment),\n  );\n\n  let commentObjects = comments as Array<CommentObject>;\n  if (!isObjectStyle) {\n    commentObjects = [\n      {\n        jsdoc: true,\n        lines: comments as CommentLines,\n      },\n    ];\n  }\n\n  for (const commentObject of commentObjects) {\n    processCommentObject({\n      commentObject,\n      node,\n    });\n  }\n};\n","import ts from 'typescript';\n\nimport { escapeName } from '~/utils/escape';\nimport { validTypescriptIdentifierRegExp } from '~/utils/regexp';\n\nimport {\n  addLeadingComments,\n  type Comments,\n  createIdentifier,\n  createModifier,\n  isTsNode,\n  isType,\n  ots,\n} from './utils';\n\nexport type AccessLevel = 'private' | 'protected' | 'public';\n\nexport type FunctionParameter =\n  | {\n      accessLevel?: AccessLevel;\n      default?: any;\n      isReadOnly?: boolean;\n      isRequired?: boolean;\n      name: string;\n      type?: any | ts.TypeNode;\n    }\n  | {\n      destructure: ReadonlyArray<FunctionParameter>;\n      type?: any | ts.TypeNode;\n    };\n\nexport interface FunctionTypeParameter {\n  default?: any;\n  extends?: string | ts.TypeNode;\n  name: string | ts.Identifier;\n}\n\nexport const createTypeNode = (\n  base: any | ts.TypeNode,\n  args?: (any | ts.TypeNode)[],\n): ts.TypeNode => {\n  if (ts.isTypeNode(base)) {\n    return base;\n  }\n\n  if (typeof base === 'number') {\n    return ts.factory.createLiteralTypeNode(ots.number(base));\n  }\n\n  return createTypeReferenceNode({\n    typeArguments: args?.map((arg) => createTypeNode(arg)),\n    typeName: ts.isIdentifier(base) ? base.text : base,\n  });\n};\n\nexport const createPropertyAccessChain = ({\n  expression,\n  name,\n}: {\n  expression: ts.Expression;\n  name: string | ts.MemberName;\n}) => {\n  const node = ts.factory.createPropertyAccessChain(\n    expression,\n    ts.factory.createToken(ts.SyntaxKind.QuestionDotToken),\n    name,\n  );\n  return node;\n};\n\nexport const createPropertyAccessExpression = ({\n  expression,\n  isOptional,\n  name,\n}: {\n  expression: string | ts.Expression;\n  isOptional?: boolean;\n  name: string | number | ts.MemberName;\n}):\n  | ts.PropertyAccessChain\n  | ts.PropertyAccessExpression\n  | ts.ElementAccessExpression => {\n  const nodeExpression =\n    typeof expression === 'string'\n      ? createIdentifier({ text: expression })\n      : expression;\n\n  if (isOptional && typeof name !== 'number') {\n    return createPropertyAccessChain({\n      expression: nodeExpression,\n      name,\n    });\n  }\n\n  if (typeof name === 'string') {\n    validTypescriptIdentifierRegExp.lastIndex = 0;\n    if (!validTypescriptIdentifierRegExp.test(name)) {\n      // TODO: parser - this should escape name only for new parser\n      if (!name.startsWith(\"'\") && !name.endsWith(\"'\")) {\n        // eslint-disable-next-line no-useless-escape\n        name = `\\'${name}\\'`;\n      }\n      const nodeName = createIdentifier({ text: name });\n      return ts.factory.createElementAccessExpression(nodeExpression, nodeName);\n    }\n\n    const nodeName = createIdentifier({ text: name });\n    return ts.factory.createPropertyAccessExpression(nodeExpression, nodeName);\n  }\n\n  if (typeof name === 'number') {\n    const nodeName = ts.factory.createNumericLiteral(name);\n    return ts.factory.createElementAccessExpression(nodeExpression, nodeName);\n  }\n\n  return ts.factory.createPropertyAccessExpression(nodeExpression, name);\n};\n\nexport const createNull = (): ts.NullLiteral => ts.factory.createNull();\n\n/**\n * Convert an unknown value to an expression.\n * @param identifiers - list of keys that are treated as identifiers.\n * @param shorthand - if shorthand syntax is allowed.\n * @param unescape - if string should be unescaped.\n * @param value - the unknown value.\n * @returns ts.Expression\n */\nexport const toExpression = <T = unknown>({\n  identifiers = [],\n  isValueAccess,\n  shorthand,\n  unescape,\n  value,\n}: {\n  identifiers?: string[];\n  isValueAccess?: boolean;\n  shorthand?: boolean;\n  unescape?: boolean;\n  value: T;\n}): ts.Expression | undefined => {\n  if (value === null) {\n    return createNull();\n  }\n\n  if (Array.isArray(value)) {\n    return createArrayLiteralExpression({ elements: value });\n  }\n\n  if (typeof value === 'object') {\n    return createObjectType({\n      identifiers,\n      obj: value,\n      shorthand,\n    });\n  }\n\n  if (typeof value === 'number') {\n    return ots.number(value);\n  }\n\n  if (typeof value === 'boolean') {\n    return ots.boolean(value);\n  }\n\n  if (typeof value === 'string') {\n    if (isValueAccess) {\n      // TODO; handle more than single nested level, i.e. foo.bar.baz\n      const parts = value.split('.');\n      return createPropertyAccessExpression({\n        expression: parts[0]!,\n        name: parts[1]!,\n      });\n    }\n    return ots.string(value, unescape);\n  }\n\n  return;\n};\n\n/**\n * Convert parameters to the declaration array expected by TypeScript\n * Compiler API.\n * @param parameters - the parameters to convert to declarations\n * @returns ts.ParameterDeclaration[]\n */\nexport const toParameterDeclarations = (\n  parameters: ReadonlyArray<FunctionParameter>,\n) =>\n  parameters.map((parameter) => {\n    if ('destructure' in parameter) {\n      return createParameterDeclaration({\n        name: ts.factory.createObjectBindingPattern(\n          parameter.destructure\n            .map((param) => {\n              // TODO: add support for nested destructuring, not needed at the moment\n              if ('destructure' in param) {\n                return;\n              }\n\n              const result = ts.factory.createBindingElement(\n                undefined,\n                undefined,\n                createIdentifier({ text: param.name }),\n                undefined,\n              );\n              return result;\n            })\n            .filter(Boolean) as ts.BindingElement[],\n        ),\n        type:\n          parameter.type !== undefined\n            ? createTypeNode(parameter.type)\n            : undefined,\n      });\n    }\n\n    const modifiers = parameter.accessLevel\n      ? [createModifier({ keyword: parameter.accessLevel })]\n      : [];\n\n    if (parameter.isReadOnly) {\n      modifiers.push(createModifier({ keyword: 'readonly' }));\n    }\n\n    return createParameterDeclaration({\n      initializer:\n        parameter.default !== undefined\n          ? toExpression({ value: parameter.default })\n          : undefined,\n      modifiers,\n      name: createIdentifier({ text: parameter.name }),\n      required: parameter.isRequired !== false,\n      type:\n        parameter.type !== undefined\n          ? createTypeNode(parameter.type)\n          : undefined,\n    });\n  });\n\nexport type SyntaxKindKeyword =\n  | 'any'\n  | 'async'\n  | 'boolean'\n  | 'export'\n  | 'never'\n  | 'number'\n  | 'private'\n  | 'protected'\n  | 'public'\n  | 'readonly'\n  | 'static'\n  | 'string'\n  | 'undefined'\n  | 'unknown'\n  | 'void';\n\nexport const syntaxKindKeyword = <T extends SyntaxKindKeyword>({\n  keyword,\n}: {\n  keyword: T;\n}): T extends 'protected'\n  ? ts.SyntaxKind.ProtectedKeyword\n  : T extends 'public'\n    ? ts.SyntaxKind.PublicKeyword\n    : T extends 'private'\n      ? ts.SyntaxKind.PrivateKeyword\n      : T extends 'export'\n        ? ts.SyntaxKind.ExportKeyword\n        : T extends 'async'\n          ? ts.SyntaxKind.ExportKeyword\n          : T extends 'readonly'\n            ? ts.SyntaxKind.ExportKeyword\n            : T extends 'static'\n              ? ts.SyntaxKind.ExportKeyword\n              :\n                  | ts.SyntaxKind.AnyKeyword\n                  | ts.SyntaxKind.BooleanKeyword\n                  | ts.SyntaxKind.NeverKeyword\n                  | ts.SyntaxKind.NumberKeyword\n                  | ts.SyntaxKind.StringKeyword\n                  | ts.SyntaxKind.UndefinedKeyword\n                  | ts.SyntaxKind.UnknownKeyword\n                  | ts.SyntaxKind.VoidKeyword => {\n  switch (keyword) {\n    case 'any':\n      return ts.SyntaxKind.AnyKeyword as any;\n    case 'async':\n      return ts.SyntaxKind.AsyncKeyword as any;\n    case 'boolean':\n      return ts.SyntaxKind.BooleanKeyword as any;\n    case 'export':\n      return ts.SyntaxKind.ExportKeyword as any;\n    case 'never':\n      return ts.SyntaxKind.NeverKeyword as any;\n    case 'number':\n      return ts.SyntaxKind.NumberKeyword as any;\n    case 'private':\n      return ts.SyntaxKind.PrivateKeyword as any;\n    case 'protected':\n      return ts.SyntaxKind.ProtectedKeyword as any;\n    case 'public':\n      return ts.SyntaxKind.PublicKeyword as any;\n    case 'readonly':\n      return ts.SyntaxKind.ReadonlyKeyword as any;\n    case 'static':\n      return ts.SyntaxKind.StaticKeyword as any;\n    case 'string':\n      return ts.SyntaxKind.StringKeyword as any;\n    case 'undefined':\n      return ts.SyntaxKind.UndefinedKeyword as any;\n    case 'unknown':\n      return ts.SyntaxKind.UnknownKeyword as any;\n    case 'void':\n      return ts.SyntaxKind.VoidKeyword as any;\n    default:\n      throw new Error(`unsupported syntax kind keyword \"${keyword}\"`);\n  }\n};\n\nexport const createKeywordTypeNode = ({\n  keyword,\n}: {\n  keyword: Extract<\n    SyntaxKindKeyword,\n    | 'any'\n    | 'boolean'\n    | 'never'\n    | 'number'\n    | 'string'\n    | 'undefined'\n    | 'unknown'\n    | 'void'\n  >;\n}) => {\n  const kind = syntaxKindKeyword({ keyword });\n  return ts.factory.createKeywordTypeNode(kind);\n};\n\nexport const toTypeParameters = (\n  types: (FunctionTypeParameter | ts.TypeParameterDeclaration)[],\n) =>\n  types.map((node) => {\n    // @ts-expect-error\n    if (ts.isTypeParameterDeclaration(node)) {\n      return node;\n    }\n\n    return createTypeParameterDeclaration({\n      // TODO: support other extends values\n      constraint: node.extends\n        ? typeof node.extends === 'string'\n          ? createKeywordTypeNode({ keyword: 'boolean' })\n          : node.extends\n        : undefined,\n      // TODO: support other default types\n      defaultType:\n        node.default !== undefined\n          ? isTsNode(node.default)\n            ? (node.default as unknown as ts.TypeNode)\n            : ts.factory.createLiteralTypeNode(\n                node.default\n                  ? ts.factory.createTrue()\n                  : ts.factory.createFalse(),\n              )\n          : undefined,\n      name: node.name,\n    });\n  });\n\nexport const createTypeOperatorNode = ({\n  operator,\n  type,\n}: {\n  operator: 'keyof' | 'readonly' | 'unique';\n  type: ts.TypeNode;\n}) => {\n  const operatorKeyword =\n    operator === 'keyof'\n      ? ts.SyntaxKind.KeyOfKeyword\n      : operator === 'readonly'\n        ? ts.SyntaxKind.ReadonlyKeyword\n        : ts.SyntaxKind.UniqueKeyword;\n  return ts.factory.createTypeOperatorNode(operatorKeyword, type);\n};\n\nexport const createTypeParameterDeclaration = ({\n  constraint,\n  defaultType,\n  modifiers,\n  name,\n}: {\n  constraint?: ts.TypeNode;\n  defaultType?: ts.TypeNode;\n  modifiers?: Array<ts.Modifier>;\n  name: string | ts.Identifier;\n}) =>\n  ts.factory.createTypeParameterDeclaration(\n    modifiers,\n    name,\n    constraint,\n    defaultType,\n  );\n\nexport const createMappedTypeNode = ({\n  members,\n  nameType,\n  questionToken,\n  readonlyToken,\n  type,\n  typeParameter,\n}: {\n  members?: ts.NodeArray<ts.TypeElement>;\n  nameType?: ts.TypeNode;\n  questionToken?: ts.QuestionToken | ts.PlusToken | ts.MinusToken;\n  readonlyToken?: ts.ReadonlyKeyword | ts.PlusToken | ts.MinusToken;\n  type?: ts.TypeNode;\n  typeParameter: ts.TypeParameterDeclaration;\n}) =>\n  ts.factory.createMappedTypeNode(\n    readonlyToken,\n    typeParameter,\n    nameType,\n    questionToken,\n    type,\n    members,\n  );\n\nexport const createLiteralTypeNode = ({\n  literal,\n}: {\n  literal: ts.LiteralTypeNode['literal'];\n}) => {\n  const node = ts.factory.createLiteralTypeNode(literal);\n  return node;\n};\n\n/**\n * Create arrow function type expression.\n */\nexport const createArrowFunction = ({\n  async,\n  comment,\n  multiLine,\n  parameters = [],\n  returnType,\n  statements = [],\n  types = [],\n}: {\n  async?: boolean;\n  comment?: Comments;\n  multiLine?: boolean;\n  parameters?: ReadonlyArray<FunctionParameter>;\n  returnType?: string | ts.TypeNode;\n  statements?: ts.Statement[] | ts.Expression;\n  types?: FunctionTypeParameter[];\n}) => {\n  const expression = ts.factory.createArrowFunction(\n    async ? [createModifier({ keyword: 'async' })] : undefined,\n    types ? toTypeParameters(types) : undefined,\n    toParameterDeclarations(parameters),\n    returnType ? createTypeNode(returnType) : undefined,\n    undefined,\n    Array.isArray(statements)\n      ? createBlock({ multiLine, statements })\n      : statements,\n  );\n\n  addLeadingComments({\n    comments: comment,\n    node: expression,\n  });\n\n  return expression;\n};\n\n/**\n * Create anonymous function type expression.\n */\nexport const createAnonymousFunction = ({\n  async,\n  comment,\n  multiLine,\n  parameters = [],\n  returnType,\n  statements = [],\n  types = [],\n}: {\n  async?: boolean;\n  comment?: Comments;\n  multiLine?: boolean;\n  parameters?: FunctionParameter[];\n  returnType?: string | ts.TypeNode;\n  statements?: ReadonlyArray<ts.Statement>;\n  types?: FunctionTypeParameter[];\n}) => {\n  const expression = ts.factory.createFunctionExpression(\n    async ? [createModifier({ keyword: 'async' })] : undefined,\n    undefined,\n    undefined,\n    types ? toTypeParameters(types) : undefined,\n    toParameterDeclarations(parameters),\n    returnType ? createTypeNode(returnType) : undefined,\n    createBlock({ multiLine, statements }),\n  );\n\n  addLeadingComments({\n    comments: comment,\n    node: expression,\n  });\n\n  return expression;\n};\n\n/**\n * Create Array type expression.\n */\nexport const createArrayLiteralExpression = <T>({\n  elements,\n  multiLine = false,\n}: {\n  /**\n   * The array to create.\n   */\n  elements: T[];\n  /**\n   * Should the array be multi line?\n   *\n   * @default false\n   */\n  multiLine?: boolean;\n}): ts.ArrayLiteralExpression => {\n  const expression = ts.factory.createArrayLiteralExpression(\n    elements\n      .map((value) => (isTsNode(value) ? value : toExpression({ value })))\n      .filter(isType<ts.Expression>),\n    // multiline if array contains objects\n    multiLine ||\n      (!Array.isArray(elements[0]) && typeof elements[0] === 'object'),\n  );\n  return expression;\n};\n\nexport const createAwaitExpression = ({\n  expression,\n}: {\n  expression: ts.Expression;\n}) => ts.factory.createAwaitExpression(expression);\n\nexport const createFunctionTypeNode = ({\n  parameters = [],\n  returnType,\n  typeParameters,\n}: {\n  parameters?: ts.ParameterDeclaration[];\n  returnType: ts.TypeNode;\n  typeParameters?: ts.TypeParameterDeclaration[];\n}) => {\n  const node = ts.factory.createFunctionTypeNode(\n    typeParameters,\n    parameters,\n    returnType,\n  );\n  return node;\n};\n\nexport type ObjectValue =\n  | {\n      assertion?: 'any' | ts.TypeNode;\n      comments?: Comments;\n      spread: string;\n    }\n  | {\n      comments?: Comments;\n      isValueAccess?: boolean;\n      key: string;\n      shorthand?: boolean;\n      value: any;\n    };\n\ntype ObjectAssignment =\n  | ts.PropertyAssignment\n  | ts.ShorthandPropertyAssignment\n  | ts.SpreadAssignment;\n\n/**\n * Create Object type expression.\n * @param comments - comments to add to each property.\n * @param identifier - keys that should be treated as identifiers.\n * @param multiLine - if the object should be multiline.\n * @param obj - the object to create expression with.\n * @param shorthand - if shorthand syntax should be used.\n * @param unescape - if properties strings should be unescaped.\n * @returns ts.ObjectLiteralExpression\n */\nexport const createObjectType = <\n  T extends Record<string, any> | Array<ObjectValue>,\n>({\n  comments,\n  identifiers = [],\n  multiLine = true,\n  obj,\n  shorthand,\n  unescape = false,\n}: {\n  comments?: Comments;\n  identifiers?: string[];\n  multiLine?: boolean;\n  obj: T;\n  shorthand?: boolean;\n  unescape?: boolean;\n}): ts.ObjectLiteralExpression => {\n  const properties = Array.isArray(obj)\n    ? obj\n        .map((value: ObjectValue) => {\n          // Check key value equality before possibly modifying it\n          let canShorthand = false;\n          if ('key' in value) {\n            const { key } = value;\n            canShorthand = key === value.value;\n            const firstDigitAndNonDigits =\n              key.match(/^[0-9]/) && key.match(/\\D+/g);\n            if (\n              (firstDigitAndNonDigits || key.match(/\\W/g) || key === '') &&\n              !key.startsWith(\"'\") &&\n              !key.endsWith(\"'\")\n            ) {\n              value.key = `'${key}'`;\n            }\n          }\n          let assignment: ObjectAssignment;\n          if ('spread' in value) {\n            const nameIdentifier = isTsNode(value.spread)\n              ? value.spread\n              : createIdentifier({ text: value.spread });\n            assignment = ts.factory.createSpreadAssignment(\n              value.assertion\n                ? createAsExpression({\n                    expression: nameIdentifier,\n                    type:\n                      typeof value.assertion === 'string'\n                        ? createKeywordTypeNode({ keyword: value.assertion })\n                        : value.assertion,\n                  })\n                : nameIdentifier,\n            );\n          } else if (value.shorthand || (shorthand && canShorthand)) {\n            assignment = ts.factory.createShorthandPropertyAssignment(\n              value.value,\n            );\n          } else {\n            let initializer: ts.Expression | undefined = isTsNode(value.value)\n              ? value.value\n              : Array.isArray(value.value) &&\n                  (!value.value.length || typeof value.value[0] === 'object')\n                ? createObjectType({\n                    multiLine,\n                    obj: value.value,\n                    shorthand,\n                    unescape,\n                  })\n                : toExpression({\n                    identifiers: identifiers.includes(value.key)\n                      ? Object.keys(value.value)\n                      : [],\n                    isValueAccess: value.isValueAccess,\n                    shorthand,\n                    unescape,\n                    value: value.value,\n                  });\n            if (!initializer) {\n              return;\n            }\n            // Create a identifier if the current key is one and it is not an object\n            if (\n              identifiers.includes(value.key) &&\n              !ts.isObjectLiteralExpression(initializer)\n            ) {\n              initializer = createIdentifier({ text: value.value as string });\n            }\n            assignment = createPropertyAssignment({\n              initializer,\n              name: value.key,\n            });\n          }\n\n          addLeadingComments({\n            comments: value.comments,\n            node: assignment,\n          });\n\n          return assignment;\n        })\n        .filter(isType<ObjectAssignment>)\n    : Object.entries(obj)\n        .map(([key, value]) => {\n          // Pass all object properties as identifiers if the whole object is an identifier\n          let initializer: ts.Expression | undefined = toExpression({\n            identifiers: identifiers.includes(key) ? Object.keys(value) : [],\n            shorthand,\n            unescape,\n            value,\n          });\n          if (!initializer) {\n            return;\n          }\n          // Create a identifier if the current key is one and it is not an object\n          if (\n            identifiers.includes(key) &&\n            !ts.isObjectLiteralExpression(initializer)\n          ) {\n            initializer = createIdentifier({ text: value as string });\n          }\n          // Check key value equality before possibly modifying it\n          const canShorthand = key === value;\n          if (\n            key.match(/^[0-9]/) &&\n            key.match(/\\D+/g) &&\n            !key.startsWith(\"'\") &&\n            !key.endsWith(\"'\")\n          ) {\n            key = `'${key}'`;\n          }\n          if (key.match(/\\W/g) && !key.startsWith(\"'\") && !key.endsWith(\"'\")) {\n            key = `'${key}'`;\n          }\n          const assignment =\n            shorthand && canShorthand\n              ? ts.factory.createShorthandPropertyAssignment(value)\n              : createPropertyAssignment({ initializer, name: key });\n\n          return assignment;\n        })\n        .filter(isType<ObjectAssignment>);\n\n  const node = ts.factory.createObjectLiteralExpression(\n    properties as any[],\n    multiLine,\n  );\n\n  addLeadingComments({\n    comments,\n    node,\n  });\n\n  return node;\n};\n\n/**\n * Create enum declaration. Example `export enum T = { X, Y };`\n * @param asConst - whether to use const enums.\n * @param comments - comments to add to each property.\n * @param leadingComment - leading comment to add to enum.\n * @param name - the name of the enum.\n * @param obj - the object representing the enum.\n * @returns ts.EnumDeclaration\n */\nexport const createEnumDeclaration = <\n  T extends Record<string, any> | Array<ObjectValue>,\n>({\n  asConst,\n  comments: enumMemberComments = {},\n  leadingComment: comments,\n  name,\n  obj,\n}: {\n  asConst: boolean;\n  comments?: Record<string | number, Comments>;\n  leadingComment?: Comments;\n  name: string | ts.TypeReferenceNode;\n  obj: T;\n}): ts.EnumDeclaration => {\n  const members: Array<ts.EnumMember> = Array.isArray(obj)\n    ? obj.map((value) => {\n        const enumMember = createEnumMember({\n          initializer: toExpression({\n            value: value.value,\n          }),\n          name: value.key,\n        });\n\n        addLeadingComments({\n          comments: value.comments,\n          node: enumMember,\n        });\n\n        return enumMember;\n      })\n    : // TODO: parser - deprecate object syntax\n      Object.entries(obj).map(([key, value]) => {\n        const enumMember = ts.factory.createEnumMember(\n          key,\n          toExpression({\n            unescape: true,\n            value,\n          }),\n        );\n\n        addLeadingComments({\n          comments: enumMemberComments[key],\n          node: enumMember,\n        });\n\n        return enumMember;\n      });\n\n  const defaultModifiers = [createModifier({ keyword: 'export' })];\n  const constModifier = asConst\n    ? [ts.factory.createToken(ts.SyntaxKind.ConstKeyword)]\n    : [];\n  const modifiers = [...defaultModifiers, ...constModifier];\n  const node = ts.factory.createEnumDeclaration(\n    modifiers,\n    typeof name === 'string'\n      ? createIdentifier({ text: name })\n      : // TODO: https://github.com/hey-api/openapi-ts/issues/2289\n        (name as unknown as ts.Identifier),\n    members,\n  );\n\n  addLeadingComments({\n    comments,\n    node,\n  });\n\n  return node;\n};\n\nconst createEnumMember = ({\n  initializer,\n  name,\n}: {\n  initializer?: ts.Expression;\n  name: string | ts.PropertyName;\n}) => {\n  let key = name;\n  if (typeof key === 'string') {\n    if (key.includes(\"'\")) {\n      key = createStringLiteral({\n        isSingleQuote: false,\n        text: key,\n      });\n    } else {\n      key = escapeName(key);\n    }\n  }\n  return ts.factory.createEnumMember(key, initializer);\n};\n\n/**\n * Create namespace declaration. Example `export namespace MyNamespace { ... }`\n * @param name - the name of the namespace.\n * @param nodes - the nodes in the namespace.\n * @returns\n */\nexport const createNamespaceDeclaration = ({\n  name,\n  statements,\n}: {\n  name: string;\n  statements: Array<ts.Statement>;\n}) =>\n  ts.factory.createModuleDeclaration(\n    [createModifier({ keyword: 'export' })],\n    createIdentifier({ text: name }),\n    ts.factory.createModuleBlock(statements),\n    ts.NodeFlags.Namespace,\n  );\n\nexport const createIndexedAccessTypeNode = ({\n  indexType,\n  objectType,\n}: {\n  indexType: ts.TypeNode;\n  objectType: ts.TypeNode;\n}) => {\n  const node = ts.factory.createIndexedAccessTypeNode(objectType, indexType);\n  return node;\n};\n\nexport const createGetAccessorDeclaration = ({\n  name,\n  returnType,\n  statements,\n}: {\n  name: string | ts.PropertyName;\n  returnType?: string | ts.Identifier;\n  statements: ReadonlyArray<ts.Statement>;\n}) =>\n  ts.factory.createGetAccessorDeclaration(\n    undefined, // modifiers\n    name,\n    [], // parameters\n    returnType ? createTypeReferenceNode({ typeName: returnType }) : undefined,\n    createBlock({ statements }),\n  );\n\nexport const createStringLiteral = ({\n  isSingleQuote,\n  text,\n}: {\n  isSingleQuote?: boolean;\n  text: string;\n}) => {\n  if (isSingleQuote === undefined) {\n    isSingleQuote = !text.includes(\"'\");\n  }\n  const node = ts.factory.createStringLiteral(text, isSingleQuote);\n  return node;\n};\n\nexport const createConditionalExpression = ({\n  condition,\n  whenFalse,\n  whenTrue,\n}: {\n  condition: ts.Expression;\n  whenFalse: ts.Expression;\n  whenTrue: ts.Expression;\n}) => {\n  const expression = ts.factory.createConditionalExpression(\n    condition,\n    ts.factory.createToken(ts.SyntaxKind.QuestionToken),\n    whenTrue,\n    ts.factory.createToken(ts.SyntaxKind.ColonToken),\n    whenFalse,\n  );\n  return expression;\n};\n\nexport const createTypeOfExpression = ({\n  text,\n}: {\n  text: string | ts.Identifier;\n}) => {\n  const expression = ts.factory.createTypeOfExpression(\n    typeof text === 'string' ? createIdentifier({ text }) : text,\n  );\n  return expression;\n};\n\n/**\n * Create a type alias declaration. Example `export type X = Y;`.\n * @param comment (optional) comments to add\n * @param name the name of the type\n * @param type the type\n * @returns ts.TypeAliasDeclaration\n */\nexport const createTypeAliasDeclaration = ({\n  comment,\n  exportType,\n  name,\n  type,\n  typeParameters = [],\n}: {\n  comment?: Comments;\n  exportType?: boolean;\n  name: string | ts.TypeReferenceNode;\n  type: string | ts.TypeNode | ts.Identifier;\n  typeParameters?: FunctionTypeParameter[];\n}): ts.TypeAliasDeclaration => {\n  const node = ts.factory.createTypeAliasDeclaration(\n    exportType ? [createModifier({ keyword: 'export' })] : undefined,\n    // TODO: https://github.com/hey-api/openapi-ts/issues/2289\n    // passing type reference node seems to work and allows for dynamic renaming\n    // @ts-expect-error\n    typeof name === 'string' ? createIdentifier({ text: name }) : name,\n    toTypeParameters(typeParameters),\n    createTypeNode(type),\n  );\n\n  addLeadingComments({\n    comments: comment,\n    node,\n  });\n\n  return node;\n};\n\nexport const createTypeReferenceNode = ({\n  typeArguments,\n  typeName,\n}: {\n  typeArguments?: ts.TypeNode[];\n  typeName: string | ts.EntityName;\n}) => ts.factory.createTypeReferenceNode(typeName, typeArguments);\n\nexport const createTypeParenthesizedNode = ({ type }: { type: ts.TypeNode }) =>\n  ts.factory.createParenthesizedType(type);\n\nexport const createParameterDeclaration = ({\n  initializer,\n  modifiers,\n  name,\n  required = true,\n  type,\n}: {\n  initializer?: ts.Expression;\n  modifiers?: ReadonlyArray<ts.ModifierLike>;\n  name: string | ts.BindingName;\n  required?: boolean;\n  type?: ts.TypeNode;\n}) => {\n  const node = ts.factory.createParameterDeclaration(\n    modifiers,\n    undefined,\n    name,\n    required ? undefined : ts.factory.createToken(ts.SyntaxKind.QuestionToken),\n    type,\n    initializer,\n  );\n  return node;\n};\n\nexport const createNewExpression = ({\n  argumentsArray,\n  expression,\n  typeArguments,\n}: {\n  argumentsArray?: Array<ts.Expression>;\n  expression: ts.Expression;\n  typeArguments?: Array<ts.TypeNode>;\n}) => {\n  const node = ts.factory.createNewExpression(\n    expression,\n    typeArguments,\n    argumentsArray,\n  );\n  return node;\n};\n\nexport const createForOfStatement = ({\n  awaitModifier,\n  expression,\n  initializer,\n  statement,\n}: {\n  // TODO: parser - simplify this to be await?: boolean\n  awaitModifier?: ts.AwaitKeyword;\n  expression: ts.Expression;\n  initializer: ts.ForInitializer;\n  statement: ts.Statement;\n}) => {\n  const node = ts.factory.createForOfStatement(\n    awaitModifier,\n    initializer,\n    expression,\n    statement,\n  );\n  return node;\n};\n\nexport const createAssignment = ({\n  left,\n  right,\n}: {\n  left: ts.Expression;\n  right: ts.Expression;\n}) => ts.factory.createAssignment(left, right);\n\nexport const createBlock = ({\n  multiLine = true,\n  statements,\n}: {\n  multiLine?: boolean;\n  statements: ReadonlyArray<ts.Statement>;\n}) => ts.factory.createBlock(statements, multiLine);\n\nexport const createPropertyAssignment = ({\n  initializer,\n  name,\n}: {\n  initializer: ts.Expression;\n  name: string | ts.PropertyName;\n}) => ts.factory.createPropertyAssignment(name, initializer);\n\nexport const createRegularExpressionLiteral = ({\n  flags = [],\n  text,\n}: {\n  flags?: ReadonlyArray<'g' | 'i' | 'm' | 's' | 'u' | 'y'>;\n  text: string;\n}) => {\n  // Extract pattern content, removing outer slashes if present\n  const patternContent =\n    text.startsWith('/') && text.endsWith('/') ? text.slice(1, -1) : text;\n\n  // Escape forward slashes in the pattern content, but only if they're not already escaped\n  const escapedPattern = patternContent.replace(/(?<!\\\\)\\//g, '\\\\/');\n\n  // Wrap with forward slashes\n  const textWithSlashes = `/${escapedPattern}/`;\n\n  return ts.factory.createRegularExpressionLiteral(\n    `${textWithSlashes}${flags.join('')}`,\n  );\n};\n\nexport const createAsExpression = ({\n  expression,\n  type,\n}: {\n  expression: ts.Expression;\n  type: ts.TypeNode;\n}) => ts.factory.createAsExpression(expression, type);\n\nexport const createTemplateLiteralType = ({\n  value,\n}: {\n  value: ReadonlyArray<string | ts.TypeNode>;\n}) => {\n  const spans: Array<ts.TemplateLiteralTypeSpan> = [];\n  let spanText = '';\n\n  for (const item of value.slice(0).reverse()) {\n    if (typeof item === 'string') {\n      spanText = `${item}${spanText}`;\n    } else {\n      const literal = spans.length\n        ? ts.factory.createTemplateMiddle(spanText)\n        : ts.factory.createTemplateTail(spanText);\n      const span = ts.factory.createTemplateLiteralTypeSpan(item, literal);\n      spans.push(span);\n      spanText = '';\n    }\n  }\n\n  const templateLiteralType = ts.factory.createTemplateLiteralType(\n    ts.factory.createTemplateHead(spanText),\n    spans.reverse(),\n  );\n  return templateLiteralType;\n};\n","import ts from 'typescript';\n\nimport { createAsExpression, createTypeReferenceNode } from './types';\nimport {\n  addLeadingComments,\n  type Comments,\n  createIdentifier,\n  createModifier,\n  type ImportExportItemObject,\n  ots,\n} from './utils';\n\n/**\n * Create export all declaration. Example: `export * from './y'`.\n * @param module - module containing exports\n * @returns ts.ExportDeclaration\n */\nexport const createExportAllDeclaration = ({\n  module,\n  shouldAppendJs,\n}: {\n  module: string;\n  shouldAppendJs?: boolean;\n}): ts.ExportDeclaration => {\n  const statement = ts.factory.createExportDeclaration(\n    undefined,\n    false,\n    undefined,\n    ots.string(shouldAppendJs ? `${module}.js` : module),\n  );\n  return statement;\n};\n\nexport type ImportExportItem = ImportExportItemObject | string;\n\nexport const createCallExpression = ({\n  functionName,\n  parameters = [],\n  types,\n}: {\n  functionName:\n    | string\n    | ts.PropertyAccessExpression\n    | ts.PropertyAccessChain\n    | ts.ElementAccessExpression\n    | ts.Expression;\n  parameters?: Array<string | ts.Expression | undefined>;\n  types?: ReadonlyArray<ts.TypeNode>;\n}) => {\n  const expression =\n    typeof functionName === 'string'\n      ? createIdentifier({ text: functionName })\n      : functionName;\n  const argumentsArray = parameters\n    .filter((parameter) => parameter !== undefined)\n    .map((parameter) =>\n      typeof parameter === 'string'\n        ? createIdentifier({ text: parameter })\n        : parameter,\n    );\n  const callExpression = ts.factory.createCallExpression(\n    expression,\n    types,\n    argumentsArray,\n  );\n  return callExpression;\n};\n\n/**\n * Create a named export declaration. Example: `export { X } from './y'`.\n * @param exports - named imports to export\n * @param module - module containing exports\n * @returns ts.ExportDeclaration\n */\nexport const createNamedExportDeclarations = ({\n  exports,\n  module,\n}: {\n  exports: Array<ImportExportItem> | ImportExportItem;\n  module: string;\n}): ts.ExportDeclaration => {\n  const exportedTypes = Array.isArray(exports) ? exports : [exports];\n  const hasNonTypeExport = exportedTypes.some(\n    (item) => typeof item !== 'object' || !item.asType,\n  );\n  const elements = exportedTypes.map((name) => {\n    const item = typeof name === 'string' ? { name } : name;\n    return ots.export({\n      alias: item.alias,\n      asType: hasNonTypeExport && item.asType,\n      name: item.name,\n    });\n  });\n  const exportClause = ts.factory.createNamedExports(elements);\n  const moduleSpecifier = ots.string(module);\n  const statement = ts.factory.createExportDeclaration(\n    undefined,\n    !hasNonTypeExport,\n    exportClause,\n    moduleSpecifier,\n  );\n  return statement;\n};\n\n/**\n * Create a const variable. Optionally, it can use const assertion or export\n * statement. Example: `export x = {} as const`.\n * @param assertion use const assertion?\n * @param exportConst export created variable?\n * @param expression expression for the variable.\n * @param name name of the variable.\n * @returns ts.VariableStatement\n */\nexport const createConstVariable = ({\n  assertion,\n  comment,\n  destructure,\n  exportConst,\n  expression,\n  name,\n  typeName,\n}: {\n  assertion?: 'const' | ts.TypeNode;\n  comment?: Comments;\n  destructure?: boolean;\n  exportConst?: boolean;\n  expression: ts.Expression;\n  name: string | ts.TypeReferenceNode;\n  // TODO: support a more intuitive definition of generics for example\n  typeName?: string | ts.IndexedAccessTypeNode | ts.TypeNode;\n}): ts.VariableStatement => {\n  const initializer = assertion\n    ? createAsExpression({\n        expression,\n        type:\n          typeof assertion === 'string'\n            ? createTypeReferenceNode({ typeName: assertion })\n            : assertion,\n      })\n    : expression;\n  const nameIdentifier =\n    typeof name === 'string'\n      ? createIdentifier({ text: name })\n      : // TODO: https://github.com/hey-api/openapi-ts/issues/2289\n        (name as unknown as ts.Identifier);\n  const declaration = ts.factory.createVariableDeclaration(\n    destructure\n      ? ts.factory.createObjectBindingPattern([\n          ts.factory.createBindingElement(\n            undefined,\n            undefined,\n            nameIdentifier,\n            undefined,\n          ),\n        ])\n      : nameIdentifier,\n    undefined,\n    typeName\n      ? typeof typeName === 'string'\n        ? createTypeReferenceNode({ typeName })\n        : typeName\n      : undefined,\n    initializer,\n  );\n  const statement = ts.factory.createVariableStatement(\n    exportConst ? [createModifier({ keyword: 'export' })] : undefined,\n    ts.factory.createVariableDeclarationList([declaration], ts.NodeFlags.Const),\n  );\n\n  addLeadingComments({\n    comments: comment,\n    node: statement,\n  });\n\n  return statement;\n};\n\n/**\n * Create a named import declaration. Example: `import { X } from './y'`.\n * @param imports - named exports to import\n * @param module - module containing imports\n * @returns ts.ImportDeclaration\n */\nexport const createNamedImportDeclarations = ({\n  imports,\n  module,\n}: {\n  imports: Array<ImportExportItem> | ImportExportItem;\n  module: string;\n}): ts.ImportDeclaration => {\n  const importedTypes = Array.isArray(imports) ? imports : [imports];\n  const hasNonTypeImport = importedTypes.some(\n    (item) => typeof item !== 'object' || !item.asType,\n  );\n  let namespaceBinding: ImportExportItemObject | undefined;\n  const elements: Array<ts.ImportSpecifier> = [];\n  importedTypes.forEach((name) => {\n    const item = typeof name === 'string' ? { name } : name;\n    if (item.name === '*' && item.alias) {\n      namespaceBinding = item;\n    } else {\n      elements.push(\n        ots.import({\n          alias: item.alias,\n          asType: hasNonTypeImport && item.asType,\n          name: item.name,\n        }),\n      );\n    }\n  });\n  const namedBindings = namespaceBinding\n    ? ts.factory.createNamespaceImport(\n        createIdentifier({ text: namespaceBinding.alias! }),\n      )\n    : ts.factory.createNamedImports(elements);\n  const importClause = ts.factory.createImportClause(\n    !hasNonTypeImport,\n    undefined,\n    namedBindings,\n  );\n  const moduleSpecifier = ots.string(module);\n  const statement = ts.factory.createImportDeclaration(\n    undefined,\n    importClause,\n    moduleSpecifier,\n  );\n  return statement;\n};\n","import ts from 'typescript';\n\nimport { createCallExpression } from './module';\nimport {\n  type AccessLevel,\n  createBlock,\n  createTypeNode,\n  type FunctionParameter,\n  type FunctionTypeParameter,\n  toExpression,\n  toParameterDeclarations,\n  toTypeParameters,\n} from './types';\nimport type { Comments } from './utils';\nimport {\n  addLeadingComments,\n  createIdentifier,\n  createModifier,\n  isType,\n} from './utils';\n\n/**\n * Create a class constructor declaration.\n * @param accessLevel - the access level of the constructor.\n * @param comment - comment to add to function.\n * @param multiLine - if it should be multi line.\n * @param parameters - parameters for the constructor.\n * @param statements - statements to put in the constructor body.\n * @returns ts.ConstructorDeclaration\n */\nexport const createConstructorDeclaration = ({\n  accessLevel,\n  comment,\n  multiLine = true,\n  parameters = [],\n  statements = [],\n}: {\n  accessLevel?: AccessLevel;\n  comment?: Comments;\n  multiLine?: boolean;\n  parameters?: FunctionParameter[];\n  statements?: ts.Statement[];\n}) => {\n  const modifiers = accessLevel\n    ? [createModifier({ keyword: accessLevel })]\n    : undefined;\n  const node = ts.factory.createConstructorDeclaration(\n    modifiers,\n    toParameterDeclarations(parameters),\n    createBlock({ multiLine, statements }),\n  );\n\n  addLeadingComments({\n    comments: comment,\n    node,\n  });\n\n  return node;\n};\n\n/**\n * Create a class method declaration.\n * @param accessLevel - the access level of the method.\n * @param comment - comment to add to function.\n * @param isStatic - if the function is static.\n * @param multiLine - if it should be multi line.\n * @param name - name of the method.\n * @param parameters - parameters for the method.\n * @param returnType - the return type of the method.\n * @param statements - statements to put in the constructor body.\n * @returns ts.MethodDeclaration\n */\nexport const createMethodDeclaration = ({\n  accessLevel,\n  comment,\n  isStatic = false,\n  multiLine = true,\n  name,\n  parameters = [],\n  returnType,\n  statements = [],\n  types = [],\n}: {\n  accessLevel?: AccessLevel;\n  comment?: Comments;\n  isStatic?: boolean;\n  multiLine?: boolean;\n  name: string;\n  parameters?: ReadonlyArray<FunctionParameter>;\n  returnType?: string | ts.TypeNode;\n  statements?: ts.Statement[];\n  types?: FunctionTypeParameter[];\n}) => {\n  const modifiers = accessLevel\n    ? [createModifier({ keyword: accessLevel })]\n    : [];\n\n  if (isStatic) {\n    modifiers.push(createModifier({ keyword: 'static' }));\n  }\n\n  const node = ts.factory.createMethodDeclaration(\n    modifiers,\n    undefined,\n    createIdentifier({ text: name }),\n    undefined,\n    types ? toTypeParameters(types) : undefined,\n    toParameterDeclarations(parameters),\n    returnType ? createTypeNode(returnType) : undefined,\n    createBlock({ multiLine, statements }),\n  );\n\n  addLeadingComments({\n    comments: comment,\n    node,\n  });\n\n  return node;\n};\n\ntype ClassDecorator = {\n  args: any[];\n  name: string;\n};\n\n/**\n * Create a class declaration.\n */\nexport const createClassDeclaration = ({\n  decorator,\n  exportClass,\n  extendedClasses,\n  name,\n  nodes,\n}: {\n  /**\n   * Class decorator.\n   */\n  decorator?: ClassDecorator;\n  /**\n   * @default false\n   */\n  exportClass?: boolean;\n  /**\n   * List of extended classes.\n   */\n  extendedClasses?: ReadonlyArray<string>;\n  /**\n   * Class name.\n   */\n  name: string;\n  /**\n   * Class elements.\n   */\n  nodes: ReadonlyArray<ts.ClassElement>;\n}): ts.ClassDeclaration => {\n  const modifiers: Array<ts.ModifierLike> = [];\n\n  if (exportClass) {\n    modifiers.push(createModifier({ keyword: 'export' }));\n  }\n\n  if (decorator) {\n    modifiers.unshift(\n      ts.factory.createDecorator(\n        createCallExpression({\n          functionName: decorator.name,\n          parameters: decorator.args\n            .map((arg) => toExpression({ value: arg }))\n            .filter(isType<ts.Expression>),\n        }),\n      ),\n    );\n  }\n\n  const heritageClauses: Array<ts.HeritageClause> = [];\n\n  if (extendedClasses) {\n    for (const extendedClass of extendedClasses) {\n      heritageClauses.push(\n        ts.factory.createHeritageClause(ts.SyntaxKind.ExtendsKeyword, [\n          ts.factory.createExpressionWithTypeArguments(\n            createIdentifier({ text: extendedClass }),\n            undefined,\n          ),\n        ]),\n      );\n    }\n  }\n\n  return ts.factory.createClassDeclaration(\n    modifiers,\n    createIdentifier({ text: name }),\n    undefined,\n    heritageClauses,\n    nodes,\n  );\n};\n","import ts from 'typescript';\n\nexport const expressionToStatement = ({\n  expression,\n}: {\n  expression: ts.Expression;\n}) => {\n  const statement = ts.factory.createExpressionStatement(expression);\n  return statement;\n};\n","import ts from 'typescript';\n\nimport { createCallExpression } from './module';\nimport { createTypeReferenceNode } from './types';\nimport { createIdentifier, isType } from './utils';\n\nexport const createReturnStatement = ({\n  expression,\n}: {\n  expression?: ts.Expression;\n}) => ts.factory.createReturnStatement(expression);\n\n/**\n * Create a return function call statement.\n *\n * @example `return fn<string>(params)`\n *\n * @returns ts.ReturnStatement\n */\nexport const createReturnFunctionCall = ({\n  args = [],\n  name,\n  types = [],\n}: {\n  /**\n   * Arguments to pass to the function.\n   */\n  args: any[];\n  /**\n   * Name of the function to call or expression.\n   */\n  name: string | ts.Expression;\n  /**\n   * List of function types.\n   */\n  types?: ReadonlyArray<string | ts.StringLiteral>;\n}) => {\n  const typeArguments = types.map((type) =>\n    // this works with string literals too despite throwing a type error.\n    // should be probably fixed at some point...\n    // @ts-expect-error\n    createTypeReferenceNode({ typeName: type }),\n  );\n  const argumentsArray = args\n    .map((arg) =>\n      ts.isExpression(arg) ? arg : createIdentifier({ text: arg }),\n    )\n    .filter(isType<ts.Identifier | ts.Expression>);\n  const expression = createCallExpression({\n    functionName: name,\n    parameters: argumentsArray,\n    types: typeArguments,\n  });\n  const statement = createReturnStatement({ expression });\n  return statement;\n};\n\nexport const createReturnVariable = ({\n  expression,\n}: {\n  expression: string | ts.Expression;\n}) => {\n  const statement = createReturnStatement({\n    expression:\n      typeof expression === 'string'\n        ? createIdentifier({ text: expression })\n        : expression,\n  });\n  return statement;\n};\n","import ts from 'typescript';\n\nimport { validTypescriptIdentifierRegExp } from '~/utils/regexp';\n\nimport { expressionToStatement } from './convert';\nimport { createCallExpression } from './module';\nimport {\n  createArrowFunction,\n  createBlock,\n  createNewExpression,\n  createPropertyAccessChain,\n  createPropertyAccessExpression,\n} from './types';\nimport { createIdentifier } from './utils';\n\nexport const createSafeAccessExpression = (path: string[]) =>\n  path.slice(1).reduce<ts.Expression>(\n    (expression, element) => {\n      validTypescriptIdentifierRegExp.lastIndex = 0;\n      if (validTypescriptIdentifierRegExp.test(element)) {\n        return createPropertyAccessChain({\n          expression,\n          name: element,\n        });\n      }\n\n      return ts.factory.createElementAccessChain(\n        expression,\n        ts.factory.createToken(ts.SyntaxKind.QuestionDotToken),\n        createIdentifier({ text: element }),\n      );\n    },\n    createIdentifier({ text: path[0]! }),\n  );\n\nexport const createAccessExpression = (path: string[]) =>\n  path.slice(1).reduce<ts.Expression>(\n    (expression, element) =>\n      createPropertyAccessExpression({\n        expression,\n        name: element,\n      }),\n    createIdentifier({ text: path[0]! }),\n  );\n\n/**\n * Handles an array of access expressions instead of nesting them (default TypeScript syntax)\n */\nexport const createPropertyAccessExpressions = ({\n  expressions,\n}: {\n  expressions: Array<string | ts.Expression | ts.MemberName>;\n}): ts.PropertyAccessExpression => {\n  const expression = expressions.reduce((expression, name) => {\n    const node = createPropertyAccessExpression({\n      expression,\n      // @ts-expect-error\n      name,\n    });\n    return node;\n  });\n  return expression as ts.PropertyAccessExpression;\n};\n\nexport const createBinaryExpression = ({\n  left,\n  operator = '=',\n  right,\n}: {\n  left: ts.Expression;\n  operator?: '=' | '===' | '!==' | 'in' | '??';\n  right: ts.Expression | string;\n}) => {\n  const expression = ts.factory.createBinaryExpression(\n    left,\n    // TODO: add support for other tokens\n    operator === '='\n      ? ts.SyntaxKind.EqualsToken\n      : operator === '==='\n        ? ts.SyntaxKind.EqualsEqualsEqualsToken\n        : operator === '!=='\n          ? ts.SyntaxKind.ExclamationEqualsEqualsToken\n          : operator === '??'\n            ? ts.SyntaxKind.QuestionQuestionToken\n            : ts.SyntaxKind.InKeyword,\n    typeof right === 'string' ? createIdentifier({ text: right }) : right,\n  );\n  return expression;\n};\n\nexport const createIfStatement = ({\n  elseStatement,\n  expression,\n  thenStatement,\n}: {\n  elseStatement?: ts.Statement;\n  expression: ts.Expression;\n  thenStatement: ts.Statement;\n}) => ts.factory.createIfStatement(expression, thenStatement, elseStatement);\n\nexport const createDateTransformMutation = ({\n  path,\n}: {\n  path: string[];\n}): ts.Statement => {\n  const safeAccessExpression = createSafeAccessExpression(path);\n  const accessExpression = createAccessExpression(path);\n\n  const thenStatement = createBlock({\n    statements: [\n      expressionToStatement({\n        expression: createBinaryExpression({\n          left: accessExpression,\n          right: createNewExpression({\n            argumentsArray: [accessExpression],\n            expression: createIdentifier({ text: 'Date' }),\n          }),\n        }),\n      }),\n    ],\n  });\n\n  const statement = createIfStatement({\n    expression: safeAccessExpression,\n    thenStatement,\n  });\n\n  return statement;\n};\n\nexport const createFunctionTransformMutation = ({\n  path,\n  transformerName,\n}: {\n  path: string[];\n  transformerName: string;\n}) => {\n  const safeAccessExpression = createSafeAccessExpression(path);\n  const accessExpression = createAccessExpression(path);\n\n  const thenStatement = createBlock({\n    statements: [\n      expressionToStatement({\n        expression: createCallExpression({\n          functionName: transformerName,\n          parameters: [accessExpression],\n        }),\n      }),\n    ],\n  });\n\n  const statement = [\n    createIfStatement({\n      expression: safeAccessExpression,\n      thenStatement,\n    }),\n  ];\n\n  return statement;\n};\n\nexport const createArrayTransformMutation = ({\n  path,\n  transformerName,\n}: {\n  path: string[];\n  transformerName: string;\n}): ts.Statement => {\n  const safeAccessExpression = createSafeAccessExpression(path);\n  const accessExpression = createAccessExpression(path);\n\n  const statement = createIfStatement({\n    expression: createCallExpression({\n      functionName: createPropertyAccessExpression({\n        expression: 'Array',\n        name: 'isArray',\n      }),\n      parameters: [safeAccessExpression],\n    }),\n    thenStatement: createBlock({\n      statements: [\n        expressionToStatement({\n          expression: ts.factory.createCallChain(\n            createPropertyAccessExpression({\n              expression: accessExpression,\n              name: 'forEach',\n            }),\n            undefined,\n            undefined,\n            [createIdentifier({ text: transformerName })],\n          ),\n        }),\n      ],\n    }),\n  });\n\n  return statement;\n};\n\nexport const createDateTransformerExpression = ({\n  parameterName,\n}: {\n  parameterName: string;\n}) => {\n  const expression = createIdentifier({ text: 'Date' });\n  const newExpression = createNewExpression({\n    argumentsArray: [createIdentifier({ text: parameterName })],\n    expression,\n  });\n  return newExpression;\n};\n\nexport const createArrayMapTransform = ({\n  path,\n  transformExpression,\n}: {\n  path: string[];\n  transformExpression: ts.Expression;\n}) => {\n  const safeAccessExpression = createSafeAccessExpression(path);\n  const accessExpression = createAccessExpression(path);\n\n  const statement = createIfStatement({\n    expression: createCallExpression({\n      functionName: createPropertyAccessExpression({\n        expression: 'Array',\n        name: 'isArray',\n      }),\n      parameters: [safeAccessExpression],\n    }),\n    thenStatement: createBlock({\n      statements: [\n        expressionToStatement({\n          expression: createBinaryExpression({\n            left: accessExpression,\n            right: ts.factory.createCallChain(\n              createPropertyAccessExpression({\n                expression: accessExpression,\n                name: 'map',\n              }),\n              undefined,\n              undefined,\n              [\n                createArrowFunction({\n                  parameters: [\n                    {\n                      name: 'item',\n                    },\n                  ],\n                  statements: transformExpression,\n                }),\n              ],\n            ),\n          }),\n        }),\n      ],\n    }),\n  });\n\n  return statement;\n};\n","import ts from 'typescript';\n\nimport { validTypescriptIdentifierRegExp } from '~/utils/regexp';\n\nimport {\n  createKeywordTypeNode,\n  createMappedTypeNode,\n  createParameterDeclaration,\n  createStringLiteral,\n  createTypeNode,\n  createTypeParameterDeclaration,\n  createTypeReferenceNode,\n} from './types';\nimport {\n  addLeadingComments,\n  type Comments,\n  createIdentifier,\n  createModifier,\n  tsNodeToString,\n} from './utils';\n\nconst nullNode = createTypeReferenceNode({ typeName: 'null' });\n\n// Property of a interface type node.\nexport type Property = {\n  comment?: Comments;\n  isReadOnly?: boolean;\n  isRequired?: boolean;\n  name: string | ts.PropertyName;\n  type: any | ts.TypeNode;\n};\n\n/**\n * Returns a union of provided node with null if marked as nullable,\n * otherwise returns the provided node unmodified.\n */\nconst maybeNullable = ({\n  isNullable,\n  node,\n}: {\n  isNullable?: boolean;\n  node: ts.TypeNode;\n}) => {\n  if (!isNullable) {\n    return node;\n  }\n  return ts.factory.createUnionTypeNode([node, nullNode]);\n};\n\n/**\n * Create a interface type node. Example `{ readonly x: string, y?: number }`\n * @param properties - the properties of the interface.\n * @param isNullable - if the whole interface can be nullable\n * @returns ts.TypeLiteralNode | ts.TypeUnionNode\n */\nexport const createTypeInterfaceNode = ({\n  indexKey,\n  indexProperty,\n  isNullable,\n  properties,\n  useLegacyResolution,\n}: {\n  /**\n   * Adds an index key type.\n   *\n   * @example\n   * ```ts\n   * type IndexKey = {\n   *   [key in Foo]: string\n   * }\n   * ```\n   */\n  indexKey?: ts.TypeReferenceNode;\n  /**\n   * Adds an index signature if defined.\n   *\n   * @example\n   * ```ts\n   * type IndexProperty = {\n   *   [key: string]: string\n   * }\n   * ```\n   */\n  indexProperty?: Property;\n  isNullable?: boolean;\n  properties: Property[];\n  useLegacyResolution: boolean;\n}) => {\n  const propertyTypes: Array<ts.TypeNode> = [];\n\n  const members: Array<ts.TypeElement | ts.MappedTypeNode> = properties.map(\n    (property) => {\n      const modifiers: readonly ts.Modifier[] | undefined = property.isReadOnly\n        ? [createModifier({ keyword: 'readonly' })]\n        : undefined;\n\n      const questionToken: ts.QuestionToken | undefined =\n        property.isRequired !== false\n          ? undefined\n          : ts.factory.createToken(ts.SyntaxKind.QuestionToken);\n\n      const type: ts.TypeNode | undefined = createTypeNode(property.type);\n      propertyTypes.push(type);\n\n      const signature = ts.factory.createPropertySignature(\n        modifiers,\n        useLegacyResolution ||\n          (typeof property.name === 'string' &&\n            property.name.match(validTypescriptIdentifierRegExp)) ||\n          (typeof property.name !== 'string' &&\n            ts.isPropertyName(property.name))\n          ? property.name\n          : createStringLiteral({ text: property.name }),\n        questionToken,\n        type,\n      );\n\n      addLeadingComments({\n        comments: property.comment,\n        node: signature,\n      });\n\n      return signature;\n    },\n  );\n\n  let isIndexMapped = false;\n\n  if (indexProperty) {\n    if (!properties.length && indexKey) {\n      const indexSignature = createMappedTypeNode({\n        questionToken: ts.factory.createToken(ts.SyntaxKind.QuestionToken),\n        type:\n          indexProperty.type ?? createKeywordTypeNode({ keyword: 'string' }),\n        typeParameter: createTypeParameterDeclaration({\n          constraint: indexKey,\n          name: createIdentifier({ text: String(indexProperty.name) }),\n        }),\n      });\n      members.push(indexSignature);\n      isIndexMapped = true;\n    } else {\n      const modifiers: ReadonlyArray<ts.Modifier> | undefined =\n        indexProperty.isReadOnly\n          ? [createModifier({ keyword: 'readonly' })]\n          : undefined;\n      const indexSignature = ts.factory.createIndexSignature(\n        modifiers,\n        [\n          createParameterDeclaration({\n            name: createIdentifier({ text: String(indexProperty.name) }),\n            type: createKeywordTypeNode({ keyword: 'string' }),\n          }),\n        ],\n        createTypeNode(indexProperty.type),\n      );\n      members.push(indexSignature);\n    }\n  }\n\n  const node = isIndexMapped\n    ? members[0]!\n    : // @ts-expect-error\n      ts.factory.createTypeLiteralNode(members);\n  return maybeNullable({\n    isNullable,\n    // @ts-expect-error\n    node,\n  });\n};\n\n/**\n * Create type union node. Example `string | number | boolean`\n * @param types - the types in the union\n * @param isNullable - if the whole type can be null\n * @returns ts.UnionTypeNode\n */\nexport const createTypeUnionNode = ({\n  isNullable,\n  types,\n}: {\n  isNullable?: boolean;\n  types: ReadonlyArray<any | ts.TypeNode>;\n}) => {\n  // flatten nested unions\n  const nodes: Array<ts.TypeNode> = [];\n  for (const type of types) {\n    const node = createTypeNode(type);\n    if (ts.isUnionTypeNode(node)) {\n      nodes.push(...node.types);\n    } else {\n      nodes.push(node);\n    }\n  }\n  const unionNode = ts.factory.createUnionTypeNode(nodes);\n  return maybeNullable({ isNullable, node: unionNode });\n};\n\n/**\n * Create type intersection node. Example `string & number & boolean`\n * @param types - the types in the union\n * @param isNullable - if the whole type can be null\n * @returns ts.IntersectionTypeNode | ts.UnionTypeNode\n */\nexport const createTypeIntersectionNode = ({\n  isNullable,\n  types,\n}: {\n  isNullable?: boolean;\n  types: (any | ts.TypeNode)[];\n}) => {\n  // flatten nested intersections\n  const nodes: Array<ts.TypeNode> = [];\n  for (const type of types) {\n    const node = createTypeNode(type);\n    if (ts.isIntersectionTypeNode(node)) {\n      nodes.push(...node.types);\n    } else {\n      nodes.push(node);\n    }\n  }\n  const intersectionNode = ts.factory.createIntersectionTypeNode(nodes);\n  return maybeNullable({ isNullable, node: intersectionNode });\n};\n\n/**\n * Create type tuple node. Example `string, number, boolean`\n * @param isNullable if the whole type can be null\n * @param types the types in the union\n * @returns ts.UnionTypeNode\n */\nexport const createTypeTupleNode = ({\n  isNullable = false,\n  types,\n}: {\n  isNullable?: boolean;\n  types: Array<any | ts.TypeNode>;\n}) => {\n  const nodes = types.map((type) => createTypeNode(type));\n  const node = ts.factory.createTupleTypeNode(nodes);\n  return maybeNullable({ isNullable, node });\n};\n\n/**\n * Create type record node. Example `{ [key: string]: string }`\n * @param keys - key types.\n * @param values - value types.\n * @param isNullable - if the whole type can be null\n * @returns ts.TypeReferenceNode | ts.UnionTypeNode\n */\nexport const createTypeRecordNode = (\n  keys: (any | ts.TypeNode)[],\n  values: (any | ts.TypeNode)[],\n  isNullable: boolean = false,\n  useLegacyResolution: boolean = true,\n) => {\n  const keyNode = createTypeUnionNode({\n    types: keys,\n  });\n  const valueNode = createTypeUnionNode({\n    types: values,\n  });\n  // NOTE: We use the syntax `{ [key: string]: string }` because using a Record causes\n  //       invalid types with circular dependencies. This is functionally the same.\n  // Ref: https://github.com/hey-api/openapi-ts/issues/370\n  const node = createTypeInterfaceNode({\n    properties: [\n      {\n        name: `[key: ${tsNodeToString({ node: keyNode, unescape: true })}]`,\n        type: valueNode,\n      },\n    ],\n    useLegacyResolution,\n  });\n  return maybeNullable({ isNullable, node });\n};\n\n/**\n * Create type array node. Example `Array<string | number>`\n * @param types - the types\n * @param isNullable - if the whole type can be null\n * @returns ts.TypeReferenceNode | ts.UnionTypeNode\n */\nexport const createTypeArrayNode = (\n  types:\n    | ReadonlyArray<any | ts.TypeNode>\n    | ts.TypeNode\n    | ts.Identifier\n    | string,\n  isNullable: boolean = false,\n) => {\n  const node = createTypeReferenceNode({\n    typeArguments: [\n      // @ts-expect-error\n      Array.isArray(types) ? createTypeUnionNode({ types }) : types,\n    ],\n    typeName: 'Array',\n  });\n  return maybeNullable({ isNullable, node });\n};\n","import * as classes from './classes';\nimport * as convert from './convert';\nimport * as module from './module';\nimport * as _return from './return';\nimport * as transform from './transform';\nimport * as typedef from './typedef';\nimport * as types from './types';\nimport * as utils from './utils';\n\nexport type { Property } from './typedef';\nexport type { FunctionParameter } from './types';\nexport type { Comments } from './utils';\n\nexport const tsc = {\n  anonymousFunction: types.createAnonymousFunction,\n  arrayLiteralExpression: types.createArrayLiteralExpression,\n  arrowFunction: types.createArrowFunction,\n  asExpression: types.createAsExpression,\n  assignment: types.createAssignment,\n  awaitExpression: types.createAwaitExpression,\n  binaryExpression: transform.createBinaryExpression,\n  block: types.createBlock,\n  callExpression: module.createCallExpression,\n  classDeclaration: classes.createClassDeclaration,\n  conditionalExpression: types.createConditionalExpression,\n  constVariable: module.createConstVariable,\n  constructorDeclaration: classes.createConstructorDeclaration,\n  enumDeclaration: types.createEnumDeclaration,\n  exportAllDeclaration: module.createExportAllDeclaration,\n  exportNamedDeclaration: module.createNamedExportDeclarations,\n  expressionToStatement: convert.expressionToStatement,\n  forOfStatement: types.createForOfStatement,\n  functionTypeNode: types.createFunctionTypeNode,\n  getAccessorDeclaration: types.createGetAccessorDeclaration,\n  identifier: utils.createIdentifier,\n  ifStatement: transform.createIfStatement,\n  indexedAccessTypeNode: types.createIndexedAccessTypeNode,\n  isTsNode: utils.isTsNode,\n  keywordTypeNode: types.createKeywordTypeNode,\n  literalTypeNode: types.createLiteralTypeNode,\n  mappedTypeNode: types.createMappedTypeNode,\n  methodDeclaration: classes.createMethodDeclaration,\n  namedImportDeclarations: module.createNamedImportDeclarations,\n  namespaceDeclaration: types.createNamespaceDeclaration,\n  newExpression: types.createNewExpression,\n  nodeToString: utils.tsNodeToString,\n  null: types.createNull,\n  objectExpression: types.createObjectType,\n  ots: utils.ots,\n  parameterDeclaration: types.createParameterDeclaration,\n  propertyAccessExpression: types.createPropertyAccessExpression,\n  propertyAccessExpressions: transform.createPropertyAccessExpressions,\n  propertyAssignment: types.createPropertyAssignment,\n  propertyDeclaration: utils.createPropertyDeclaration,\n  regularExpressionLiteral: types.createRegularExpressionLiteral,\n  returnFunctionCall: _return.createReturnFunctionCall,\n  returnStatement: _return.createReturnStatement,\n  returnVariable: _return.createReturnVariable,\n  safeAccessExpression: transform.createSafeAccessExpression,\n  stringLiteral: types.createStringLiteral,\n  templateLiteralType: types.createTemplateLiteralType,\n  this: utils.createThis,\n  transformArrayMap: transform.createArrayMapTransform,\n  transformArrayMutation: transform.createArrayTransformMutation,\n  transformDateMutation: transform.createDateTransformMutation,\n  transformFunctionMutation: transform.createFunctionTransformMutation,\n  transformNewDate: transform.createDateTransformerExpression,\n  typeAliasDeclaration: types.createTypeAliasDeclaration,\n  typeArrayNode: typedef.createTypeArrayNode,\n  typeInterfaceNode: typedef.createTypeInterfaceNode,\n  typeIntersectionNode: typedef.createTypeIntersectionNode,\n  typeNode: types.createTypeNode,\n  typeOfExpression: types.createTypeOfExpression,\n  typeOperatorNode: types.createTypeOperatorNode,\n  typeParameterDeclaration: types.createTypeParameterDeclaration,\n  typeParenthesizedNode: types.createTypeParenthesizedNode,\n  typeRecordNode: typedef.createTypeRecordNode,\n  typeReferenceNode: types.createTypeReferenceNode,\n  typeTupleNode: typedef.createTypeTupleNode,\n  typeUnionNode: typedef.createTypeUnionNode,\n  valueToExpression: types.toExpression,\n};\n\n/** @deprecated use tsc */\nexport const compiler = tsc;\n","import path from 'node:path';\n\nimport type {\n  BiMap,\n  Binding,\n  File,\n  IProject,\n  ProjectRenderMeta,\n  Renderer,\n  Symbol,\n} from '@hey-api/codegen-core';\nimport { createBinding, mergeBindings, renderIds } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport { ensureValidIdentifier } from '~/openApi/shared/utils/identifier';\nimport { tsc } from '~/tsc';\nimport { tsNodeToString } from '~/tsc/utils';\n\nconst nodeBuiltins = new Set([\n  'buffer',\n  'child_process',\n  'cluster',\n  'console',\n  'constants',\n  'crypto',\n  'dgram',\n  'dns',\n  'domain',\n  'events',\n  'freelist',\n  'fs',\n  'http',\n  'https',\n  'module',\n  'net',\n  'os',\n  'path',\n  'process',\n  'punycode',\n  'querystring',\n  'readline',\n  'repl',\n  'stream',\n  'string_decoder',\n  'timers',\n  'tls',\n  'tty',\n  'url',\n  'util',\n  'v8',\n  'vm',\n  'worker_threads',\n  'zlib',\n]);\n\nexport class TypeScriptRenderer implements Renderer {\n  private addBinding({\n    bindings,\n    file,\n    meta,\n    project,\n    symbol,\n  }: {\n    bindings: Map<string, Binding>;\n    file: File;\n    meta?: ProjectRenderMeta;\n    project: IProject;\n    symbol: Symbol;\n  }): void {\n    if (!symbol.external && !project.symbols.hasValue(symbol.id)) {\n      return;\n    }\n\n    const [symbolFile] = project.symbolIdToFiles(symbol.id);\n    if (!symbolFile) return;\n\n    const modulePath = this.getBindingPath(file, symbolFile, meta);\n    const existing = bindings.get(modulePath);\n    const binding = createBinding({\n      file,\n      modulePath,\n      symbol,\n      symbolFile,\n    });\n    if (existing) {\n      mergeBindings(existing, binding);\n      bindings.set(modulePath, existing);\n    } else {\n      bindings.set(modulePath, binding);\n    }\n  }\n\n  private getBindingPath(\n    currentFile: File,\n    symbolFile: File,\n    meta?: ProjectRenderMeta,\n  ): string {\n    if (!currentFile.path || !symbolFile.path) {\n      return '';\n    }\n    if (symbolFile.external && !path.isAbsolute(symbolFile.path)) {\n      return symbolFile.path;\n    }\n    let relativePath = path.posix.relative(\n      path.posix.dirname(\n        currentFile.path.split(path.sep).join(path.posix.sep), // normalize to posix\n      ),\n      symbolFile.path.split(path.sep).join(path.posix.sep), // normalize to posix\n    );\n    if (!relativePath.startsWith('.') && relativePath !== '') {\n      relativePath = `./${relativePath}`;\n    }\n    if (symbolFile.extension === '.ts') {\n      if (relativePath.endsWith(symbolFile.extension)) {\n        relativePath = relativePath.slice(0, -symbolFile.extension.length);\n      }\n      if (meta?.importFileExtension) {\n        relativePath += meta.importFileExtension;\n      } else if (relativePath.endsWith('/index')) {\n        relativePath = relativePath.slice(0, -'/index'.length);\n      }\n    }\n    return relativePath;\n  }\n\n  private getBodyLines(file: File, project: IProject): Array<string> {\n    const lines: Array<string> = [];\n\n    for (const symbolId of file.symbols.body) {\n      const value = project.symbols.getValue(symbolId);\n      if (typeof value === 'string') {\n        lines.push(value);\n      } else if (value instanceof Array) {\n        for (const node of value) {\n          lines.push(tsNodeToString({ node, unescape: true }));\n        }\n      } else if (value !== undefined && value !== null) {\n        lines.push(tsNodeToString({ node: value as any, unescape: true }));\n      }\n    }\n\n    return lines;\n  }\n\n  private getExportLines(\n    bindings: Map<string, Binding>,\n    file: File,\n    project: IProject,\n  ): Array<string> {\n    const lines: Array<string> = [];\n\n    for (const [from, value] of bindings.entries()) {\n      const specifiers: Array<ts.ExportSpecifier> = [];\n      let namespaceBinding: string | undefined;\n      let isTypeOnly = false;\n\n      if (value.namespaceBinding !== undefined) {\n        if (typeof value.namespaceBinding === 'string') {\n          namespaceBinding = renderIds(value.namespaceBinding, (symbolId) => {\n            const symbol = project.symbols.get(symbolId);\n            return this.replacerFn({ file, project, symbol });\n          });\n        }\n        if (value.typeNamespaceBinding) {\n          isTypeOnly = true;\n        }\n      } else if (value.names && value.names.length > 0) {\n        if (\n          value.names.every((name) => (value.typeNames ?? []).includes(name))\n        ) {\n          isTypeOnly = true;\n        }\n\n        for (const name of value.names) {\n          const alias = value.aliases?.[name];\n          let finalName = name;\n          let finalAlias: string | undefined;\n          if (alias && alias !== finalName) {\n            finalAlias = finalName;\n            finalName = alias;\n          }\n          finalName = renderIds(finalName, (symbolId) => {\n            const symbol = project.symbols.get(symbolId);\n            const name = this.replacerFn({ file, project, symbol });\n            const [symbolFile] = project.symbolIdToFiles(symbolId);\n            const sourceName = symbolFile\n              ? symbolFile.resolvedNames.get(symbolId)\n              : undefined;\n            if (sourceName && sourceName !== name) {\n              // handle only simple imports for now\n              if (!finalAlias) {\n                finalAlias = sourceName;\n              }\n            }\n            return name;\n          });\n          if (finalAlias) {\n            finalAlias = renderIds(finalAlias, (symbolId) => {\n              const symbol = project.symbols.get(symbolId);\n              return this.replacerFn({ file, project, symbol });\n            });\n            // remove redundant alias\n            if (finalAlias === finalName) {\n              finalAlias = undefined;\n            }\n          }\n          const specifier = ts.factory.createExportSpecifier(\n            isTypeOnly ? false : (value.typeNames?.includes(name) ?? false),\n            finalAlias ? tsc.identifier({ text: finalAlias }) : undefined,\n            tsc.identifier({ text: finalName }),\n          );\n          specifiers.push(specifier);\n        }\n      }\n\n      const exportClause = namespaceBinding\n        ? ts.factory.createNamespaceExport(\n            tsc.identifier({ text: namespaceBinding }),\n          )\n        : specifiers.length\n          ? ts.factory.createNamedExports(specifiers)\n          : undefined;\n\n      const node = ts.factory.createExportDeclaration(\n        undefined,\n        isTypeOnly,\n        exportClause,\n        tsc.stringLiteral({ isSingleQuote: true, text: from }),\n      );\n      lines.push(tsNodeToString({ node, unescape: true }));\n    }\n\n    return lines;\n  }\n\n  private getHeaderLines(): Array<string> {\n    return ['// This file is auto-generated by @hey-api/openapi-ts'];\n  }\n\n  private getImportLines(\n    bindings: Map<string, Binding>,\n    file: File,\n    project: IProject,\n  ): Array<string> {\n    const lines: Array<string> = [];\n\n    let lastGroup = -1;\n    const importSortKey = (binding: Binding): [number, number, string] => {\n      const path = binding.from;\n      if (!path.startsWith('.')) {\n        // Node.js built-in\n        if (nodeBuiltins.has(path.split('/')[0]!)) {\n          return [0, 0, path];\n        }\n        // external package\n        return [1, 0, path];\n      }\n      // sibling relative\n      if (path.startsWith('./')) {\n        return [2, 0, path];\n      }\n      // parent relative\n      const parentCount = path.match(/\\.\\.\\//g)?.length ?? 0;\n      return [2, parentCount, path];\n    };\n\n    const sortedBindings = Array.from(bindings.values())\n      .map((value) => ({\n        ...value,\n        k: importSortKey(value),\n      }))\n      .sort(\n        (a, b) =>\n          a.k[0] - b.k[0] || a.k[1] - b.k[1] || a.k[2].localeCompare(b.k[2]),\n      );\n\n    for (const value of sortedBindings) {\n      let specifiers: Array<ts.ImportSpecifier> = [];\n      let defaultBinding: ts.Identifier | undefined;\n      let namespaceBinding: string | undefined;\n      let isTypeOnly = false;\n\n      if (value.defaultBinding) {\n        const processedDefaultBinding = renderIds(\n          value.defaultBinding,\n          (symbolId) => {\n            const symbol = project.symbols.get(symbolId);\n            return this.replacerFn({ file, project, symbol });\n          },\n        );\n        defaultBinding = tsc.identifier({ text: processedDefaultBinding });\n        if (value.typeDefaultBinding) {\n          isTypeOnly = true;\n        }\n      } else if (typeof value.namespaceBinding === 'string') {\n        namespaceBinding = renderIds(value.namespaceBinding, (symbolId) => {\n          const symbol = project.symbols.get(symbolId);\n          return this.replacerFn({ file, project, symbol });\n        });\n        if (value.typeNamespaceBinding) {\n          isTypeOnly = true;\n        }\n      } else if (value.names && value.names.length > 0) {\n        if (value.names.every((name) => value.typeNames?.includes(name))) {\n          isTypeOnly = true;\n        }\n\n        const namedImports: Array<{\n          isTypeOnly: boolean;\n          name: string;\n          propertyName: ts.ModuleExportName | undefined;\n        }> = [];\n\n        for (const name of value.names) {\n          const alias = value.aliases?.[name];\n          let finalName = name;\n          let finalAlias: string | undefined;\n          if (alias && alias !== finalName) {\n            finalAlias = finalName;\n            finalName = alias;\n          }\n          finalName = renderIds(finalName, (symbolId) => {\n            const symbol = project.symbols.get(symbolId);\n            const name = this.replacerFn({ file, project, symbol });\n            const [symbolFile] = project.symbolIdToFiles(symbolId);\n            const sourceName = symbolFile\n              ? symbolFile.resolvedNames.get(symbolId)\n              : undefined;\n            if (sourceName && sourceName !== name) {\n              // handle only simple imports for now\n              if (!finalAlias) {\n                finalAlias = sourceName;\n              }\n            }\n            return name;\n          });\n          if (finalAlias) {\n            finalAlias = renderIds(finalAlias, (symbolId) => {\n              const symbol = project.symbols.get(symbolId);\n              return this.replacerFn({ file, project, symbol });\n            });\n            // remove redundant alias\n            if (finalAlias === finalName) {\n              finalAlias = undefined;\n            }\n          }\n          namedImports.push({\n            isTypeOnly: isTypeOnly\n              ? false\n              : (value.typeNames?.includes(name) ?? false),\n            name: finalName,\n            propertyName: finalAlias\n              ? tsc.identifier({ text: finalAlias })\n              : undefined,\n          });\n        }\n\n        specifiers = namedImports\n          .sort((a, b) => a.name.localeCompare(b.name))\n          .map(({ isTypeOnly, name, propertyName }) =>\n            ts.factory.createImportSpecifier(\n              isTypeOnly,\n              propertyName,\n              tsc.identifier({ text: name }),\n            ),\n          );\n      }\n\n      const importClause = ts.factory.createImportClause(\n        isTypeOnly,\n        defaultBinding,\n        namespaceBinding\n          ? ts.factory.createNamespaceImport(\n              tsc.identifier({ text: namespaceBinding }),\n            )\n          : specifiers.length\n            ? ts.factory.createNamedImports(specifiers)\n            : undefined,\n      );\n\n      const node = ts.factory.createImportDeclaration(\n        undefined,\n        importClause,\n        tsc.stringLiteral({ isSingleQuote: true, text: value.from }),\n      );\n\n      if (lastGroup !== -1 && value.k[0] !== lastGroup) {\n        lines.push(''); // add empty line between groups\n      }\n\n      lines.push(tsNodeToString({ node, unescape: true }));\n      lastGroup = value.k[0];\n    }\n\n    return lines;\n  }\n\n  private getUniqueName(base: string, names: BiMap<number, string>): string {\n    let index = 2;\n    let name = base;\n    while (names.hasValue(name)) {\n      name = `${base}${index}`;\n      index += 1;\n    }\n    return name;\n  }\n\n  renderFile(\n    symbolsAndExports: string,\n    file: File,\n    project: IProject,\n    meta?: ProjectRenderMeta,\n  ): string {\n    const imports: Map<string, Binding> = new Map();\n    symbolsAndExports = renderIds(symbolsAndExports, (symbolId) => {\n      const symbol = project.symbols.get(symbolId);\n      const replaced = this.replacerFn({ file, project, symbol });\n      if (symbol) {\n        this.addBinding({ bindings: imports, file, meta, project, symbol });\n      }\n      return replaced;\n    });\n    if (!symbolsAndExports.length) return '';\n    let output = '';\n    const headerLines = this.getHeaderLines();\n    output += `${headerLines.join('\\n')}${headerLines.length ? '\\n\\n' : ''}`;\n    const importLines = this.getImportLines(imports, file, project);\n    output += `${importLines.join('\\n')}${importLines.length ? '\\n\\n' : ''}`;\n    return `${output}${symbolsAndExports}`;\n  }\n\n  renderSymbols(\n    file: File,\n    project: IProject,\n    meta?: ProjectRenderMeta,\n  ): string {\n    const exports: Map<string, Binding> = new Map();\n    let output = '';\n    const bodyLines = this.getBodyLines(file, project);\n    output += `${bodyLines.join('\\n\\n')}${bodyLines.length ? '\\n' : ''}`;\n    output = renderIds(output, (symbolId) => {\n      if (!file.symbols.body.includes(symbolId)) return;\n      const symbol = project.symbols.get(symbolId);\n      return this.replacerFn({ file, project, symbol });\n    });\n    for (const symbolId of file.symbols.exports) {\n      const symbol = project.symbols.get(symbolId);\n      if (symbol) {\n        this.addBinding({ bindings: exports, file, meta, project, symbol });\n      }\n    }\n    // cast everything into namespace exports for now\n    for (const binding of exports.values()) {\n      binding.namespaceBinding = true;\n      binding.typeNamespaceBinding =\n        binding.names &&\n        binding.typeNames &&\n        binding.names.length === binding.typeNames.length &&\n        binding.names.every((name) => (binding.typeNames ?? []).includes(name));\n    }\n    const exportLines = this.getExportLines(exports, file, project);\n    output += `${exportLines.join('\\n')}${exportLines.length ? '\\n' : ''}`;\n    return output;\n  }\n\n  private replacerFn({\n    file,\n    project,\n    symbol,\n  }: {\n    file: File;\n    project: IProject;\n    symbol: Symbol | undefined;\n  }): string | undefined {\n    if (!symbol) return;\n    const cached = file.resolvedNames.get(symbol.id);\n    if (cached) return cached;\n    if (!symbol.name) return;\n    const [symbolFile] = project.symbolIdToFiles(symbol.id);\n    const symbolFileResolvedName = symbolFile?.resolvedNames.get(symbol.id);\n    let name = ensureValidIdentifier(symbolFileResolvedName ?? symbol.name);\n    const conflictId = file.resolvedNames.getKey(name);\n    if (conflictId !== undefined) {\n      const conflictSymbol = project.symbols.get(conflictId);\n      if (\n        (conflictSymbol?.meta?.kind === 'type' &&\n          symbol.meta?.kind === 'type') ||\n        (conflictSymbol?.meta?.kind !== 'type' && symbol.meta?.kind !== 'type')\n      ) {\n        name = this.getUniqueName(name, file.resolvedNames);\n      }\n    }\n    file.resolvedNames.set(symbol.id, name);\n    return name;\n  }\n}\n","export class MinHeap {\n  private heap: Array<string> = [];\n\n  constructor(public declIndex: Map<string, number>) {}\n\n  isEmpty(): boolean {\n    return !this.heap.length;\n  }\n\n  pop(): string | undefined {\n    const [top] = this.heap;\n    if (!this.heap.length) return;\n    const last = this.heap.pop()!;\n    if (!this.heap.length) return top;\n    this.heap[0] = last;\n    this.sinkDown(0);\n    return top;\n  }\n\n  push(item: string): void {\n    this.heap.push(item);\n    this.bubbleUp(this.heap.length - 1);\n  }\n\n  private bubbleUp(index: number): void {\n    const heap = this.heap;\n    while (index > 0) {\n      const parent = Math.floor((index - 1) / 2);\n      const parentVal = heap[parent]!;\n      const curVal = heap[index]!;\n      if (this.declIndex.get(parentVal)! <= this.declIndex.get(curVal)!) break;\n      heap[parent] = curVal;\n      heap[index] = parentVal;\n      index = parent;\n    }\n  }\n\n  private sinkDown(index: number): void {\n    const heap = this.heap;\n    const len = heap.length;\n    while (true) {\n      const left = 2 * index + 1;\n      const right = 2 * index + 2;\n      let smallest = index;\n      if (left < len) {\n        const leftVal = heap[left]!;\n        const smallestVal = heap[smallest]!;\n        if (this.declIndex.get(leftVal)! < this.declIndex.get(smallestVal)!)\n          smallest = left;\n      }\n      if (right < len) {\n        const rightVal = heap[right]!;\n        const smallestVal = heap[smallest]!;\n        if (this.declIndex.get(rightVal)! < this.declIndex.get(smallestVal)!)\n          smallest = right;\n      }\n      if (smallest === index) break;\n      const tmp = heap[smallest]!;\n      heap[smallest] = heap[index]!;\n      heap[index] = tmp;\n      index = smallest;\n    }\n  }\n}\n","import { MinHeap } from '~/utils/minHeap';\n\nimport type { GetPointerPriorityFn, WalkFn } from './types/walk';\n\n/**\n * Walk the nodes of the graph in declaration (insertion) order.\n * This is a cheap alternative to `walkTopological` when dependency ordering\n * is not required and the caller only wants nodes in the order they were\n * added to the graph.\n */\nconst walkDeclarations: WalkFn = (graph, callback, options) => {\n  const pointers = Array.from(graph.nodes.keys());\n\n  if (options?.preferGroups && options.preferGroups.length > 0) {\n    // emit nodes that match each preferred group in order, preserving insertion order\n    const emitted = new Set<string>();\n    if (options.matchPointerToGroup) {\n      for (const kind of options.preferGroups) {\n        for (const pointer of pointers) {\n          const result = options.matchPointerToGroup(pointer);\n          if (!result.matched) continue;\n          if (result.kind === kind) {\n            emitted.add(pointer);\n            callback(pointer, graph.nodes.get(pointer)!);\n          }\n        }\n      }\n    }\n\n    // emit anything not covered by the preferGroups (in declaration order)\n    for (const pointer of pointers) {\n      if (emitted.has(pointer)) continue;\n      callback(pointer, graph.nodes.get(pointer)!);\n    }\n    return;\n  }\n\n  // fallback: simple declaration order\n  for (const pointer of pointers) {\n    callback(pointer, graph.nodes.get(pointer)!);\n  }\n};\n\n/**\n * Walks the nodes of the graph in topological order (dependencies before dependents).\n * Calls the callback for each node pointer in order.\n * Nodes in cycles are grouped together and emitted in arbitrary order within the group.\n *\n * @param graph - The dependency graph\n * @param callback - Function to call for each node pointer\n */\nconst walkTopological: WalkFn = (graph, callback, options) => {\n  // stable Kahn's algorithm that respects declaration order as a tiebreaker.\n  const pointers = Array.from(graph.nodes.keys());\n  // base insertion order\n  const baseIndex = new Map<string, number>();\n  pointers.forEach((pointer, index) => baseIndex.set(pointer, index));\n\n  // composite decl index: group priority then base insertion order\n  const declIndex = new Map<string, number>();\n  for (const pointer of pointers) {\n    const priority = options?.getPointerPriority?.(pointer) ?? 10;\n    const composite = priority * 1_000_000 + (baseIndex.get(pointer) ?? 0);\n    declIndex.set(pointer, composite);\n  }\n\n  // build dependency sets for each pointer\n  const depsOf = new Map<string, Set<string>>();\n  for (const pointer of pointers) {\n    const raw = graph.subtreeDependencies?.get(pointer) ?? new Set();\n    const filtered = new Set<string>();\n    for (const rawPointer of raw) {\n      if (rawPointer === pointer) continue; // ignore self-dependencies for ordering\n      if (graph.nodes.has(rawPointer)) {\n        filtered.add(rawPointer);\n      }\n    }\n    depsOf.set(pointer, filtered);\n  }\n\n  // build inDegree and dependents adjacency\n  const inDegree = new Map<string, number>();\n  const dependents = new Map<string, Set<string>>();\n  for (const pointer of pointers) {\n    inDegree.set(pointer, 0);\n  }\n  for (const [pointer, deps] of depsOf) {\n    inDegree.set(pointer, deps.size);\n    for (const d of deps) {\n      if (!dependents.has(d)) {\n        dependents.set(d, new Set());\n      }\n      dependents.get(d)!.add(pointer);\n    }\n  }\n\n  // sort pointers by declaration order\n  const sortByDecl = (arr: Array<string>) =>\n    arr.sort((a, b) => declIndex.get(a)! - declIndex.get(b)!);\n\n  // initialize queue with zero-inDegree nodes in declaration order\n  // use min-heap prioritized by declaration index to avoid repeated full sorts\n  const heap = new MinHeap(declIndex);\n  for (const pointer of pointers) {\n    if ((inDegree.get(pointer) ?? 0) === 0) {\n      heap.push(pointer);\n    }\n  }\n\n  const emitted = new Set<string>();\n  const order: Array<string> = [];\n\n  while (!heap.isEmpty()) {\n    const cur = heap.pop()!;\n    if (emitted.has(cur)) continue;\n    emitted.add(cur);\n    order.push(cur);\n\n    const deps = dependents.get(cur);\n    if (!deps) continue;\n\n    for (const dep of deps) {\n      const v = (inDegree.get(dep) ?? 0) - 1;\n      inDegree.set(dep, v);\n      if (v === 0) {\n        heap.push(dep);\n      }\n    }\n  }\n\n  // emit remaining nodes (cycles) in declaration order\n  const remaining = pointers.filter((pointer) => !emitted.has(pointer));\n  sortByDecl(remaining);\n  for (const pointer of remaining) {\n    emitted.add(pointer);\n    order.push(pointer);\n  }\n\n  // prefer specified groups when safe\n  let finalOrder = order;\n  if (options?.preferGroups && options.preferGroups.length > 0) {\n    // build group priority map (lower = earlier)\n    const groupPriority = new Map<string, number>();\n    for (let i = 0; i < options.preferGroups.length; i++) {\n      const k = options.preferGroups[i];\n      if (k) {\n        groupPriority.set(k, i);\n      }\n    }\n\n    const getGroup: GetPointerPriorityFn = (pointer) => {\n      if (options.matchPointerToGroup) {\n        const result = options.matchPointerToGroup(pointer);\n        if (result.matched) {\n          return groupPriority.has(result.kind)\n            ? groupPriority.get(result.kind)!\n            : options.preferGroups!.length;\n        }\n      }\n      return options.preferGroups!.length;\n    };\n\n    // proposed order: sort by (groupPriority, originalIndex)\n    const proposed = [...order].sort((a, b) => {\n      const ga = getGroup(a);\n      const gb = getGroup(b);\n      return ga !== gb ? ga - gb : order.indexOf(a) - order.indexOf(b);\n    });\n\n    // build quick lookup of original index and proposed index\n    const proposedIndex = new Map<string, number>();\n    for (let i = 0; i < proposed.length; i++) {\n      proposedIndex.set(proposed[i]!, i);\n    }\n\n    // only validate edges where group(dep) > group(node)\n    const violated = (() => {\n      for (const [node, deps] of depsOf) {\n        for (const dep of deps) {\n          const gDep = getGroup(dep);\n          const gNode = getGroup(node);\n          if (gDep <= gNode) continue; // not a crossing edge, cannot be violated by grouping\n          const pDep = proposedIndex.get(dep)!;\n          const pNode = proposedIndex.get(node)!;\n          if (pDep >= pNode) {\n            return true;\n          }\n        }\n      }\n      return false;\n    })();\n\n    if (!violated) {\n      finalOrder = proposed;\n    }\n  }\n\n  for (const pointer of finalOrder) {\n    callback(pointer, graph.nodes.get(pointer)!);\n  }\n};\n\nexport const walk: WalkFn = (graph, callback, options) => {\n  if (options?.order === 'topological') {\n    return walkTopological(graph, callback, options);\n  }\n  return walkDeclarations(graph, callback, options);\n};\n","import type { GetPointerPriorityFn, MatchPointerToGroupFn } from '~/graph';\n\nexport const irTopLevelKinds = [\n  'operation',\n  'parameter',\n  'requestBody',\n  'schema',\n  'server',\n  'webhook',\n] as const;\n\nexport type IrTopLevelKind = (typeof irTopLevelKinds)[number];\n\n/**\n * Checks if a pointer matches a known top-level IR component (schema, parameter, etc) and returns match info.\n *\n * @param pointer - The IR pointer string (e.g. '#/components/schemas/Foo')\n * @param kind - (Optional) The component kind to check\n * @returns { matched: true, kind: IrTopLevelKind } | { matched: false } - Whether it matched, and the matched kind if so\n */\nexport const matchIrPointerToGroup: MatchPointerToGroupFn<IrTopLevelKind> = (\n  pointer,\n  kind,\n) => {\n  const patterns: Record<IrTopLevelKind, RegExp> = {\n    operation:\n      /^#\\/paths\\/[^/]+\\/(get|put|post|delete|options|head|patch|trace)$/,\n    parameter: /^#\\/components\\/parameters\\/[^/]+$/,\n    requestBody: /^#\\/components\\/requestBodies\\/[^/]+$/,\n    schema: /^#\\/components\\/schemas\\/[^/]+$/,\n    server: /^#\\/servers\\/(\\d+|[^/]+)$/,\n    webhook:\n      /^#\\/webhooks\\/[^/]+\\/(get|put|post|delete|options|head|patch|trace)$/,\n  };\n  if (kind) {\n    return patterns[kind].test(pointer)\n      ? { kind, matched: true }\n      : { matched: false };\n  }\n  for (const key of Object.keys(patterns)) {\n    const kind = key as IrTopLevelKind;\n    if (patterns[kind].test(pointer)) {\n      return { kind, matched: true };\n    }\n  }\n  return { matched: false };\n};\n\n// default grouping preference (earlier groups emitted first when safe)\nexport const preferGroups = [\n  'server',\n  'schema',\n  'parameter',\n  'requestBody',\n  'operation',\n  'webhook',\n] satisfies ReadonlyArray<IrTopLevelKind>;\n\ntype KindPriority = Record<IrTopLevelKind, number>;\n\n// default group priority (lower = earlier)\n// built from `preferGroups` so the priority order stays in sync with the prefer-groups array.\nconst kindPriority: KindPriority = (() => {\n  const partial: Partial<KindPriority> = {};\n  for (let i = 0; i < preferGroups.length; i++) {\n    const k = preferGroups[i];\n    if (k) partial[k] = i;\n  }\n  // Ensure all known kinds exist in the map (fall back to a high index).\n  for (const k of irTopLevelKinds) {\n    if (partial[k] === undefined) {\n      partial[k] = preferGroups.length;\n    }\n  }\n  return partial as KindPriority;\n})();\n\nconst defaultPriority = 10;\n\nexport const getIrPointerPriority: GetPointerPriorityFn = (pointer) => {\n  const result = matchIrPointerToGroup(pointer);\n  if (result.matched) {\n    return kindPriority[result.kind] ?? defaultPriority;\n  }\n  return defaultPriority;\n};\n","const jsonPointerSlash = /~1/g;\nconst jsonPointerTilde = /~0/g;\n\n/**\n * Returns the reusable component name from `$ref`.\n */\nexport const refToName = ($ref: string): string => {\n  const path = jsonPointerToPath($ref);\n  const name = path[path.length - 1]!;\n  // refs using unicode characters become encoded, didn't investigate why\n  // but the suspicion is this comes from `@hey-api/json-schema-ref-parser`\n  return decodeURI(name);\n};\n\n/**\n * Encodes a path segment for use in a JSON Pointer (RFC 6901).\n *\n * - Replaces all '~' with '~0'.\n * - Replaces all '/' with '~1'.\n *\n * This ensures that path segments containing these characters are safely\n * represented in JSON Pointer strings.\n *\n * @param segment - The path segment (string or number) to encode.\n * @returns The encoded segment as a string.\n */\nexport const encodeJsonPointerSegment = (segment: string | number): string =>\n  String(segment).replace(/~/g, '~0').replace(/\\//g, '~1');\n\n/**\n * Converts a JSON Pointer string (RFC 6901) to an array of path segments.\n *\n * - Removes the leading '#' if present.\n * - Splits the pointer on '/'.\n * - Decodes '~1' to '/' and '~0' to '~' in each segment.\n * - Returns an empty array for the root pointer ('#' or '').\n *\n * @param pointer - The JSON Pointer string to convert (e.g., '#/components/schemas/Foo').\n * @returns An array of decoded path segments.\n */\nexport const jsonPointerToPath = (pointer: string): ReadonlyArray<string> => {\n  let clean = pointer.trim();\n  if (clean.startsWith('#')) {\n    clean = clean.slice(1);\n  }\n  if (clean.startsWith('/')) {\n    clean = clean.slice(1);\n  }\n  if (!clean) {\n    return [];\n  }\n  return clean\n    .split('/')\n    .map((part) =>\n      part.replace(jsonPointerSlash, '/').replace(jsonPointerTilde, '~'),\n    );\n};\n\n/**\n * Normalizes a JSON Pointer string to a canonical form.\n *\n * - Ensures the pointer starts with '#'.\n * - Removes trailing slashes (except for root).\n * - Collapses multiple consecutive slashes into one.\n * - Trims whitespace from the input.\n *\n * @param pointer - The JSON Pointer string to normalize.\n * @returns The normalized JSON Pointer string.\n */\nexport const normalizeJsonPointer = (pointer: string): string => {\n  let normalized = pointer.trim();\n  if (!normalized.startsWith('#')) {\n    normalized = `#${normalized}`;\n  }\n  // Remove trailing slashes (except for root)\n  if (normalized.length > 1 && normalized.endsWith('/')) {\n    normalized = normalized.slice(0, -1);\n  }\n  // Collapse multiple slashes\n  normalized = normalized.replace(/\\/+/g, '/');\n  return normalized;\n};\n\n/**\n * Encode path as JSON Pointer (RFC 6901).\n *\n * @param path\n * @returns\n */\nexport const pathToJsonPointer = (\n  path: ReadonlyArray<string | number>,\n): string => {\n  const segments = path.map(encodeJsonPointerSegment).join('/');\n  return '#' + (segments ? `/${segments}` : '');\n};\n\nexport const resolveRef = <T>({\n  $ref,\n  spec,\n}: {\n  $ref: string;\n  spec: Record<string, any>;\n}): T => {\n  // refs using unicode characters become encoded, didn't investigate why\n  // but the suspicion is this comes from `@hey-api/json-schema-ref-parser`\n  const path = jsonPointerToPath(decodeURI($ref));\n\n  let current = spec;\n\n  for (const part of path) {\n    const segment = part as keyof typeof current;\n    if (current[segment] === undefined) {\n      throw new Error(`Reference not found: ${$ref}`);\n    }\n    current = current[segment];\n  }\n\n  return current as T;\n};\n","import path from 'node:path';\n\nimport type {\n  IProject,\n  Selector,\n  Symbol,\n  SymbolIn,\n} from '@hey-api/codegen-core';\n\nimport { HeyApiError } from '~/error';\nimport type { MatchPointerToGroupFn, WalkOptions } from '~/graph';\nimport { walk } from '~/graph';\nimport type { IrTopLevelKind } from '~/ir/graph';\nimport {\n  getIrPointerPriority,\n  irTopLevelKinds,\n  matchIrPointerToGroup,\n  preferGroups,\n} from '~/ir/graph';\nimport type { IR } from '~/ir/types';\nimport type { OpenApi } from '~/openApi/types';\nimport type { Hooks } from '~/parser/types/hooks';\nimport type { Plugin } from '~/plugins';\nimport type { PluginConfigMap } from '~/plugins/config';\nimport { jsonPointerToPath } from '~/utils/ref';\n\nimport type { BaseEvent, WalkEvent } from '../types/instance';\n\nconst defaultGetFilePath = (symbol: Symbol): string | undefined => {\n  if (!symbol.meta?.pluginName || typeof symbol.meta.pluginName !== 'string') {\n    return;\n  }\n  if (symbol.meta.pluginName.startsWith('@hey-api/client-')) {\n    return 'client';\n  }\n  if (symbol.meta.pluginName === '@hey-api/typescript') {\n    return 'types';\n  }\n  if (symbol.meta.pluginName.startsWith('@hey-api/')) {\n    return symbol.meta.pluginName.split('/')[1];\n  }\n  return symbol.meta.pluginName;\n};\n\nconst defaultGetKind: Required<Required<Hooks>['operations']>['getKind'] = (\n  operation,\n) => {\n  switch (operation.method) {\n    case 'delete':\n    case 'patch':\n    case 'post':\n    case 'put':\n      return ['mutation'];\n    case 'get':\n      return ['query'];\n    default:\n      return;\n  }\n};\n\ntype EventHooks = {\n  [K in keyof Required<NonNullable<Hooks['events']>>]: Array<\n    NonNullable<NonNullable<Hooks['events']>[K]>\n  >;\n};\n\nexport class PluginInstance<T extends Plugin.Types = Plugin.Types> {\n  api: T['api'];\n  config: Omit<T['resolvedConfig'], 'name' | 'output'>;\n  context: IR.Context;\n  dependencies: Required<Plugin.Config<T>>['dependencies'] = [];\n  private eventHooks: EventHooks;\n  gen: IProject;\n  private handler: Plugin.Config<T>['handler'];\n  name: T['resolvedConfig']['name'];\n  output: string;\n  /**\n   * The package metadata and utilities for the current context, constructed\n   * from the provided dependencies. Used for managing package-related\n   * information such as name, version, and dependency resolution during\n   * code generation.\n   */\n  package: IR.Context['package'];\n\n  constructor(\n    props: Pick<\n      Required<Plugin.Config<T>>,\n      'config' | 'dependencies' | 'handler'\n    > & {\n      api?: T['api'];\n      context: IR.Context<OpenApi.V2_0_X | OpenApi.V3_0_X | OpenApi.V3_1_X>;\n      gen: IProject;\n      name: string;\n      output: string;\n    },\n  ) {\n    this.api = props.api ?? {};\n    this.config = props.config;\n    this.context = props.context;\n    this.dependencies = props.dependencies;\n    this.eventHooks = this.buildEventHooks();\n    this.gen = props.gen;\n    this.handler = props.handler;\n    this.name = props.name;\n    this.output = props.output;\n    this.package = props.context.package;\n  }\n\n  /**\n   * Iterates over various input elements as specified by the event types, in\n   * a specific order: servers, schemas, parameters, request bodies, then\n   * operations.\n   *\n   * This ensures, for example, that schemas are always processed before\n   * operations, which may reference them.\n   *\n   * @template T - The event type(s) to yield. Defaults to all event types.\n   * @param events - The event types to walk over. If none are provided, all event types are included.\n   * @param callback - Function to execute for each event.\n   *\n   * @example\n   * // Iterate over all operations and schemas\n   * plugin.forEach('operation', 'schema', (event) => {\n   *   if (event.type === 'operation') {\n   *     // handle operation\n   *   } else if (event.type === 'schema') {\n   *     // handle schema\n   *   }\n   * });\n   */\n  forEach<T extends IrTopLevelKind = IrTopLevelKind>(\n    ...args: [\n      ...events: ReadonlyArray<T>,\n      callback: (event: WalkEvent<T>) => void,\n    ]\n  ): void;\n  forEach<T extends IrTopLevelKind = IrTopLevelKind>(\n    ...args: [\n      ...events: ReadonlyArray<T>,\n      callback: (event: WalkEvent<T>) => void,\n      options: WalkOptions<T>,\n    ]\n  ): void;\n  forEach<T extends IrTopLevelKind = IrTopLevelKind>(\n    ...args: [\n      ...events: ReadonlyArray<T>,\n      callback: (event: WalkEvent<T>) => void,\n      options: any,\n    ]\n  ): void {\n    if (!this.context.graph) {\n      throw new Error('No graph available in context');\n    }\n\n    let callback: (event: WalkEvent<T>) => void;\n    let events: ReadonlyArray<T>;\n    let options: WalkOptions<T> = {\n      getPointerPriority: getIrPointerPriority,\n      // default functions operate on the full union of kinds; cast them\n      // to the WalkOptions generic to keep strict typing for callers.\n      matchPointerToGroup:\n        matchIrPointerToGroup as unknown as MatchPointerToGroupFn<T>,\n      order: 'topological',\n      preferGroups: preferGroups as unknown as ReadonlyArray<T>,\n    };\n    if (typeof args[args.length - 1] === 'function') {\n      events = args.slice(0, -1);\n      callback = args[args.length - 1];\n    } else {\n      events = args.slice(0, -2);\n      callback = args[args.length - 2];\n      options = {\n        ...options,\n        ...args[args.length - 1],\n      };\n    }\n    const eventSet = new Set(events.length ? events : irTopLevelKinds);\n\n    walk(\n      this.context.graph,\n      (pointer, nodeInfo) => {\n        const result = matchIrPointerToGroup(pointer);\n        if (!result.matched || !eventSet.has(result.kind)) return;\n        let event: WalkEvent | undefined;\n        const baseEvent: BaseEvent = {\n          _path: jsonPointerToPath(pointer),\n          pointer,\n          tags: nodeInfo.tags,\n        };\n        switch (result.kind) {\n          case 'operation':\n            event = {\n              ...baseEvent,\n              method: nodeInfo.key as keyof IR.PathItemObject,\n              operation: nodeInfo.node as IR.OperationObject,\n              path: baseEvent._path[1] as string,\n              type: result.kind,\n            } satisfies WalkEvent<'operation'>;\n            break;\n          case 'parameter':\n            event = {\n              ...baseEvent,\n              name: nodeInfo.key as string,\n              parameter: nodeInfo.node as IR.ParameterObject,\n              type: result.kind,\n            } satisfies WalkEvent<'parameter'>;\n            break;\n          case 'requestBody':\n            event = {\n              ...baseEvent,\n              name: nodeInfo.key as string,\n              requestBody: nodeInfo.node as IR.RequestBodyObject,\n              type: result.kind,\n            } satisfies WalkEvent<'requestBody'>;\n            break;\n          case 'schema':\n            event = {\n              ...baseEvent,\n              name: nodeInfo.key as string,\n              schema: nodeInfo.node as IR.SchemaObject,\n              type: result.kind,\n            } satisfies WalkEvent<'schema'>;\n            break;\n          case 'server':\n            event = {\n              ...baseEvent,\n              server: nodeInfo.node as IR.ServerObject,\n              type: result.kind,\n            } satisfies WalkEvent<'server'>;\n            break;\n          case 'webhook':\n            event = {\n              ...baseEvent,\n              key: baseEvent._path[1] as string,\n              method: nodeInfo.key as keyof IR.PathItemObject,\n              operation: nodeInfo.node as IR.OperationObject,\n              type: result.kind,\n            } satisfies WalkEvent<'webhook'>;\n            break;\n        }\n        if (event) {\n          try {\n            callback(event as WalkEvent<T>);\n          } catch (error) {\n            this.forEachError(error, event);\n          }\n        }\n      },\n      options,\n    );\n  }\n\n  /**\n   * Retrieves a registered plugin instance by its name from the context. This\n   * allows plugins to access other plugins that have been registered in the\n   * same context, enabling cross-plugin communication and dependencies.\n   *\n   * @param name Plugin name as defined in the configuration.\n   * @returns The plugin instance if found, undefined otherwise.\n   */\n  getPlugin<T extends keyof PluginConfigMap>(\n    name: T,\n  ): T extends any ? PluginInstance<PluginConfigMap[T]> | undefined : never {\n    return this.context.plugins[name] as any;\n  }\n\n  /**\n   * Retrieves a registered plugin instance by its name from the context. This\n   * allows plugins to access other plugins that have been registered in the\n   * same context, enabling cross-plugin communication and dependencies.\n   *\n   * @param name Plugin name as defined in the configuration.\n   * @returns The plugin instance if found, throw otherwise.\n   */\n  getPluginOrThrow<T extends keyof PluginConfigMap>(\n    name: T,\n  ): T extends any ? PluginInstance<PluginConfigMap[T]> : never {\n    const plugin = this.getPlugin(name);\n    if (!plugin) throw new Error(`plugin not found ${name}`);\n    return plugin as any;\n  }\n\n  getSymbol(symbolIdOrSelector: number | Selector): Symbol | undefined {\n    return this.gen.symbols.get(symbolIdOrSelector);\n  }\n\n  hooks = {\n    operation: {\n      isMutation: (operation: IR.OperationObject): boolean =>\n        this.isOperationKind(operation, 'mutation'),\n      isQuery: (operation: IR.OperationObject): boolean =>\n        this.isOperationKind(operation, 'query'),\n    },\n  };\n\n  isSymbolRegistered(symbolIdOrSelector: number | Selector): boolean {\n    return this.gen.symbols.isRegistered(symbolIdOrSelector);\n  }\n\n  referenceSymbol(symbolIdOrSelector: number | Selector): Symbol {\n    return this.gen.symbols.reference(symbolIdOrSelector);\n  }\n\n  registerSymbol(symbol: SymbolIn): Symbol {\n    const symbolIn: SymbolIn = {\n      ...symbol,\n      exportFrom:\n        symbol.exportFrom ??\n        (!symbol.external &&\n        this.context.config.output.indexFile &&\n        this.config.exportFromIndex\n          ? ['index']\n          : undefined),\n      getFilePath: symbol.getFilePath ?? this.getSymbolFilePath.bind(this),\n      meta: {\n        pluginName: path.isAbsolute(this.name) ? 'custom' : this.name,\n        ...symbol.meta,\n      },\n    };\n    for (const hook of this.eventHooks['symbol:register:before']) {\n      hook({ plugin: this, symbol: symbolIn });\n    }\n    const symbolOut = this.gen.symbols.register(symbolIn);\n    for (const hook of this.eventHooks['symbol:register:after']) {\n      hook({ plugin: this, symbol: symbolOut });\n    }\n    return symbolOut;\n  }\n\n  /**\n   * Executes plugin's handler function.\n   */\n  async run(): Promise<void> {\n    for (const hook of this.eventHooks['plugin:handler:before']) {\n      hook({ plugin: this });\n    }\n    await this.handler({ plugin: this });\n    for (const hook of this.eventHooks['plugin:handler:after']) {\n      hook({ plugin: this });\n    }\n  }\n\n  setSymbolValue(symbol: Symbol, value: unknown): void {\n    for (const hook of this.eventHooks['symbol:setValue:before']) {\n      hook({ plugin: this, symbol, value });\n    }\n    this.gen.symbols.setValue(symbol.id, value);\n    for (const hook of this.eventHooks['symbol:setValue:after']) {\n      hook({ plugin: this, symbol, value });\n    }\n  }\n\n  private buildEventHooks(): EventHooks {\n    const result: EventHooks = {\n      'plugin:handler:after': [],\n      'plugin:handler:before': [],\n      'symbol:register:after': [],\n      'symbol:register:before': [],\n      'symbol:setValue:after': [],\n      'symbol:setValue:before': [],\n    };\n    const scopes = [\n      this.config['~hooks']?.events,\n      this.context.config.parser.hooks.events,\n    ];\n    for (const scope of scopes) {\n      if (!scope) continue;\n      for (const [key, value] of Object.entries(scope)) {\n        if (value) {\n          result[key as keyof typeof result].push(value.bind(scope) as any);\n        }\n      }\n    }\n    return result;\n  }\n\n  private forEachError(error: unknown, event: WalkEvent) {\n    const originalError =\n      error instanceof Error ? error : new Error(String(error));\n    throw new HeyApiError({\n      args: [event],\n      error: originalError,\n      event: event.type,\n      name: 'Error',\n      pluginName: this.name,\n    });\n  }\n\n  private getSymbolFilePath(symbol: Symbol): string | undefined {\n    const hooks = [\n      this.config['~hooks']?.symbols,\n      this.context.config.parser.hooks.symbols,\n    ];\n    for (const hook of hooks) {\n      const result = hook?.getFilePath?.(symbol);\n      if (result !== undefined) return result;\n    }\n    return defaultGetFilePath(symbol);\n  }\n\n  private isOperationKind(\n    operation: IR.OperationObject,\n    kind: 'mutation' | 'query',\n  ): boolean {\n    const method = kind === 'query' ? 'isQuery' : 'isMutation';\n    const hooks = [\n      this.config['~hooks']?.operations?.[method],\n      this.config['~hooks']?.operations?.getKind,\n      this.context.config.parser.hooks.operations?.[method],\n      this.context.config.parser.hooks.operations?.getKind,\n      defaultGetKind,\n    ];\n    for (const hook of hooks) {\n      if (hook) {\n        const result = hook(operation);\n        if (result !== undefined) {\n          return typeof result === 'boolean' ? result : result.includes(kind);\n        }\n      }\n    }\n    return false;\n  }\n}\n","import { Project } from '@hey-api/codegen-core';\n\nimport type { Package } from '~/config/utils/package';\nimport { packageFactory } from '~/config/utils/package';\nimport { TypeScriptRenderer } from '~/generate/renderer';\nimport type { Graph } from '~/graph';\nimport { buildName } from '~/openApi/shared/utils/name';\nimport type { PluginConfigMap } from '~/plugins/config';\nimport { PluginInstance } from '~/plugins/shared/utils/instance';\nimport type { PluginNames } from '~/plugins/types';\nimport type { Config } from '~/types/config';\nimport type { Logger } from '~/utils/logger';\nimport { resolveRef } from '~/utils/ref';\n\nimport type { IR } from './types';\n\nexport class Context<Spec extends Record<string, any> = any> {\n  /**\n   * Configuration for parsing and generating the output. This\n   * is a mix of user-provided and default values.\n   */\n  config: Config;\n  /**\n   * The code generation project instance used to manage files, symbols,\n   */\n  gen: Project;\n  /**\n   * The dependency graph built from the intermediate representation.\n   */\n  graph: Graph | undefined;\n  /**\n   * Intermediate representation model obtained from `spec`.\n   */\n  ir: IR.Model = {};\n  /**\n   * Logger instance.\n   */\n  logger: Logger;\n  /**\n   * The package metadata and utilities for the current context, constructed\n   * from the provided dependencies. Used for managing package-related\n   * information such as name, version, and dependency resolution during\n   * code generation.\n   */\n  package: Package;\n  /**\n   * A map of registered plugin instances, keyed by plugin name. Plugins are\n   * registered through the `registerPlugin` method and can be accessed by\n   * their configured name from the config.\n   */\n  plugins: Partial<\n    Record<PluginNames, PluginInstance<PluginConfigMap[keyof PluginConfigMap]>>\n  > = {};\n  /**\n   * Resolved specification from `input`.\n   */\n  spec: Spec;\n\n  constructor({\n    config,\n    dependencies,\n    logger,\n    spec,\n  }: {\n    config: Config;\n    dependencies: Record<string, string>;\n    logger: Logger;\n    spec: Spec;\n  }) {\n    this.config = config;\n    this.gen = new Project({\n      defaultFileName: 'index',\n      fileName: (base) => {\n        const name = buildName({\n          config: config.output.fileName,\n          name: base,\n        });\n        const { suffix } = config.output.fileName;\n        if (!suffix) {\n          return name;\n        }\n        return name === 'index' || name.endsWith(suffix)\n          ? name\n          : `${name}${suffix}`;\n      },\n      renderers: {\n        // TODO: allow overriding via config with custom renderers\n        '.ts': new TypeScriptRenderer(),\n      },\n      root: config.output.path,\n    });\n    this.logger = logger;\n    this.package = packageFactory(dependencies);\n    this.spec = spec;\n  }\n\n  /**\n   * Returns a resolved and dereferenced schema from `spec`.\n   */\n  dereference<T>(schema: { $ref: string }) {\n    const resolved = this.resolveRef<T>(schema.$ref);\n    const dereferenced = {\n      ...schema,\n      ...resolved,\n    } as T;\n    // @ts-expect-error\n    delete dereferenced.$ref;\n    return dereferenced;\n  }\n\n  /**\n   * Registers a new plugin to the global context.\n   *\n   * @param name Plugin name.\n   * @returns Registered plugin instance.\n   */\n  private registerPlugin<T extends PluginNames>(\n    name: T,\n  ): PluginInstance<PluginConfigMap[T]> {\n    const plugin = this.config.plugins[name]!;\n    const instance = new PluginInstance({\n      api: plugin.api,\n      config: plugin.config as any,\n      context: this as any,\n      dependencies: plugin.dependencies ?? [],\n      gen: this.gen,\n      handler: plugin.handler,\n      name: plugin.name,\n      output: plugin.output as string,\n    });\n    this.plugins[instance.name] = instance;\n    return instance;\n  }\n\n  /**\n   * Registers all plugins in the order specified by the configuration and returns\n   * an array of the registered PluginInstance objects. Each plugin is instantiated\n   * and added to the context's plugins map.\n   *\n   * @returns {ReadonlyArray<PluginInstance>} An array of registered plugin instances in order.\n   */\n  registerPlugins(): ReadonlyArray<PluginInstance> {\n    return this.config.pluginOrder.map((name) => this.registerPlugin(name));\n  }\n\n  // TODO: parser - works the same as resolveRef, but for IR schemas.\n  // for now, they map 1:1, but if they diverge (like with OpenAPI 2.0),\n  // we will want to rewrite $refs at parse time, so they continue pointing\n  // to the correct IR location\n  resolveIrRef<T>($ref: string) {\n    return resolveRef<T>({\n      $ref,\n      spec: this.ir,\n    });\n  }\n\n  /**\n   * Returns a resolved reference from `spec`.\n   */\n  resolveRef<T>($ref: string) {\n    return resolveRef<T>({\n      $ref,\n      spec: this.spec,\n    });\n  }\n}\n","import { illegalStartCharactersRegExp } from '~/utils/regexp';\n\nexport const ensureValidTypeScriptJavaScriptIdentifier = (name: string) => {\n  const replaced = name.replace(/[^$\\u200c\\u200d\\p{ID_Continue}]/gu, '_');\n  illegalStartCharactersRegExp.lastIndex = 0;\n  const startsWithIllegalCharacter =\n    illegalStartCharactersRegExp.test(replaced);\n  const valid = startsWithIllegalCharacter ? `_${replaced}` : replaced;\n  return valid;\n};\n\n/**\n * Sanitizes namespace identifiers so they are valid TypeScript identifiers of a certain form.\n *\n * 1: Remove any leading characters that are illegal as starting character of a typescript identifier.\n * 2: Replace illegal characters in remaining part of type name with hyphen (-).\n *\n * Step 1 should perhaps instead also replace illegal characters with underscore, or prefix with it, like sanitizeEnumName\n * does. The way this is now one could perhaps end up removing all characters, if all are illegal start characters. It\n * would be sort of a breaking change to do so, though, previously generated code might change then.\n *\n * JavaScript identifier regexp pattern retrieved from https://developer.mozilla.org/docs/Web/JavaScript/Reference/Lexical_grammar#identifiers\n *\n * The output of this is expected to be converted to PascalCase\n */\nexport const sanitizeNamespaceIdentifier = (name: string) =>\n  name\n    .replace(/^[^\\p{ID_Start}]+/u, '')\n    .replace(/[^$\\u200c\\u200d\\p{ID_Continue}]/gu, '-')\n    .replace(/[$+]/g, '-');\n\nexport const sanitizeOperationParameterName = (name: string) => {\n  const withoutBrackets = name.replace('[]', 'Array');\n  return sanitizeNamespaceIdentifier(withoutBrackets);\n};\n","import { createOperationKey } from '~/ir/operation';\nimport type { IR } from '~/ir/types';\nimport { sanitizeNamespaceIdentifier } from '~/openApi/common/parser/sanitize';\nimport { stringCase } from '~/utils/stringCase';\n\nimport type { State } from '../types/state';\n\nexport const httpMethods = [\n  'delete',\n  'get',\n  'head',\n  'options',\n  'patch',\n  'post',\n  'put',\n  'trace',\n] as const;\n\n/**\n * Returns an operation ID to use across the application. By default, we try\n * to use the provided ID. If it's not provided or the SDK is configured\n * to exclude it, we generate operation ID from its location.\n */\nexport const operationToId = ({\n  context,\n  count = 1,\n  id,\n  method,\n  path,\n  state,\n}: {\n  context: IR.Context;\n  count?: number;\n  id: string | undefined;\n  method: string;\n  path: string;\n  state: Pick<State, 'ids'>;\n}): string => {\n  let result: string;\n\n  const { output } = context.config;\n  const targetCase =\n    (output !== undefined && typeof output === 'object' && 'case' in output\n      ? output.case\n      : undefined) ?? 'camelCase';\n\n  if (\n    id &&\n    (!context.config.plugins['@hey-api/sdk'] ||\n      context.config.plugins['@hey-api/sdk'].config.operationId)\n  ) {\n    result = stringCase({\n      case: targetCase,\n      value: sanitizeNamespaceIdentifier(id),\n    });\n  } else {\n    const pathWithoutPlaceholders = path\n      .replace(/{(.*?)}/g, 'by-$1')\n      // replace slashes with hyphens for camelcase method at the end\n      .replace(/[/:+]/g, '-');\n\n    result = stringCase({\n      case: targetCase,\n      value: `${method}-${pathWithoutPlaceholders}`,\n    });\n  }\n\n  if (count > 1) {\n    result = `${result}${count}`;\n  }\n\n  if (state.ids.has(result)) {\n    return operationToId({\n      context,\n      count: count + 1,\n      id,\n      method,\n      path,\n      state,\n    });\n  }\n\n  state.ids.set(result, createOperationKey({ method, path }));\n\n  return result;\n};\n","import { createOperationKey } from '~/ir/operation';\nimport type { PathItemObject, PathsObject } from '~/openApi/3.1.x/types/spec';\nimport type { OpenApi } from '~/openApi/types';\nimport type { Logger } from '~/utils/logger';\n\nimport type { Config } from '../../../types/config';\nimport type { ResourceMetadata } from '../graph/meta';\nimport { httpMethods } from './operation';\n\ntype FilterNamespace =\n  | 'body'\n  | 'operation'\n  | 'parameter'\n  | 'response'\n  | 'schema'\n  | 'unknown';\n\nconst namespaceNeedle = '/';\n\nexport const addNamespace = (\n  namespace: FilterNamespace,\n  value: string = '',\n): string => `${namespace}${namespaceNeedle}${value}`;\n\nexport const removeNamespace = (\n  key: string,\n): {\n  name: string;\n  namespace: FilterNamespace;\n} => {\n  const index = key.indexOf(namespaceNeedle);\n  const name = key.slice(index + 1);\n  return {\n    name,\n    namespace: key.slice(0, index)! as FilterNamespace,\n  };\n};\n\n/**\n * Converts reference strings from OpenAPI $ref keywords into namespaces.\n *\n * @example '#/components/schemas/Foo' -> 'schema'\n */\nexport const stringToNamespace = (value: string): FilterNamespace => {\n  switch (value) {\n    case 'parameters':\n      return 'parameter';\n    case 'requestBodies':\n      return 'body';\n    case 'responses':\n      return 'response';\n    case 'definitions':\n    case 'schemas':\n      return 'schema';\n    default:\n      return 'unknown';\n  }\n};\n\ntype FiltersConfigToState<T> = {\n  [K in keyof T]-?: NonNullable<T[K]> extends ReadonlyArray<infer U>\n    ? Set<U>\n    : NonNullable<T[K]> extends object\n      ? FiltersConfigToState<NonNullable<T[K]>>\n      : T[K];\n};\n\nexport type Filters = FiltersConfigToState<\n  NonNullable<Config['parser']['filters']>\n>;\n\ninterface SetAndRegExps {\n  regexps: Array<RegExp>;\n  set: Set<string>;\n}\n\nconst createFiltersSetAndRegExps = (\n  type: FilterNamespace,\n  filters: ReadonlyArray<string> | undefined,\n): SetAndRegExps => {\n  const keys: Array<string> = [];\n  const regexps: Array<RegExp> = [];\n  if (filters) {\n    for (const value of filters) {\n      if (value.startsWith('/') && value.endsWith('/')) {\n        regexps.push(new RegExp(value.slice(1, value.length - 1)));\n      } else {\n        keys.push(addNamespace(type, value));\n      }\n    }\n  }\n  return {\n    regexps,\n    set: new Set(keys),\n  };\n};\n\ninterface CollectFiltersSetFromRegExps {\n  excludeOperations: SetAndRegExps;\n  excludeParameters: SetAndRegExps;\n  excludeRequestBodies: SetAndRegExps;\n  excludeResponses: SetAndRegExps;\n  excludeSchemas: SetAndRegExps;\n  includeOperations: SetAndRegExps;\n  includeParameters: SetAndRegExps;\n  includeRequestBodies: SetAndRegExps;\n  includeResponses: SetAndRegExps;\n  includeSchemas: SetAndRegExps;\n}\n\nconst collectFiltersSetFromRegExpsOpenApiV2 = ({\n  excludeOperations,\n  excludeSchemas,\n  includeOperations,\n  includeSchemas,\n  spec,\n}: CollectFiltersSetFromRegExps & {\n  spec: OpenApi.V2_0_X;\n}) => {\n  if (\n    (excludeOperations.regexps.length || includeOperations.regexps.length) &&\n    spec.paths\n  ) {\n    for (const entry of Object.entries(spec.paths)) {\n      const path = entry[0] as keyof PathsObject;\n      const pathItem = entry[1] as PathItemObject;\n      for (const method of httpMethods) {\n        const operation = pathItem[method];\n        if (!operation) {\n          continue;\n        }\n\n        const key = createOperationKey({ method, path });\n        if (excludeOperations.regexps.some((regexp) => regexp.test(key))) {\n          excludeOperations.set.add(addNamespace('operation', key));\n        }\n        if (includeOperations.regexps.some((regexp) => regexp.test(key))) {\n          includeOperations.set.add(addNamespace('operation', key));\n        }\n      }\n    }\n  }\n\n  if (spec.definitions) {\n    // TODO: add parameters\n\n    if (excludeSchemas.regexps.length || includeSchemas.regexps.length) {\n      for (const key of Object.keys(spec.definitions)) {\n        if (excludeSchemas.regexps.some((regexp) => regexp.test(key))) {\n          excludeSchemas.set.add(addNamespace('schema', key));\n        }\n        if (includeSchemas.regexps.some((regexp) => regexp.test(key))) {\n          includeSchemas.set.add(addNamespace('schema', key));\n        }\n      }\n    }\n  }\n};\n\nconst collectFiltersSetFromRegExpsOpenApiV3 = ({\n  excludeOperations,\n  excludeParameters,\n  excludeRequestBodies,\n  excludeResponses,\n  excludeSchemas,\n  includeOperations,\n  includeParameters,\n  includeRequestBodies,\n  includeResponses,\n  includeSchemas,\n  spec,\n}: CollectFiltersSetFromRegExps & {\n  spec: OpenApi.V3_0_X | OpenApi.V3_1_X;\n}) => {\n  if (\n    (excludeOperations.regexps.length || includeOperations.regexps.length) &&\n    spec.paths\n  ) {\n    for (const entry of Object.entries(spec.paths)) {\n      const path = entry[0] as keyof PathsObject;\n      const pathItem = entry[1] as PathItemObject;\n      for (const method of httpMethods) {\n        const operation = pathItem[method];\n        if (!operation) {\n          continue;\n        }\n\n        const key = createOperationKey({ method, path });\n        if (excludeOperations.regexps.some((regexp) => regexp.test(key))) {\n          excludeOperations.set.add(addNamespace('operation', key));\n        }\n        if (includeOperations.regexps.some((regexp) => regexp.test(key))) {\n          includeOperations.set.add(addNamespace('operation', key));\n        }\n      }\n    }\n  }\n\n  if (spec.components) {\n    if (\n      (excludeParameters.regexps.length || includeParameters.regexps.length) &&\n      spec.components.parameters\n    ) {\n      for (const key of Object.keys(spec.components.parameters)) {\n        if (excludeParameters.regexps.some((regexp) => regexp.test(key))) {\n          excludeParameters.set.add(addNamespace('parameter', key));\n        }\n        if (includeParameters.regexps.some((regexp) => regexp.test(key))) {\n          includeParameters.set.add(addNamespace('parameter', key));\n        }\n      }\n    }\n\n    if (\n      (excludeRequestBodies.regexps.length ||\n        includeRequestBodies.regexps.length) &&\n      spec.components.requestBodies\n    ) {\n      for (const key of Object.keys(spec.components.requestBodies)) {\n        if (excludeRequestBodies.regexps.some((regexp) => regexp.test(key))) {\n          excludeRequestBodies.set.add(addNamespace('body', key));\n        }\n        if (includeRequestBodies.regexps.some((regexp) => regexp.test(key))) {\n          includeRequestBodies.set.add(addNamespace('body', key));\n        }\n      }\n    }\n\n    if (\n      (excludeResponses.regexps.length || includeResponses.regexps.length) &&\n      spec.components.responses\n    ) {\n      for (const key of Object.keys(spec.components.responses)) {\n        if (excludeResponses.regexps.some((regexp) => regexp.test(key))) {\n          excludeResponses.set.add(addNamespace('response', key));\n        }\n        if (includeResponses.regexps.some((regexp) => regexp.test(key))) {\n          includeResponses.set.add(addNamespace('response', key));\n        }\n      }\n    }\n\n    if (\n      (excludeSchemas.regexps.length || includeSchemas.regexps.length) &&\n      spec.components.schemas\n    ) {\n      for (const key of Object.keys(spec.components.schemas)) {\n        if (excludeSchemas.regexps.some((regexp) => regexp.test(key))) {\n          excludeSchemas.set.add(addNamespace('schema', key));\n        }\n        if (includeSchemas.regexps.some((regexp) => regexp.test(key))) {\n          includeSchemas.set.add(addNamespace('schema', key));\n        }\n      }\n    }\n  }\n};\n\nconst collectFiltersSetFromRegExps = ({\n  spec,\n  ...filters\n}: CollectFiltersSetFromRegExps & {\n  spec: OpenApi.V2_0_X | OpenApi.V3_0_X | OpenApi.V3_1_X;\n}): void => {\n  if ('swagger' in spec) {\n    collectFiltersSetFromRegExpsOpenApiV2({ ...filters, spec });\n  } else {\n    collectFiltersSetFromRegExpsOpenApiV3({ ...filters, spec });\n  }\n};\n\nexport const createFilters = (\n  config: Config['parser']['filters'],\n  spec: OpenApi.V2_0_X | OpenApi.V3_0_X | OpenApi.V3_1_X,\n  logger: Logger,\n): Filters => {\n  const eventCreateFilters = logger.timeEvent('create-filters');\n  const excludeOperations = createFiltersSetAndRegExps(\n    'operation',\n    config?.operations?.exclude,\n  );\n  const includeOperations = createFiltersSetAndRegExps(\n    'operation',\n    config?.operations?.include,\n  );\n  const excludeParameters = createFiltersSetAndRegExps(\n    'parameter',\n    config?.parameters?.exclude,\n  );\n  const includeParameters = createFiltersSetAndRegExps(\n    'parameter',\n    config?.parameters?.include,\n  );\n  const excludeRequestBodies = createFiltersSetAndRegExps(\n    'body',\n    config?.requestBodies?.exclude,\n  );\n  const includeRequestBodies = createFiltersSetAndRegExps(\n    'body',\n    config?.requestBodies?.include,\n  );\n  const excludeResponses = createFiltersSetAndRegExps(\n    'response',\n    config?.responses?.exclude,\n  );\n  const includeResponses = createFiltersSetAndRegExps(\n    'response',\n    config?.responses?.include,\n  );\n  const excludeSchemas = createFiltersSetAndRegExps(\n    'schema',\n    config?.schemas?.exclude,\n  );\n  const includeSchemas = createFiltersSetAndRegExps(\n    'schema',\n    config?.schemas?.include,\n  );\n\n  collectFiltersSetFromRegExps({\n    excludeOperations,\n    excludeParameters,\n    excludeRequestBodies,\n    excludeResponses,\n    excludeSchemas,\n    includeOperations,\n    includeParameters,\n    includeRequestBodies,\n    includeResponses,\n    includeSchemas,\n    spec,\n  });\n\n  const filters: Filters = {\n    deprecated: config?.deprecated ?? true,\n    operations: {\n      exclude: excludeOperations.set,\n      include: includeOperations.set,\n    },\n    orphans: config?.orphans ?? false,\n    parameters: {\n      exclude: excludeParameters.set,\n      include: includeParameters.set,\n    },\n    preserveOrder: config?.preserveOrder ?? false,\n    requestBodies: {\n      exclude: excludeRequestBodies.set,\n      include: includeRequestBodies.set,\n    },\n    responses: {\n      exclude: excludeResponses.set,\n      include: includeResponses.set,\n    },\n    schemas: {\n      exclude: excludeSchemas.set,\n      include: includeSchemas.set,\n    },\n    tags: {\n      exclude: new Set(config?.tags?.exclude),\n      include: new Set(config?.tags?.include),\n    },\n  };\n  eventCreateFilters.timeEnd();\n  return filters;\n};\n\nexport const hasFilters = (config: Config['parser']['filters']): boolean => {\n  if (!config) {\n    return false;\n  }\n\n  // we explicitly want to strip orphans or deprecated\n  if (config.orphans === false || config.deprecated === false) {\n    return true;\n  }\n\n  return Boolean(\n    config.operations?.exclude?.length ||\n      config.operations?.include?.length ||\n      config.parameters?.exclude?.length ||\n      config.parameters?.include?.length ||\n      config.requestBodies?.exclude?.length ||\n      config.requestBodies?.include?.length ||\n      config.responses?.exclude?.length ||\n      config.responses?.include?.length ||\n      config.schemas?.exclude?.length ||\n      config.schemas?.include?.length ||\n      config.tags?.exclude?.length ||\n      config.tags?.include?.length,\n  );\n};\n\n/**\n * Collect operations that satisfy the include/exclude filters and schema dependencies.\n */\nconst collectOperations = ({\n  filters,\n  parameters,\n  requestBodies,\n  resourceMetadata,\n  responses,\n  schemas,\n}: {\n  filters: Filters;\n  parameters: Set<string>;\n  requestBodies: Set<string>;\n  resourceMetadata: ResourceMetadata;\n  responses: Set<string>;\n  schemas: Set<string>;\n}): {\n  operations: Set<string>;\n} => {\n  const finalSet = new Set<string>();\n  const initialSet = filters.operations.include.size\n    ? filters.operations.include\n    : new Set(resourceMetadata.operations.keys());\n  const stack = [...initialSet];\n  while (stack.length) {\n    const key = stack.pop()!;\n\n    if (filters.operations.exclude.has(key) || finalSet.has(key)) {\n      continue;\n    }\n\n    const node = resourceMetadata.operations.get(key);\n\n    if (!node) {\n      continue;\n    }\n\n    if (!filters.deprecated && node.deprecated) {\n      continue;\n    }\n\n    if (\n      filters.tags.exclude.size &&\n      node.tags.size &&\n      [...filters.tags.exclude].some((tag) => node.tags.has(tag))\n    ) {\n      continue;\n    }\n\n    if (\n      filters.tags.include.size &&\n      !new Set([...filters.tags.include].filter((tag) => node.tags.has(tag)))\n        .size\n    ) {\n      continue;\n    }\n\n    // skip operation if it references any component not included\n    if (\n      [...node.dependencies].some((dependency) => {\n        const { namespace } = removeNamespace(dependency);\n        switch (namespace) {\n          case 'body':\n            return !requestBodies.has(dependency);\n          case 'parameter':\n            return !parameters.has(dependency);\n          case 'response':\n            return !responses.has(dependency);\n          case 'schema':\n            return !schemas.has(dependency);\n          default:\n            return false;\n        }\n      })\n    ) {\n      continue;\n    }\n\n    finalSet.add(key);\n  }\n  return { operations: finalSet };\n};\n\n/**\n * Collect parameters that satisfy the include/exclude filters and schema dependencies.\n */\nconst collectParameters = ({\n  filters,\n  resourceMetadata,\n  schemas,\n}: {\n  filters: Filters;\n  resourceMetadata: ResourceMetadata;\n  schemas: Set<string>;\n}): {\n  parameters: Set<string>;\n} => {\n  const finalSet = new Set<string>();\n  const initialSet = filters.parameters.include.size\n    ? filters.parameters.include\n    : new Set(resourceMetadata.parameters.keys());\n  const stack = [...initialSet];\n  while (stack.length) {\n    const key = stack.pop()!;\n\n    if (filters.parameters.exclude.has(key) || finalSet.has(key)) {\n      continue;\n    }\n\n    const node = resourceMetadata.parameters.get(key);\n\n    if (!node) {\n      continue;\n    }\n\n    if (!filters.deprecated && node.deprecated) {\n      continue;\n    }\n\n    finalSet.add(key);\n\n    if (!node.dependencies.size) {\n      continue;\n    }\n\n    for (const dependency of node.dependencies) {\n      const { namespace } = removeNamespace(dependency);\n      switch (namespace) {\n        case 'body': {\n          if (filters.requestBodies.exclude.has(dependency)) {\n            finalSet.delete(key);\n          } else if (!finalSet.has(dependency)) {\n            stack.push(dependency);\n          }\n          break;\n        }\n        case 'schema': {\n          if (filters.schemas.exclude.has(dependency)) {\n            finalSet.delete(key);\n          } else if (!schemas.has(dependency)) {\n            schemas.add(dependency);\n          }\n          break;\n        }\n      }\n    }\n  }\n  return { parameters: finalSet };\n};\n\n/**\n * Collect request bodies that satisfy the include/exclude filters and schema dependencies.\n */\nconst collectRequestBodies = ({\n  filters,\n  resourceMetadata,\n  schemas,\n}: {\n  filters: Filters;\n  resourceMetadata: ResourceMetadata;\n  schemas: Set<string>;\n}): {\n  requestBodies: Set<string>;\n} => {\n  const finalSet = new Set<string>();\n  const initialSet = filters.requestBodies.include.size\n    ? filters.requestBodies.include\n    : new Set(resourceMetadata.requestBodies.keys());\n  const stack = [...initialSet];\n  while (stack.length) {\n    const key = stack.pop()!;\n\n    if (filters.requestBodies.exclude.has(key) || finalSet.has(key)) {\n      continue;\n    }\n\n    const node = resourceMetadata.requestBodies.get(key);\n\n    if (!node) {\n      continue;\n    }\n\n    if (!filters.deprecated && node.deprecated) {\n      continue;\n    }\n\n    finalSet.add(key);\n\n    if (!node.dependencies.size) {\n      continue;\n    }\n\n    for (const dependency of node.dependencies) {\n      const { namespace } = removeNamespace(dependency);\n      switch (namespace) {\n        case 'body': {\n          if (filters.requestBodies.exclude.has(dependency)) {\n            finalSet.delete(key);\n          } else if (!finalSet.has(dependency)) {\n            stack.push(dependency);\n          }\n          break;\n        }\n        case 'schema': {\n          if (filters.schemas.exclude.has(dependency)) {\n            finalSet.delete(key);\n          } else if (!schemas.has(dependency)) {\n            schemas.add(dependency);\n          }\n          break;\n        }\n      }\n    }\n  }\n  return { requestBodies: finalSet };\n};\n\n/**\n * Collect responses that satisfy the include/exclude filters and schema dependencies.\n */\nconst collectResponses = ({\n  filters,\n  resourceMetadata,\n  schemas,\n}: {\n  filters: Filters;\n  resourceMetadata: ResourceMetadata;\n  schemas: Set<string>;\n}): {\n  responses: Set<string>;\n} => {\n  const finalSet = new Set<string>();\n  const initialSet = filters.responses.include.size\n    ? filters.responses.include\n    : new Set(resourceMetadata.responses.keys());\n  const stack = [...initialSet];\n  while (stack.length) {\n    const key = stack.pop()!;\n\n    if (filters.responses.exclude.has(key) || finalSet.has(key)) {\n      continue;\n    }\n\n    const node = resourceMetadata.responses.get(key);\n\n    if (!node) {\n      continue;\n    }\n\n    if (!filters.deprecated && node.deprecated) {\n      continue;\n    }\n\n    finalSet.add(key);\n\n    if (!node.dependencies.size) {\n      continue;\n    }\n\n    for (const dependency of node.dependencies) {\n      const { namespace } = removeNamespace(dependency);\n      switch (namespace) {\n        case 'body': {\n          if (filters.requestBodies.exclude.has(dependency)) {\n            finalSet.delete(key);\n          } else if (!finalSet.has(dependency)) {\n            stack.push(dependency);\n          }\n          break;\n        }\n        case 'schema': {\n          if (filters.schemas.exclude.has(dependency)) {\n            finalSet.delete(key);\n          } else if (!schemas.has(dependency)) {\n            schemas.add(dependency);\n          }\n          break;\n        }\n      }\n    }\n  }\n  return { responses: finalSet };\n};\n\n/**\n * Collect schemas that satisfy the include/exclude filters.\n */\nconst collectSchemas = ({\n  filters,\n  resourceMetadata,\n}: {\n  filters: Filters;\n  resourceMetadata: ResourceMetadata;\n}): {\n  schemas: Set<string>;\n} => {\n  const finalSet = new Set<string>();\n  const initialSet = filters.schemas.include.size\n    ? filters.schemas.include\n    : new Set(resourceMetadata.schemas.keys());\n  const stack = [...initialSet];\n  while (stack.length) {\n    const key = stack.pop()!;\n\n    if (filters.schemas.exclude.has(key) || finalSet.has(key)) {\n      continue;\n    }\n\n    const node = resourceMetadata.schemas.get(key);\n\n    if (!node) {\n      continue;\n    }\n\n    if (!filters.deprecated && node.deprecated) {\n      continue;\n    }\n\n    finalSet.add(key);\n\n    if (!node.dependencies.size) {\n      continue;\n    }\n\n    for (const dependency of node.dependencies) {\n      const { namespace } = removeNamespace(dependency);\n      switch (namespace) {\n        case 'schema': {\n          if (\n            !finalSet.has(dependency) &&\n            !filters.schemas.exclude.has(dependency)\n          ) {\n            stack.push(dependency);\n          }\n          break;\n        }\n      }\n    }\n  }\n  return { schemas: finalSet };\n};\n\n/**\n * Drop parameters that depend on already excluded parameters.\n */\nconst dropExcludedParameters = ({\n  filters,\n  parameters,\n  resourceMetadata,\n}: {\n  filters: Filters;\n  parameters: Set<string>;\n  resourceMetadata: ResourceMetadata;\n}): void => {\n  if (!filters.parameters.exclude.size) {\n    return;\n  }\n\n  for (const key of parameters) {\n    const node = resourceMetadata.parameters.get(key);\n\n    if (!node?.dependencies.size) {\n      continue;\n    }\n\n    for (const excludedKey of filters.parameters.exclude) {\n      if (node.dependencies.has(excludedKey)) {\n        parameters.delete(key);\n        break;\n      }\n    }\n  }\n};\n\n/**\n * Drop request bodies that depend on already excluded request bodies.\n */\nconst dropExcludedRequestBodies = ({\n  filters,\n  requestBodies,\n  resourceMetadata,\n}: {\n  filters: Filters;\n  requestBodies: Set<string>;\n  resourceMetadata: ResourceMetadata;\n}): void => {\n  if (!filters.requestBodies.exclude.size) {\n    return;\n  }\n\n  for (const key of requestBodies) {\n    const node = resourceMetadata.requestBodies.get(key);\n\n    if (!node?.dependencies.size) {\n      continue;\n    }\n\n    for (const excludedKey of filters.requestBodies.exclude) {\n      if (node.dependencies.has(excludedKey)) {\n        requestBodies.delete(key);\n        break;\n      }\n    }\n  }\n};\n\n/**\n * Drop responses that depend on already excluded responses.\n */\nconst dropExcludedResponses = ({\n  filters,\n  resourceMetadata,\n  responses,\n}: {\n  filters: Filters;\n  resourceMetadata: ResourceMetadata;\n  responses: Set<string>;\n}): void => {\n  if (!filters.responses.exclude.size) {\n    return;\n  }\n\n  for (const key of responses) {\n    const node = resourceMetadata.responses.get(key);\n\n    if (!node?.dependencies.size) {\n      continue;\n    }\n\n    for (const excludedKey of filters.responses.exclude) {\n      if (node.dependencies.has(excludedKey)) {\n        responses.delete(key);\n        break;\n      }\n    }\n  }\n};\n\n/**\n * Drop schemas that depend on already excluded schemas.\n */\nconst dropExcludedSchemas = ({\n  filters,\n  resourceMetadata,\n  schemas,\n}: {\n  filters: Filters;\n  resourceMetadata: ResourceMetadata;\n  schemas: Set<string>;\n}): void => {\n  if (!filters.schemas.exclude.size) {\n    return;\n  }\n\n  for (const key of schemas) {\n    const node = resourceMetadata.schemas.get(key);\n\n    if (!node?.dependencies.size) {\n      continue;\n    }\n\n    for (const excludedKey of filters.schemas.exclude) {\n      if (node.dependencies.has(excludedKey)) {\n        schemas.delete(key);\n        break;\n      }\n    }\n  }\n};\n\nconst dropOrphans = ({\n  operationDependencies,\n  parameters,\n  requestBodies,\n  responses,\n  schemas,\n}: {\n  operationDependencies: Set<string>;\n  parameters: Set<string>;\n  requestBodies: Set<string>;\n  responses: Set<string>;\n  schemas: Set<string>;\n}) => {\n  for (const key of schemas) {\n    if (!operationDependencies.has(key)) {\n      schemas.delete(key);\n    }\n  }\n  for (const key of parameters) {\n    if (!operationDependencies.has(key)) {\n      parameters.delete(key);\n    }\n  }\n  for (const key of requestBodies) {\n    if (!operationDependencies.has(key)) {\n      requestBodies.delete(key);\n    }\n  }\n  for (const key of responses) {\n    if (!operationDependencies.has(key)) {\n      responses.delete(key);\n    }\n  }\n};\n\nconst collectOperationDependencies = ({\n  operations,\n  resourceMetadata,\n}: {\n  operations: Set<string>;\n  resourceMetadata: ResourceMetadata;\n}): {\n  operationDependencies: Set<string>;\n} => {\n  const finalSet = new Set<string>();\n  const initialSet = new Set(\n    [...operations].flatMap((key) => [\n      ...(resourceMetadata.operations.get(key)?.dependencies ?? []),\n    ]),\n  );\n  const stack = [...initialSet];\n  while (stack.length) {\n    const key = stack.pop()!;\n\n    if (finalSet.has(key)) {\n      continue;\n    }\n\n    finalSet.add(key);\n\n    const { namespace } = removeNamespace(key);\n    let dependencies: Set<string> | undefined;\n    if (namespace === 'body') {\n      dependencies = resourceMetadata.requestBodies.get(key)?.dependencies;\n    } else if (namespace === 'operation') {\n      dependencies = resourceMetadata.operations.get(key)?.dependencies;\n    } else if (namespace === 'parameter') {\n      dependencies = resourceMetadata.parameters.get(key)?.dependencies;\n    } else if (namespace === 'response') {\n      dependencies = resourceMetadata.responses.get(key)?.dependencies;\n    } else if (namespace === 'schema') {\n      dependencies = resourceMetadata.schemas.get(key)?.dependencies;\n    }\n\n    if (!dependencies?.size) {\n      continue;\n    }\n\n    for (const dependency of dependencies) {\n      if (!finalSet.has(dependency)) {\n        stack.push(dependency);\n      }\n    }\n  }\n  return { operationDependencies: finalSet };\n};\n\nexport const createFilteredDependencies = ({\n  filters,\n  logger,\n  resourceMetadata,\n}: {\n  filters: Filters;\n  logger: Logger;\n  resourceMetadata: ResourceMetadata;\n}): {\n  operations: Set<string>;\n  parameters: Set<string>;\n  requestBodies: Set<string>;\n  responses: Set<string>;\n  schemas: Set<string>;\n} => {\n  const eventCreateFilteredDependencies = logger.timeEvent(\n    'create-filtered-dependencies',\n  );\n  const { schemas } = collectSchemas({ filters, resourceMetadata });\n  const { parameters } = collectParameters({\n    filters,\n    resourceMetadata,\n    schemas,\n  });\n  const { requestBodies } = collectRequestBodies({\n    filters,\n    resourceMetadata,\n    schemas,\n  });\n  const { responses } = collectResponses({\n    filters,\n    resourceMetadata,\n    schemas,\n  });\n\n  dropExcludedSchemas({ filters, resourceMetadata, schemas });\n  dropExcludedParameters({ filters, parameters, resourceMetadata });\n  dropExcludedRequestBodies({ filters, requestBodies, resourceMetadata });\n  dropExcludedResponses({ filters, resourceMetadata, responses });\n\n  // collect operations after dropping components\n  const { operations } = collectOperations({\n    filters,\n    parameters,\n    requestBodies,\n    resourceMetadata,\n    responses,\n    schemas,\n  });\n\n  if (!filters.orphans && operations.size) {\n    const { operationDependencies } = collectOperationDependencies({\n      operations,\n      resourceMetadata,\n    });\n    dropOrphans({\n      operationDependencies,\n      parameters,\n      requestBodies,\n      responses,\n      schemas,\n    });\n  }\n\n  eventCreateFilteredDependencies.timeEnd();\n  return {\n    operations,\n    parameters,\n    requestBodies,\n    responses,\n    schemas,\n  };\n};\n","import type { Graph } from '~/graph';\nimport { createOperationKey } from '~/ir/operation';\nimport type { Logger } from '~/utils/logger';\nimport { jsonPointerToPath } from '~/utils/ref';\n\nimport { addNamespace, stringToNamespace } from '../utils/filter';\nimport { httpMethods } from '../utils/operation';\n\nexport type ResourceMetadata = {\n  operations: Map<\n    string,\n    {\n      dependencies: Set<string>;\n      deprecated: boolean;\n      tags: Set<string>;\n    }\n  >;\n  parameters: Map<\n    string,\n    {\n      dependencies: Set<string>;\n      deprecated: boolean;\n    }\n  >;\n  requestBodies: Map<\n    string,\n    {\n      dependencies: Set<string>;\n      deprecated: boolean;\n    }\n  >;\n  responses: Map<\n    string,\n    {\n      dependencies: Set<string>;\n      deprecated: boolean;\n    }\n  >;\n  schemas: Map<\n    string,\n    {\n      dependencies: Set<string>;\n      deprecated: boolean;\n    }\n  >;\n};\n\n/**\n * Builds a resource metadata map from a Graph, matching the old Graph interface\n * for compatibility with filtering code.\n */\nexport const buildResourceMetadata = (\n  graph: Graph,\n  logger: Logger,\n): {\n  resourceMetadata: ResourceMetadata;\n} => {\n  const eventBuildResourceMetadata = logger.timeEvent(\n    'build-resource-metadata',\n  );\n  const resourceMetadata: ResourceMetadata = {\n    operations: new Map(),\n    parameters: new Map(),\n    requestBodies: new Map(),\n    responses: new Map(),\n    schemas: new Map(),\n  };\n\n  const getDependencies = (pointer: string): Set<string> => {\n    const dependencies = new Set<string>();\n    const nodeDependencies = graph.transitiveDependencies.get(pointer);\n    if (nodeDependencies?.size) {\n      for (const dependency of nodeDependencies) {\n        const path = jsonPointerToPath(dependency);\n        const type = path[path.length - 2];\n        const name = path[path.length - 1];\n        if (type && name) {\n          const namespace = stringToNamespace(type);\n          if (namespace === 'unknown') {\n            console.warn(`unsupported type: ${type}`);\n          }\n          dependencies.add(addNamespace(namespace, name));\n        }\n      }\n    }\n    return dependencies;\n  };\n\n  // Process each node to find top-level resources\n  for (const [pointer, nodeInfo] of graph.nodes) {\n    // const node = nodeInfo.node as Record<string, unknown>;\n    const path = jsonPointerToPath(pointer);\n\n    // OpenAPI 3.x\n    if (path[0] === 'components') {\n      if (path.length === 3) {\n        if (path[1] === 'schemas') {\n          // Schema: #/components/schemas/{name}\n          const name = path[path.length - 1]!;\n          resourceMetadata.schemas.set(addNamespace('schema', name), {\n            dependencies: getDependencies(pointer),\n            deprecated: nodeInfo.deprecated ?? false,\n          });\n        } else if (path[1] === 'parameters') {\n          // Parameter: #/components/parameters/{name}\n          const name = path[path.length - 1]!;\n          resourceMetadata.parameters.set(addNamespace('parameter', name), {\n            dependencies: getDependencies(pointer),\n            deprecated: nodeInfo.deprecated ?? false,\n          });\n        } else if (path[1] === 'requestBodies') {\n          // RequestBody: #/components/requestBodies/{name}\n          const name = path[path.length - 1]!;\n          resourceMetadata.requestBodies.set(addNamespace('body', name), {\n            dependencies: getDependencies(pointer),\n            deprecated: nodeInfo.deprecated ?? false,\n          });\n        } else if (path[1] === 'responses') {\n          // Response: #/components/responses/{name}\n          const name = path[path.length - 1]!;\n          resourceMetadata.responses.set(addNamespace('response', name), {\n            dependencies: getDependencies(pointer),\n            deprecated: nodeInfo.deprecated ?? false,\n          });\n        }\n      }\n      continue;\n    }\n\n    if (path[0] === 'paths') {\n      if (\n        path.length === 3 &&\n        httpMethods.includes(path[2] as (typeof httpMethods)[number])\n      ) {\n        // Operation: #/paths/{path}/{method}\n        const method = path[path.length - 1]!;\n        const operationPath = path.slice(1, -1).join('/');\n        const operationKey = createOperationKey({\n          method,\n          path: operationPath,\n        });\n        resourceMetadata.operations.set(\n          addNamespace('operation', operationKey),\n          {\n            dependencies: getDependencies(pointer),\n            deprecated: nodeInfo.deprecated ?? false,\n            tags: nodeInfo.tags ?? new Set(),\n          },\n        );\n      }\n      continue;\n    }\n\n    // OpenAPI 2.0\n    if (path[0] === 'definitions') {\n      if (path.length === 2) {\n        // Schema: #/definitions/{name}\n        const name = path[path.length - 1]!;\n        resourceMetadata.schemas.set(addNamespace('schema', name), {\n          dependencies: getDependencies(pointer),\n          deprecated: nodeInfo.deprecated ?? false,\n        });\n      }\n      continue;\n    }\n  }\n\n  eventBuildResourceMetadata.timeEnd();\n  return { resourceMetadata };\n};\n","export const deepClone = <T>(obj: T): T => JSON.parse(JSON.stringify(obj));\n","export const childSchemaRelationships = [\n  ['additionalProperties', 'single'],\n  ['allOf', 'array'],\n  ['anyOf', 'array'],\n  ['contains', 'single'],\n  ['dependentSchemas', 'objectMap'],\n  ['else', 'single'],\n  ['if', 'single'],\n  ['items', 'singleOrArray'],\n  ['oneOf', 'array'],\n  ['patternProperties', 'objectMap'],\n  ['properties', 'objectMap'],\n  ['propertyNames', 'single'],\n  ['then', 'single'],\n] as const;\n","export const getSchemasObject = (\n  spec: unknown,\n): Record<string, unknown> | undefined => {\n  if (hasComponentsSchemasObject(spec)) {\n    return (spec as any).components.schemas;\n  }\n  if (hasDefinitionsObject(spec)) {\n    return (spec as any).definitions;\n  }\n  return;\n};\n\n/**\n * Checks if the given spec has a valid OpenAPI 3.x components.schemas object.\n * Returns true if present, false otherwise.\n */\nexport const hasComponentsSchemasObject = (spec: unknown): boolean =>\n  typeof spec === 'object' &&\n  spec !== null &&\n  'components' in spec &&\n  typeof (spec as any).components === 'object' &&\n  (spec as any).components !== null &&\n  'schemas' in (spec as any).components &&\n  typeof (spec as any).components.schemas === 'object' &&\n  (spec as any).components.schemas !== null;\n\n/**\n * Checks if the given spec has a valid OpenAPI 2.0 definitions object.\n * Returns true if present, false otherwise.\n */\nexport const hasDefinitionsObject = (spec: unknown): boolean =>\n  typeof spec === 'object' &&\n  spec !== null &&\n  'definitions' in spec &&\n  typeof (spec as any).definitions === 'object' &&\n  (spec as any).definitions !== null;\n","type Obj =\n  | Record<string, unknown>\n  | Set<string>\n  | ReadonlyArray<string | undefined>;\n\nconst hasName = (obj: Obj, value: string): boolean => {\n  if (obj instanceof Set) {\n    return obj.has(value);\n  }\n  if (obj instanceof Array) {\n    return obj.includes(value);\n  }\n  return value in obj;\n};\n\nexport const getUniqueComponentName = ({\n  base,\n  components,\n  extraComponents,\n}: {\n  base: string;\n  /**\n   * Input components.\n   */\n  components: Obj;\n  /**\n   * Temporary input components, waiting to be inserted for example.\n   */\n  extraComponents?: Obj;\n}): string => {\n  let index = 2;\n  let name = base;\n  while (\n    hasName(components, name) ||\n    (extraComponents && hasName(extraComponents, name))\n  ) {\n    name = `${base}${index}`;\n    index += 1;\n  }\n  return name;\n};\n\nexport const isPathRootSchema = (path: ReadonlyArray<string | number>) =>\n  (path.length === 3 && path[0] === 'components' && path[1] === 'schemas') ||\n  (path.length === 2 && path[0] === 'definitions');\n\nexport const specToSchemasPointerNamespace = (spec: unknown): string => {\n  if (spec && typeof spec === 'object') {\n    if ('swagger' in spec) {\n      // #/definitions/SchemaName\n      return '#/definitions/';\n    }\n\n    if ('openapi' in spec) {\n      // #/components/schemas/SchemaName\n      return '#/components/schemas/';\n    }\n  }\n\n  return '';\n};\n","import { jsonPointerToPath } from '~/utils/ref';\n\nimport type { Config } from '../../../types/config';\nimport { buildName } from '../utils/name';\nimport { deepClone } from '../utils/schema';\nimport { childSchemaRelationships } from '../utils/schemaChildRelationships';\nimport { getSchemasObject } from '../utils/transforms';\nimport {\n  getUniqueComponentName,\n  isPathRootSchema,\n  specToSchemasPointerNamespace,\n} from './utils';\n\ntype EnumsConfig = Config['parser']['transforms']['enums'];\n\n/**\n * Generate a unique, structural signature for an enum schema for deduplication.\n * Only considers 'type' and sorted 'enum' values, ignoring other fields.\n *\n * @param schema - The schema object to analyze\n * @returns A string signature if the schema is an enum, otherwise undefined\n */\nconst getEnumSignature = (schema: unknown): string | undefined => {\n  if (\n    !schema ||\n    typeof schema !== 'object' ||\n    !('enum' in schema) ||\n    !(schema.enum instanceof Array)\n  ) {\n    return;\n  }\n  // Use type + sorted enum values for signature\n  const type = ('type' in schema ? schema.type : undefined) || '';\n  const values = [...schema.enum].sort();\n  return JSON.stringify({ type, values });\n};\n\ntype NodeInfo = {\n  key: string | number | null;\n  node: unknown;\n  parent: unknown;\n  path: ReadonlyArray<string | number>;\n};\n\n/**\n * Recursively walk all schemas in the OpenAPI spec, visiting every object/array\n * that could contain an enum. Calls the visitor with node info for each.\n *\n * @param key - The key of the current node\n * @param node - The current node\n * @param parent - The parent node\n * @param path - The path to the current node\n * @param visitor - Function to call for each visited node\n */\nconst walkSchemas = ({\n  key,\n  node,\n  parent,\n  path,\n  visitor,\n}: NodeInfo & {\n  visitor: (nodeInfo: NodeInfo) => void;\n}) => {\n  if (!node || typeof node !== 'object' || node instanceof Array) return;\n\n  const value = node as Record<string, unknown>;\n\n  if (\n    'type' in value ||\n    'enum' in value ||\n    childSchemaRelationships.some(([keyword]) => keyword in value)\n  ) {\n    visitor({ key, node, parent, path });\n  }\n\n  for (const [k, v] of Object.entries(value)) {\n    if (typeof v === 'object' && v !== null) {\n      if (v instanceof Array) {\n        v.forEach((item, index) =>\n          walkSchemas({\n            key: index,\n            node: item,\n            parent: v,\n            path: [...path, k, index],\n            visitor,\n          }),\n        );\n      } else {\n        walkSchemas({\n          key: k,\n          node: v,\n          parent: node,\n          path: [...path, k],\n          visitor,\n        });\n      }\n    }\n  }\n};\n\n/**\n * Inlines all root/top-level enums by replacing $refs to them with the actual enum schema,\n * and then removes the now-unreferenced root enums from the schemas object.\n *\n * @param spec - The OpenAPI spec object to transform\n */\nconst inlineMode = ({ spec }: { spec: unknown }) => {\n  const schemasObj = getSchemasObject(spec);\n  if (!schemasObj) {\n    return;\n  }\n\n  const schemasPointerNamespace = specToSchemasPointerNamespace(spec);\n\n  // Collect all root enums\n  const rootEnums: Record<string, unknown> = {};\n  for (const [name, schema] of Object.entries(schemasObj)) {\n    const signature = getEnumSignature(schema);\n    if (signature) {\n      rootEnums[`${schemasPointerNamespace}${name}`] = schema;\n    }\n  }\n\n  // Walk the spec and replace $refs to root enums with inline enum schemas\n  const replaceEnumRefs = (node: unknown) => {\n    if (node instanceof Array) {\n      node.forEach(replaceEnumRefs);\n    } else if (node && typeof node === 'object') {\n      for (const [k, v] of Object.entries(node)) {\n        if (k === '$ref' && typeof v === 'string' && v in rootEnums) {\n          // Replace $ref with a deep clone of the enum schema\n          Object.assign(node, deepClone(rootEnums[v]));\n          delete (node as Record<string, unknown>)['$ref'];\n        } else {\n          replaceEnumRefs(v);\n        }\n      }\n    }\n  };\n  replaceEnumRefs(spec);\n\n  // Remove unreferenced root enums\n  for (const pointer of Object.keys(rootEnums)) {\n    const path = jsonPointerToPath(pointer);\n    const name = path[path.length - 1]!;\n    if (name) {\n      delete schemasObj[name];\n    }\n  }\n};\n\n/**\n * Promotes all inline enums to reusable root components (if mode is 'root'),\n * deduplicates by signature, and replaces inline enums with $refs.\n *\n * Naming, casing, and deduplication are controlled by the enums transform config.\n * Existing root enums are reused if structurally identical.\n *\n * @param spec - The OpenAPI spec object to transform\n * @param config - The enums transform config\n */\nconst rootMode = ({ config, spec }: { config: EnumsConfig; spec: unknown }) => {\n  const schemasObj = getSchemasObject(spec);\n  if (!schemasObj) {\n    return;\n  }\n\n  // Build a map of existing root enum signatures to their names for deduplication\n  const rootEnumSignatures: Record<string, string> = {};\n  for (const [name, schema] of Object.entries(schemasObj)) {\n    const signature = getEnumSignature(schema);\n    if (signature) {\n      rootEnumSignatures[signature] = name;\n    }\n  }\n\n  // Collect all inline enums (not at root schemas)\n  const inlineEnums: Array<{\n    key: string | number | null;\n    node: unknown;\n    parent: unknown;\n    path: ReadonlyArray<string | number>;\n    signature: string;\n  }> = [];\n\n  walkSchemas({\n    key: null,\n    node: spec,\n    parent: null,\n    path: [],\n    visitor: (nodeInfo) => {\n      if (!isPathRootSchema(nodeInfo.path)) {\n        const signature = getEnumSignature(nodeInfo.node);\n        if (signature) {\n          inlineEnums.push({ ...nodeInfo, signature });\n        }\n      }\n    },\n  });\n\n  // Deduplicate and assign unique names for promoted enums\n  const signatureToName: Record<string, string | undefined> = {};\n  const signatureToSchema: Record<string, unknown> = {};\n\n  for (const { key, node, signature } of inlineEnums) {\n    if (signature in signatureToName) {\n      // Already handled\n      continue;\n    }\n\n    // Use existing root enum if available\n    if (signature in rootEnumSignatures) {\n      signatureToName[signature] = rootEnumSignatures[signature];\n      continue;\n    }\n\n    // Generate a unique name for the new root enum using config\n    const base = buildName({\n      config,\n      name:\n        typeof node === 'object' &&\n        node &&\n        'title' in node &&\n        typeof node.title === 'string'\n          ? node.title\n          : String(key),\n    });\n    const name = getUniqueComponentName({\n      base,\n      components: schemasObj,\n      extraComponents: Object.values(signatureToName),\n    });\n    signatureToName[signature] = name;\n    signatureToSchema[signature] = node;\n  }\n\n  // Add new root enums to the schemas object\n  for (const [signature, name] of Object.entries(signatureToName)) {\n    // Only add if not already present\n    const schema = signatureToSchema[signature];\n    if (name && !(name in schemasObj) && schema && typeof schema === 'object') {\n      schemasObj[name] = schema;\n    }\n  }\n\n  // Replace inline enums with $ref to the new root enum\n  const schemasPointerNamespace = specToSchemasPointerNamespace(spec);\n  for (const { key, parent, signature } of inlineEnums) {\n    const name = signatureToName[signature];\n    if (name && key != null && parent && typeof parent === 'object') {\n      (parent as Record<string, unknown>)[key] = {\n        $ref: `${schemasPointerNamespace}${name}`,\n      };\n    }\n  }\n};\n\n/**\n * Applies the enums transform according to the configured mode ('inline' or 'root').\n *\n * - In 'inline' mode, all root enums are inlined and removed.\n * - In 'root' mode, all inline enums are promoted to root components and deduplicated.\n *\n * @param config - The enums transform config\n * @param spec - The OpenAPI spec object to transform\n */\nexport const enumsTransform = ({\n  config,\n  spec,\n}: {\n  config: EnumsConfig;\n  spec: unknown;\n}) => {\n  if (config.mode === 'inline') {\n    inlineMode({ spec });\n    return;\n  }\n\n  if (config.mode === 'root') {\n    rootMode({ config, spec });\n    return;\n  }\n};\n","import { childSchemaRelationships } from '../utils/schemaChildRelationships';\n\ntype NodeInfo = {\n  key: string | number | null;\n  node: unknown;\n  parent: unknown;\n  path: ReadonlyArray<string | number>;\n};\n\n/**\n * Recursively walk all schemas in the OpenAPI spec, visiting every object.\n * Calls the visitor with node info for each.\n *\n * @param key - The key of the current node\n * @param node - The current node\n * @param parent - The parent node\n * @param path - The path to the current node\n * @param visitor - Function to call for each visited node\n */\nconst walkSchemas = ({\n  key,\n  node,\n  parent,\n  path,\n  visitor,\n}: NodeInfo & {\n  visitor: (nodeInfo: NodeInfo) => void;\n}) => {\n  if (!node || typeof node !== 'object' || node instanceof Array) return;\n\n  const value = node as Record<string, unknown>;\n\n  if (\n    'type' in value ||\n    childSchemaRelationships.some(([keyword]) => keyword in value)\n  ) {\n    visitor({ key, node, parent, path });\n  }\n\n  for (const [k, v] of Object.entries(value)) {\n    if (typeof v === 'object' && v !== null) {\n      if (v instanceof Array) {\n        v.forEach((item, index) =>\n          walkSchemas({\n            key: index,\n            node: item,\n            parent: v,\n            path: [...path, k, index],\n            visitor,\n          }),\n        );\n      } else {\n        walkSchemas({\n          key: k,\n          node: v,\n          parent: node,\n          path: [...path, k],\n          visitor,\n        });\n      }\n    }\n  }\n};\n\n/**\n * Applies the properties required by default transform\n *\n * @param spec - The OpenAPI spec object to transform\n */\nexport const propertiesRequiredByDefaultTransform = ({\n  spec,\n}: {\n  spec: unknown;\n}) => {\n  walkSchemas({\n    key: null,\n    node: spec,\n    parent: null,\n    path: [],\n    visitor: (nodeInfo) => {\n      if (\n        nodeInfo.node &&\n        typeof nodeInfo.node === 'object' &&\n        'type' in nodeInfo.node &&\n        nodeInfo.node.type === 'object' &&\n        'properties' in nodeInfo.node &&\n        nodeInfo.node.properties &&\n        typeof nodeInfo.node.properties === 'object' &&\n        !('required' in nodeInfo.node)\n      ) {\n        const propKeys = Object.keys(\n          nodeInfo.node.properties as Record<string, unknown>,\n        );\n        if (propKeys.length > 0) {\n          (nodeInfo.node as Record<string, unknown>).required = propKeys;\n        }\n      }\n    },\n  });\n};\n","/**\n * Deep equality for JSON-compatible values (objects, arrays, primitives).\n * Used to determine whether read/write pruned variants actually differ.\n */\nconst deepEqual = (a: unknown, b: unknown): boolean => {\n  if (a === b) return true;\n  if (a === null || b === null) return a === b;\n  const typeA = typeof a;\n  const typeB = typeof b;\n  if (typeA !== typeB) return false;\n  if (typeA !== 'object') return false;\n\n  // Arrays\n  if (Array.isArray(a) || Array.isArray(b)) {\n    if (!Array.isArray(a) || !Array.isArray(b)) return false;\n    if (a.length !== b.length) return false;\n    for (let i = 0; i < a.length; i++) {\n      if (!deepEqual(a[i], b[i])) return false;\n    }\n    return true;\n  }\n\n  // Plain objects\n  const objA = a as Record<string, unknown>;\n  const objB = b as Record<string, unknown>;\n  const keysA = Object.keys(objA).sort();\n  const keysB = Object.keys(objB).sort();\n  if (keysA.length !== keysB.length) return false;\n  for (let i = 0; i < keysA.length; i++) {\n    if (keysA[i] !== keysB[i]) return false;\n  }\n  for (const key of keysA) {\n    if (!deepEqual(objA[key], objB[key])) return false;\n  }\n  return true;\n};\n\nexport default deepEqual;\n","import type { Graph, NodeInfo } from '~/graph';\nimport type { Logger } from '~/utils/logger';\nimport { normalizeJsonPointer, pathToJsonPointer } from '~/utils/ref';\n\nimport { childSchemaRelationships } from './schemaChildRelationships';\n\n/**\n * Represents the possible access scopes for OpenAPI nodes.\n * - 'normal': Default scope for regular nodes.\n * - 'read': Node is read-only (e.g., readOnly: true).\n * - 'write': Node is write-only (e.g., writeOnly: true).\n */\nexport type Scope = 'normal' | 'read' | 'write';\n\n/**\n * Ensures every relevant child node (e.g., properties, items) in the graph has a `scopes` property.\n * If a node does not have its own scopes, it inherits from its parent if available.\n *\n * @param nodes - Map of JSON Pointer to NodeInfo.\n */\nexport const annotateChildScopes = (nodes: Graph['nodes']): void => {\n  for (const [, nodeInfo] of nodes) {\n    if (nodeInfo.scopes) continue;\n\n    if (nodeInfo.parentPointer) {\n      const parentInfo = nodes.get(nodeInfo.parentPointer);\n      if (parentInfo?.scopes) {\n        nodeInfo.scopes = new Set(parentInfo.scopes);\n      }\n    }\n  }\n};\n\ninterface Cache {\n  parentToChildren: Map<string, Array<string>>;\n  subtreeDependencies: Map<string, Set<string>>;\n  transitiveDependencies: Map<string, Set<string>>;\n}\n\ntype PointerDependenciesResult = {\n  subtreeDependencies: Set<string>;\n  transitiveDependencies: Set<string>;\n};\n\n/**\n * Recursively collects all $ref dependencies in the subtree rooted at `pointer`.\n */\nconst collectPointerDependencies = ({\n  cache,\n  graph,\n  pointer,\n  visited,\n}: {\n  cache: Cache;\n  graph: Graph;\n  pointer: string;\n  visited: Set<string>;\n}): PointerDependenciesResult => {\n  const cached = cache.transitiveDependencies.get(pointer);\n  if (cached) {\n    return {\n      subtreeDependencies: cache.subtreeDependencies.get(pointer)!,\n      transitiveDependencies: cached,\n    };\n  }\n\n  if (visited.has(pointer)) {\n    return {\n      subtreeDependencies: new Set(),\n      transitiveDependencies: new Set(),\n    };\n  }\n  visited.add(pointer);\n\n  const nodeInfo = graph.nodes.get(pointer);\n  if (!nodeInfo) {\n    return {\n      subtreeDependencies: new Set(),\n      transitiveDependencies: new Set(),\n    };\n  }\n\n  const transitiveDependencies = new Set<string>();\n  const subtreeDependencies = new Set<string>();\n\n  // Add direct $ref dependencies for this node\n  // (from the dependencies map, or by checking nodeInfo.node directly)\n  // We'll use the dependencies map for consistency:\n  const nodeDependencies = graph.nodeDependencies.get(pointer);\n  if (nodeDependencies) {\n    for (const depPointer of nodeDependencies) {\n      transitiveDependencies.add(depPointer);\n      subtreeDependencies.add(depPointer);\n      // Recursively collect dependencies of the referenced node\n      const depResult = collectPointerDependencies({\n        cache,\n        graph,\n        pointer: depPointer,\n        visited,\n      });\n      for (const dependency of depResult.transitiveDependencies) {\n        transitiveDependencies.add(dependency);\n      }\n    }\n  }\n\n  const children = cache.parentToChildren.get(pointer) ?? [];\n  for (const childPointer of children) {\n    let childResult: Partial<PointerDependenciesResult> = {\n      subtreeDependencies: cache.subtreeDependencies.get(childPointer),\n      transitiveDependencies: cache.transitiveDependencies.get(childPointer),\n    };\n    if (\n      !childResult.subtreeDependencies ||\n      !childResult.transitiveDependencies\n    ) {\n      childResult = collectPointerDependencies({\n        cache,\n        graph,\n        pointer: childPointer,\n        visited,\n      });\n      cache.transitiveDependencies.set(\n        childPointer,\n        childResult.transitiveDependencies!,\n      );\n      cache.subtreeDependencies.set(\n        childPointer,\n        childResult.subtreeDependencies!,\n      );\n    }\n    for (const dependency of childResult.transitiveDependencies!) {\n      transitiveDependencies.add(dependency);\n    }\n    for (const dependency of childResult.subtreeDependencies!) {\n      subtreeDependencies.add(dependency);\n    }\n  }\n\n  cache.transitiveDependencies.set(pointer, transitiveDependencies);\n  cache.subtreeDependencies.set(pointer, subtreeDependencies);\n  return {\n    subtreeDependencies,\n    transitiveDependencies,\n  };\n};\n\n/**\n * Propagates scopes through the graph using a worklist algorithm.\n * Each node's scopes will be updated to include any scopes inherited via $ref dependencies, combinator/child relationships, and parent relationships.\n * Handles cycles and deep chains efficiently.\n *\n * Whenever a node's scopes change, all dependents are notified:\n *   - Its parent (if any)\n *   - All nodes that reference it via $ref (reverse dependencies)\n *   - Combinator parents (allOf/anyOf/oneOf) if applicable\n *\n * @param graph - The Graph structure containing nodes, dependencies, and reverseNodeDependencies.\n */\nexport const propagateScopes = (graph: Graph): void => {\n  const worklist: Set<string> = new Set(\n    Array.from(graph.nodes.entries())\n      .filter(([, nodeInfo]) => nodeInfo.scopes && nodeInfo.scopes.size > 0)\n      .map(([pointer]) => pointer),\n  );\n\n  /**\n   * Notifies all dependents of a node that its scopes may have changed.\n   * Dependents include:\n   *   - The parent node (if any)\n   *   - All nodes that reference this node via $ref (reverse dependencies)\n   *   - Combinator parents (allOf/anyOf/oneOf) if this node is a combinator child\n   *\n   * @param pointer - The JSON pointer of the node whose dependents to notify\n   * @param nodeInfo - The NodeInfo of the node\n   * @param childPointer - (Optional) The pointer of the child, used to detect combinator parents\n   */\n  const notifyAllDependents = (\n    pointer: string,\n    nodeInfo: NodeInfo,\n    childPointer?: string,\n  ) => {\n    if (nodeInfo.parentPointer) {\n      worklist.add(nodeInfo.parentPointer);\n    }\n    const reverseNodeDependencies = graph.reverseNodeDependencies.get(pointer);\n    if (reverseNodeDependencies) {\n      for (const dependentPointer of reverseNodeDependencies) {\n        worklist.add(dependentPointer);\n      }\n    }\n    if (childPointer) {\n      // If this is a combinator child, notify the combinator parent\n      const combinatorChildMatch = childPointer.match(\n        /(.*)\\/(allOf|anyOf|oneOf)\\/\\d+$/,\n      );\n      if (combinatorChildMatch) {\n        const combinatorParentPointer = combinatorChildMatch[1];\n        if (combinatorParentPointer) {\n          worklist.add(combinatorParentPointer);\n        }\n      }\n    }\n  };\n\n  /**\n   * Propagates scopes from a child node to its parent node.\n   * If the parent's scopes change, notifies all dependents.\n   *\n   * @param pointer - The parent node's pointer\n   * @param nodeInfo - The parent node's NodeInfo\n   * @param childPointer - The child node's pointer\n   */\n  const propagateChildScopes = (\n    pointer: string,\n    nodeInfo: NodeInfo,\n    childPointer: string,\n  ): void => {\n    if (!nodeInfo?.scopes) return;\n    const childInfo = graph.nodes.get(childPointer);\n    if (!childInfo?.scopes) return;\n    const changed = propagateScopesToNode(childInfo, nodeInfo);\n    if (changed) {\n      notifyAllDependents(pointer, nodeInfo, childPointer);\n    }\n  };\n\n  while (worklist.size > 0) {\n    const pointer = worklist.values().next().value!;\n    worklist.delete(pointer);\n\n    const nodeInfo = graph.nodes.get(pointer);\n    if (!nodeInfo) continue;\n\n    if (!nodeInfo.scopes) {\n      nodeInfo.scopes = new Set();\n    }\n\n    const node = nodeInfo.node as Record<string, unknown>;\n\n    // Propagate scopes from all child schema relationships (combinators, properties, etc.)\n    for (const [keyword, type] of childSchemaRelationships) {\n      if (!node || typeof node !== 'object' || !(keyword in node)) continue;\n      const value = node[keyword];\n      if (type === 'array' && value instanceof Array) {\n        for (let index = 0; index < value.length; index++) {\n          const childPointer = `${pointer}/${keyword}/${index}`;\n          propagateChildScopes(pointer, nodeInfo, childPointer);\n        }\n      } else if (\n        type === 'objectMap' &&\n        typeof value === 'object' &&\n        value !== null &&\n        !(value instanceof Array)\n      ) {\n        for (const key of Object.keys(value)) {\n          const childPointer = `${pointer}/${keyword}/${key}`;\n          propagateChildScopes(pointer, nodeInfo, childPointer);\n        }\n      } else if (\n        type === 'single' &&\n        typeof value === 'object' &&\n        value !== null\n      ) {\n        const childPointer = `${pointer}/${keyword}`;\n        propagateChildScopes(pointer, nodeInfo, childPointer);\n      } else if (type === 'singleOrArray') {\n        if (value instanceof Array) {\n          for (let index = 0; index < value.length; index++) {\n            const childPointer = `${pointer}/${keyword}/${index}`;\n            propagateChildScopes(pointer, nodeInfo, childPointer);\n          }\n        } else if (typeof value === 'object' && value !== null) {\n          const childPointer = `${pointer}/${keyword}`;\n          propagateChildScopes(pointer, nodeInfo, childPointer);\n        }\n      }\n    }\n\n    // Propagate scopes from $ref dependencies\n    const nodeDependencies = graph.nodeDependencies.get(pointer);\n    if (nodeDependencies) {\n      for (const depPointer of nodeDependencies) {\n        const depNode = graph.nodes.get(depPointer);\n        if (depNode?.scopes) {\n          const changed = propagateScopesToNode(depNode, nodeInfo);\n          if (changed) {\n            notifyAllDependents(pointer, nodeInfo);\n          }\n        }\n      }\n    }\n\n    // Propagate scopes up the parent chain\n    if (nodeInfo.parentPointer) {\n      const parentInfo = graph.nodes.get(nodeInfo.parentPointer);\n      if (parentInfo) {\n        const changed = propagateScopesToNode(nodeInfo, parentInfo);\n        if (changed) {\n          notifyAllDependents(nodeInfo.parentPointer, parentInfo);\n        }\n      }\n    }\n  }\n};\n\n/**\n * Propagates scopes from one node to another.\n * Adds any scopes from fromNodeInfo to toNodeInfo that are not already present.\n * Returns true if any scopes were added, false otherwise.\n *\n * @param fromNodeInfo - The node to propagate scopes from\n * @param toNodeInfo - The node to propagate scopes to\n * @returns boolean - Whether any scopes were added\n */\nconst propagateScopesToNode = (\n  fromNodeInfo: NodeInfo,\n  toNodeInfo: NodeInfo,\n): boolean => {\n  if (!fromNodeInfo.scopes) {\n    return false;\n  }\n\n  if (!toNodeInfo.scopes) {\n    toNodeInfo.scopes = new Set();\n  }\n\n  let changed = false;\n\n  for (const scope of fromNodeInfo.scopes) {\n    if (!toNodeInfo.scopes.has(scope)) {\n      toNodeInfo.scopes.add(scope);\n      changed = true;\n    }\n  }\n\n  return changed;\n};\n\n/**\n * Seeds each node in the graph with its local access scope(s) based on its own properties.\n * - 'read' if readOnly: true\n * - 'write' if writeOnly: true\n * - 'normal' if node is an object property\n *\n * Only non-array objects are considered for scope seeding.\n *\n * @param nodes - Map of JSON Pointer to NodeInfo.\n */\nexport const seedLocalScopes = (nodes: Graph['nodes']): void => {\n  for (const [pointer, nodeInfo] of nodes) {\n    const { node } = nodeInfo;\n\n    if (typeof node !== 'object' || node === null || node instanceof Array) {\n      continue;\n    }\n\n    if ('readOnly' in node && node.readOnly === true) {\n      nodeInfo.scopes = new Set(['read']);\n    } else if ('writeOnly' in node && node.writeOnly === true) {\n      nodeInfo.scopes = new Set(['write']);\n    } else if (pointer.match(/\\/properties\\/[^/]+$/)) {\n      nodeInfo.scopes = new Set(['normal']);\n    }\n  }\n};\n\n/**\n * Builds a graph of all nodes in an OpenAPI spec, indexed by normalized JSON Pointer,\n * and tracks all $ref dependencies and reverse dependencies between nodes.\n *\n * - All keys in the returned maps are normalized JSON Pointers (RFC 6901, always starting with '#').\n * - The `nodes` map allows fast lookup of any node and its parent/key context.\n * - The `dependencies` map records, for each node, the set of normalized pointers it references via $ref.\n * - The `reverseNodeDependencies` map records, for each node, the set of nodes that reference it via $ref.\n * - After construction, all nodes will have their local and propagated scopes annotated.\n *\n * @param root The root object (e.g., the OpenAPI spec)\n * @returns An object with:\n *   - nodes: Map from normalized JSON Pointer string to NodeInfo\n *   - dependencies: Map from normalized JSON Pointer string to Set of referenced normalized JSON Pointers\n *   - reverseNodeDependencies: Map from normalized JSON Pointer string to Set of referencing normalized JSON Pointers\n */\nexport const buildGraph = (\n  root: unknown,\n  logger: Logger,\n): {\n  graph: Graph;\n} => {\n  const eventBuildGraph = logger.timeEvent('build-graph');\n  const graph: Graph = {\n    nodeDependencies: new Map(),\n    nodes: new Map(),\n    reverseNodeDependencies: new Map(),\n    subtreeDependencies: new Map(),\n    transitiveDependencies: new Map(),\n  };\n\n  const walk = ({\n    key,\n    node,\n    parentPointer,\n    path,\n  }: NodeInfo & {\n    path: ReadonlyArray<string | number>;\n  }) => {\n    if (typeof node !== 'object' || node === null) {\n      return;\n    }\n\n    const pointer = pathToJsonPointer(path);\n\n    let deprecated: boolean | undefined;\n    let tags: Set<string> | undefined;\n\n    if (typeof node === 'object' && node !== null) {\n      // Check for deprecated property\n      if ('deprecated' in node && typeof node.deprecated === 'boolean') {\n        deprecated = Boolean(node.deprecated);\n      }\n      // If this node has a $ref, record the dependency\n      if ('$ref' in node && typeof node.$ref === 'string') {\n        const refPointer = normalizeJsonPointer(node.$ref);\n        if (!graph.nodeDependencies.has(pointer)) {\n          graph.nodeDependencies.set(pointer, new Set());\n        }\n        graph.nodeDependencies.get(pointer)!.add(refPointer);\n      }\n      // Check for tags property (should be an array of strings)\n      if ('tags' in node && node.tags instanceof Array) {\n        tags = new Set(node.tags.filter((tag) => typeof tag === 'string'));\n      }\n    }\n\n    graph.nodes.set(pointer, { deprecated, key, node, parentPointer, tags });\n\n    if (node instanceof Array) {\n      node.forEach((item, index) =>\n        walk({\n          key: index,\n          node: item,\n          parentPointer: pointer,\n          path: [...path, index],\n        }),\n      );\n    } else {\n      for (const [childKey, value] of Object.entries(node)) {\n        walk({\n          key: childKey,\n          node: value,\n          parentPointer: pointer,\n          path: [...path, childKey],\n        });\n      }\n    }\n  };\n\n  walk({\n    key: null,\n    node: root,\n    parentPointer: null,\n    path: [],\n  });\n\n  const cache: Cache = {\n    parentToChildren: new Map(),\n    subtreeDependencies: new Map(),\n    transitiveDependencies: new Map(),\n  };\n\n  for (const [pointer, nodeInfo] of graph.nodes) {\n    const parent = nodeInfo.parentPointer;\n    if (!parent) continue;\n    if (!cache.parentToChildren.has(parent)) {\n      cache.parentToChildren.set(parent, []);\n    }\n    cache.parentToChildren.get(parent)!.push(pointer);\n  }\n\n  for (const [pointerFrom, pointers] of graph.nodeDependencies) {\n    for (const pointerTo of pointers) {\n      if (!graph.reverseNodeDependencies.has(pointerTo)) {\n        graph.reverseNodeDependencies.set(pointerTo, new Set());\n      }\n      graph.reverseNodeDependencies.get(pointerTo)!.add(pointerFrom);\n    }\n  }\n\n  seedLocalScopes(graph.nodes);\n  propagateScopes(graph);\n  annotateChildScopes(graph.nodes);\n\n  for (const pointer of graph.nodes.keys()) {\n    const result = collectPointerDependencies({\n      cache,\n      graph,\n      pointer,\n      visited: new Set(),\n    });\n    graph.transitiveDependencies.set(pointer, result.transitiveDependencies);\n    graph.subtreeDependencies.set(pointer, result.subtreeDependencies);\n  }\n\n  eventBuildGraph.timeEnd();\n\n  // functions creating data for debug scripts located in `dev/`\n  // const { maxChildren, maxDepth, totalNodes } = debugTools.graph.analyzeStructure(graph);\n  // const nodesForViz = debugTools.graph.exportForVisualization(graph);\n  // fs.writeFileSync('dev/graph.json', JSON.stringify(nodesForViz, null, 2));\n\n  return { graph };\n};\n","import type { Graph } from '~/graph';\nimport type { Logger } from '~/utils/logger';\nimport { jsonPointerToPath } from '~/utils/ref';\n\nimport type { Config } from '../../../types/config';\nimport deepEqual from '../utils/deepEqual';\nimport { buildGraph, type Scope } from '../utils/graph';\nimport { buildName } from '../utils/name';\nimport { deepClone } from '../utils/schema';\nimport { childSchemaRelationships } from '../utils/schemaChildRelationships';\nimport {\n  getSchemasObject,\n  hasComponentsSchemasObject,\n  hasDefinitionsObject,\n} from '../utils/transforms';\nimport {\n  getUniqueComponentName,\n  isPathRootSchema,\n  specToSchemasPointerNamespace,\n} from './utils';\n\ntype OriginalSchemas = Record<string, unknown>;\n\ntype SplitSchemas = {\n  /** Key is the original schema pointer. */\n  mapping: Record<\n    string,\n    {\n      read?: string;\n      write?: string;\n    }\n  >;\n  /** splitPointer -> originalPointer */\n  reverseMapping: Record<string, string>;\n  /** name -> schema object */\n  schemas: Record<string, unknown>;\n};\n\ntype ReadWriteConfig = Config['parser']['transforms']['readWrite'];\n\nconst schemaKeys = new Set([\n  'additionalProperties',\n  'allOf',\n  'anyOf',\n  'items',\n  'not',\n  'oneOf',\n  'patternProperties',\n  'properties',\n  'schema',\n]);\n\nconst getComponentContext = (\n  path: ReadonlyArray<string | number>,\n): Scope | undefined => {\n  // OpenAPI 3.x: #/components/{type}/{name}\n  if (path.length === 3 && path[0] === 'components') {\n    const type = path[1];\n    if (type === 'parameters') return 'write';\n    if (type === 'requestBodies') return 'write';\n    if (type === 'responses') return 'read';\n    if (type === 'headers') return 'read';\n  }\n  // OpenAPI 2.x: #/parameters/{name}, #/responses/{name}\n  if (path.length === 2) {\n    const type = path[0];\n    if (type === 'parameters') return 'write';\n    if (type === 'responses') return 'read';\n  }\n  return;\n};\n\n/**\n * Capture the original schema objects by pointer before splitting.\n * This is used to safely remove only the true originals after splitting,\n * even if names are swapped or overwritten by split variants.\n */\nconst captureOriginalSchemas = (\n  spec: unknown,\n  logger: Logger,\n): OriginalSchemas => {\n  const event = logger.timeEvent('capture-original-schemas');\n  const originals: OriginalSchemas = {};\n  if (hasComponentsSchemasObject(spec)) {\n    for (const [name, obj] of Object.entries(\n      (spec as any).components.schemas,\n    )) {\n      originals[`#/components/schemas/${name}`] = obj;\n    }\n  } else if (hasDefinitionsObject(spec)) {\n    for (const [name, obj] of Object.entries((spec as any).definitions)) {\n      originals[`#/definitions/${name}`] = obj;\n    }\n  }\n  event.timeEnd();\n  return originals;\n};\n\n/**\n * Inserts split schemas into the spec at the correct location (OpenAPI 3.x or 2.0).\n * This function is robust to spec version and will assign all split schemas\n * to either components.schemas (OAS3) or definitions (OAS2).\n *\n * @param spec - The OpenAPI spec object\n * @param split - The split schemas (from splitSchemas)\n */\nconst insertSplitSchemasIntoSpec = ({\n  logger,\n  spec,\n  split,\n}: {\n  logger: Logger;\n  spec: unknown;\n  split: Pick<SplitSchemas, 'schemas'>;\n}) => {\n  const event = logger.timeEvent('insert-split-schemas-into-spec');\n  if (hasComponentsSchemasObject(spec)) {\n    Object.assign((spec as any).components.schemas, split.schemas);\n  } else if (hasDefinitionsObject(spec)) {\n    Object.assign((spec as any).definitions, split.schemas);\n  }\n  event.timeEnd();\n};\n\n/**\n * Prunes a schema by removing all child schemas (in any structural keyword)\n * that are marked with the given scope (readOnly/writeOnly), or that are $ref to a schema\n * that is exclusively the excluded scope (according to the graph).\n *\n * Uses childSchemaRelationships for parity with graph traversal.\n * Returns true if the schema itself should be removed from its parent.\n *\n * @param graph - The Graph containing all nodes and their scopes\n * @param schema - The schema object to prune\n * @param scope - The scope to exclude ('readOnly' or 'writeOnly')\n * @returns boolean - Whether the schema should be removed from its parent\n */\nconst pruneSchemaByScope = (\n  graph: Graph,\n  schema: unknown,\n  scope: 'readOnly' | 'writeOnly',\n): boolean => {\n  if (schema && typeof schema === 'object') {\n    // Handle $ref schemas\n    if ('$ref' in schema && typeof schema.$ref === 'string') {\n      const nodeInfo = graph.nodes.get(schema.$ref);\n      if (nodeInfo?.scopes) {\n        // Only remove $ref if the referenced schema is *exclusively* the excluded scope.\n        // This ensures 'normal' or multi-scope schemas are always kept.\n        if (\n          (scope === 'writeOnly' &&\n            nodeInfo.scopes.size === 1 &&\n            nodeInfo.scopes.has('write')) ||\n          (scope === 'readOnly' &&\n            nodeInfo.scopes.size === 1 &&\n            nodeInfo.scopes.has('read'))\n        ) {\n          delete (schema as Record<string, unknown>)['$ref'];\n          // If the schema is now empty, remove it\n          if (\n            !childSchemaRelationships.some(([keyword]) => keyword in schema)\n          ) {\n            return true;\n          }\n        }\n      }\n    }\n    // Recursively prune all child schemas according to childSchemaRelationships\n    for (const [keyword, type] of childSchemaRelationships) {\n      if (!(keyword in schema)) {\n        continue;\n      }\n      const value = (schema as Record<string, unknown>)[keyword];\n      if (type === 'array' && value instanceof Array) {\n        for (let index = value.length - 1; index >= 0; index--) {\n          const item = value[index];\n          if (\n            item &&\n            typeof item === 'object' &&\n            (item as Record<string, unknown>)[scope] === true\n          ) {\n            value.splice(index, 1);\n          } else {\n            const shouldRemove = pruneSchemaByScope(graph, item, scope);\n            if (shouldRemove) value.splice(index, 1);\n          }\n        }\n        if (!value.length) {\n          delete (schema as Record<string, unknown>)[keyword];\n        }\n      } else if (\n        type === 'objectMap' &&\n        typeof value === 'object' &&\n        value !== null &&\n        !(value instanceof Array)\n      ) {\n        const objMap = value as Record<string, unknown>;\n        // Track removed properties for object schemas to update required array\n        const removedProperties = new Set<string>();\n\n        for (const key of Object.keys(objMap)) {\n          const prop = objMap[key];\n          if (\n            prop &&\n            typeof prop === 'object' &&\n            (prop as Record<string, unknown>)[scope] === true\n          ) {\n            delete objMap[key];\n            // Track removed properties for object schemas\n            if (keyword === 'properties') {\n              removedProperties.add(key);\n            }\n          } else {\n            const shouldRemove = pruneSchemaByScope(graph, prop, scope);\n            if (shouldRemove) {\n              delete objMap[key];\n              // Track removed properties for object schemas\n              if (keyword === 'properties') {\n                removedProperties.add(key);\n              }\n            }\n          }\n        }\n\n        // Update required array if properties were removed\n        if (\n          removedProperties.size > 0 &&\n          keyword === 'properties' &&\n          'required' in schema &&\n          Array.isArray((schema as Record<string, unknown>).required)\n        ) {\n          const required = (schema as Record<string, unknown>)\n            .required as string[];\n          const filteredRequired = required.filter(\n            (prop) => !removedProperties.has(prop),\n          );\n\n          if (!filteredRequired.length) {\n            delete (schema as Record<string, unknown>).required;\n          } else {\n            (schema as Record<string, unknown>).required = filteredRequired;\n          }\n        }\n\n        if (!Object.keys(objMap).length) {\n          delete (schema as Record<string, unknown>)[keyword];\n        }\n      } else if (\n        type === 'single' &&\n        typeof value === 'object' &&\n        value !== null\n      ) {\n        if ((value as Record<string, unknown>)[scope] === true) {\n          delete (schema as Record<string, unknown>)[keyword];\n        } else {\n          const shouldRemove = pruneSchemaByScope(graph, value, scope);\n          if (shouldRemove) {\n            delete (schema as Record<string, unknown>)[keyword];\n          }\n        }\n      } else if (type === 'singleOrArray') {\n        if (value instanceof Array) {\n          for (let index = value.length - 1; index >= 0; index--) {\n            const item = value[index];\n            if (\n              item &&\n              typeof item === 'object' &&\n              (item as Record<string, unknown>)[scope] === true\n            ) {\n              value.splice(index, 1);\n            } else {\n              const shouldRemove = pruneSchemaByScope(graph, item, scope);\n              if (shouldRemove) value.splice(index, 1);\n            }\n          }\n          if (!value.length) {\n            delete (schema as Record<string, unknown>)[keyword];\n          }\n        } else if (typeof value === 'object' && value !== null) {\n          if ((value as Record<string, unknown>)[scope] === true) {\n            delete (schema as Record<string, unknown>)[keyword];\n          } else {\n            const shouldRemove = pruneSchemaByScope(graph, value, scope);\n            if (shouldRemove) {\n              delete (schema as Record<string, unknown>)[keyword];\n            }\n          }\n        }\n      }\n    }\n    // After all removals, if this is type: object and has no structural fields, remove it\n    if (\n      (schema as Record<string, unknown>).type === 'object' &&\n      !childSchemaRelationships.some(([keyword]) => keyword in schema)\n    ) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * Remove only the true original schemas that were split, by object identity.\n * This is robust to swaps, overwrites, and name collisions.\n *\n * @param originalSchemas - Map of original pointers to their schema objects (captured before splitting)\n * @param spec - The OpenAPI spec object\n * @param split - The split mapping (from splitSchemas)\n */\nconst removeOriginalSplitSchemas = ({\n  logger,\n  originalSchemas,\n  spec,\n  split,\n}: {\n  logger: Logger;\n  originalSchemas: OriginalSchemas;\n  spec: unknown;\n  split: Pick<SplitSchemas, 'mapping'>;\n}) => {\n  const event = logger.timeEvent('remove-original-split-schemas');\n  const schemasObj = getSchemasObject(spec);\n\n  for (const originalPointer of Object.keys(split.mapping)) {\n    const path = jsonPointerToPath(originalPointer);\n    const name = path[path.length - 1]!;\n    if (\n      typeof name === 'string' &&\n      schemasObj &&\n      Object.prototype.hasOwnProperty.call(schemasObj, name) &&\n      schemasObj[name] === originalSchemas[originalPointer]\n    ) {\n      delete schemasObj[name];\n    }\n  }\n  event.timeEnd();\n};\n\n/**\n * Splits schemas with both 'read' and 'write' scopes into read/write variants.\n * Returns the new schemas and a mapping from original pointer to new variant pointers.\n *\n * @param config - The readWrite transform config\n * @param graph - The Graph containing all nodes and their scopes\n * @param spec - The OpenAPI spec object\n * @returns SplitSchemas - The split schemas and pointer mappings\n */\nexport const splitSchemas = ({\n  config,\n  graph,\n  logger,\n  spec,\n}: {\n  config: ReadWriteConfig;\n  graph: Graph;\n  logger: Logger;\n  spec: unknown;\n}): SplitSchemas => {\n  const event = logger.timeEvent('split-schemas');\n  const existingNames = new Set<string>();\n  const split: SplitSchemas = {\n    mapping: {},\n    reverseMapping: {},\n    schemas: {},\n  };\n\n  const schemasPointerNamespace = specToSchemasPointerNamespace(spec);\n  const schemasNamespaceSegments =\n    schemasPointerNamespace.split('/').length - 1;\n\n  /**\n   * Extracts the schema name from pointer, but only if it's a top-level schema\n   * pointer. Returns an empty string if it's a nested pointer.\n   * @param pointer\n   * @returns Schema's base name.\n   */\n  const pointerToSchema = (pointer: string): string => {\n    if (pointer.startsWith(schemasPointerNamespace)) {\n      const path = jsonPointerToPath(pointer);\n      if (path.length === schemasNamespaceSegments) {\n        return path[schemasNamespaceSegments - 1] || '';\n      }\n    }\n    return '';\n  };\n\n  // Collect all existing schema names\n  for (const pointer of graph.nodes.keys()) {\n    const name = pointerToSchema(pointer);\n    if (name) existingNames.add(name);\n  }\n\n  for (const [pointer, nodeInfo] of graph.nodes) {\n    const name = pointerToSchema(pointer);\n    // Only split top-level schemas, with either read-only or write-only scopes (or both).\n    if (\n      !name ||\n      !(nodeInfo.scopes?.has('read') || nodeInfo.scopes?.has('write')) ||\n      !nodeInfo.scopes?.has('normal')\n    ) {\n      continue;\n    }\n\n    // read variant\n    const readSchema = deepClone<unknown>(nodeInfo.node);\n    pruneSchemaByScope(graph, readSchema, 'writeOnly');\n    const readBase = buildName({\n      config: config.responses,\n      name,\n    });\n    const readName =\n      readBase === name\n        ? readBase\n        : getUniqueComponentName({\n            base: readBase,\n            components: existingNames,\n          });\n    existingNames.add(readName);\n    split.schemas[readName] = readSchema;\n    const readPointer = `${schemasPointerNamespace}${readName}`;\n\n    // write variant\n    const writeSchema = deepClone<unknown>(nodeInfo.node);\n    pruneSchemaByScope(graph, writeSchema, 'readOnly');\n\n    // Check if this schema (or any of its descendants) references any schema that\n    // will need read/write variants. This is determined by checking transitive\n    // dependencies for schemas with both 'normal' and ('read' or 'write') scopes.\n    const transitiveDeps =\n      graph.transitiveDependencies.get(pointer) || new Set();\n    const referencesReadWriteSchemas = Array.from(transitiveDeps).some(\n      (depPointer) => {\n        const depNodeInfo = graph.nodes.get(depPointer);\n        return (\n          depNodeInfo?.scopes?.has('normal') &&\n          (depNodeInfo.scopes.has('read') || depNodeInfo.scopes.has('write'))\n        );\n      },\n    );\n\n    // If pruning did not change anything (both variants equal and equal to original),\n    // and the schema doesn't reference any schemas that will have read/write variants,\n    // skip splitting and keep the original single schema.\n    if (\n      !referencesReadWriteSchemas &&\n      deepEqual(readSchema, writeSchema) &&\n      deepEqual(readSchema, nodeInfo.node)\n    ) {\n      continue;\n    }\n    const writeBase = buildName({\n      config: config.requests,\n      name,\n    });\n    const writeName =\n      writeBase === name && writeBase !== readName\n        ? writeBase\n        : getUniqueComponentName({\n            base: writeBase,\n            components: existingNames,\n          });\n    existingNames.add(writeName);\n    split.schemas[writeName] = writeSchema;\n    const writePointer = `${schemasPointerNamespace}${writeName}`;\n\n    split.mapping[pointer] = {\n      read: readPointer,\n      write: writePointer,\n    };\n    split.reverseMapping[readPointer] = pointer;\n    split.reverseMapping[writePointer] = pointer;\n  }\n\n  event.timeEnd();\n  return split;\n};\n\ntype WalkArgs = {\n  context: Scope | null;\n  currentPointer: string | null;\n  inSchema: boolean;\n  node: unknown;\n  path: ReadonlyArray<string | number>;\n  visited?: Set<string>;\n};\n\n/**\n * Recursively updates $ref fields in the spec to point to the correct read/write variant\n * according to the current context (read/write), using the split mapping.\n *\n * @param spec - The OpenAPI spec object\n * @param split - The split mapping (from splitSchemas)\n */\nexport const updateRefsInSpec = ({\n  logger,\n  spec,\n  split,\n}: {\n  logger: Logger;\n  spec: unknown;\n  split: Omit<SplitSchemas, 'schemas'>;\n}): void => {\n  const event = logger.timeEvent('update-refs-in-spec');\n  const schemasPointerNamespace = specToSchemasPointerNamespace(spec);\n\n  const walk = ({\n    context,\n    currentPointer,\n    inSchema,\n    node,\n    path,\n    visited = new Set(),\n  }: WalkArgs): void => {\n    if (node instanceof Array) {\n      node.forEach((item, index) =>\n        walk({\n          context,\n          currentPointer,\n          inSchema,\n          node: item,\n          path: [...path, index],\n          visited,\n        }),\n      );\n    } else if (node && typeof node === 'object') {\n      // Detect if we're entering a split schema variant\n      let nextPointer = currentPointer;\n      let nextContext = context;\n      if (isPathRootSchema(path)) {\n        // Use the last path segment instead of a fixed index (path[2]) because\n        // path depth varies across OAS2/OAS3 and contexts; fixed indexing is brittle.\n        const nameSegment = path[path.length - 1] as string;\n        nextPointer = `${schemasPointerNamespace}${nameSegment}`;\n        const originalPointer = split.reverseMapping[nextPointer];\n        if (originalPointer) {\n          const mapping = split.mapping[originalPointer];\n          if (mapping?.read === nextPointer) {\n            nextContext = 'read';\n          } else if (mapping?.write === nextPointer) {\n            nextContext = 'write';\n          }\n        }\n        // For schemas that are not split variants, keep the inherited context.\n        // This ensures that $refs inside these schemas are resolved based on\n        // where the schema is actually used (requestBody vs responses), not\n        // based on the schema's own scopes which track readOnly/writeOnly fields.\n      }\n\n      const compContext = getComponentContext(path);\n      if (compContext !== undefined) {\n        // For each component, walk with the correct context\n        for (const key in node) {\n          if (!Object.prototype.hasOwnProperty.call(node, key)) {\n            continue;\n          }\n          walk({\n            context: compContext,\n            currentPointer: nextPointer,\n            inSchema: false,\n            node: (node as Record<string, unknown>)[key],\n            path: [...path, key],\n            visited,\n          });\n        }\n        return;\n      }\n\n      for (const key in node) {\n        if (!Object.prototype.hasOwnProperty.call(node, key)) {\n          continue;\n        }\n        const value = (node as Record<string, unknown>)[key];\n\n        // Only treat context switches at the OpenAPI structure level (not inside schemas)\n        if (!inSchema) {\n          if (key === 'requestBody') {\n            walk({\n              context: 'write',\n              currentPointer: nextPointer,\n              inSchema: false,\n              node: value,\n              path: [...path, key],\n              visited,\n            });\n            continue;\n          }\n          if (key === 'responses') {\n            walk({\n              context: 'read',\n              currentPointer: nextPointer,\n              inSchema: false,\n              node: value,\n              path: [...path, key],\n              visited,\n            });\n            continue;\n          }\n          if (key === 'parameters' && Array.isArray(value)) {\n            value.forEach((param, index) => {\n              if (param && typeof param === 'object' && 'schema' in param) {\n                walk({\n                  context: 'write',\n                  currentPointer: nextPointer,\n                  inSchema: true,\n                  node: param.schema,\n                  path: [...path, key, index, 'schema'],\n                  visited,\n                });\n              }\n              // Also handle content (OpenAPI 3.x)\n              if (param && typeof param === 'object' && 'content' in param) {\n                walk({\n                  context: 'write',\n                  currentPointer: nextPointer,\n                  inSchema: false,\n                  node: param.content,\n                  path: [...path, key, index, 'content'],\n                  visited,\n                });\n              }\n            });\n            continue;\n          }\n          // OpenAPI 3.x: headers in responses\n          if (\n            key === 'headers' &&\n            typeof value === 'object' &&\n            value !== null\n          ) {\n            for (const headerKey in value) {\n              if (!Object.prototype.hasOwnProperty.call(value, headerKey)) {\n                continue;\n              }\n              walk({\n                context: 'read',\n                currentPointer: nextPointer,\n                inSchema: false,\n                node: (value as Record<string, unknown>)[headerKey],\n                path: [...path, key, headerKey],\n                visited,\n              });\n            }\n            continue;\n          }\n        }\n\n        // Entering a schema context\n        if (schemaKeys.has(key)) {\n          walk({\n            context: nextContext,\n            currentPointer: nextPointer,\n            inSchema: true,\n            node: value,\n            path: [...path, key],\n            visited,\n          });\n        } else if (key === '$ref' && typeof value === 'string') {\n          // Prefer exact match first\n          const map = split.mapping[value];\n          if (map) {\n            if (nextContext === 'read' && map.read) {\n              (node as Record<string, unknown>)[key] = map.read;\n            } else if (nextContext === 'write' && map.write) {\n              (node as Record<string, unknown>)[key] = map.write;\n            } else if (!nextContext && map.read) {\n              // For schemas with no context (unused in operations), default to read variant\n              // This ensures $refs in unused schemas don't point to removed originals\n              (node as Record<string, unknown>)[key] = map.read;\n            }\n          }\n        } else {\n          walk({\n            context: nextContext,\n            currentPointer: nextPointer,\n            inSchema,\n            node: value,\n            path: [...path, key],\n            visited,\n          });\n        }\n      }\n    }\n  };\n  walk({\n    context: null,\n    currentPointer: null,\n    inSchema: false,\n    node: spec,\n    path: [],\n  });\n  event.timeEnd();\n};\n\n/**\n * Orchestrates the full read/write transform:\n * - Captures original schemas\n * - Splits schemas into read/write variants\n * - Inserts split schemas into the spec\n * - Updates $refs throughout the spec\n * - Removes original schemas that were split\n *\n * @param config - The readWrite transform config\n * @param spec - The OpenAPI spec object\n */\nexport const readWriteTransform = ({\n  config,\n  logger,\n  spec,\n}: {\n  config: ReadWriteConfig;\n  logger: Logger;\n  spec: unknown;\n}) => {\n  const { graph } = buildGraph(spec, logger);\n  const originalSchemas = captureOriginalSchemas(spec, logger);\n  const split = splitSchemas({ config, graph, logger, spec });\n  insertSplitSchemasIntoSpec({ logger, spec, split });\n  updateRefsInSpec({ logger, spec, split });\n  removeOriginalSplitSchemas({ logger, originalSchemas, spec, split });\n};\n","import type { IR } from '~/ir/types';\n\nimport { enumsTransform } from './enums';\nimport { propertiesRequiredByDefaultTransform } from './propertiesRequiredByDefault';\nimport { readWriteTransform } from './readWrite';\n\nexport const transformOpenApiSpec = ({ context }: { context: IR.Context }) => {\n  const { logger } = context;\n  const eventTransformOpenApiSpec = logger.timeEvent('transform-openapi-spec');\n  if (context.config.parser.transforms.enums.enabled) {\n    enumsTransform({\n      config: context.config.parser.transforms.enums,\n      spec: context.spec,\n    });\n  }\n\n  if (context.config.parser.transforms.propertiesRequiredByDefault) {\n    propertiesRequiredByDefaultTransform({ spec: context.spec });\n  }\n\n  if (context.config.parser.transforms.readWrite.enabled) {\n    readWriteTransform({\n      config: context.config.parser.transforms.readWrite,\n      logger,\n      spec: context.spec,\n    });\n  }\n  eventTransformOpenApiSpec.timeEnd();\n};\n","import type { IR } from '~/ir/types';\n\nexport const mergeParametersObjects = ({\n  source,\n  target,\n}: {\n  source: IR.ParametersObject | undefined;\n  target: IR.ParametersObject | undefined;\n}): IR.ParametersObject | undefined => {\n  const result = { ...target };\n\n  if (source) {\n    if (source.cookie) {\n      if (result.cookie) {\n        result.cookie = {\n          ...result.cookie,\n          ...source.cookie,\n        };\n      } else {\n        result.cookie = source.cookie;\n      }\n    }\n\n    if (source.header) {\n      if (result.header) {\n        result.header = {\n          ...result.header,\n          ...source.header,\n        };\n      } else {\n        result.header = source.header;\n      }\n    }\n\n    if (source.path) {\n      if (result.path) {\n        result.path = {\n          ...result.path,\n          ...source.path,\n        };\n      } else {\n        result.path = source.path;\n      }\n    }\n\n    if (source.query) {\n      if (result.query) {\n        result.query = {\n          ...result.query,\n          ...source.query,\n        };\n      } else {\n        result.query = source.query;\n      }\n    }\n  }\n\n  if (!Object.keys(result).length) {\n    return;\n  }\n\n  return result;\n};\n","import colors from 'ansi-colors';\n\nimport type { IR } from '~/ir/types';\n\nexport interface ValidatorIssue {\n  /**\n   * Machine-readable issue code\n   *\n   * @example\n   * 'invalid_type'\n   */\n  code: 'duplicate_key' | 'invalid_type' | 'missing_required_field';\n  /**\n   * Optional additional data.\n   *\n   * @example\n   * 'expectedType'\n   */\n  context?: Record<string, any>;\n  /**\n   * Human-readable issue summary.\n   */\n  message: string;\n  /**\n   * JSONPath-like array to issue location.\n   */\n  path: ReadonlyArray<string | number>;\n  /**\n   * Error severity.\n   */\n  severity: 'error' | 'warning';\n}\n\nexport interface ValidatorResult {\n  issues: ReadonlyArray<ValidatorIssue>;\n  valid: boolean;\n}\n\nconst isSimpleKey = (key: string) => /^[A-Za-z_$][A-Za-z0-9_$]*$/.test(key);\n\nconst formatPath = (path: ReadonlyArray<string | number>): string =>\n  path\n    .map((segment, i) => {\n      if (typeof segment === 'number') {\n        return `[${segment}]`;\n      }\n\n      if (i === 0) {\n        // first segment no dot or brackets\n        return segment;\n      }\n\n      return isSimpleKey(segment)\n        ? `.${segment}`\n        : `['${segment.replace(/\"/g, \"\\\\'\")}']`;\n    })\n    .join('');\n\nconst formatValidatorIssue = (issue: ValidatorIssue): string => {\n  const pathStr = formatPath(issue.path);\n  const level =\n    issue.severity === 'error' ? colors.bold.red : colors.bold.yellow;\n\n  const highlightedMessage = issue.message.replace(/`([^`]+)`/g, (_, code) =>\n    colors.yellow(`\\`${code}\\``),\n  );\n\n  return `${level(`[${issue.severity.toUpperCase()}]`)} ${colors.cyan(pathStr)}: ${highlightedMessage}`;\n};\n\nconst shouldPrint = ({\n  context,\n  issue,\n}: {\n  context: IR.Context;\n  issue: ValidatorIssue;\n}) => {\n  if (context.config.logs.level === 'silent') {\n    return false;\n  }\n\n  if (issue.severity === 'error') {\n    return context.config.logs.level !== 'warn';\n  }\n\n  return true;\n};\n\nexport const handleValidatorResult = ({\n  context,\n  result,\n}: {\n  context: IR.Context;\n  result: ValidatorResult;\n}) => {\n  for (const issue of result.issues) {\n    if (shouldPrint({ context, issue })) {\n      console.log(formatValidatorIssue(issue));\n    }\n  }\n\n  if (!result.valid) {\n    process.exit(1);\n  }\n};\n","import { createOperationKey } from '~/ir/operation';\nimport { addNamespace, removeNamespace } from '~/openApi/shared/utils/filter';\nimport { httpMethods } from '~/openApi/shared/utils/operation';\nimport type { Logger } from '~/utils/logger';\n\nimport type {\n  OpenApiV2_0_X,\n  OperationObject,\n  PathItemObject,\n  PathsObject,\n} from '../types/spec';\n\n/**\n * Replace source spec with filtered version.\n */\nexport const filterSpec = ({\n  logger,\n  operations,\n  preserveOrder,\n  schemas,\n  spec,\n}: {\n  logger: Logger;\n  operations: Set<string>;\n  parameters: Set<string>;\n  preserveOrder: boolean;\n  requestBodies: Set<string>;\n  responses: Set<string>;\n  schemas: Set<string>;\n  spec: OpenApiV2_0_X;\n}) => {\n  const eventFilterSpec = logger.timeEvent('filter-spec');\n  if (spec.definitions) {\n    const filtered: typeof spec.definitions = {};\n\n    if (preserveOrder) {\n      for (const [name, source] of Object.entries(spec.definitions)) {\n        if (schemas.has(addNamespace('schema', name))) {\n          filtered[name] = source;\n        }\n      }\n    } else {\n      for (const key of schemas) {\n        const { name } = removeNamespace(key);\n        const source = spec.definitions[name];\n        if (source) {\n          filtered[name] = source;\n        }\n      }\n    }\n\n    spec.definitions = filtered;\n  }\n\n  if (spec.paths) {\n    for (const entry of Object.entries(spec.paths)) {\n      const path = entry[0] as keyof PathsObject;\n      const pathItem = entry[1] as PathItemObject;\n\n      for (const method of httpMethods) {\n        // @ts-expect-error\n        const operation = pathItem[method] as OperationObject;\n        if (!operation) {\n          continue;\n        }\n\n        const key = addNamespace(\n          'operation',\n          createOperationKey({ method, path }),\n        );\n        if (!operations.has(key)) {\n          // @ts-expect-error\n          delete pathItem[method];\n        }\n      }\n\n      // remove paths that have no operations left\n      if (!Object.keys(pathItem).length) {\n        delete spec.paths[path];\n      }\n    }\n  }\n  eventFilterSpec.timeEnd();\n};\n","const fileLikeRegExp =\n  /^(application\\/(pdf|rtf|msword|vnd\\.(ms-|openxmlformats-officedocument\\.)|zip|x-(7z|tar|rar|zip|iso)|octet-stream|gzip|x-msdownload|json\\+download|xml|x-yaml|x-7z-compressed|x-tar)|text\\/(yaml|css|javascript)|audio\\/(mpeg|wav)|video\\/(mp4|x-matroska)|image\\/(vnd\\.adobe\\.photoshop|svg\\+xml))(; ?charset=[^;]+)?$/i;\nconst jsonMimeRegExp = /^application\\/(.*\\+)?json(;.*)?$/i;\nconst multipartFormDataMimeRegExp = /^multipart\\/form-data(;.*)?$/i;\nconst textMimeRegExp = /^text\\/[a-z0-9.+-]+(;.*)?$/i;\nconst xWwwFormUrlEncodedMimeRegExp =\n  /^application\\/x-www-form-urlencoded(;.*)?$/i;\nconst octetStreamMimeRegExp = /^application\\/octet-stream(;.*)?$/i;\n\nexport type IRMediaType =\n  | 'form-data'\n  | 'json'\n  | 'text'\n  | 'url-search-params'\n  | 'octet-stream';\n\nexport const isMediaTypeFileLike = ({\n  mediaType,\n}: {\n  mediaType: string;\n}): boolean => {\n  fileLikeRegExp.lastIndex = 0;\n  return fileLikeRegExp.test(mediaType);\n};\n\nexport const mediaTypeToIrMediaType = ({\n  mediaType,\n}: {\n  mediaType: string;\n}): IRMediaType | undefined => {\n  jsonMimeRegExp.lastIndex = 0;\n  if (jsonMimeRegExp.test(mediaType)) {\n    return 'json';\n  }\n\n  multipartFormDataMimeRegExp.lastIndex = 0;\n  if (multipartFormDataMimeRegExp.test(mediaType)) {\n    return 'form-data';\n  }\n\n  textMimeRegExp.lastIndex = 0;\n  if (textMimeRegExp.test(mediaType)) {\n    return 'text';\n  }\n\n  xWwwFormUrlEncodedMimeRegExp.lastIndex = 0;\n  if (xWwwFormUrlEncodedMimeRegExp.test(mediaType)) {\n    return 'url-search-params';\n  }\n\n  octetStreamMimeRegExp.lastIndex = 0;\n  if (octetStreamMimeRegExp.test(mediaType)) {\n    return 'octet-stream';\n  }\n\n  return;\n};\n","import type { IRMediaType } from '~/ir/mediaType';\nimport { isMediaTypeFileLike, mediaTypeToIrMediaType } from '~/ir/mediaType';\n\nimport type {\n  ReferenceObject,\n  ResponseObject,\n  SchemaObject,\n} from '../types/spec';\n\ninterface Content {\n  mediaType: string;\n  schema: SchemaObject | ReferenceObject | undefined;\n  type: IRMediaType | undefined;\n}\n\nexport const contentToSchema = ({\n  content,\n}: {\n  content: Content;\n}): SchemaObject | undefined => {\n  const { mediaType, schema } = content;\n\n  if (schema && '$ref' in schema) {\n    return {\n      allOf: [{ ...schema }],\n    };\n  }\n\n  if (!schema) {\n    if (isMediaTypeFileLike({ mediaType })) {\n      return {\n        format: 'binary',\n        type: 'string',\n      };\n    }\n    return;\n  }\n\n  if (\n    schema.type === 'string' &&\n    !schema.format &&\n    isMediaTypeFileLike({ mediaType })\n  ) {\n    return {\n      ...schema,\n      format: 'binary',\n    };\n  }\n\n  return schema;\n};\n\nexport const mediaTypeObjects = ({\n  mimeTypes,\n  response,\n}: {\n  mimeTypes: ReadonlyArray<string> | undefined;\n  response: Pick<ResponseObject, 'schema'>;\n}): ReadonlyArray<Content> => {\n  const objects: Array<Content> = [];\n\n  for (const mediaType of mimeTypes ?? []) {\n    objects.push({\n      mediaType,\n      schema: response.schema,\n      type: mediaTypeToIrMediaType({ mediaType }),\n    });\n  }\n\n  return objects;\n};\n","import type { Config } from '~/types/config';\n\nimport type { IR } from './types';\n\nexport function getPaginationKeywordsRegExp(\n  pagination: Config['parser']['pagination'],\n): RegExp {\n  const pattern = `^(${pagination.keywords.join('|')})$`;\n  return new RegExp(pattern);\n}\n\nexport interface Pagination {\n  in: 'body' | 'cookie' | 'header' | 'path' | 'query';\n  name: string;\n  schema: IR.SchemaObject;\n}\n","import { refToName } from '~/utils/ref';\n\nexport const discriminatorValues = (\n  $ref: string,\n  mapping?: Record<string, string>,\n  shouldUseRefAsValue?: () => boolean,\n): ReadonlyArray<string> => {\n  const values: Array<string> = [];\n\n  for (const name in mapping) {\n    if (mapping[name] === $ref) {\n      values.push(name);\n    }\n  }\n\n  if (!values.length && (!shouldUseRefAsValue || shouldUseRefAsValue())) {\n    return [refToName($ref)];\n  }\n\n  return values;\n};\n","import type { IR } from '~/ir/types';\nimport { addItemsToSchema } from '~/ir/utils';\nimport type {\n  SchemaState,\n  SchemaType,\n  SchemaWithRequired,\n} from '~/openApi/shared/types/schema';\nimport { discriminatorValues } from '~/openApi/shared/utils/discriminator';\nimport { refToName } from '~/utils/ref';\n\nimport type { SchemaObject } from '../types/spec';\n\nexport const getSchemaType = ({\n  schema,\n}: {\n  schema: SchemaObject;\n}): SchemaType<SchemaObject> | undefined => {\n  if (schema.type) {\n    return schema.type;\n  }\n\n  // infer object based on the presence of properties\n  if (schema.properties) {\n    return 'object';\n  }\n\n  return;\n};\n\nconst parseSchemaJsDoc = ({\n  irSchema,\n  schema,\n}: {\n  irSchema: IR.SchemaObject;\n  schema: SchemaObject;\n}) => {\n  if (schema.example) {\n    irSchema.example = schema.example;\n  }\n\n  if (schema.description) {\n    irSchema.description = schema.description;\n  }\n\n  if (schema.title) {\n    irSchema.title = schema.title;\n  }\n};\n\nconst parseSchemaMeta = ({\n  irSchema,\n  schema,\n}: {\n  irSchema: IR.SchemaObject;\n  schema: SchemaObject;\n}) => {\n  if (schema.default !== undefined) {\n    irSchema.default = schema.default;\n  }\n\n  if (schema.exclusiveMaximum) {\n    if (schema.maximum !== undefined) {\n      irSchema.exclusiveMaximum = schema.maximum;\n    }\n  } else if (schema.maximum !== undefined) {\n    irSchema.maximum = schema.maximum;\n  }\n\n  if (schema.exclusiveMinimum) {\n    if (schema.minimum !== undefined) {\n      irSchema.exclusiveMinimum = schema.minimum;\n    }\n  } else if (schema.minimum !== undefined) {\n    irSchema.minimum = schema.minimum;\n  }\n\n  if (schema.format) {\n    irSchema.format = schema.format;\n  }\n\n  if (schema.maxItems !== undefined) {\n    irSchema.maxItems = schema.maxItems;\n  }\n\n  if (schema.maxLength !== undefined) {\n    irSchema.maxLength = schema.maxLength;\n  }\n\n  if (schema.minItems !== undefined) {\n    irSchema.minItems = schema.minItems;\n  }\n\n  if (schema.minLength !== undefined) {\n    irSchema.minLength = schema.minLength;\n  }\n\n  if (schema.pattern) {\n    irSchema.pattern = schema.pattern;\n  }\n\n  if (schema.readOnly) {\n    irSchema.accessScope = 'read';\n  }\n};\n\nconst parseArray = ({\n  context,\n  irSchema = {},\n  schema,\n  state,\n}: {\n  context: IR.Context;\n  irSchema?: IR.SchemaObject;\n  schema: SchemaObject;\n  state: SchemaState;\n}): IR.SchemaObject => {\n  if (schema.maxItems && schema.maxItems === schema.minItems) {\n    irSchema.type = 'tuple';\n  } else {\n    irSchema.type = 'array';\n  }\n\n  let schemaItems: Array<IR.SchemaObject> = [];\n\n  if (schema.items) {\n    const irItemsSchema = schemaToIrSchema({\n      context,\n      schema: schema.items,\n      state,\n    });\n\n    if (\n      !schemaItems.length &&\n      schema.maxItems &&\n      schema.maxItems === schema.minItems\n    ) {\n      schemaItems = Array(schema.maxItems).fill(irItemsSchema);\n    } else {\n      if ('$ref' in schema.items) {\n        schemaItems.push(irItemsSchema);\n      } else {\n        const ofArray = schema.items.allOf;\n        if (ofArray && ofArray.length > 1 && !schema.items['x-nullable']) {\n          // bring composition up to avoid incorrectly nested arrays\n          irSchema = {\n            ...irSchema,\n            ...irItemsSchema,\n          };\n        } else {\n          schemaItems.push(irItemsSchema);\n        }\n      }\n    }\n  }\n\n  irSchema = addItemsToSchema({\n    items: schemaItems,\n    schema: irSchema,\n  });\n\n  return irSchema;\n};\n\nconst parseBoolean = ({\n  irSchema = {},\n}: {\n  context: IR.Context;\n  irSchema?: IR.SchemaObject;\n  schema: SchemaObject;\n  state: SchemaState;\n}): IR.SchemaObject => {\n  irSchema.type = 'boolean';\n\n  return irSchema;\n};\n\nconst parseNumber = ({\n  irSchema = {},\n  schema,\n}: {\n  context: IR.Context;\n  irSchema?: IR.SchemaObject;\n  schema: SchemaWithRequired<SchemaObject, 'type'>;\n  state: SchemaState;\n}): IR.SchemaObject => {\n  irSchema.type = schema.type;\n\n  return irSchema;\n};\n\nconst parseObject = ({\n  context,\n  irSchema = {},\n  schema,\n  state,\n}: {\n  context: IR.Context;\n  irSchema?: IR.SchemaObject;\n  schema: SchemaObject;\n  state: SchemaState;\n}): IR.SchemaObject => {\n  irSchema.type = 'object';\n\n  const schemaProperties: Record<string, IR.SchemaObject> = {};\n\n  for (const name in schema.properties) {\n    const property = schema.properties[name]!;\n    if (typeof property === 'boolean') {\n      // TODO: parser - handle boolean properties\n    } else {\n      const irPropertySchema = schemaToIrSchema({\n        context,\n        schema: property,\n        state,\n      });\n      schemaProperties[name] = irPropertySchema;\n    }\n  }\n\n  if (Object.keys(schemaProperties).length) {\n    irSchema.properties = schemaProperties;\n  }\n\n  if (schema.additionalProperties === undefined) {\n    if (!irSchema.properties) {\n      irSchema.additionalProperties = {\n        type: 'unknown',\n      };\n    }\n  } else if (typeof schema.additionalProperties === 'boolean') {\n    // Avoid [key: string]: never for empty objects with additionalProperties: false inside allOf\n    // This would override inherited properties from other schemas in the composition\n    const isEmptyObjectInAllOf =\n      state.inAllOf &&\n      schema.additionalProperties === false &&\n      (!schema.properties || !Object.keys(schema.properties).length);\n\n    if (!isEmptyObjectInAllOf) {\n      irSchema.additionalProperties = {\n        type: schema.additionalProperties ? 'unknown' : 'never',\n      };\n    }\n  } else {\n    const irAdditionalPropertiesSchema = schemaToIrSchema({\n      context,\n      schema: schema.additionalProperties,\n      state,\n    });\n    irSchema.additionalProperties = irAdditionalPropertiesSchema;\n  }\n\n  if (schema.required) {\n    irSchema.required = schema.required;\n  }\n\n  return irSchema;\n};\n\nconst parseString = ({\n  irSchema = {},\n}: {\n  context: IR.Context;\n  irSchema?: IR.SchemaObject;\n  schema: SchemaObject;\n  state: SchemaState;\n}): IR.SchemaObject => {\n  irSchema.type = 'string';\n\n  return irSchema;\n};\n\nconst initIrSchema = ({\n  schema,\n}: {\n  schema: SchemaObject;\n}): IR.SchemaObject => {\n  const irSchema: IR.SchemaObject = {};\n\n  parseSchemaJsDoc({\n    irSchema,\n    schema,\n  });\n\n  return irSchema;\n};\n\nconst parseAllOf = ({\n  context,\n  schema,\n  state,\n}: {\n  context: IR.Context;\n  schema: SchemaWithRequired<SchemaObject, 'allOf'>;\n  state: SchemaState;\n}): IR.SchemaObject => {\n  let irSchema = initIrSchema({ schema });\n\n  const schemaItems: Array<IR.SchemaObject> = [];\n  const schemaType = getSchemaType({ schema });\n\n  const compositionSchemas = schema.allOf;\n\n  for (const compositionSchema of compositionSchemas) {\n    const originalInAllOf = state.inAllOf;\n    // Don't propagate inAllOf flag to $ref schemas to avoid issues with reusable components\n    if (!('$ref' in compositionSchema)) {\n      state.inAllOf = true;\n    }\n    const irCompositionSchema = schemaToIrSchema({\n      context,\n      schema: compositionSchema,\n      state,\n    });\n    state.inAllOf = originalInAllOf;\n    if (state.inAllOf === undefined) {\n      delete state.inAllOf;\n    }\n\n    if (schema.required) {\n      if (irCompositionSchema.required) {\n        irCompositionSchema.required = [\n          ...irCompositionSchema.required,\n          ...schema.required,\n        ];\n      } else {\n        irCompositionSchema.required = schema.required;\n      }\n    }\n\n    schemaItems.push(irCompositionSchema);\n\n    if (compositionSchema.$ref) {\n      const ref = context.resolveRef<SchemaObject>(compositionSchema.$ref);\n      // `$ref` should be passed from the root `parseSchema()` call\n      if (ref.discriminator && state.$ref) {\n        const values = discriminatorValues(state.$ref);\n        const valueSchemas: ReadonlyArray<IR.SchemaObject> = values.map(\n          (value) => ({\n            const: value,\n            type: 'string',\n          }),\n        );\n        const irDiscriminatorSchema: IR.SchemaObject = {\n          properties: {\n            [ref.discriminator]:\n              valueSchemas.length > 1\n                ? {\n                    items: valueSchemas,\n                    logicalOperator: 'or',\n                  }\n                : valueSchemas[0]!,\n          },\n          type: 'object',\n        };\n        if (ref.required?.includes(ref.discriminator)) {\n          irDiscriminatorSchema.required = [ref.discriminator];\n        }\n        schemaItems.push(irDiscriminatorSchema);\n      }\n    }\n  }\n\n  if (schemaType === 'object') {\n    const irObjectSchema = parseOneType({\n      context,\n      schema: {\n        ...schema,\n        type: 'object',\n      },\n      state,\n    });\n\n    if (irObjectSchema.properties) {\n      for (const requiredProperty of irObjectSchema.required ?? []) {\n        if (!irObjectSchema.properties[requiredProperty]) {\n          for (const compositionSchema of compositionSchemas) {\n            // TODO: parser - this could be probably resolved more accurately\n            const finalCompositionSchema = compositionSchema.$ref\n              ? context.resolveRef<SchemaObject>(compositionSchema.$ref)\n              : compositionSchema;\n\n            if (\n              getSchemaType({ schema: finalCompositionSchema }) === 'object'\n            ) {\n              const irCompositionSchema = parseOneType({\n                context,\n                schema: {\n                  ...finalCompositionSchema,\n                  type: 'object',\n                },\n                state,\n              });\n\n              if (irCompositionSchema.properties?.[requiredProperty]) {\n                irObjectSchema.properties[requiredProperty] =\n                  irCompositionSchema.properties[requiredProperty];\n                break;\n              }\n            }\n          }\n        }\n      }\n      schemaItems.push(irObjectSchema);\n    }\n  }\n\n  irSchema = addItemsToSchema({\n    items: schemaItems,\n    logicalOperator: 'and',\n    mutateSchemaOneItem: true,\n    schema: irSchema,\n  });\n\n  if (schema['x-nullable']) {\n    // nest composition to avoid producing an intersection with null\n    const nestedItems: Array<IR.SchemaObject> = [\n      {\n        type: 'null',\n      },\n    ];\n\n    if (schemaItems.length) {\n      nestedItems.unshift(irSchema);\n    }\n\n    irSchema = {\n      items: nestedItems,\n      logicalOperator: 'or',\n    };\n\n    // TODO: parser - this is a hack to bring back up meta fields\n    // without it, some schemas were missing original deprecated\n    if (nestedItems[0]!.deprecated) {\n      irSchema.deprecated = nestedItems[0]!.deprecated;\n    }\n\n    // TODO: parser - this is a hack to bring back up meta fields\n    // without it, some schemas were missing original description\n    if (nestedItems[0]!.description) {\n      irSchema.description = nestedItems[0]!.description;\n    }\n  }\n\n  return irSchema;\n};\n\nconst parseEnum = ({\n  context,\n  schema,\n  state,\n}: {\n  context: IR.Context;\n  schema: SchemaWithRequired<SchemaObject, 'enum'>;\n  state: SchemaState;\n}): IR.SchemaObject => {\n  let irSchema = initIrSchema({ schema });\n\n  irSchema.type = 'enum';\n\n  const schemaItems: Array<IR.SchemaObject> = [];\n\n  for (const [index, enumValue] of schema.enum.entries()) {\n    const typeOfEnumValue = typeof enumValue;\n    let enumType: SchemaType<SchemaObject> | 'null' | undefined;\n\n    if (\n      typeOfEnumValue === 'string' ||\n      typeOfEnumValue === 'number' ||\n      typeOfEnumValue === 'boolean'\n    ) {\n      enumType = typeOfEnumValue;\n    } else if (typeOfEnumValue === 'object' && Array.isArray(enumValue)) {\n      enumType = 'array';\n    } else if (enumValue === null) {\n      // nullable must be true\n      if (schema['x-nullable']) {\n        enumType = 'null';\n      }\n    } else {\n      console.warn(\n        '',\n        `unhandled \"${typeOfEnumValue}\" typeof value \"${enumValue}\" for enum`,\n        schema.enum,\n      );\n    }\n\n    if (!enumType) {\n      continue;\n    }\n\n    const irTypeSchema = parseOneType({\n      context,\n      schema: {\n        description: schema['x-enum-descriptions']?.[index],\n        title:\n          schema['x-enum-varnames']?.[index] ?? schema['x-enumNames']?.[index],\n        // cast enum to string temporarily\n        type: enumType === 'null' ? 'string' : enumType,\n      },\n      state,\n    });\n\n    irTypeSchema.const = enumValue;\n\n    // cast enum back\n    if (enumType === 'null') {\n      irTypeSchema.type = enumType;\n    }\n\n    if (irTypeSchema.type === 'array') {\n      irTypeSchema.type = 'tuple';\n    }\n\n    schemaItems.push(irTypeSchema);\n  }\n\n  irSchema = addItemsToSchema({\n    items: schemaItems,\n    schema: irSchema,\n  });\n\n  return irSchema;\n};\n\nconst parseRef = ({\n  context,\n  schema,\n  state,\n}: {\n  context: IR.Context;\n  schema: SchemaWithRequired<SchemaObject, '$ref'>;\n  state: SchemaState;\n}): IR.SchemaObject => {\n  const irSchema: IR.SchemaObject = {};\n  // Inline non-component refs (e.g. #/paths/...) to avoid generating orphaned named types\n  const isComponentsRef = schema.$ref.startsWith('#/definitions/');\n  if (!isComponentsRef) {\n    if (!state.circularReferenceTracker.has(schema.$ref)) {\n      const refSchema = context.resolveRef<SchemaObject>(schema.$ref);\n      const originalRef = state.$ref;\n      state.$ref = schema.$ref;\n      const irSchema = schemaToIrSchema({\n        context,\n        schema: refSchema,\n        state,\n      });\n      state.$ref = originalRef;\n      return irSchema;\n    }\n    // Fallback to preserving the ref if circular\n  }\n\n  // refs using unicode characters become encoded, didn't investigate why\n  // but the suspicion is this comes from `@hey-api/json-schema-ref-parser`\n  irSchema.$ref = decodeURI(schema.$ref);\n\n  // rewrite definitions refs as the internal schema follows OpenAPI 3.x syntax\n  // and stores all definitions as reusable schemas\n  irSchema.$ref = irSchema.$ref.replace(\n    /#\\/definitions\\/([^/]+)/g,\n    '#/components/schemas/$1',\n  );\n\n  if (!state.circularReferenceTracker.has(schema.$ref)) {\n    const refSchema = context.resolveRef<SchemaObject>(schema.$ref);\n    const originalRef = state.$ref;\n    state.$ref = schema.$ref;\n    schemaToIrSchema({\n      context,\n      schema: refSchema,\n      state,\n    });\n    state.$ref = originalRef;\n  }\n\n  return irSchema;\n};\n\nconst parseNullableType = ({\n  context,\n  irSchema,\n  schema,\n  state,\n}: {\n  context: IR.Context;\n  irSchema?: IR.SchemaObject;\n  schema: SchemaWithRequired<SchemaObject, 'type'>;\n  state: SchemaState;\n}): IR.SchemaObject => {\n  if (!irSchema) {\n    irSchema = initIrSchema({ schema });\n  }\n\n  const typeIrSchema: IR.SchemaObject = {};\n\n  parseSchemaMeta({ irSchema: typeIrSchema, schema });\n\n  if (typeIrSchema.default === null) {\n    // clear to avoid duplicate default inside the non-null schema.\n    // this would produce incorrect validator output\n    delete typeIrSchema.default;\n  }\n\n  const schemaItems: Array<IR.SchemaObject> = [\n    parseOneType({\n      context,\n      irSchema: typeIrSchema,\n      schema,\n      state,\n    }),\n    {\n      type: 'null',\n    },\n  ];\n\n  irSchema = addItemsToSchema({\n    items: schemaItems,\n    schema: irSchema,\n  });\n\n  return irSchema;\n};\n\nconst parseType = ({\n  context,\n  schema,\n  state,\n}: {\n  context: IR.Context;\n  schema: SchemaWithRequired<SchemaObject, 'type'>;\n  state: SchemaState;\n}): IR.SchemaObject => {\n  const irSchema = initIrSchema({ schema });\n\n  parseSchemaMeta({ irSchema, schema });\n\n  const type = getSchemaType({ schema });\n\n  if (!type) {\n    return irSchema;\n  }\n\n  if (schema['x-nullable']) {\n    return parseNullableType({\n      context,\n      irSchema,\n      schema: {\n        ...schema,\n        type,\n      },\n      state,\n    });\n  }\n\n  return parseOneType({\n    context,\n    irSchema,\n    schema: {\n      ...schema,\n      type,\n    },\n    state,\n  });\n};\n\nconst parseOneType = ({\n  context,\n  irSchema,\n  schema,\n  state,\n}: {\n  context: IR.Context;\n  irSchema?: IR.SchemaObject;\n  schema: SchemaWithRequired<SchemaObject, 'type'>;\n  state: SchemaState;\n}): IR.SchemaObject => {\n  if (!irSchema) {\n    irSchema = initIrSchema({ schema });\n\n    parseSchemaMeta({ irSchema, schema });\n  }\n\n  switch (schema.type) {\n    case 'array':\n      return parseArray({\n        context,\n        irSchema,\n        schema,\n        state,\n      });\n    case 'boolean':\n      return parseBoolean({\n        context,\n        irSchema,\n        schema,\n        state,\n      });\n    case 'integer':\n    case 'number':\n      return parseNumber({\n        context,\n        irSchema,\n        schema,\n        state,\n      });\n    case 'object':\n      return parseObject({\n        context,\n        irSchema,\n        schema,\n        state,\n      });\n    case 'string':\n      return parseString({\n        context,\n        irSchema,\n        schema,\n        state,\n      });\n    default:\n      // gracefully handle invalid type\n      return parseUnknown({\n        context,\n        irSchema,\n        schema,\n      });\n  }\n};\n\nconst parseUnknown = ({\n  irSchema,\n  schema,\n}: {\n  context: IR.Context;\n  irSchema?: IR.SchemaObject;\n  schema: SchemaObject;\n}): IR.SchemaObject => {\n  if (!irSchema) {\n    irSchema = initIrSchema({ schema });\n  }\n\n  irSchema.type = 'unknown';\n\n  parseSchemaMeta({ irSchema, schema });\n\n  return irSchema;\n};\n\nexport const schemaToIrSchema = ({\n  context,\n  schema,\n  state,\n}: {\n  context: IR.Context;\n  schema: SchemaObject;\n  state: SchemaState | undefined;\n}): IR.SchemaObject => {\n  if (!state) {\n    state = {\n      circularReferenceTracker: new Set(),\n    };\n  }\n\n  if (state.$ref) {\n    state.circularReferenceTracker.add(state.$ref);\n  }\n\n  if (schema.$ref) {\n    return parseRef({\n      context,\n      schema: schema as SchemaWithRequired<SchemaObject, '$ref'>,\n      state,\n    });\n  }\n\n  if (schema.enum) {\n    return parseEnum({\n      context,\n      schema: schema as SchemaWithRequired<SchemaObject, 'enum'>,\n      state,\n    });\n  }\n\n  if (schema.allOf) {\n    return parseAllOf({\n      context,\n      schema: schema as SchemaWithRequired<SchemaObject, 'allOf'>,\n      state,\n    });\n  }\n\n  // infer object based on the presence of properties\n  if (schema.type || schema.properties) {\n    return parseType({\n      context,\n      schema: schema as SchemaWithRequired<SchemaObject, 'type'>,\n      state,\n    });\n  }\n\n  return parseUnknown({ context, schema });\n};\n\nexport const parseSchema = ({\n  $ref,\n  context,\n  schema,\n}: {\n  $ref: string;\n  context: IR.Context;\n  schema: SchemaObject;\n}) => {\n  if (!context.ir.components) {\n    context.ir.components = {};\n  }\n\n  if (!context.ir.components.schemas) {\n    context.ir.components.schemas = {};\n  }\n\n  context.ir.components.schemas[refToName($ref)] = schemaToIrSchema({\n    context,\n    schema,\n    state: {\n      $ref,\n      circularReferenceTracker: new Set(),\n    },\n  });\n};\n","import { getPaginationKeywordsRegExp } from '~/ir/pagination';\nimport type { IR } from '~/ir/types';\nimport type { SchemaType } from '~/openApi/shared/types/schema';\n\nimport type { ParameterObject, ReferenceObject } from '../types/spec';\nimport type { SchemaObject } from '../types/spec';\nimport { getSchemaType } from './schema';\n\nconst isPaginationType = (\n  schemaType: SchemaType<SchemaObject> | undefined,\n): boolean =>\n  schemaType === 'boolean' ||\n  schemaType === 'integer' ||\n  schemaType === 'number' ||\n  schemaType === 'string';\n\n// We handle only simple values for now, up to 1 nested field\nexport const paginationField = ({\n  context,\n  name,\n  schema,\n}: {\n  context: IR.Context;\n  name: string;\n  schema:\n    | ParameterObject\n    | SchemaObject\n    | ReferenceObject\n    | {\n        in: undefined;\n      };\n}): boolean | string => {\n  const paginationRegExp = getPaginationKeywordsRegExp(\n    context.config.parser.pagination,\n  );\n  if (paginationRegExp.test(name)) {\n    return true;\n  }\n\n  if ('$ref' in schema) {\n    const ref = context.resolveRef<ParameterObject | SchemaObject>(\n      schema.$ref ?? '',\n    );\n\n    if ('in' in ref && ref.in) {\n      const refSchema =\n        'schema' in ref\n          ? ref.schema\n          : {\n              ...ref,\n              in: undefined,\n            };\n\n      return paginationField({\n        context,\n        name,\n        schema: refSchema,\n      });\n    }\n\n    return paginationField({\n      context,\n      name,\n      schema: ref,\n    });\n  }\n\n  if ('in' in schema) {\n    if (!schema.in) {\n      return false;\n    }\n\n    const finalSchema =\n      'schema' in schema\n        ? schema.schema\n        : {\n            ...schema,\n            in: undefined,\n          };\n\n    return paginationField({\n      context,\n      name,\n      schema: finalSchema,\n    });\n  }\n\n  for (const name in schema.properties) {\n    const paginationRegExp = getPaginationKeywordsRegExp(\n      context.config.parser.pagination,\n    );\n\n    if (paginationRegExp.test(name)) {\n      const property = schema.properties[name]!;\n\n      if (typeof property !== 'boolean' && !('$ref' in property)) {\n        const schemaType = getSchemaType({ schema: property });\n        // TODO: resolve deeper references\n\n        if (isPaginationType(schemaType)) {\n          return name;\n        }\n      }\n    }\n  }\n\n  for (const allOf of schema.allOf ?? []) {\n    const pagination = paginationField({\n      context,\n      name,\n      schema: allOf,\n    });\n    if (pagination) {\n      return pagination;\n    }\n  }\n\n  return false;\n};\n","import type { IR, IRBodyObject } from '~/ir/types';\nimport type { State } from '~/openApi/shared/types/state';\nimport { operationToId } from '~/openApi/shared/utils/operation';\n\nimport type {\n  OperationObject,\n  ParameterObject,\n  PathItemObject,\n  ResponseObject,\n  SchemaObject,\n  SecuritySchemeObject,\n} from '../types/spec';\nimport { contentToSchema, mediaTypeObjects } from './mediaType';\nimport { paginationField } from './pagination';\nimport { schemaToIrSchema } from './schema';\n\ninterface Operation\n  extends Omit<OperationObject, 'parameters'>,\n    Pick<IR.OperationObject, 'parameters'> {\n  requestBody?: OperationObject['parameters'];\n}\n\nconst parseOperationJsDoc = ({\n  irOperation,\n  operation,\n}: {\n  irOperation: IR.OperationObject;\n  operation: Operation;\n}) => {\n  if (operation.deprecated !== undefined) {\n    irOperation.deprecated = operation.deprecated;\n  }\n\n  if (operation.description) {\n    irOperation.description = operation.description;\n  }\n\n  if (operation.summary) {\n    irOperation.summary = operation.summary;\n  }\n\n  if (operation.tags?.length) {\n    irOperation.tags = operation.tags;\n  }\n};\n\nconst initIrOperation = ({\n  context,\n  method,\n  operation,\n  path,\n  state,\n}: Pick<IR.OperationObject, 'method' | 'path'> & {\n  context: IR.Context;\n  operation: Operation;\n  state: State;\n}): IR.OperationObject => {\n  const irOperation: IR.OperationObject = {\n    id: operationToId({\n      context,\n      id: operation.operationId,\n      method,\n      path,\n      state,\n    }),\n    method,\n    path,\n  };\n\n  if (operation.operationId) {\n    irOperation.operationId = operation.operationId;\n  }\n\n  parseOperationJsDoc({\n    irOperation,\n    operation,\n  });\n\n  return irOperation;\n};\n\nconst operationToIrOperation = ({\n  context,\n  method,\n  operation,\n  path,\n  securitySchemesMap,\n  state,\n}: Pick<IR.OperationObject, 'method' | 'path'> & {\n  context: IR.Context;\n  operation: Operation;\n  securitySchemesMap: Map<string, SecuritySchemeObject>;\n  state: State;\n}): IR.OperationObject => {\n  const irOperation = initIrOperation({\n    context,\n    method,\n    operation,\n    path,\n    state,\n  });\n\n  if (operation.parameters) {\n    irOperation.parameters = operation.parameters;\n  }\n\n  let isRequestBodyRequired = false;\n  const requestBodyObject: IRBodyObject = {\n    mediaType: '',\n    schema: {\n      properties: {},\n      required: [],\n      type: 'object',\n    },\n  };\n  const requestBodyObjectRequired: Array<string> = [];\n\n  for (const requestBodyParameter of operation.requestBody ?? []) {\n    const requestBody =\n      '$ref' in requestBodyParameter\n        ? context.resolveRef<ParameterObject>(requestBodyParameter.$ref)\n        : requestBodyParameter;\n    const schema: SchemaObject =\n      requestBody.in === 'body'\n        ? requestBody.schema\n        : {\n            ...requestBody,\n            format: requestBody.type === 'file' ? 'binary' : requestBody.format,\n            required: undefined,\n            type: requestBody.type === 'file' ? 'string' : requestBody.type,\n          };\n    const contents = mediaTypeObjects({\n      mimeTypes: operation.consumes,\n      response: { schema },\n    });\n    // TODO: add support for multiple content types, for now prefer JSON\n    const content =\n      contents.find((content) => content.type === 'json') || contents[0];\n\n    if (content) {\n      const pagination = paginationField({\n        context,\n        name: '',\n        schema:\n          content.schema && '$ref' in content.schema\n            ? {\n                allOf: [{ ...content.schema }],\n                description: requestBody.description,\n              }\n            : {\n                description: requestBody.description,\n                ...content.schema,\n              },\n      });\n\n      const irSchema = schemaToIrSchema({\n        context,\n        schema:\n          '$ref' in requestBody\n            ? {\n                allOf: [\n                  {\n                    ...requestBody,\n                    $ref: requestBody.$ref as string,\n                    required: [],\n                    type: 'string',\n                  },\n                ],\n                description: requestBody.description,\n              }\n            : content.schema && '$ref' in content.schema\n              ? {\n                  allOf: [{ ...content.schema }],\n                  description: requestBody.description,\n                }\n              : {\n                  description: requestBody.description,\n                  ...content.schema,\n                },\n        state: undefined,\n      });\n\n      requestBodyObject.mediaType = content.mediaType;\n\n      if (requestBody.in === 'body') {\n        requestBodyObject.schema = irSchema;\n      } else {\n        requestBodyObject.schema.properties![requestBody.name] = irSchema;\n\n        if (requestBody.required) {\n          requestBodyObjectRequired.push(requestBody.name);\n        }\n      }\n\n      if (pagination) {\n        requestBodyObject.pagination = pagination;\n      }\n\n      if (content.type) {\n        requestBodyObject.type = content.type;\n      }\n    }\n\n    if (requestBody.required) {\n      isRequestBodyRequired = true;\n    }\n  }\n\n  if (requestBodyObject.mediaType) {\n    if (requestBodyObjectRequired.length) {\n      requestBodyObject.schema.required = requestBodyObjectRequired;\n    }\n\n    irOperation.body = requestBodyObject;\n\n    if (isRequestBodyRequired) {\n      irOperation.body.required = isRequestBodyRequired;\n    }\n  }\n\n  for (const name in operation.responses) {\n    if (!irOperation.responses) {\n      irOperation.responses = {};\n    }\n\n    const response = operation.responses[name]!;\n    const responseObject =\n      '$ref' in response\n        ? context.resolveRef<ResponseObject>(response.$ref)\n        : response;\n    const contents = mediaTypeObjects({\n      // assume JSON by default\n      mimeTypes: operation.produces ? operation.produces : ['application/json'],\n      response: responseObject,\n    });\n    // TODO: add support for multiple content types, for now prefer JSON\n    const content =\n      contents.find((content) => content.type === 'json') || contents[0];\n\n    if (content) {\n      irOperation.responses[name] = {\n        mediaType: content.mediaType,\n        schema: schemaToIrSchema({\n          context,\n          schema: {\n            description: responseObject.description,\n            ...contentToSchema({ content }),\n          },\n          state: undefined,\n        }),\n      };\n    } else {\n      irOperation.responses[name] = {\n        schema: {\n          description: responseObject.description,\n          // TODO: parser - cover all statues with empty response bodies\n          // 1xx, 204, 205, 304\n          type: name === '204' ? 'void' : 'unknown',\n        },\n      };\n    }\n  }\n\n  if (operation.security) {\n    const securitySchemeObjects: Map<string, IR.SecurityObject> = new Map();\n\n    for (const securityRequirementObject of operation.security) {\n      for (const name in securityRequirementObject) {\n        const securitySchemeObject = securitySchemesMap.get(name);\n\n        if (!securitySchemeObject) {\n          continue;\n        }\n\n        let irSecuritySchemeObject: IR.SecurityObject | undefined;\n\n        if (securitySchemeObject.type === 'apiKey') {\n          irSecuritySchemeObject = securitySchemeObject;\n        }\n\n        if (securitySchemeObject.type === 'basic') {\n          irSecuritySchemeObject = {\n            description: securitySchemeObject.description,\n            scheme: 'basic',\n            type: 'http',\n          };\n        }\n\n        if (securitySchemeObject.type === 'oauth2') {\n          irSecuritySchemeObject = {\n            description: securitySchemeObject.description,\n            flows: {},\n            type: 'oauth2',\n          };\n\n          switch (securitySchemeObject.flow) {\n            case 'accessCode':\n              irSecuritySchemeObject.flows.authorizationCode = {\n                authorizationUrl: securitySchemeObject.authorizationUrl!,\n                scopes: securitySchemeObject.scopes,\n                tokenUrl: securitySchemeObject.tokenUrl!,\n              };\n              break;\n            case 'application':\n              irSecuritySchemeObject.flows.clientCredentials = {\n                scopes: securitySchemeObject.scopes,\n                tokenUrl: securitySchemeObject.tokenUrl!,\n              };\n              break;\n            case 'implicit':\n              irSecuritySchemeObject.flows.implicit = {\n                authorizationUrl: securitySchemeObject.authorizationUrl!,\n                scopes: securitySchemeObject.scopes,\n              };\n              break;\n            case 'password':\n              irSecuritySchemeObject.flows.password = {\n                scopes: securitySchemeObject.scopes,\n                tokenUrl: securitySchemeObject.tokenUrl!,\n              };\n              break;\n          }\n        }\n\n        if (!irSecuritySchemeObject) {\n          continue;\n        }\n\n        securitySchemeObjects.set(name, irSecuritySchemeObject);\n      }\n    }\n\n    if (securitySchemeObjects.size) {\n      irOperation.security = Array.from(securitySchemeObjects.values());\n    }\n  }\n\n  // TODO: parser - handle servers\n  // qux: operation.servers\n\n  return irOperation;\n};\n\nexport const parsePathOperation = ({\n  context,\n  method,\n  operation,\n  path,\n  securitySchemesMap,\n  state,\n}: {\n  context: IR.Context;\n  method: Extract<\n    keyof PathItemObject,\n    'delete' | 'get' | 'head' | 'options' | 'patch' | 'post' | 'put' | 'trace'\n  >;\n  operation: Operation;\n  path: keyof IR.PathsObject;\n  securitySchemesMap: Map<string, SecuritySchemeObject>;\n  state: State;\n}) => {\n  if (!context.ir.paths) {\n    context.ir.paths = {};\n  }\n\n  if (!context.ir.paths[path]) {\n    context.ir.paths[path] = {};\n  }\n\n  context.ir.paths[path][method] = operationToIrOperation({\n    context,\n    method,\n    operation,\n    path,\n    securitySchemesMap,\n    state,\n  });\n};\n","import type { IR } from '~/ir/types';\n\nimport type {\n  OperationObject,\n  ParameterObject,\n  ReferenceObject,\n  SchemaObject,\n} from '../types/spec';\nimport { paginationField } from './pagination';\nimport { schemaToIrSchema } from './schema';\n\ntype Parameter = Exclude<ParameterObject, { in: 'body' }>;\n\n/**\n * Returns default parameter `explode` based on value of `collectionFormat`.\n */\nconst defaultExplode = (\n  collectionFormat: Parameter['collectionFormat'],\n): boolean => {\n  switch (collectionFormat) {\n    case 'multi':\n      return true;\n    case 'csv':\n    case 'pipes':\n    case 'ssv':\n    case 'tsv':\n    default:\n      return false;\n  }\n};\n\n/**\n * Returns default parameter `style` based on value of `in`.\n */\nconst defaultStyle = (\n  _in: Parameter['in'],\n): Required<IR.ParameterObject>['style'] => {\n  switch (_in) {\n    case 'header':\n    case 'path':\n      return 'simple';\n    case 'query':\n    default:\n      return 'form';\n  }\n};\n\nexport const parametersArrayToObject = ({\n  context,\n  operation,\n  parameters,\n}: {\n  context: IR.Context;\n  operation: OperationObject;\n  parameters?: ReadonlyArray<ParameterObject | ReferenceObject>;\n}): IR.ParametersObject | undefined => {\n  if (!parameters || !Object.keys(parameters).length) {\n    return;\n  }\n\n  const parametersObject: IR.ParametersObject = {};\n\n  for (const parameterOrReference of parameters) {\n    const parameter =\n      '$ref' in parameterOrReference\n        ? context.dereference<ParameterObject>(parameterOrReference)\n        : parameterOrReference;\n\n    // push request body parameters into a separate field\n    if (parameter.in === 'body' || parameter.in === 'formData') {\n      // @ts-expect-error\n      if (!operation.requestBody) {\n        // @ts-expect-error\n        operation.requestBody = [];\n      }\n\n      // @ts-expect-error\n      operation.requestBody.push(parameter);\n      continue;\n    }\n\n    if (!parametersObject[parameter.in]) {\n      parametersObject[parameter.in] = {};\n    }\n\n    // lowercase keys for case insensitive access\n    parametersObject[parameter.in]![parameter.name.toLocaleLowerCase()] =\n      parameterToIrParameter({\n        $ref: `#/todo/real/path/to/parameter/${parameter.name}`,\n        context,\n        parameter,\n      });\n  }\n\n  return parametersObject;\n};\n\nconst parameterToIrParameter = ({\n  $ref,\n  context,\n  parameter,\n}: {\n  $ref: string;\n  context: IR.Context;\n  parameter: Parameter;\n}): IR.ParameterObject => {\n  const schema = parameter;\n\n  const finalSchema: SchemaObject =\n    schema && '$ref' in schema\n      ? {\n          allOf: [\n            {\n              ...schema,\n              $ref: schema.$ref as string,\n              required: Array.isArray(schema.required) ? schema.required : [],\n              type: schema.type as SchemaObject['type'],\n            },\n          ],\n          description: parameter.description,\n        }\n      : {\n          description: parameter.description,\n          ...schema,\n          required: Array.isArray(schema.required) ? schema.required : [],\n          type: schema.type as SchemaObject['type'],\n        };\n\n  const pagination = paginationField({\n    context,\n    name: parameter.name,\n    schema: finalSchema,\n  });\n\n  const style = defaultStyle(parameter.in);\n  const explode = defaultExplode(parameter.collectionFormat);\n  const allowReserved = false;\n\n  const irParameter: IR.ParameterObject = {\n    allowReserved,\n    explode,\n    location: parameter.in as IR.ParameterObject['location'],\n    name: parameter.name,\n    schema: schemaToIrSchema({\n      context,\n      schema: finalSchema,\n      state: {\n        $ref,\n        circularReferenceTracker: new Set(),\n      },\n    }),\n    style,\n  };\n\n  if (parameter.description) {\n    irParameter.description = parameter.description;\n  }\n\n  if (pagination) {\n    irParameter.pagination = pagination;\n  }\n\n  if (parameter.required) {\n    irParameter.required = parameter.required;\n  }\n\n  return irParameter;\n};\n","const parseUrlRegExp =\n  /^(([^:/?#]+):)?((\\/\\/)?([^:/?#]*)(:?([^/?#]*)))?([^?#]*)(\\?([^#]*))?(#(.*))?/;\n\ninterface Url {\n  host: string;\n  path: string;\n  port: string;\n  protocol: string;\n}\n\nexport const parseUrl = (value: string): Url => {\n  const errorResponse: Url = {\n    host: '',\n    path: '',\n    port: '',\n    protocol: '',\n  };\n\n  parseUrlRegExp.lastIndex = 0;\n  const match = value.match(parseUrlRegExp);\n\n  if (!match) {\n    return errorResponse;\n  }\n\n  const host = match[5] || '';\n\n  // value is a relative file system path\n  if (host === '.' || host === '..') {\n    return errorResponse;\n  }\n\n  const path = match[8] || '';\n  const protocol = match[2] || '';\n\n  // value is probably a Windows file system path\n  if (protocol.length === 1) {\n    return errorResponse;\n  }\n\n  return {\n    host,\n    path: path === '/' ? '' : path,\n    port: match[7] || '',\n    protocol,\n  };\n};\n","import type { IR } from '~/ir/types';\nimport { parseUrl } from '~/utils/url';\n\nexport const parseServers = ({ context }: { context: IR.Context }) => {\n  let schemes: ReadonlyArray<string> = context.spec.schemes ?? [];\n  let host = context.spec.host ?? '';\n  const path = context.spec.basePath ?? '';\n\n  for (const input of context.config.input) {\n    if (typeof input.path === 'string') {\n      const url = parseUrl(input.path);\n\n      if (!schemes.length) {\n        if (url.protocol) {\n          schemes = [url.protocol] as typeof schemes;\n        }\n      }\n\n      if (!host) {\n        host = `${url.host}${url.port ? `:${url.port}` : ''}`;\n      }\n    }\n  }\n\n  if (!schemes.length) {\n    schemes = [''];\n  }\n\n  const servers = schemes\n    .map((scheme) => `${scheme ? `${scheme}://` : ''}${host}${path}`)\n    .filter(Boolean);\n\n  if (servers.length) {\n    context.ir.servers = servers.map((url) => ({\n      url,\n    }));\n  }\n};\n","import { createOperationKey } from '~/ir/operation';\nimport { httpMethods } from '~/openApi/shared/utils/operation';\nimport type {\n  ValidatorIssue,\n  ValidatorResult,\n} from '~/openApi/shared/utils/validator';\nimport type { Logger } from '~/utils/logger';\n\nimport type { OpenApiV2_0_X, PathItemObject, PathsObject } from '../types/spec';\n\nexport const validateOpenApiSpec = (\n  spec: OpenApiV2_0_X,\n  logger: Logger,\n): ValidatorResult => {\n  const eventValidate = logger.timeEvent('validate');\n  const issues: Array<ValidatorIssue> = [];\n  const operationIds = new Map();\n\n  if (spec.paths) {\n    for (const entry of Object.entries(spec.paths)) {\n      const path = entry[0] as keyof PathsObject;\n      const pathItem = entry[1] as PathItemObject;\n      for (const method of httpMethods) {\n        if (method === 'trace') {\n          continue;\n        }\n\n        const operation = pathItem[method];\n        if (!operation) {\n          continue;\n        }\n\n        const operationKey = createOperationKey({ method, path });\n\n        if (operation.operationId) {\n          if (!operationIds.has(operation.operationId)) {\n            operationIds.set(operation.operationId, operationKey);\n          } else {\n            issues.push({\n              code: 'duplicate_key',\n              context: {\n                key: 'operationId',\n                value: operation.operationId,\n              },\n              message:\n                'Duplicate `operationId` found. Each `operationId` must be unique.',\n              path: ['paths', path, method, 'operationId'],\n              severity: 'error',\n            });\n          }\n        }\n      }\n    }\n  }\n\n  eventValidate.timeEnd();\n  return {\n    issues,\n    valid: !issues.some((issue) => issue.severity === 'error'),\n  };\n};\n","import type { IR } from '~/ir/types';\nimport { buildResourceMetadata } from '~/openApi/shared/graph/meta';\nimport { transformOpenApiSpec } from '~/openApi/shared/transforms';\nimport type { State } from '~/openApi/shared/types/state';\nimport {\n  createFilteredDependencies,\n  createFilters,\n  hasFilters,\n} from '~/openApi/shared/utils/filter';\nimport { buildGraph } from '~/openApi/shared/utils/graph';\nimport { mergeParametersObjects } from '~/openApi/shared/utils/parameter';\nimport { handleValidatorResult } from '~/openApi/shared/utils/validator';\n\nimport type {\n  OpenApiV2_0_X,\n  OperationObject,\n  PathItemObject,\n  PathsObject,\n  SecuritySchemeObject,\n} from '../types/spec';\nimport { filterSpec } from './filter';\nimport { parsePathOperation } from './operation';\nimport { parametersArrayToObject } from './parameter';\nimport { parseSchema } from './schema';\nimport { parseServers } from './server';\nimport { validateOpenApiSpec } from './validate';\n\ntype PathKeys<T extends keyof PathsObject = keyof PathsObject> =\n  keyof T extends infer K ? (K extends `/${string}` ? K : never) : never;\n\nexport const parseV2_0_X = (context: IR.Context<OpenApiV2_0_X>) => {\n  if (context.config.parser.validate_EXPERIMENTAL) {\n    const result = validateOpenApiSpec(context.spec, context.logger);\n    handleValidatorResult({ context, result });\n  }\n\n  const shouldFilterSpec = hasFilters(context.config.parser.filters);\n  if (shouldFilterSpec) {\n    const filters = createFilters(\n      context.config.parser.filters,\n      context.spec,\n      context.logger,\n    );\n    const { graph } = buildGraph(context.spec, context.logger);\n    const { resourceMetadata } = buildResourceMetadata(graph, context.logger);\n    const sets = createFilteredDependencies({\n      filters,\n      logger: context.logger,\n      resourceMetadata,\n    });\n    filterSpec({\n      ...sets,\n      logger: context.logger,\n      preserveOrder: filters.preserveOrder,\n      spec: context.spec,\n    });\n  }\n\n  transformOpenApiSpec({ context });\n\n  const state: State = {\n    ids: new Map(),\n  };\n  const securitySchemesMap = new Map<string, SecuritySchemeObject>();\n\n  for (const name in context.spec.securityDefinitions) {\n    const securitySchemeObject = context.spec.securityDefinitions[name]!;\n    securitySchemesMap.set(name, securitySchemeObject);\n  }\n\n  if (context.spec.definitions) {\n    for (const name in context.spec.definitions) {\n      const $ref = `#/definitions/${name}`;\n      const schema = context.spec.definitions[name]!;\n\n      parseSchema({\n        $ref,\n        context,\n        schema,\n      });\n    }\n  }\n\n  parseServers({ context });\n\n  for (const path in context.spec.paths) {\n    if (path.startsWith('x-')) {\n      continue;\n    }\n\n    const pathItem = context.spec.paths[path as PathKeys]!;\n\n    const finalPathItem = pathItem.$ref\n      ? {\n          ...context.resolveRef<PathItemObject>(pathItem.$ref),\n          ...pathItem,\n        }\n      : pathItem;\n\n    const commonOperation: OperationObject = {\n      consumes: context.spec.consumes,\n      produces: context.spec.produces,\n      responses: {},\n      security: context.spec.security,\n    };\n    const operationArgs: Omit<\n      Parameters<typeof parsePathOperation>[0],\n      'method'\n    > = {\n      context,\n      operation: {\n        ...commonOperation,\n        parameters: parametersArrayToObject({\n          context,\n          operation: commonOperation,\n          parameters: finalPathItem.parameters,\n        }),\n      },\n      path: path as PathKeys,\n      securitySchemesMap,\n      state,\n    };\n\n    if (finalPathItem.delete) {\n      const parameters = mergeParametersObjects({\n        source: parametersArrayToObject({\n          context,\n          operation: finalPathItem.delete,\n          parameters: finalPathItem.delete.parameters,\n        }),\n        target: operationArgs.operation.parameters,\n      });\n      parsePathOperation({\n        ...operationArgs,\n        method: 'delete',\n        operation: {\n          ...operationArgs.operation,\n          ...finalPathItem.delete,\n          parameters,\n        },\n      });\n    }\n\n    if (finalPathItem.get) {\n      const parameters = mergeParametersObjects({\n        source: parametersArrayToObject({\n          context,\n          operation: finalPathItem.get,\n          parameters: finalPathItem.get.parameters,\n        }),\n        target: operationArgs.operation.parameters,\n      });\n      parsePathOperation({\n        ...operationArgs,\n        method: 'get',\n        operation: {\n          ...operationArgs.operation,\n          ...finalPathItem.get,\n          parameters,\n        },\n      });\n    }\n\n    if (finalPathItem.head) {\n      const parameters = mergeParametersObjects({\n        source: parametersArrayToObject({\n          context,\n          operation: finalPathItem.head,\n          parameters: finalPathItem.head.parameters,\n        }),\n        target: operationArgs.operation.parameters,\n      });\n      parsePathOperation({\n        ...operationArgs,\n        method: 'head',\n        operation: {\n          ...operationArgs.operation,\n          ...finalPathItem.head,\n          parameters,\n        },\n      });\n    }\n\n    if (finalPathItem.options) {\n      const parameters = mergeParametersObjects({\n        source: parametersArrayToObject({\n          context,\n          operation: finalPathItem.options,\n          parameters: finalPathItem.options.parameters,\n        }),\n        target: operationArgs.operation.parameters,\n      });\n      parsePathOperation({\n        ...operationArgs,\n        method: 'options',\n        operation: {\n          ...operationArgs.operation,\n          ...finalPathItem.options,\n          parameters,\n        },\n      });\n    }\n\n    if (finalPathItem.patch) {\n      const parameters = mergeParametersObjects({\n        source: parametersArrayToObject({\n          context,\n          operation: finalPathItem.patch,\n          parameters: finalPathItem.patch.parameters,\n        }),\n        target: operationArgs.operation.parameters,\n      });\n      parsePathOperation({\n        ...operationArgs,\n        method: 'patch',\n        operation: {\n          ...operationArgs.operation,\n          ...finalPathItem.patch,\n          parameters,\n        },\n      });\n    }\n\n    if (finalPathItem.post) {\n      const parameters = mergeParametersObjects({\n        source: parametersArrayToObject({\n          context,\n          operation: finalPathItem.post,\n          parameters: finalPathItem.post.parameters,\n        }),\n        target: operationArgs.operation.parameters,\n      });\n      parsePathOperation({\n        ...operationArgs,\n        method: 'post',\n        operation: {\n          ...operationArgs.operation,\n          ...finalPathItem.post,\n          parameters,\n        },\n      });\n    }\n\n    if (finalPathItem.put) {\n      const parameters = mergeParametersObjects({\n        source: parametersArrayToObject({\n          context,\n          operation: finalPathItem.put,\n          parameters: finalPathItem.put.parameters,\n        }),\n        target: operationArgs.operation.parameters,\n      });\n      parsePathOperation({\n        ...operationArgs,\n        method: 'put',\n        operation: {\n          ...operationArgs.operation,\n          ...finalPathItem.put,\n          parameters,\n        },\n      });\n    }\n  }\n};\n","import { createOperationKey } from '~/ir/operation';\nimport { addNamespace, removeNamespace } from '~/openApi/shared/utils/filter';\nimport { httpMethods } from '~/openApi/shared/utils/operation';\nimport type { Logger } from '~/utils/logger';\n\nimport type { OpenApiV3_0_X, PathItemObject, PathsObject } from '../types/spec';\n\n/**\n * Replace source spec with filtered version.\n */\nexport const filterSpec = ({\n  logger,\n  operations,\n  parameters,\n  preserveOrder,\n  requestBodies,\n  responses,\n  schemas,\n  spec,\n}: {\n  logger: Logger;\n  operations: Set<string>;\n  parameters: Set<string>;\n  preserveOrder: boolean;\n  requestBodies: Set<string>;\n  responses: Set<string>;\n  schemas: Set<string>;\n  spec: OpenApiV3_0_X;\n}) => {\n  const eventFilterSpec = logger.timeEvent('filter-spec');\n  if (spec.components) {\n    if (spec.components.parameters) {\n      const filtered: typeof spec.components.parameters = {};\n\n      if (preserveOrder) {\n        for (const [name, source] of Object.entries(\n          spec.components.parameters,\n        )) {\n          if (parameters.has(addNamespace('parameter', name))) {\n            filtered[name] = source;\n          }\n        }\n      } else {\n        for (const key of parameters) {\n          const { name } = removeNamespace(key);\n          const source = spec.components.parameters[name];\n          if (source) {\n            filtered[name] = source;\n          }\n        }\n      }\n\n      spec.components.parameters = filtered;\n    }\n\n    if (spec.components.requestBodies) {\n      const filtered: typeof spec.components.requestBodies = {};\n\n      if (preserveOrder) {\n        for (const [name, source] of Object.entries(\n          spec.components.requestBodies,\n        )) {\n          if (requestBodies.has(addNamespace('body', name))) {\n            filtered[name] = source;\n          }\n        }\n      } else {\n        for (const key of requestBodies) {\n          const { name } = removeNamespace(key);\n          const source = spec.components.requestBodies[name];\n          if (source) {\n            filtered[name] = source;\n          }\n        }\n      }\n\n      spec.components.requestBodies = filtered;\n    }\n\n    if (spec.components.responses) {\n      const filtered: typeof spec.components.responses = {};\n\n      if (preserveOrder) {\n        for (const [name, source] of Object.entries(\n          spec.components.responses,\n        )) {\n          if (responses.has(addNamespace('response', name))) {\n            filtered[name] = source;\n          }\n        }\n      } else {\n        for (const key of responses) {\n          const { name } = removeNamespace(key);\n          const source = spec.components.responses[name];\n          if (source) {\n            filtered[name] = source;\n          }\n        }\n      }\n\n      spec.components.responses = filtered;\n    }\n\n    if (spec.components.schemas) {\n      const filtered: typeof spec.components.schemas = {};\n\n      if (preserveOrder) {\n        for (const [name, source] of Object.entries(spec.components.schemas)) {\n          if (schemas.has(addNamespace('schema', name))) {\n            filtered[name] = source;\n          }\n        }\n      } else {\n        for (const key of schemas) {\n          const { name } = removeNamespace(key);\n          const source = spec.components.schemas[name];\n          if (source) {\n            filtered[name] = source;\n          }\n        }\n      }\n\n      spec.components.schemas = filtered;\n    }\n  }\n\n  if (spec.paths) {\n    for (const entry of Object.entries(spec.paths)) {\n      const path = entry[0] as keyof PathsObject;\n      const pathItem = entry[1] as PathItemObject;\n\n      for (const method of httpMethods) {\n        const operation = pathItem[method];\n        if (!operation) {\n          continue;\n        }\n\n        const key = addNamespace(\n          'operation',\n          createOperationKey({ method, path }),\n        );\n        if (!operations.has(key)) {\n          delete pathItem[method];\n        }\n      }\n\n      // remove paths that have no operations left\n      if (!Object.keys(pathItem).length) {\n        delete spec.paths[path];\n      }\n    }\n  }\n  eventFilterSpec.timeEnd();\n};\n","import type { IRMediaType } from '~/ir/mediaType';\nimport { isMediaTypeFileLike, mediaTypeToIrMediaType } from '~/ir/mediaType';\n\nimport type {\n  MediaTypeObject,\n  ReferenceObject,\n  SchemaObject,\n} from '../types/spec';\n\ninterface Content {\n  mediaType: string;\n  schema: SchemaObject | ReferenceObject | undefined;\n  type: IRMediaType | undefined;\n}\n\nexport const contentToSchema = ({\n  content,\n}: {\n  content: Content;\n}): SchemaObject | undefined => {\n  const { mediaType, schema } = content;\n\n  if (schema && '$ref' in schema) {\n    return {\n      allOf: [{ ...schema }],\n    };\n  }\n\n  if (!schema) {\n    if (isMediaTypeFileLike({ mediaType })) {\n      return {\n        format: 'binary',\n        type: 'string',\n      };\n    }\n    return;\n  }\n\n  if (\n    schema.type === 'string' &&\n    !schema.format &&\n    isMediaTypeFileLike({ mediaType })\n  ) {\n    return {\n      ...schema,\n      format: 'binary',\n    };\n  }\n\n  return schema;\n};\n\nexport const mediaTypeObjects = ({\n  content,\n}: {\n  content: Record<string, MediaTypeObject> | undefined;\n}): ReadonlyArray<Content> => {\n  const objects: Array<Content> = [];\n\n  for (const mediaType in content) {\n    objects.push({\n      mediaType,\n      schema: content[mediaType]!.schema,\n      type: mediaTypeToIrMediaType({ mediaType }),\n    });\n  }\n\n  return objects;\n};\n","import type { IR } from '~/ir/types';\nimport { addItemsToSchema } from '~/ir/utils';\nimport type {\n  SchemaState,\n  SchemaType,\n  SchemaWithRequired,\n} from '~/openApi/shared/types/schema';\nimport { discriminatorValues } from '~/openApi/shared/utils/discriminator';\nimport { refToName } from '~/utils/ref';\n\nimport type { ReferenceObject, SchemaObject } from '../types/spec';\n\nexport const getSchemaType = ({\n  schema,\n}: {\n  schema: SchemaObject;\n}): SchemaType<SchemaObject> | undefined => {\n  if (schema.type) {\n    return schema.type;\n  }\n\n  // infer object based on the presence of properties\n  if (schema.properties) {\n    return 'object';\n  }\n\n  return;\n};\n\nconst parseSchemaJsDoc = ({\n  irSchema,\n  schema,\n}: {\n  irSchema: IR.SchemaObject;\n  schema: SchemaObject;\n}) => {\n  if (schema.deprecated !== undefined) {\n    irSchema.deprecated = schema.deprecated;\n  }\n\n  if (schema.example) {\n    irSchema.example = schema.example;\n  }\n\n  if (schema.description) {\n    irSchema.description = schema.description;\n  }\n\n  if (schema.title) {\n    irSchema.title = schema.title;\n  }\n};\n\nconst parseSchemaMeta = ({\n  irSchema,\n  schema,\n}: {\n  irSchema: IR.SchemaObject;\n  schema: SchemaObject;\n}) => {\n  if (schema.default !== undefined) {\n    irSchema.default = schema.default;\n  }\n\n  if (schema.exclusiveMaximum) {\n    if (schema.maximum !== undefined) {\n      irSchema.exclusiveMaximum = schema.maximum;\n    }\n  } else if (schema.maximum !== undefined) {\n    irSchema.maximum = schema.maximum;\n  }\n\n  if (schema.exclusiveMinimum) {\n    if (schema.minimum !== undefined) {\n      irSchema.exclusiveMinimum = schema.minimum;\n    }\n  } else if (schema.minimum !== undefined) {\n    irSchema.minimum = schema.minimum;\n  }\n\n  if (schema.format) {\n    irSchema.format = schema.format;\n  }\n\n  if (schema.maxItems !== undefined) {\n    irSchema.maxItems = schema.maxItems;\n  }\n\n  if (schema.maxLength !== undefined) {\n    irSchema.maxLength = schema.maxLength;\n  }\n\n  if (schema.minItems !== undefined) {\n    irSchema.minItems = schema.minItems;\n  }\n\n  if (schema.minLength !== undefined) {\n    irSchema.minLength = schema.minLength;\n  }\n\n  if (schema.pattern) {\n    irSchema.pattern = schema.pattern;\n  }\n\n  if (schema.readOnly) {\n    irSchema.accessScope = 'read';\n  } else if (schema.writeOnly) {\n    irSchema.accessScope = 'write';\n  }\n};\n\nconst parseArray = ({\n  context,\n  irSchema = {},\n  schema,\n  state,\n}: {\n  context: IR.Context;\n  irSchema?: IR.SchemaObject;\n  schema: SchemaObject;\n  state: SchemaState;\n}): IR.SchemaObject => {\n  if (schema.maxItems && schema.maxItems === schema.minItems) {\n    irSchema.type = 'tuple';\n  } else {\n    irSchema.type = 'array';\n  }\n\n  let schemaItems: Array<IR.SchemaObject> = [];\n\n  if (schema.items) {\n    const irItemsSchema = schemaToIrSchema({\n      context,\n      schema: schema.items,\n      state,\n    });\n\n    if (\n      !schemaItems.length &&\n      schema.maxItems &&\n      schema.maxItems === schema.minItems\n    ) {\n      schemaItems = Array(schema.maxItems).fill(irItemsSchema);\n    } else {\n      if ('$ref' in schema.items) {\n        schemaItems.push(irItemsSchema);\n      } else {\n        const ofArray =\n          schema.items.allOf || schema.items.anyOf || schema.items.oneOf;\n        if (ofArray && ofArray.length > 1 && !schema.items.nullable) {\n          // bring composition up to avoid incorrectly nested arrays\n          irSchema = {\n            ...irSchema,\n            ...irItemsSchema,\n          };\n        } else {\n          schemaItems.push(irItemsSchema);\n        }\n      }\n    }\n  }\n\n  irSchema = addItemsToSchema({\n    items: schemaItems,\n    schema: irSchema,\n  });\n\n  return irSchema;\n};\n\nconst parseBoolean = ({\n  irSchema = {},\n}: {\n  context: IR.Context;\n  irSchema?: IR.SchemaObject;\n  schema: SchemaObject;\n  state: SchemaState;\n}): IR.SchemaObject => {\n  irSchema.type = 'boolean';\n\n  return irSchema;\n};\n\nconst parseNumber = ({\n  irSchema = {},\n  schema,\n}: {\n  context: IR.Context;\n  irSchema?: IR.SchemaObject;\n  schema: SchemaWithRequired<SchemaObject, 'type'>;\n  state: SchemaState;\n}): IR.SchemaObject => {\n  irSchema.type = schema.type;\n\n  return irSchema;\n};\n\nconst parseObject = ({\n  context,\n  irSchema = {},\n  schema,\n  state,\n}: {\n  context: IR.Context;\n  irSchema?: IR.SchemaObject;\n  schema: SchemaObject;\n  state: SchemaState;\n}): IR.SchemaObject => {\n  irSchema.type = 'object';\n\n  const schemaProperties: Record<string, IR.SchemaObject> = {};\n\n  for (const name in schema.properties) {\n    const property = schema.properties[name]!;\n    if (typeof property === 'boolean') {\n      // TODO: parser - handle boolean properties\n    } else {\n      schemaProperties[name] = schemaToIrSchema({\n        context,\n        schema: property,\n        state,\n      });\n    }\n  }\n\n  if (Object.keys(schemaProperties).length) {\n    irSchema.properties = schemaProperties;\n  }\n\n  if (schema.additionalProperties === undefined) {\n    if (!irSchema.properties) {\n      irSchema.additionalProperties = {\n        type: 'unknown',\n      };\n    }\n  } else if (typeof schema.additionalProperties === 'boolean') {\n    // Avoid [key: string]: never for empty objects with additionalProperties: false inside allOf\n    // This would override inherited properties from other schemas in the composition\n    const isEmptyObjectInAllOf =\n      state.inAllOf &&\n      schema.additionalProperties === false &&\n      (!schema.properties || !Object.keys(schema.properties).length);\n\n    if (!isEmptyObjectInAllOf) {\n      irSchema.additionalProperties = {\n        type: schema.additionalProperties ? 'unknown' : 'never',\n      };\n    }\n  } else {\n    const irAdditionalPropertiesSchema = schemaToIrSchema({\n      context,\n      schema: schema.additionalProperties,\n      state,\n    });\n    irSchema.additionalProperties = irAdditionalPropertiesSchema;\n  }\n\n  if (schema.required) {\n    irSchema.required = schema.required;\n  }\n\n  return irSchema;\n};\n\nconst parseString = ({\n  irSchema = {},\n}: {\n  context: IR.Context;\n  irSchema?: IR.SchemaObject;\n  schema: SchemaObject;\n  state: SchemaState;\n}): IR.SchemaObject => {\n  irSchema.type = 'string';\n\n  return irSchema;\n};\n\nconst initIrSchema = ({\n  schema,\n}: {\n  schema: SchemaObject;\n}): IR.SchemaObject => {\n  const irSchema: IR.SchemaObject = {};\n\n  parseSchemaJsDoc({\n    irSchema,\n    schema,\n  });\n\n  return irSchema;\n};\n\nconst parseAllOf = ({\n  context,\n  schema,\n  state,\n}: {\n  context: IR.Context;\n  schema: SchemaWithRequired<SchemaObject, 'allOf'>;\n  state: SchemaState;\n}): IR.SchemaObject => {\n  let irSchema = initIrSchema({ schema });\n\n  const schemaItems: Array<IR.SchemaObject> = [];\n  const schemaType = getSchemaType({ schema });\n\n  const compositionSchemas = schema.allOf;\n\n  for (const compositionSchema of compositionSchemas) {\n    const originalInAllOf = state.inAllOf;\n    // Don't propagate inAllOf flag to $ref schemas to avoid issues with reusable components\n    if (!('$ref' in compositionSchema)) {\n      state.inAllOf = true;\n    }\n    const irCompositionSchema = schemaToIrSchema({\n      context,\n      schema: compositionSchema,\n      state,\n    });\n    state.inAllOf = originalInAllOf;\n    if (state.inAllOf === undefined) {\n      delete state.inAllOf;\n    }\n\n    if (schema.required) {\n      if (irCompositionSchema.required) {\n        irCompositionSchema.required = [\n          ...irCompositionSchema.required,\n          ...schema.required,\n        ];\n      } else {\n        irCompositionSchema.required = schema.required;\n      }\n    }\n\n    schemaItems.push(irCompositionSchema);\n\n    if ('$ref' in compositionSchema) {\n      const ref = context.resolveRef<SchemaObject>(compositionSchema.$ref);\n      // `$ref` should be passed from the root `parseSchema()` call\n      if (ref.discriminator && state.$ref) {\n        const values = discriminatorValues(\n          state.$ref,\n          ref.discriminator.mapping,\n          // If the ref has oneOf, we only use the schema name as the value\n          // only if current schema is part of the oneOf. Else it is extending\n          // the ref schema\n          ref.oneOf\n            ? () => ref.oneOf!.some((o) => '$ref' in o && o.$ref === state.$ref)\n            : undefined,\n        );\n\n        if (values.length > 0) {\n          const valueSchemas: ReadonlyArray<IR.SchemaObject> = values.map(\n            (value) => ({\n              const: value,\n              type: 'string',\n            }),\n          );\n          const irDiscriminatorSchema: IR.SchemaObject = {\n            properties: {\n              [ref.discriminator.propertyName]:\n                valueSchemas.length > 1\n                  ? {\n                      items: valueSchemas,\n                      logicalOperator: 'or',\n                    }\n                  : valueSchemas[0]!,\n            },\n            type: 'object',\n          };\n          if (ref.required?.includes(ref.discriminator.propertyName)) {\n            irDiscriminatorSchema.required = [ref.discriminator.propertyName];\n          }\n          schemaItems.push(irDiscriminatorSchema);\n        }\n      }\n    }\n  }\n\n  if (schemaType === 'object') {\n    const irObjectSchema = parseOneType({\n      context,\n      schema: {\n        ...schema,\n        type: 'object',\n      },\n      state,\n    });\n\n    if (irObjectSchema.properties) {\n      for (const requiredProperty of irObjectSchema.required ?? []) {\n        if (!irObjectSchema.properties[requiredProperty]) {\n          for (const compositionSchema of compositionSchemas) {\n            // TODO: parser - this could be probably resolved more accurately\n            const finalCompositionSchema =\n              '$ref' in compositionSchema\n                ? context.resolveRef<SchemaObject>(compositionSchema.$ref)\n                : compositionSchema;\n\n            if (\n              getSchemaType({ schema: finalCompositionSchema }) === 'object'\n            ) {\n              const irCompositionSchema = parseOneType({\n                context,\n                schema: {\n                  ...finalCompositionSchema,\n                  type: 'object',\n                },\n                state,\n              });\n\n              if (irCompositionSchema.properties?.[requiredProperty]) {\n                irObjectSchema.properties[requiredProperty] =\n                  irCompositionSchema.properties[requiredProperty];\n                break;\n              }\n            }\n          }\n        }\n      }\n      schemaItems.push(irObjectSchema);\n    }\n  }\n\n  irSchema = addItemsToSchema({\n    items: schemaItems,\n    logicalOperator: 'and',\n    mutateSchemaOneItem: true,\n    schema: irSchema,\n  });\n\n  if (schema.nullable) {\n    // nest composition to avoid producing an intersection with null\n    const nestedItems: Array<IR.SchemaObject> = [\n      {\n        type: 'null',\n      },\n    ];\n\n    if (schemaItems.length) {\n      nestedItems.unshift(irSchema);\n    }\n\n    irSchema = {\n      items: nestedItems,\n      logicalOperator: 'or',\n    };\n\n    // TODO: parser - this is a hack to bring back up meta fields\n    // without it, some schemas were missing original deprecated\n    if (nestedItems[0]!.deprecated) {\n      irSchema.deprecated = nestedItems[0]!.deprecated;\n    }\n\n    // TODO: parser - this is a hack to bring back up meta fields\n    // without it, some schemas were missing original description\n    if (nestedItems[0]!.description) {\n      irSchema.description = nestedItems[0]!.description;\n    }\n  }\n\n  return irSchema;\n};\n\nconst parseAnyOf = ({\n  context,\n  schema,\n  state,\n}: {\n  context: IR.Context;\n  schema: SchemaWithRequired<SchemaObject, 'anyOf'>;\n  state: SchemaState;\n}): IR.SchemaObject => {\n  let irSchema = initIrSchema({ schema });\n\n  const schemaItems: Array<IR.SchemaObject> = [];\n  const schemaType = getSchemaType({ schema });\n\n  const compositionSchemas = schema.anyOf;\n\n  for (const compositionSchema of compositionSchemas) {\n    let irCompositionSchema = schemaToIrSchema({\n      context,\n      schema: compositionSchema,\n      state,\n    });\n\n    // `$ref` should be defined with discriminators\n    if (schema.discriminator && irCompositionSchema.$ref != null) {\n      const values = discriminatorValues(\n        irCompositionSchema.$ref,\n        schema.discriminator.mapping,\n      );\n      const valueSchemas: ReadonlyArray<IR.SchemaObject> = values.map(\n        (value) => ({\n          const: value,\n          type: 'string',\n        }),\n      );\n      const irDiscriminatorSchema: IR.SchemaObject = {\n        properties: {\n          [schema.discriminator.propertyName]:\n            valueSchemas.length > 1\n              ? {\n                  items: valueSchemas,\n                  logicalOperator: 'or',\n                }\n              : valueSchemas[0]!,\n        },\n        type: 'object',\n      };\n      irCompositionSchema = {\n        items: [irDiscriminatorSchema, irCompositionSchema],\n        logicalOperator: 'and',\n      };\n    }\n\n    schemaItems.push(irCompositionSchema);\n  }\n\n  if (schema.nullable) {\n    schemaItems.push({ type: 'null' });\n  }\n\n  irSchema = addItemsToSchema({\n    items: schemaItems,\n    mutateSchemaOneItem: true,\n    schema: irSchema,\n  });\n\n  if (schemaType === 'object') {\n    // nest composition to avoid producing a union with object properties\n    const irObjectSchema = parseOneType({\n      context,\n      schema: {\n        ...schema,\n        type: 'object',\n      },\n      state,\n    });\n\n    if (irObjectSchema.properties) {\n      irSchema = {\n        items: [irSchema, irObjectSchema],\n        logicalOperator: 'and',\n      };\n    }\n  }\n\n  return irSchema;\n};\n\nconst parseEnum = ({\n  context,\n  schema,\n  state,\n}: {\n  context: IR.Context;\n  schema: SchemaWithRequired<SchemaObject, 'enum'>;\n  state: SchemaState;\n}): IR.SchemaObject => {\n  let irSchema = initIrSchema({ schema });\n\n  irSchema.type = 'enum';\n\n  const schemaItems: Array<IR.SchemaObject> = [];\n\n  for (const [index, enumValue] of schema.enum.entries()) {\n    const typeOfEnumValue = typeof enumValue;\n    let enumType: SchemaType<SchemaObject> | 'null' | undefined;\n\n    if (\n      typeOfEnumValue === 'string' ||\n      typeOfEnumValue === 'number' ||\n      typeOfEnumValue === 'boolean'\n    ) {\n      enumType = typeOfEnumValue;\n    } else if (typeOfEnumValue === 'object' && Array.isArray(enumValue)) {\n      enumType = 'array';\n    } else if (enumValue === null) {\n      // nullable must be true\n      if (schema.nullable) {\n        enumType = 'null';\n      }\n    } else {\n      console.warn(\n        '',\n        `unhandled \"${typeOfEnumValue}\" typeof value \"${enumValue}\" for enum`,\n        schema.enum,\n      );\n    }\n\n    if (!enumType) {\n      continue;\n    }\n\n    const irTypeSchema = parseOneType({\n      context,\n      schema: {\n        description: schema['x-enum-descriptions']?.[index],\n        title:\n          schema['x-enum-varnames']?.[index] ?? schema['x-enumNames']?.[index],\n        // cast enum to string temporarily\n        type: enumType === 'null' ? 'string' : enumType,\n      },\n      state,\n    });\n\n    irTypeSchema.const = enumValue;\n\n    // cast enum back\n    if (enumType === 'null') {\n      irTypeSchema.type = enumType;\n    }\n\n    if (irTypeSchema.type === 'array') {\n      irTypeSchema.type = 'tuple';\n    }\n\n    schemaItems.push(irTypeSchema);\n  }\n\n  irSchema = addItemsToSchema({\n    items: schemaItems,\n    schema: irSchema,\n  });\n\n  return irSchema;\n};\n\nconst parseOneOf = ({\n  context,\n  schema,\n  state,\n}: {\n  context: IR.Context;\n  schema: SchemaWithRequired<SchemaObject, 'oneOf'>;\n  state: SchemaState;\n}): IR.SchemaObject => {\n  let irSchema = initIrSchema({ schema });\n\n  let schemaItems: Array<IR.SchemaObject> = [];\n  const schemaType = getSchemaType({ schema });\n\n  const compositionSchemas = schema.oneOf;\n\n  for (const compositionSchema of compositionSchemas) {\n    let irCompositionSchema = schemaToIrSchema({\n      context,\n      schema: compositionSchema,\n      state,\n    });\n\n    // `$ref` should be defined with discriminators\n    if (schema.discriminator && irCompositionSchema.$ref != null) {\n      const values = discriminatorValues(\n        irCompositionSchema.$ref,\n        schema.discriminator.mapping,\n      );\n      const valueSchemas: ReadonlyArray<IR.SchemaObject> = values.map(\n        (value) => ({\n          const: value,\n          type: 'string',\n        }),\n      );\n      const irDiscriminatorSchema: IR.SchemaObject = {\n        properties: {\n          [schema.discriminator.propertyName]:\n            valueSchemas.length > 1\n              ? {\n                  items: valueSchemas,\n                  logicalOperator: 'or',\n                }\n              : valueSchemas[0]!,\n        },\n        required: [schema.discriminator.propertyName],\n        type: 'object',\n      };\n      irCompositionSchema = {\n        items: [irDiscriminatorSchema, irCompositionSchema],\n        logicalOperator: 'and',\n      };\n    }\n\n    // since we know oneOf will be using \"or\" logical operator, if the parsed\n    // composition schema also has an \"or\" operator, we can bring it up\n    // to avoid unnecessary brackets\n    if (\n      irCompositionSchema.logicalOperator === 'or' &&\n      irCompositionSchema.type !== 'array' &&\n      irCompositionSchema.items\n    ) {\n      schemaItems = schemaItems.concat(irCompositionSchema.items);\n    } else {\n      schemaItems.push(irCompositionSchema);\n    }\n  }\n\n  if (schema.nullable) {\n    schemaItems.push({ type: 'null' });\n  }\n\n  irSchema = addItemsToSchema({\n    items: schemaItems,\n    mutateSchemaOneItem: true,\n    schema: irSchema,\n  });\n\n  if (schemaType === 'object') {\n    // nest composition to avoid producing a union with object properties\n    const irObjectSchema = parseOneType({\n      context,\n      schema: {\n        ...schema,\n        type: 'object',\n      },\n      state,\n    });\n\n    if (irObjectSchema.properties) {\n      irSchema = {\n        items: [irSchema, irObjectSchema],\n        logicalOperator: 'and',\n      };\n    }\n  }\n\n  return irSchema;\n};\n\nconst parseRef = ({\n  context,\n  schema,\n  state,\n}: {\n  context: IR.Context;\n  schema: ReferenceObject;\n  state: SchemaState;\n}): IR.SchemaObject => {\n  // Inline non-component refs (e.g. #/paths/...) to avoid generating orphaned named types\n  const isComponentsRef = schema.$ref.startsWith('#/components/');\n  if (!isComponentsRef) {\n    if (!state.circularReferenceTracker.has(schema.$ref)) {\n      const refSchema = context.resolveRef<SchemaObject>(schema.$ref);\n      const originalRef = state.$ref;\n      state.$ref = schema.$ref;\n      const irSchema = schemaToIrSchema({\n        context,\n        schema: refSchema,\n        state,\n      });\n      state.$ref = originalRef;\n      return irSchema;\n    }\n    // Fallback to preserving the ref if circular\n  }\n\n  const irSchema: IR.SchemaObject = {};\n\n  // refs using unicode characters become encoded, didn't investigate why\n  // but the suspicion is this comes from `@hey-api/json-schema-ref-parser`\n  irSchema.$ref = decodeURI(schema.$ref);\n\n  if (!state.circularReferenceTracker.has(schema.$ref)) {\n    const refSchema = context.resolveRef<SchemaObject>(schema.$ref);\n    const originalRef = state.$ref;\n    state.$ref = schema.$ref;\n    schemaToIrSchema({\n      context,\n      schema: refSchema,\n      state,\n    });\n    state.$ref = originalRef;\n  }\n\n  return irSchema;\n};\n\nconst parseNullableType = ({\n  context,\n  irSchema,\n  schema,\n  state,\n}: {\n  context: IR.Context;\n  irSchema?: IR.SchemaObject;\n  schema: SchemaWithRequired<SchemaObject, 'type'>;\n  state: SchemaState;\n}): IR.SchemaObject => {\n  if (!irSchema) {\n    irSchema = initIrSchema({ schema });\n  }\n\n  const typeIrSchema: IR.SchemaObject = {};\n\n  parseSchemaMeta({ irSchema: typeIrSchema, schema });\n\n  if (typeIrSchema.default === null) {\n    // clear to avoid duplicate default inside the non-null schema.\n    // this would produce incorrect validator output\n    delete typeIrSchema.default;\n  }\n\n  const schemaItems: Array<IR.SchemaObject> = [\n    parseOneType({\n      context,\n      irSchema: typeIrSchema,\n      schema,\n      state,\n    }),\n    {\n      type: 'null',\n    },\n  ];\n\n  irSchema = addItemsToSchema({\n    items: schemaItems,\n    schema: irSchema,\n  });\n\n  return irSchema;\n};\n\nconst parseType = ({\n  context,\n  schema,\n  state,\n}: {\n  context: IR.Context;\n  schema: SchemaWithRequired<SchemaObject, 'type'>;\n  state: SchemaState;\n}): IR.SchemaObject => {\n  const irSchema = initIrSchema({ schema });\n\n  parseSchemaMeta({ irSchema, schema });\n\n  const type = getSchemaType({ schema });\n\n  if (!type) {\n    return irSchema;\n  }\n\n  if (!schema.nullable) {\n    return parseOneType({\n      context,\n      irSchema,\n      schema: {\n        ...schema,\n        type,\n      },\n      state,\n    });\n  }\n\n  return parseNullableType({\n    context,\n    irSchema,\n    schema: {\n      ...schema,\n      type,\n    },\n    state,\n  });\n};\n\nconst parseOneType = ({\n  context,\n  irSchema,\n  schema,\n  state,\n}: {\n  context: IR.Context;\n  irSchema?: IR.SchemaObject;\n  schema: SchemaWithRequired<SchemaObject, 'type'>;\n  state: SchemaState;\n}): IR.SchemaObject => {\n  if (!irSchema) {\n    irSchema = initIrSchema({ schema });\n\n    parseSchemaMeta({ irSchema, schema });\n  }\n\n  switch (schema.type) {\n    case 'array':\n      return parseArray({\n        context,\n        irSchema,\n        schema,\n        state,\n      });\n    case 'boolean':\n      return parseBoolean({\n        context,\n        irSchema,\n        schema,\n        state,\n      });\n    case 'integer':\n    case 'number':\n      return parseNumber({\n        context,\n        irSchema,\n        schema,\n        state,\n      });\n    case 'object':\n      return parseObject({\n        context,\n        irSchema,\n        schema,\n        state,\n      });\n    case 'string':\n      return parseString({\n        context,\n        irSchema,\n        schema,\n        state,\n      });\n    default:\n      // gracefully handle invalid type\n      return parseUnknown({\n        context,\n        irSchema,\n        schema,\n      });\n  }\n};\n\nconst parseUnknown = ({\n  irSchema,\n  schema,\n}: {\n  context: IR.Context;\n  irSchema?: IR.SchemaObject;\n  schema: SchemaObject;\n}): IR.SchemaObject => {\n  if (!irSchema) {\n    irSchema = initIrSchema({ schema });\n  }\n\n  irSchema.type = 'unknown';\n\n  parseSchemaMeta({ irSchema, schema });\n\n  return irSchema;\n};\n\nexport const schemaToIrSchema = ({\n  context,\n  schema,\n  state,\n}: {\n  context: IR.Context;\n  schema: SchemaObject | ReferenceObject;\n  state: SchemaState | undefined;\n}): IR.SchemaObject => {\n  if (!state) {\n    state = {\n      circularReferenceTracker: new Set(),\n    };\n  }\n\n  if (state.$ref) {\n    state.circularReferenceTracker.add(state.$ref);\n  }\n\n  if ('$ref' in schema) {\n    return parseRef({\n      context,\n      schema,\n      state,\n    });\n  }\n\n  if (schema.enum) {\n    return parseEnum({\n      context,\n      schema: schema as SchemaWithRequired<SchemaObject, 'enum'>,\n      state,\n    });\n  }\n\n  if (schema.allOf) {\n    return parseAllOf({\n      context,\n      schema: schema as SchemaWithRequired<SchemaObject, 'allOf'>,\n      state,\n    });\n  }\n\n  if (schema.anyOf) {\n    return parseAnyOf({\n      context,\n      schema: schema as SchemaWithRequired<SchemaObject, 'anyOf'>,\n      state,\n    });\n  }\n\n  if (schema.oneOf) {\n    return parseOneOf({\n      context,\n      schema: schema as SchemaWithRequired<SchemaObject, 'oneOf'>,\n      state,\n    });\n  }\n\n  // infer object based on the presence of properties\n  if (schema.type || schema.properties) {\n    return parseType({\n      context,\n      schema: schema as SchemaWithRequired<SchemaObject, 'type'>,\n      state,\n    });\n  }\n\n  return parseUnknown({ context, schema });\n};\n\nexport const parseSchema = ({\n  $ref,\n  context,\n  schema,\n}: {\n  $ref: string;\n  context: IR.Context;\n  schema: SchemaObject | ReferenceObject;\n}) => {\n  if (!context.ir.components) {\n    context.ir.components = {};\n  }\n\n  if (!context.ir.components.schemas) {\n    context.ir.components.schemas = {};\n  }\n\n  context.ir.components.schemas[refToName($ref)] = schemaToIrSchema({\n    context,\n    schema,\n    state: {\n      $ref,\n      circularReferenceTracker: new Set(),\n    },\n  });\n};\n","import { getPaginationKeywordsRegExp } from '~/ir/pagination';\nimport type { IR } from '~/ir/types';\nimport type { SchemaType } from '~/openApi/shared/types/schema';\n\nimport type {\n  ParameterObject,\n  ReferenceObject,\n  RequestBodyObject,\n} from '../types/spec';\nimport type { SchemaObject } from '../types/spec';\nimport { mediaTypeObjects } from './mediaType';\nimport { getSchemaType } from './schema';\n\nconst isPaginationType = (\n  schemaType: SchemaType<SchemaObject> | undefined,\n): boolean =>\n  schemaType === 'boolean' ||\n  schemaType === 'integer' ||\n  schemaType === 'number' ||\n  schemaType === 'string';\n\n// We handle only simple values for now, up to 1 nested field\nexport const paginationField = ({\n  context,\n  name,\n  schema,\n}: {\n  context: IR.Context;\n  name: string;\n  schema: SchemaObject | ReferenceObject;\n}): boolean | string => {\n  const paginationRegExp = getPaginationKeywordsRegExp(\n    context.config.parser.pagination,\n  );\n  if (paginationRegExp.test(name)) {\n    return true;\n  }\n\n  if ('$ref' in schema) {\n    const ref = context.resolveRef<\n      ParameterObject | RequestBodyObject | SchemaObject\n    >(schema.$ref);\n\n    if ('content' in ref || 'in' in ref) {\n      let refSchema: SchemaObject | ReferenceObject | undefined;\n\n      if ('in' in ref) {\n        refSchema = ref.schema;\n      }\n\n      if (!refSchema) {\n        // parameter or body\n        const contents = mediaTypeObjects({ content: ref.content });\n        // TODO: add support for multiple content types, for now prefer JSON\n        const content =\n          contents.find((content) => content.type === 'json') || contents[0];\n        if (content?.schema) {\n          refSchema = content.schema;\n        }\n      }\n\n      if (!refSchema) {\n        return false;\n      }\n\n      return paginationField({\n        context,\n        name,\n        schema: refSchema,\n      });\n    }\n\n    return paginationField({\n      context,\n      name,\n      schema: ref,\n    });\n  }\n\n  for (const name in schema.properties) {\n    const paginationRegExp = getPaginationKeywordsRegExp(\n      context.config.parser.pagination,\n    );\n\n    if (paginationRegExp.test(name)) {\n      const property = schema.properties[name]!;\n\n      if (typeof property !== 'boolean' && !('$ref' in property)) {\n        const schemaType = getSchemaType({ schema: property });\n        // TODO: resolve deeper references\n\n        if (isPaginationType(schemaType)) {\n          return name;\n        }\n      }\n    }\n  }\n\n  for (const allOf of schema.allOf ?? []) {\n    const pagination = paginationField({\n      context,\n      name,\n      schema: allOf,\n    });\n    if (pagination) {\n      return pagination;\n    }\n  }\n\n  return false;\n};\n","import type { IR } from '~/ir/types';\nimport type { State } from '~/openApi/shared/types/state';\nimport { operationToId } from '~/openApi/shared/utils/operation';\n\nimport type {\n  OperationObject,\n  PathItemObject,\n  RequestBodyObject,\n  ResponseObject,\n  SecuritySchemeObject,\n} from '../types/spec';\nimport { contentToSchema, mediaTypeObjects } from './mediaType';\nimport { paginationField } from './pagination';\nimport { schemaToIrSchema } from './schema';\n\ninterface Operation\n  extends Omit<OperationObject, 'parameters'>,\n    Pick<IR.OperationObject, 'parameters'> {}\n\nconst parseOperationJsDoc = ({\n  irOperation,\n  operation,\n}: {\n  irOperation: IR.OperationObject;\n  operation: Operation;\n}) => {\n  if (operation.deprecated !== undefined) {\n    irOperation.deprecated = operation.deprecated;\n  }\n\n  if (operation.description) {\n    irOperation.description = operation.description;\n  }\n\n  if (operation.summary) {\n    irOperation.summary = operation.summary;\n  }\n\n  if (operation.tags?.length) {\n    irOperation.tags = operation.tags;\n  }\n};\n\nconst initIrOperation = ({\n  context,\n  method,\n  operation,\n  path,\n  state,\n}: Pick<IR.OperationObject, 'method' | 'path'> & {\n  context: IR.Context;\n  operation: Operation;\n  state: State;\n}): IR.OperationObject => {\n  const irOperation: IR.OperationObject = {\n    id: operationToId({\n      context,\n      id: operation.operationId,\n      method,\n      path,\n      state,\n    }),\n    method,\n    path,\n  };\n\n  if (operation.operationId) {\n    irOperation.operationId = operation.operationId;\n  }\n\n  parseOperationJsDoc({\n    irOperation,\n    operation,\n  });\n\n  return irOperation;\n};\n\nconst operationToIrOperation = ({\n  context,\n  method,\n  operation,\n  path,\n  securitySchemesMap,\n  state,\n}: Pick<IR.OperationObject, 'method' | 'path'> & {\n  context: IR.Context;\n  operation: Operation;\n  securitySchemesMap: Map<string, SecuritySchemeObject>;\n  state: State;\n}): IR.OperationObject => {\n  const irOperation = initIrOperation({\n    context,\n    method,\n    operation,\n    path,\n    state,\n  });\n\n  if (operation.parameters) {\n    irOperation.parameters = operation.parameters;\n  }\n\n  if (operation.requestBody) {\n    const requestBody =\n      '$ref' in operation.requestBody\n        ? context.resolveRef<RequestBodyObject>(operation.requestBody.$ref)\n        : operation.requestBody;\n    const contents = mediaTypeObjects({ content: requestBody.content });\n    // TODO: add support for multiple content types, for now prefer JSON\n    const content =\n      contents.find((content) => content.type === 'json') || contents[0];\n\n    if (content) {\n      const pagination = paginationField({\n        context,\n        name: '',\n        schema:\n          content.schema && '$ref' in content.schema\n            ? {\n                allOf: [{ ...content.schema }],\n                description: requestBody.description,\n              }\n            : {\n                description: requestBody.description,\n                ...content.schema,\n              },\n      });\n\n      irOperation.body = {\n        mediaType: content.mediaType,\n        schema: schemaToIrSchema({\n          context,\n          schema:\n            '$ref' in operation.requestBody\n              ? {\n                  allOf: [{ ...operation.requestBody }],\n                  description: requestBody.description,\n                }\n              : content.schema && '$ref' in content.schema\n                ? {\n                    allOf: [{ ...content.schema }],\n                    description: requestBody.description,\n                  }\n                : {\n                    description: requestBody.description,\n                    ...content.schema,\n                  },\n          state: undefined,\n        }),\n      };\n\n      if (pagination) {\n        irOperation.body.pagination = pagination;\n      }\n\n      if (requestBody.required) {\n        irOperation.body.required = requestBody.required;\n      }\n\n      if (content.type) {\n        irOperation.body.type = content.type;\n      }\n    }\n  }\n\n  for (const name in operation.responses) {\n    if (!irOperation.responses) {\n      irOperation.responses = {};\n    }\n\n    const response = operation.responses[name]!;\n    const responseObject =\n      '$ref' in response\n        ? context.resolveRef<ResponseObject>(response.$ref)\n        : response;\n    const contents = mediaTypeObjects({ content: responseObject.content });\n    // TODO: add support for multiple content types, for now prefer JSON\n    const content =\n      contents.find((content) => content.type === 'json') || contents[0];\n\n    if (content) {\n      irOperation.responses[name] = {\n        mediaType: content.mediaType,\n        schema: schemaToIrSchema({\n          context,\n          schema: {\n            description: responseObject.description,\n            ...contentToSchema({ content }),\n          },\n          state: undefined,\n        }),\n      };\n    } else {\n      irOperation.responses[name] = {\n        schema: {\n          description: responseObject.description,\n          // TODO: parser - cover all statues with empty response bodies\n          // 1xx, 204, 205, 304\n          type: name === '204' ? 'void' : 'unknown',\n        },\n      };\n    }\n  }\n\n  if (operation.security) {\n    const securitySchemeObjects: Map<string, IR.SecurityObject> = new Map();\n\n    for (const securityRequirementObject of operation.security) {\n      for (const name in securityRequirementObject) {\n        const securitySchemeObject = securitySchemesMap.get(name);\n\n        if (!securitySchemeObject) {\n          continue;\n        }\n\n        securitySchemeObjects.set(name, securitySchemeObject);\n      }\n    }\n\n    if (securitySchemeObjects.size) {\n      irOperation.security = Array.from(securitySchemeObjects.values());\n    }\n  }\n\n  // TODO: parser - handle servers\n  // qux: operation.servers\n\n  return irOperation;\n};\n\nexport const parsePathOperation = ({\n  context,\n  method,\n  operation,\n  path,\n  securitySchemesMap,\n  state,\n}: {\n  context: IR.Context;\n  method: Extract<\n    keyof PathItemObject,\n    'delete' | 'get' | 'head' | 'options' | 'patch' | 'post' | 'put' | 'trace'\n  >;\n  operation: Operation;\n  path: keyof IR.PathsObject;\n  securitySchemesMap: Map<string, SecuritySchemeObject>;\n  state: State;\n}) => {\n  if (!context.ir.paths) {\n    context.ir.paths = {};\n  }\n\n  if (!context.ir.paths[path]) {\n    context.ir.paths[path] = {};\n  }\n\n  if (operation.servers) {\n    context.ir.servers = [...(context.ir.servers ?? []), ...operation.servers];\n  }\n\n  context.ir.paths[path][method] = operationToIrOperation({\n    context,\n    method,\n    operation,\n    path,\n    securitySchemesMap,\n    state,\n  });\n};\n","import type { IR } from '~/ir/types';\nimport { refToName } from '~/utils/ref';\n\nimport type {\n  ParameterObject,\n  ReferenceObject,\n  SchemaObject,\n} from '../types/spec';\nimport { mediaTypeObjects } from './mediaType';\nimport { paginationField } from './pagination';\nimport { schemaToIrSchema } from './schema';\n\n/**\n * Returns default parameter `allowReserved` based on value of `in`.\n */\nconst defaultAllowReserved = (\n  _in: ParameterObject['in'],\n): boolean | undefined => {\n  switch (_in) {\n    // this keyword only applies to parameters with an `in` value of `query`\n    case 'query':\n      return false;\n    default:\n      return;\n  }\n};\n\n/**\n * Returns default parameter `explode` based on value of `style`.\n */\nconst defaultExplode = (style: Required<ParameterObject>['style']): boolean => {\n  switch (style) {\n    // default value for `deepObject` is `false`, but that behavior is undefined\n    // so we use `true` to make this work with the `client-fetch` package\n    case 'deepObject':\n    case 'form':\n      return true;\n    default:\n      return false;\n  }\n};\n\n/**\n * Returns default parameter `style` based on value of `in`.\n */\nconst defaultStyle = (\n  _in: ParameterObject['in'],\n): Required<IR.ParameterObject>['style'] => {\n  switch (_in) {\n    case 'header':\n    case 'path':\n      return 'simple';\n    case 'cookie':\n    case 'query':\n      return 'form';\n  }\n};\n\nexport const parametersArrayToObject = ({\n  context,\n  parameters,\n}: {\n  context: IR.Context;\n  parameters?: ReadonlyArray<ParameterObject | ReferenceObject>;\n}): IR.ParametersObject | undefined => {\n  if (!parameters || !Object.keys(parameters).length) {\n    return;\n  }\n\n  const parametersObject: IR.ParametersObject = {};\n\n  for (const parameterOrReference of parameters) {\n    const parameter =\n      '$ref' in parameterOrReference\n        ? context.dereference<ParameterObject>(parameterOrReference)\n        : parameterOrReference;\n\n    if (!parametersObject[parameter.in]) {\n      parametersObject[parameter.in] = {};\n    }\n\n    // lowercase keys for case insensitive access\n    parametersObject[parameter.in]![parameter.name.toLocaleLowerCase()] =\n      parameterToIrParameter({\n        $ref: `#/todo/real/path/to/parameter/${parameter.name}`,\n        context,\n        parameter,\n      });\n  }\n\n  return parametersObject;\n};\n\nconst parameterToIrParameter = ({\n  $ref,\n  context,\n  parameter,\n}: {\n  $ref: string;\n  context: IR.Context;\n  parameter: ParameterObject;\n}): IR.ParameterObject => {\n  // TODO: parser - fix\n  let schema = parameter.schema;\n\n  if (!schema) {\n    const contents = mediaTypeObjects({ content: parameter.content });\n    // TODO: add support for multiple content types, for now prefer JSON\n    const content =\n      contents.find((content) => content.type === 'json') || contents[0];\n    if (content) {\n      schema = content.schema;\n    }\n  }\n\n  const finalSchema: SchemaObject =\n    schema && '$ref' in schema\n      ? {\n          allOf: [{ ...schema }],\n          deprecated: parameter.deprecated,\n          description: parameter.description,\n        }\n      : {\n          deprecated: parameter.deprecated,\n          description: parameter.description,\n          ...schema,\n        };\n\n  const pagination = paginationField({\n    context,\n    name: parameter.name,\n    schema: finalSchema,\n  });\n\n  const style = parameter.style || defaultStyle(parameter.in);\n  const explode =\n    parameter.explode !== undefined ? parameter.explode : defaultExplode(style);\n  const allowReserved =\n    parameter.allowReserved !== undefined\n      ? parameter.allowReserved\n      : defaultAllowReserved(parameter.in);\n\n  const irParameter: IR.ParameterObject = {\n    allowReserved,\n    explode,\n    location: parameter.in,\n    name: parameter.name,\n    schema: schemaToIrSchema({\n      context,\n      schema: finalSchema,\n      state: {\n        $ref,\n        circularReferenceTracker: new Set(),\n      },\n    }),\n    style,\n  };\n\n  if (parameter.deprecated) {\n    irParameter.deprecated = parameter.deprecated;\n  }\n\n  if (parameter.description) {\n    irParameter.description = parameter.description;\n  }\n\n  if (pagination) {\n    irParameter.pagination = pagination;\n  }\n\n  if (parameter.required) {\n    irParameter.required = parameter.required;\n  }\n\n  return irParameter;\n};\n\nexport const parseParameter = ({\n  $ref,\n  context,\n  parameter,\n}: {\n  $ref: string;\n  context: IR.Context;\n  parameter: ParameterObject;\n}) => {\n  if (!context.ir.components) {\n    context.ir.components = {};\n  }\n\n  if (!context.ir.components.parameters) {\n    context.ir.components.parameters = {};\n  }\n\n  context.ir.components.parameters[refToName($ref)] = parameterToIrParameter({\n    $ref,\n    context,\n    parameter,\n  });\n};\n","import type { IR } from '~/ir/types';\nimport { refToName } from '~/utils/ref';\n\nimport type { RequestBodyObject, SchemaObject } from '../types/spec';\nimport { mediaTypeObjects } from './mediaType';\nimport { schemaToIrSchema } from './schema';\n\nconst requestBodyToIrRequestBody = ({\n  $ref,\n  context,\n  requestBody,\n}: {\n  $ref: string;\n  context: IR.Context;\n  requestBody: RequestBodyObject;\n}): IR.RequestBodyObject => {\n  // TODO: parser - fix\n  const contents = mediaTypeObjects({ content: requestBody.content });\n  // TODO: add support for multiple content types, for now prefer JSON\n  const content =\n    contents.find((content) => content.type === 'json') || contents[0];\n  const schema = content ? content.schema : undefined;\n\n  const finalSchema: SchemaObject = {\n    description: requestBody.description,\n    ...schema,\n  };\n\n  const irRequestBody: IR.RequestBodyObject = {\n    schema: schemaToIrSchema({\n      context,\n      schema: finalSchema,\n      state: {\n        $ref,\n        circularReferenceTracker: new Set(),\n      },\n    }),\n  };\n\n  if (requestBody.description) {\n    irRequestBody.description = requestBody.description;\n  }\n\n  if (requestBody.required) {\n    irRequestBody.required = requestBody.required;\n  }\n\n  return irRequestBody;\n};\n\nexport const parseRequestBody = ({\n  $ref,\n  context,\n  requestBody,\n}: {\n  $ref: string;\n  context: IR.Context;\n  requestBody: RequestBodyObject;\n}) => {\n  if (!context.ir.components) {\n    context.ir.components = {};\n  }\n\n  if (!context.ir.components.requestBodies) {\n    context.ir.components.requestBodies = {};\n  }\n\n  context.ir.components.requestBodies[refToName($ref)] =\n    requestBodyToIrRequestBody({\n      $ref,\n      context,\n      requestBody,\n    });\n};\n","import type { IR } from '~/ir/types';\nimport { parseUrl } from '~/utils/url';\n\nexport const parseServers = ({ context }: { context: IR.Context }) => {\n  if (context.spec.servers) {\n    context.ir.servers = context.spec.servers;\n    return;\n  }\n\n  for (const input of context.config.input) {\n    if (typeof input.path === 'string') {\n      const url = parseUrl(input.path);\n      context.ir.servers = [\n        {\n          url: `${url.protocol ? `${url.protocol}://` : ''}${url.host}${url.port ? `:${url.port}` : ''}`,\n        },\n      ];\n    }\n  }\n\n  if (!context.ir.servers) {\n    context.ir.servers = [\n      {\n        url: '/',\n      },\n    ];\n  }\n};\n","import { createOperationKey } from '~/ir/operation';\nimport { httpMethods } from '~/openApi/shared/utils/operation';\nimport type {\n  ValidatorIssue,\n  ValidatorResult,\n} from '~/openApi/shared/utils/validator';\nimport type { Logger } from '~/utils/logger';\n\nimport type { OpenApiV3_0_X, PathItemObject, PathsObject } from '../types/spec';\n\nexport const validateOpenApiSpec = (\n  spec: OpenApiV3_0_X,\n  logger: Logger,\n): ValidatorResult => {\n  const eventValidate = logger.timeEvent('validate');\n  const issues: Array<ValidatorIssue> = [];\n  const operationIds = new Map();\n\n  if (spec.paths) {\n    for (const entry of Object.entries(spec.paths)) {\n      const path = entry[0] as keyof PathsObject;\n      const pathItem = entry[1] as PathItemObject;\n      for (const method of httpMethods) {\n        const operation = pathItem[method];\n        if (!operation) {\n          continue;\n        }\n\n        const operationKey = createOperationKey({ method, path });\n\n        if (operation.operationId) {\n          if (!operationIds.has(operation.operationId)) {\n            operationIds.set(operation.operationId, operationKey);\n          } else {\n            issues.push({\n              code: 'duplicate_key',\n              context: {\n                key: 'operationId',\n                value: operation.operationId,\n              },\n              message:\n                'Duplicate `operationId` found. Each `operationId` must be unique.',\n              path: ['paths', path, method, 'operationId'],\n              severity: 'error',\n            });\n          }\n        }\n      }\n    }\n  }\n\n  if (spec.servers) {\n    if (typeof spec.servers !== 'object' || !Array.isArray(spec.servers)) {\n      issues.push({\n        code: 'invalid_type',\n        message: '`servers` must be an array.',\n        path: [],\n        severity: 'error',\n      });\n    }\n\n    for (let index = 0; index < spec.servers.length; index++) {\n      const server = spec.servers[index];\n      if (!server || typeof server !== 'object') {\n        issues.push({\n          code: 'invalid_type',\n          context: {\n            actual: typeof server,\n            expected: 'object',\n          },\n          message: 'Each entry in `servers` must be an object.',\n          path: ['servers', index],\n          severity: 'error',\n        });\n      } else {\n        if (!server.url) {\n          issues.push({\n            code: 'missing_required_field',\n            context: {\n              field: 'url',\n            },\n            message: 'Missing required field `url` in server object.',\n            path: ['servers', index],\n            severity: 'error',\n          });\n        }\n      }\n    }\n  }\n\n  eventValidate.timeEnd();\n  return {\n    issues,\n    valid: !issues.some((issue) => issue.severity === 'error'),\n  };\n};\n","import type { IR } from '~/ir/types';\nimport { buildResourceMetadata } from '~/openApi/shared/graph/meta';\nimport { transformOpenApiSpec } from '~/openApi/shared/transforms';\nimport type { State } from '~/openApi/shared/types/state';\nimport {\n  createFilteredDependencies,\n  createFilters,\n  hasFilters,\n} from '~/openApi/shared/utils/filter';\nimport { buildGraph } from '~/openApi/shared/utils/graph';\nimport { mergeParametersObjects } from '~/openApi/shared/utils/parameter';\nimport { handleValidatorResult } from '~/openApi/shared/utils/validator';\n\nimport type {\n  OpenApiV3_0_X,\n  ParameterObject,\n  PathItemObject,\n  PathsObject,\n  RequestBodyObject,\n  SecuritySchemeObject,\n} from '../types/spec';\nimport { filterSpec } from './filter';\nimport { parsePathOperation } from './operation';\nimport { parametersArrayToObject, parseParameter } from './parameter';\nimport { parseRequestBody } from './requestBody';\nimport { parseSchema } from './schema';\nimport { parseServers } from './server';\nimport { validateOpenApiSpec } from './validate';\n\nexport const parseV3_0_X = (context: IR.Context<OpenApiV3_0_X>) => {\n  if (context.config.parser.validate_EXPERIMENTAL) {\n    const result = validateOpenApiSpec(context.spec, context.logger);\n    handleValidatorResult({ context, result });\n  }\n\n  const shouldFilterSpec = hasFilters(context.config.parser.filters);\n  if (shouldFilterSpec) {\n    const filters = createFilters(\n      context.config.parser.filters,\n      context.spec,\n      context.logger,\n    );\n    const { graph } = buildGraph(context.spec, context.logger);\n    const { resourceMetadata } = buildResourceMetadata(graph, context.logger);\n    const sets = createFilteredDependencies({\n      filters,\n      logger: context.logger,\n      resourceMetadata,\n    });\n    filterSpec({\n      ...sets,\n      logger: context.logger,\n      preserveOrder: filters.preserveOrder,\n      spec: context.spec,\n    });\n  }\n\n  transformOpenApiSpec({ context });\n\n  const state: State = {\n    ids: new Map(),\n  };\n  const securitySchemesMap = new Map<string, SecuritySchemeObject>();\n\n  // TODO: parser - handle more component types, old parser handles only parameters and schemas\n  if (context.spec.components) {\n    for (const name in context.spec.components.securitySchemes) {\n      const securityOrReference =\n        context.spec.components.securitySchemes[name]!;\n      const securitySchemeObject =\n        '$ref' in securityOrReference\n          ? context.resolveRef<SecuritySchemeObject>(securityOrReference.$ref)\n          : securityOrReference;\n      securitySchemesMap.set(name, securitySchemeObject);\n    }\n\n    for (const name in context.spec.components.parameters) {\n      const $ref = `#/components/parameters/${name}`;\n      const parameterOrReference = context.spec.components.parameters[name]!;\n      const parameter =\n        '$ref' in parameterOrReference\n          ? context.resolveRef<ParameterObject>(parameterOrReference.$ref)\n          : parameterOrReference;\n\n      parseParameter({\n        $ref,\n        context,\n        parameter,\n      });\n    }\n\n    for (const name in context.spec.components.requestBodies) {\n      const $ref = `#/components/requestBodies/${name}`;\n      const requestBodyOrReference =\n        context.spec.components.requestBodies[name]!;\n      const requestBody =\n        '$ref' in requestBodyOrReference\n          ? context.resolveRef<RequestBodyObject>(requestBodyOrReference.$ref)\n          : requestBodyOrReference;\n\n      parseRequestBody({\n        $ref,\n        context,\n        requestBody,\n      });\n    }\n\n    for (const name in context.spec.components.schemas) {\n      const $ref = `#/components/schemas/${name}`;\n      const schema = context.spec.components.schemas[name]!;\n\n      parseSchema({\n        $ref,\n        context,\n        schema,\n      });\n    }\n  }\n\n  parseServers({ context });\n\n  for (const path in context.spec.paths) {\n    const pathItem = context.spec.paths[path as keyof PathsObject]!;\n\n    const finalPathItem = pathItem.$ref\n      ? {\n          ...context.resolveRef<PathItemObject>(pathItem.$ref),\n          ...pathItem,\n        }\n      : pathItem;\n\n    const operationArgs: Omit<\n      Parameters<typeof parsePathOperation>[0],\n      'method' | 'operation'\n    > & {\n      operation: Omit<\n        Parameters<typeof parsePathOperation>[0]['operation'],\n        'responses'\n      >;\n    } = {\n      context,\n      operation: {\n        description: finalPathItem.description,\n        parameters: parametersArrayToObject({\n          context,\n          parameters: finalPathItem.parameters,\n        }),\n        security: context.spec.security,\n        servers: finalPathItem.servers,\n        summary: finalPathItem.summary,\n      },\n      path: path as keyof PathsObject,\n      securitySchemesMap,\n      state,\n    };\n\n    if (finalPathItem.delete) {\n      parsePathOperation({\n        ...operationArgs,\n        method: 'delete',\n        operation: {\n          ...operationArgs.operation,\n          ...finalPathItem.delete,\n          parameters: mergeParametersObjects({\n            source: parametersArrayToObject({\n              context,\n              parameters: finalPathItem.delete.parameters,\n            }),\n            target: operationArgs.operation.parameters,\n          }),\n        },\n      });\n    }\n\n    if (finalPathItem.get) {\n      parsePathOperation({\n        ...operationArgs,\n        method: 'get',\n        operation: {\n          ...operationArgs.operation,\n          ...finalPathItem.get,\n          parameters: mergeParametersObjects({\n            source: parametersArrayToObject({\n              context,\n              parameters: finalPathItem.get.parameters,\n            }),\n            target: operationArgs.operation.parameters,\n          }),\n        },\n      });\n    }\n\n    if (finalPathItem.head) {\n      parsePathOperation({\n        ...operationArgs,\n        method: 'head',\n        operation: {\n          ...operationArgs.operation,\n          ...finalPathItem.head,\n          parameters: mergeParametersObjects({\n            source: parametersArrayToObject({\n              context,\n              parameters: finalPathItem.head.parameters,\n            }),\n            target: operationArgs.operation.parameters,\n          }),\n        },\n      });\n    }\n\n    if (finalPathItem.options) {\n      parsePathOperation({\n        ...operationArgs,\n        method: 'options',\n        operation: {\n          ...operationArgs.operation,\n          ...finalPathItem.options,\n          parameters: mergeParametersObjects({\n            source: parametersArrayToObject({\n              context,\n              parameters: finalPathItem.options.parameters,\n            }),\n            target: operationArgs.operation.parameters,\n          }),\n        },\n      });\n    }\n\n    if (finalPathItem.patch) {\n      parsePathOperation({\n        ...operationArgs,\n        method: 'patch',\n        operation: {\n          ...operationArgs.operation,\n          ...finalPathItem.patch,\n          parameters: mergeParametersObjects({\n            source: parametersArrayToObject({\n              context,\n              parameters: finalPathItem.patch.parameters,\n            }),\n            target: operationArgs.operation.parameters,\n          }),\n        },\n      });\n    }\n\n    if (finalPathItem.post) {\n      parsePathOperation({\n        ...operationArgs,\n        method: 'post',\n        operation: {\n          ...operationArgs.operation,\n          ...finalPathItem.post,\n          parameters: mergeParametersObjects({\n            source: parametersArrayToObject({\n              context,\n              parameters: finalPathItem.post.parameters,\n            }),\n            target: operationArgs.operation.parameters,\n          }),\n        },\n      });\n    }\n\n    if (finalPathItem.put) {\n      parsePathOperation({\n        ...operationArgs,\n        method: 'put',\n        operation: {\n          ...operationArgs.operation,\n          ...finalPathItem.put,\n          parameters: mergeParametersObjects({\n            source: parametersArrayToObject({\n              context,\n              parameters: finalPathItem.put.parameters,\n            }),\n            target: operationArgs.operation.parameters,\n          }),\n        },\n      });\n    }\n\n    if (finalPathItem.trace) {\n      parsePathOperation({\n        ...operationArgs,\n        method: 'trace',\n        operation: {\n          ...operationArgs.operation,\n          ...finalPathItem.trace,\n          parameters: mergeParametersObjects({\n            source: parametersArrayToObject({\n              context,\n              parameters: finalPathItem.trace.parameters,\n            }),\n            target: operationArgs.operation.parameters,\n          }),\n        },\n      });\n    }\n  }\n};\n","import { createOperationKey } from '~/ir/operation';\nimport { addNamespace, removeNamespace } from '~/openApi/shared/utils/filter';\nimport { httpMethods } from '~/openApi/shared/utils/operation';\nimport type { Logger } from '~/utils/logger';\n\nimport type { OpenApiV3_1_X, PathItemObject, PathsObject } from '../types/spec';\n\n/**\n * Replace source spec with filtered version.\n */\nexport const filterSpec = ({\n  logger,\n  operations,\n  parameters,\n  preserveOrder,\n  requestBodies,\n  responses,\n  schemas,\n  spec,\n}: {\n  logger: Logger;\n  operations: Set<string>;\n  parameters: Set<string>;\n  preserveOrder: boolean;\n  requestBodies: Set<string>;\n  responses: Set<string>;\n  schemas: Set<string>;\n  spec: OpenApiV3_1_X;\n}) => {\n  const eventFilterSpec = logger.timeEvent('filter-spec');\n  if (spec.components) {\n    if (spec.components.parameters) {\n      const filtered: typeof spec.components.parameters = {};\n\n      if (preserveOrder) {\n        for (const [name, source] of Object.entries(\n          spec.components.parameters,\n        )) {\n          if (parameters.has(addNamespace('parameter', name))) {\n            filtered[name] = source;\n          }\n        }\n      } else {\n        for (const key of parameters) {\n          const { name } = removeNamespace(key);\n          const source = spec.components.parameters[name];\n          if (source) {\n            filtered[name] = source;\n          }\n        }\n      }\n\n      spec.components.parameters = filtered;\n    }\n\n    if (spec.components.requestBodies) {\n      const filtered: typeof spec.components.requestBodies = {};\n\n      if (preserveOrder) {\n        for (const [name, source] of Object.entries(\n          spec.components.requestBodies,\n        )) {\n          if (requestBodies.has(addNamespace('body', name))) {\n            filtered[name] = source;\n          }\n        }\n      } else {\n        for (const key of requestBodies) {\n          const { name } = removeNamespace(key);\n          const source = spec.components.requestBodies[name];\n          if (source) {\n            filtered[name] = source;\n          }\n        }\n      }\n\n      spec.components.requestBodies = filtered;\n    }\n\n    if (spec.components.responses) {\n      const filtered: typeof spec.components.responses = {};\n\n      if (preserveOrder) {\n        for (const [name, source] of Object.entries(\n          spec.components.responses,\n        )) {\n          if (responses.has(addNamespace('response', name))) {\n            filtered[name] = source;\n          }\n        }\n      } else {\n        for (const key of responses) {\n          const { name } = removeNamespace(key);\n          const source = spec.components.responses[name];\n          if (source) {\n            filtered[name] = source;\n          }\n        }\n      }\n\n      spec.components.responses = filtered;\n    }\n\n    if (spec.components.schemas) {\n      const filtered: typeof spec.components.schemas = {};\n\n      if (preserveOrder) {\n        for (const [name, source] of Object.entries(spec.components.schemas)) {\n          if (schemas.has(addNamespace('schema', name))) {\n            filtered[name] = source;\n          }\n        }\n      } else {\n        for (const key of schemas) {\n          const { name } = removeNamespace(key);\n          const source = spec.components.schemas[name];\n          if (source) {\n            filtered[name] = source;\n          }\n        }\n      }\n\n      spec.components.schemas = filtered;\n    }\n  }\n\n  if (spec.paths) {\n    for (const entry of Object.entries(spec.paths)) {\n      const path = entry[0] as keyof PathsObject;\n      const pathItem = entry[1] as PathItemObject;\n\n      for (const method of httpMethods) {\n        const operation = pathItem[method];\n        if (!operation) {\n          continue;\n        }\n\n        const key = addNamespace(\n          'operation',\n          createOperationKey({ method, path }),\n        );\n        if (!operations.has(key)) {\n          delete pathItem[method];\n        }\n      }\n\n      // remove paths that have no operations left\n      if (!Object.keys(pathItem).length) {\n        delete spec.paths[path];\n      }\n    }\n  }\n  eventFilterSpec.timeEnd();\n};\n","import type { IRMediaType } from '~/ir/mediaType';\nimport { isMediaTypeFileLike, mediaTypeToIrMediaType } from '~/ir/mediaType';\n\nimport type { MediaTypeObject, SchemaObject } from '../types/spec';\n\ninterface Content {\n  mediaType: string;\n  schema: SchemaObject | undefined;\n  type: IRMediaType | undefined;\n}\n\nexport const contentToSchema = ({\n  content,\n}: {\n  content: Content;\n}): SchemaObject | undefined => {\n  const { mediaType, schema } = content;\n\n  if (!schema) {\n    if (isMediaTypeFileLike({ mediaType })) {\n      return {\n        format: 'binary',\n        type: 'string',\n      };\n    }\n    return;\n  }\n\n  if (\n    schema.type === 'string' &&\n    !schema.format &&\n    isMediaTypeFileLike({ mediaType })\n  ) {\n    return {\n      ...schema,\n      format: 'binary',\n    };\n  }\n\n  return schema;\n};\n\nexport const mediaTypeObjects = ({\n  content,\n}: {\n  content: Record<string, MediaTypeObject> | undefined;\n}): ReadonlyArray<Content> => {\n  const objects: Array<Content> = [];\n\n  for (const mediaType in content) {\n    objects.push({\n      mediaType,\n      schema: content[mediaType]!.schema,\n      type: mediaTypeToIrMediaType({ mediaType }),\n    });\n  }\n\n  return objects;\n};\n","import type { IR } from '~/ir/types';\nimport { addItemsToSchema } from '~/ir/utils';\nimport type {\n  SchemaState,\n  SchemaType,\n  SchemaWithRequired,\n} from '~/openApi/shared/types/schema';\nimport { discriminatorValues } from '~/openApi/shared/utils/discriminator';\nimport { refToName } from '~/utils/ref';\n\nimport type { SchemaObject } from '../types/spec';\n\nexport const getSchemaTypes = ({\n  schema,\n}: {\n  schema: SchemaObject;\n}): ReadonlyArray<SchemaType<SchemaObject>> => {\n  if (typeof schema.type === 'string') {\n    return [schema.type];\n  }\n\n  if (schema.type) {\n    return schema.type;\n  }\n\n  // infer object based on the presence of properties\n  if (schema.properties) {\n    return ['object'];\n  }\n\n  return [];\n};\n\nconst parseSchemaJsDoc = ({\n  irSchema,\n  schema,\n}: {\n  irSchema: IR.SchemaObject;\n  schema: SchemaObject;\n}) => {\n  if (schema.deprecated !== undefined) {\n    irSchema.deprecated = schema.deprecated;\n  }\n\n  if (schema.example) {\n    irSchema.example = schema.example;\n  }\n\n  if (schema.description) {\n    irSchema.description = schema.description;\n  }\n\n  if (schema.title) {\n    irSchema.title = schema.title;\n  }\n};\n\nconst parseSchemaMeta = ({\n  irSchema,\n  schema,\n}: {\n  irSchema: IR.SchemaObject;\n  schema: SchemaObject;\n}) => {\n  if (schema.const !== undefined) {\n    irSchema.const = schema.const;\n\n    // try to infer schema type\n    if (!schema.type) {\n      if (schema.const === null) {\n        irSchema.type = 'null';\n      } else {\n        switch (typeof schema.const) {\n          case 'bigint':\n          case 'number':\n            irSchema.type = 'number';\n            break;\n          case 'boolean':\n            irSchema.type = 'boolean';\n            break;\n          case 'string':\n            irSchema.type = 'string';\n            break;\n        }\n      }\n    }\n  }\n\n  if (schema.default !== undefined) {\n    irSchema.default = schema.default;\n  }\n\n  if (schema.exclusiveMaximum !== undefined) {\n    irSchema.exclusiveMaximum = schema.exclusiveMaximum;\n  }\n\n  if (schema.exclusiveMinimum !== undefined) {\n    irSchema.exclusiveMinimum = schema.exclusiveMinimum;\n  }\n\n  if (schema.format) {\n    irSchema.format = schema.format;\n  }\n\n  if (schema.maximum !== undefined) {\n    irSchema.maximum = schema.maximum;\n  }\n\n  if (schema.maxItems !== undefined) {\n    irSchema.maxItems = schema.maxItems;\n  }\n\n  if (schema.maxLength !== undefined) {\n    irSchema.maxLength = schema.maxLength;\n  }\n\n  if (schema.minimum !== undefined) {\n    irSchema.minimum = schema.minimum;\n  }\n\n  if (schema.minItems !== undefined) {\n    irSchema.minItems = schema.minItems;\n  }\n\n  if (schema.minLength !== undefined) {\n    irSchema.minLength = schema.minLength;\n  }\n\n  if (schema.pattern) {\n    irSchema.pattern = schema.pattern;\n  }\n\n  if (schema.readOnly) {\n    irSchema.accessScope = 'read';\n  } else if (schema.writeOnly) {\n    irSchema.accessScope = 'write';\n  }\n};\n\nconst parseArray = ({\n  context,\n  irSchema = {},\n  schema,\n  state,\n}: {\n  context: IR.Context;\n  irSchema?: IR.SchemaObject;\n  schema: SchemaObject;\n  state: SchemaState;\n}): IR.SchemaObject => {\n  if (\n    (schema.prefixItems && schema.prefixItems.length) ||\n    (schema.maxItems && schema.maxItems === schema.minItems) ||\n    schema.const !== undefined\n  ) {\n    irSchema.type = 'tuple';\n  } else {\n    irSchema.type = 'array';\n  }\n\n  let schemaItems: Array<IR.SchemaObject> = [];\n\n  for (const item of schema.prefixItems ?? []) {\n    const irItemSchema = schemaToIrSchema({\n      context,\n      schema: item,\n      state,\n    });\n    schemaItems.push(irItemSchema);\n  }\n\n  if (schema.items) {\n    const irItemsSchema = schemaToIrSchema({\n      context,\n      schema: schema.items,\n      state,\n    });\n\n    if (\n      !schemaItems.length &&\n      schema.maxItems &&\n      schema.maxItems === schema.minItems\n    ) {\n      schemaItems = Array(schema.maxItems).fill(irItemsSchema);\n    } else {\n      const ofArray =\n        schema.items.allOf || schema.items.anyOf || schema.items.oneOf;\n      if (\n        ofArray &&\n        ofArray.length > 1 &&\n        !getSchemaTypes({ schema: schema.items }).includes('null')\n      ) {\n        // bring composition up to avoid incorrectly nested arrays\n        irSchema = {\n          ...irSchema,\n          ...irItemsSchema,\n        };\n      } else {\n        schemaItems.push(irItemsSchema);\n      }\n    }\n  }\n\n  irSchema = addItemsToSchema({\n    items: schemaItems,\n    schema: irSchema,\n  });\n\n  return irSchema;\n};\n\nconst parseBoolean = ({\n  irSchema = {},\n}: {\n  context: IR.Context;\n  irSchema?: IR.SchemaObject;\n  schema: SchemaObject;\n}): IR.SchemaObject => {\n  irSchema.type = 'boolean';\n\n  return irSchema;\n};\n\nconst parseNull = ({\n  irSchema = {},\n}: {\n  context: IR.Context;\n  irSchema?: IR.SchemaObject;\n  schema: SchemaObject;\n}) => {\n  irSchema.type = 'null';\n\n  return irSchema;\n};\n\nconst parseNumber = ({\n  irSchema = {},\n  schema,\n}: {\n  context: IR.Context;\n  irSchema?: IR.SchemaObject;\n  schema: Omit<SchemaObject, 'type'> & {\n    type: SchemaType<SchemaObject>;\n  };\n}): IR.SchemaObject => {\n  irSchema.type = schema.type;\n\n  return irSchema;\n};\n\nconst parseObject = ({\n  context,\n  irSchema = {},\n  schema,\n  state,\n}: {\n  context: IR.Context;\n  irSchema?: IR.SchemaObject;\n  schema: SchemaObject;\n  state: SchemaState;\n}): IR.SchemaObject => {\n  irSchema.type = 'object';\n\n  const schemaProperties: Record<string, IR.SchemaObject> = {};\n\n  for (const name in schema.properties) {\n    const property = schema.properties[name]!;\n    if (typeof property === 'boolean') {\n      // TODO: parser - handle boolean properties\n    } else {\n      const irPropertySchema = schemaToIrSchema({\n        context,\n        schema: property,\n        state,\n      });\n      schemaProperties[name] = irPropertySchema;\n    }\n  }\n\n  if (Object.keys(schemaProperties).length) {\n    irSchema.properties = schemaProperties;\n  }\n\n  if (schema.additionalProperties === undefined) {\n    if (!irSchema.properties) {\n      irSchema.additionalProperties = {\n        type: 'unknown',\n      };\n    }\n  } else if (typeof schema.additionalProperties === 'boolean') {\n    // Avoid [key: string]: never for empty objects with additionalProperties: false inside allOf\n    // This would override inherited properties from other schemas in the composition\n    const isEmptyObjectInAllOf =\n      state.inAllOf &&\n      schema.additionalProperties === false &&\n      (!schema.properties || !Object.keys(schema.properties).length) &&\n      (!schema.patternProperties ||\n        !Object.keys(schema.patternProperties).length);\n\n    if (!isEmptyObjectInAllOf) {\n      irSchema.additionalProperties = {\n        type: schema.additionalProperties ? 'unknown' : 'never',\n      };\n    }\n  } else {\n    const irAdditionalPropertiesSchema = schemaToIrSchema({\n      context,\n      schema: schema.additionalProperties,\n      state,\n    });\n    irSchema.additionalProperties = irAdditionalPropertiesSchema;\n  }\n\n  if (schema.patternProperties) {\n    const patternProperties: Record<string, IR.SchemaObject> = {};\n\n    for (const pattern in schema.patternProperties) {\n      const patternSchema = schema.patternProperties[pattern]!;\n      const irPatternSchema = schemaToIrSchema({\n        context,\n        schema: patternSchema,\n        state,\n      });\n      patternProperties[pattern] = irPatternSchema;\n    }\n\n    if (Object.keys(patternProperties).length) {\n      irSchema.patternProperties = patternProperties;\n    }\n  }\n\n  if (schema.propertyNames) {\n    irSchema.propertyNames = schemaToIrSchema({\n      context,\n      schema: schema.propertyNames,\n      state,\n    });\n  }\n\n  if (schema.required) {\n    irSchema.required = schema.required;\n  }\n\n  return irSchema;\n};\n\nconst parseString = ({\n  irSchema = {},\n}: {\n  context: IR.Context;\n  irSchema?: IR.SchemaObject;\n  schema: SchemaObject;\n}): IR.SchemaObject => {\n  irSchema.type = 'string';\n\n  return irSchema;\n};\n\nconst initIrSchema = ({\n  schema,\n}: {\n  schema: SchemaObject;\n}): IR.SchemaObject => {\n  const irSchema: IR.SchemaObject = {};\n\n  parseSchemaJsDoc({\n    irSchema,\n    schema,\n  });\n\n  return irSchema;\n};\n\nconst parseAllOf = ({\n  context,\n  schema,\n  state,\n}: {\n  context: IR.Context;\n  schema: SchemaWithRequired<SchemaObject, 'allOf'>;\n  state: SchemaState;\n}): IR.SchemaObject => {\n  let irSchema = initIrSchema({ schema });\n\n  const schemaItems: Array<IR.SchemaObject> = [];\n  const schemaTypes = getSchemaTypes({ schema });\n\n  const compositionSchemas = schema.allOf;\n\n  for (const compositionSchema of compositionSchemas) {\n    const originalInAllOf = state.inAllOf;\n    // Don't propagate inAllOf flag to $ref schemas to avoid issues with reusable components\n    if (!('$ref' in compositionSchema)) {\n      state.inAllOf = true;\n    }\n    const irCompositionSchema = schemaToIrSchema({\n      context,\n      schema: compositionSchema,\n      state,\n    });\n    state.inAllOf = originalInAllOf;\n    if (state.inAllOf === undefined) {\n      delete state.inAllOf;\n    }\n\n    if (schema.required) {\n      if (irCompositionSchema.required) {\n        irCompositionSchema.required = [\n          ...irCompositionSchema.required,\n          ...schema.required,\n        ];\n      } else {\n        irCompositionSchema.required = schema.required;\n      }\n    }\n\n    schemaItems.push(irCompositionSchema);\n\n    if (compositionSchema.$ref) {\n      const ref = context.resolveRef<SchemaObject>(compositionSchema.$ref);\n      // `$ref` should be passed from the root `parseSchema()` call\n      if (ref.discriminator && state.$ref) {\n        const values = discriminatorValues(\n          state.$ref,\n          ref.discriminator.mapping,\n          // If the ref has oneOf, we only use the schema name as the value\n          // only if current schema is part of the oneOf. Else it is extending\n          // the ref schema\n          ref.oneOf\n            ? () => ref.oneOf!.some((o) => '$ref' in o && o.$ref === state.$ref)\n            : undefined,\n        );\n        if (values.length > 0) {\n          const valueSchemas: ReadonlyArray<IR.SchemaObject> = values.map(\n            (value) => ({\n              const: value,\n              type: 'string',\n            }),\n          );\n          const irDiscriminatorSchema: IR.SchemaObject = {\n            properties: {\n              [ref.discriminator.propertyName]:\n                valueSchemas.length > 1\n                  ? {\n                      items: valueSchemas,\n                      logicalOperator: 'or',\n                    }\n                  : valueSchemas[0]!,\n            },\n            type: 'object',\n          };\n          if (ref.required?.includes(ref.discriminator.propertyName)) {\n            irDiscriminatorSchema.required = [ref.discriminator.propertyName];\n          }\n          schemaItems.push(irDiscriminatorSchema);\n        }\n      }\n    }\n  }\n\n  if (schemaTypes.includes('object')) {\n    const irObjectSchema = parseOneType({\n      context,\n      schema: {\n        ...schema,\n        type: 'object',\n      },\n      state,\n    });\n\n    if (irObjectSchema.properties) {\n      for (const requiredProperty of irObjectSchema.required ?? []) {\n        if (!irObjectSchema.properties[requiredProperty]) {\n          for (const compositionSchema of compositionSchemas) {\n            // TODO: parser - this could be probably resolved more accurately\n            const finalCompositionSchema = compositionSchema.$ref\n              ? context.resolveRef<SchemaObject>(compositionSchema.$ref)\n              : compositionSchema;\n\n            if (\n              getSchemaTypes({ schema: finalCompositionSchema }).includes(\n                'object',\n              )\n            ) {\n              const irCompositionSchema = parseOneType({\n                context,\n                schema: {\n                  ...finalCompositionSchema,\n                  type: 'object',\n                },\n                state,\n              });\n\n              if (irCompositionSchema.properties?.[requiredProperty]) {\n                irObjectSchema.properties[requiredProperty] =\n                  irCompositionSchema.properties[requiredProperty];\n                break;\n              }\n            }\n          }\n        }\n      }\n      schemaItems.push(irObjectSchema);\n    }\n  }\n\n  irSchema = addItemsToSchema({\n    items: schemaItems,\n    logicalOperator: 'and',\n    mutateSchemaOneItem: true,\n    schema: irSchema,\n  });\n\n  if (schemaTypes.includes('null')) {\n    // nest composition to avoid producing an intersection with null\n    const nestedItems: Array<IR.SchemaObject> = [\n      {\n        type: 'null',\n      },\n    ];\n\n    if (schemaItems.length) {\n      nestedItems.unshift(irSchema);\n    }\n\n    irSchema = {\n      items: nestedItems,\n      logicalOperator: 'or',\n    };\n  }\n\n  return irSchema;\n};\n\nconst parseAnyOf = ({\n  context,\n  schema,\n  state,\n}: {\n  context: IR.Context;\n  schema: SchemaWithRequired<SchemaObject, 'anyOf'>;\n  state: SchemaState;\n}): IR.SchemaObject => {\n  let irSchema = initIrSchema({ schema });\n\n  const schemaItems: Array<IR.SchemaObject> = [];\n  const schemaTypes = getSchemaTypes({ schema });\n\n  const compositionSchemas = schema.anyOf;\n\n  for (const compositionSchema of compositionSchemas) {\n    let irCompositionSchema = schemaToIrSchema({\n      context,\n      schema: compositionSchema,\n      state,\n    });\n\n    // `$ref` should be defined with discriminators\n    if (schema.discriminator && irCompositionSchema.$ref != null) {\n      const values = discriminatorValues(\n        irCompositionSchema.$ref,\n        schema.discriminator.mapping,\n      );\n      const valueSchemas: ReadonlyArray<IR.SchemaObject> = values.map(\n        (value) => ({\n          const: value,\n          type: 'string',\n        }),\n      );\n      const irDiscriminatorSchema: IR.SchemaObject = {\n        properties: {\n          [schema.discriminator.propertyName]:\n            valueSchemas.length > 1\n              ? {\n                  items: valueSchemas,\n                  logicalOperator: 'or',\n                }\n              : valueSchemas[0]!,\n        },\n        type: 'object',\n      };\n      irCompositionSchema = {\n        items: [irDiscriminatorSchema, irCompositionSchema],\n        logicalOperator: 'and',\n      };\n    }\n\n    schemaItems.push(irCompositionSchema);\n  }\n\n  if (schemaTypes.includes('null')) {\n    schemaItems.push({ type: 'null' });\n  }\n\n  irSchema = addItemsToSchema({\n    items: schemaItems,\n    mutateSchemaOneItem: true,\n    schema: irSchema,\n  });\n\n  if (schemaTypes.includes('object')) {\n    // nest composition to avoid producing a union with object properties\n    const irObjectSchema = parseOneType({\n      context,\n      schema: {\n        ...schema,\n        type: 'object',\n      },\n      state,\n    });\n\n    if (irObjectSchema.properties) {\n      irSchema = {\n        items: [irSchema, irObjectSchema],\n        logicalOperator: 'and',\n      };\n    }\n  }\n\n  return irSchema;\n};\n\nconst parseEnum = ({\n  context,\n  schema,\n  state,\n}: {\n  context: IR.Context;\n  schema: SchemaWithRequired<SchemaObject, 'enum'>;\n  state: SchemaState;\n}): IR.SchemaObject => {\n  let irSchema = initIrSchema({ schema });\n\n  irSchema.type = 'enum';\n\n  const schemaItems: Array<IR.SchemaObject> = [];\n  const schemaTypes = getSchemaTypes({ schema });\n\n  for (const [index, enumValue] of schema.enum.entries()) {\n    const typeOfEnumValue = typeof enumValue;\n    let enumType: SchemaType<SchemaObject> | undefined;\n\n    if (\n      typeOfEnumValue === 'string' ||\n      typeOfEnumValue === 'number' ||\n      typeOfEnumValue === 'boolean'\n    ) {\n      enumType = typeOfEnumValue;\n    } else if (typeOfEnumValue === 'object' && Array.isArray(enumValue)) {\n      enumType = 'array';\n    } else if (enumValue === null) {\n      // type must contain null\n      if (schemaTypes.includes('null')) {\n        enumType = 'null';\n      }\n    } else {\n      console.warn(\n        '',\n        `unhandled \"${typeOfEnumValue}\" typeof value \"${enumValue}\" for enum`,\n        schema.enum,\n      );\n    }\n\n    if (!enumType) {\n      continue;\n    }\n\n    const irTypeSchema = parseOneType({\n      context,\n      schema: {\n        const: enumValue,\n        description: schema['x-enum-descriptions']?.[index],\n        title:\n          schema['x-enum-varnames']?.[index] ?? schema['x-enumNames']?.[index],\n        type: enumType,\n      },\n      state,\n    });\n\n    schemaItems.push(irTypeSchema);\n  }\n\n  irSchema = addItemsToSchema({\n    items: schemaItems,\n    schema: irSchema,\n  });\n\n  return irSchema;\n};\n\nconst parseOneOf = ({\n  context,\n  schema,\n  state,\n}: {\n  context: IR.Context;\n  schema: SchemaWithRequired<SchemaObject, 'oneOf'>;\n  state: SchemaState;\n}): IR.SchemaObject => {\n  let irSchema = initIrSchema({ schema });\n\n  let schemaItems: Array<IR.SchemaObject> = [];\n  const schemaTypes = getSchemaTypes({ schema });\n\n  const compositionSchemas = schema.oneOf;\n\n  for (const compositionSchema of compositionSchemas) {\n    let irCompositionSchema = schemaToIrSchema({\n      context,\n      schema: compositionSchema,\n      state,\n    });\n\n    // `$ref` should be defined with discriminators\n    if (schema.discriminator && irCompositionSchema.$ref != null) {\n      const values = discriminatorValues(\n        irCompositionSchema.$ref,\n        schema.discriminator.mapping,\n      );\n      const valueSchemas: ReadonlyArray<IR.SchemaObject> = values.map(\n        (value) => ({\n          const: value,\n          type: 'string',\n        }),\n      );\n      const irDiscriminatorSchema: IR.SchemaObject = {\n        properties: {\n          [schema.discriminator.propertyName]:\n            valueSchemas.length > 1\n              ? {\n                  items: valueSchemas,\n                  logicalOperator: 'or',\n                }\n              : valueSchemas[0]!,\n        },\n        required: [schema.discriminator.propertyName],\n        type: 'object',\n      };\n      irCompositionSchema = {\n        items: [irDiscriminatorSchema, irCompositionSchema],\n        logicalOperator: 'and',\n      };\n    }\n\n    // since we know oneOf will be using \"or\" logical operator, if the parsed\n    // composition schema also has an \"or\" operator, we can bring it up\n    // to avoid unnecessary brackets\n    if (\n      irCompositionSchema.logicalOperator === 'or' &&\n      irCompositionSchema.type !== 'array' &&\n      irCompositionSchema.items\n    ) {\n      schemaItems = schemaItems.concat(irCompositionSchema.items);\n    } else {\n      schemaItems.push(irCompositionSchema);\n    }\n  }\n\n  if (schemaTypes.includes('null')) {\n    schemaItems.push({ type: 'null' });\n  }\n\n  irSchema = addItemsToSchema({\n    items: schemaItems,\n    mutateSchemaOneItem: true,\n    schema: irSchema,\n  });\n\n  if (schemaTypes.includes('object')) {\n    // nest composition to avoid producing a union with object properties\n    const irObjectSchema = parseOneType({\n      context,\n      schema: {\n        ...schema,\n        type: 'object',\n      },\n      state,\n    });\n\n    if (irObjectSchema.properties) {\n      irSchema = {\n        items: [irSchema, irObjectSchema],\n        logicalOperator: 'and',\n      };\n    }\n  }\n\n  return irSchema;\n};\n\nconst parseRef = ({\n  context,\n  schema,\n  state,\n}: {\n  context: IR.Context;\n  schema: SchemaWithRequired<SchemaObject, '$ref'>;\n  state: SchemaState;\n}): IR.SchemaObject => {\n  // Inline non-component refs (e.g. #/paths/...) to avoid generating orphaned named types\n  const isComponentsRef = schema.$ref.startsWith('#/components/');\n  if (!isComponentsRef) {\n    if (!state.circularReferenceTracker.has(schema.$ref)) {\n      const refSchema = context.resolveRef<SchemaObject>(schema.$ref);\n      const originalRef = state.$ref;\n      state.$ref = schema.$ref;\n      const irSchema = schemaToIrSchema({\n        context,\n        schema: refSchema,\n        state,\n      });\n      state.$ref = originalRef;\n      return irSchema;\n    }\n    // Fallback to preserving the ref if circular\n  }\n\n  let irSchema = initIrSchema({ schema });\n\n  const irRefSchema: IR.SchemaObject = {};\n\n  // refs using unicode characters become encoded, didn't investigate why\n  // but the suspicion is this comes from `@hey-api/json-schema-ref-parser`\n  irRefSchema.$ref = decodeURI(schema.$ref);\n\n  if (!state.circularReferenceTracker.has(schema.$ref)) {\n    const refSchema = context.resolveRef<SchemaObject>(schema.$ref);\n    const originalRef = state.$ref;\n    state.$ref = schema.$ref;\n    schemaToIrSchema({\n      context,\n      schema: refSchema,\n      state,\n    });\n    state.$ref = originalRef;\n  }\n\n  const schemaItems: Array<IR.SchemaObject> = [];\n  schemaItems.push(irRefSchema);\n\n  if (schema.type && typeof schema.type !== 'string') {\n    if (schema.type.includes('null')) {\n      schemaItems.push({ type: 'null' });\n    }\n  }\n\n  irSchema = addItemsToSchema({\n    items: schemaItems,\n    mutateSchemaOneItem: true,\n    schema: irSchema,\n  });\n\n  return irSchema;\n};\n\nconst parseOneType = ({\n  context,\n  irSchema,\n  schema,\n  state,\n}: {\n  context: IR.Context;\n  irSchema?: IR.SchemaObject;\n  schema: Omit<SchemaObject, 'type'> & {\n    type: SchemaType<SchemaObject>;\n  };\n  state: SchemaState;\n}): IR.SchemaObject => {\n  if (!irSchema) {\n    irSchema = initIrSchema({ schema });\n    parseSchemaMeta({ irSchema, schema });\n  }\n\n  switch (schema.type) {\n    case 'array':\n      return parseArray({\n        context,\n        irSchema,\n        schema,\n        state,\n      });\n    case 'boolean':\n      return parseBoolean({\n        context,\n        irSchema,\n        schema,\n      });\n    case 'integer':\n    case 'number':\n      return parseNumber({\n        context,\n        irSchema,\n        schema,\n      });\n    case 'null':\n      return parseNull({\n        context,\n        irSchema,\n        schema,\n      });\n    case 'object':\n      return parseObject({\n        context,\n        irSchema,\n        schema,\n        state,\n      });\n    case 'string':\n      return parseString({\n        context,\n        irSchema,\n        schema,\n      });\n    default:\n      // gracefully handle invalid type\n      return parseUnknown({ context, irSchema, schema });\n  }\n};\n\nconst parseManyTypes = ({\n  context,\n  irSchema,\n  schema,\n  state,\n}: {\n  context: IR.Context;\n  irSchema?: IR.SchemaObject;\n  schema: Omit<SchemaObject, 'type'> & {\n    type: ReadonlyArray<SchemaType<SchemaObject>>;\n  };\n  state: SchemaState;\n}): IR.SchemaObject => {\n  if (!irSchema) {\n    irSchema = initIrSchema({ schema });\n  }\n\n  const typeIrSchema: IR.SchemaObject = {};\n\n  parseSchemaMeta({ irSchema: typeIrSchema, schema });\n\n  if (schema.type.includes('null') && typeIrSchema.default === null) {\n    // clear to avoid duplicate default inside the non-null schema.\n    // this would produce incorrect validator output\n    delete typeIrSchema.default;\n  }\n\n  const schemaItems: Array<IR.SchemaObject> = [];\n\n  for (const type of schema.type) {\n    if (type === 'null') {\n      schemaItems.push({ type: 'null' });\n    } else {\n      const irTypeSchema = parseOneType({\n        context,\n        irSchema: { ...typeIrSchema },\n        schema: {\n          ...schema,\n          type,\n        },\n        state,\n      });\n\n      schemaItems.push(irTypeSchema);\n    }\n  }\n\n  irSchema = addItemsToSchema({\n    items: schemaItems,\n    schema: irSchema,\n  });\n\n  return irSchema;\n};\n\nconst parseType = ({\n  context,\n  schema,\n  state,\n}: {\n  context: IR.Context;\n  schema: SchemaWithRequired<SchemaObject, 'type'>;\n  state: SchemaState;\n}): IR.SchemaObject => {\n  const irSchema = initIrSchema({ schema });\n\n  parseSchemaMeta({ irSchema, schema });\n\n  const schemaTypes = getSchemaTypes({ schema });\n\n  if (schemaTypes.length === 1) {\n    return parseOneType({\n      context,\n      irSchema,\n      schema: {\n        ...schema,\n        type: schemaTypes[0]!,\n      },\n      state,\n    });\n  }\n\n  return parseManyTypes({\n    context,\n    irSchema,\n    schema: {\n      ...schema,\n      type: schemaTypes,\n    },\n    state,\n  });\n};\n\nconst parseUnknown = ({\n  irSchema,\n  schema,\n}: {\n  context: IR.Context;\n  irSchema?: IR.SchemaObject;\n  schema: SchemaObject;\n}): IR.SchemaObject => {\n  if (!irSchema) {\n    irSchema = initIrSchema({ schema });\n  }\n\n  irSchema.type = 'unknown';\n\n  parseSchemaMeta({ irSchema, schema });\n\n  return irSchema;\n};\n\nexport const schemaToIrSchema = ({\n  context,\n  schema,\n  state,\n}: {\n  context: IR.Context;\n  schema: SchemaObject;\n  state: SchemaState | undefined;\n}): IR.SchemaObject => {\n  if (!state) {\n    state = {\n      circularReferenceTracker: new Set(),\n    };\n  }\n\n  if (state.$ref) {\n    state.circularReferenceTracker.add(state.$ref);\n  }\n\n  if (schema.$ref) {\n    return parseRef({\n      context,\n      schema: schema as SchemaWithRequired<SchemaObject, '$ref'>,\n      state,\n    });\n  }\n\n  if (schema.enum) {\n    return parseEnum({\n      context,\n      schema: schema as SchemaWithRequired<SchemaObject, 'enum'>,\n      state,\n    });\n  }\n\n  if (schema.allOf) {\n    return parseAllOf({\n      context,\n      schema: schema as SchemaWithRequired<SchemaObject, 'allOf'>,\n      state,\n    });\n  }\n\n  if (schema.anyOf) {\n    return parseAnyOf({\n      context,\n      schema: schema as SchemaWithRequired<SchemaObject, 'anyOf'>,\n      state,\n    });\n  }\n\n  if (schema.oneOf) {\n    return parseOneOf({\n      context,\n      schema: schema as SchemaWithRequired<SchemaObject, 'oneOf'>,\n      state,\n    });\n  }\n\n  // infer object based on the presence of properties\n  if (schema.type || schema.properties) {\n    return parseType({\n      context,\n      schema: schema as SchemaWithRequired<SchemaObject, 'type'>,\n      state,\n    });\n  }\n\n  return parseUnknown({ context, schema });\n};\n\nexport const parseSchema = ({\n  $ref,\n  context,\n  schema,\n}: {\n  $ref: string;\n  context: IR.Context;\n  schema: SchemaObject;\n}) => {\n  if (!context.ir.components) {\n    context.ir.components = {};\n  }\n\n  if (!context.ir.components.schemas) {\n    context.ir.components.schemas = {};\n  }\n\n  context.ir.components.schemas[refToName($ref)] = schemaToIrSchema({\n    context,\n    schema,\n    state: {\n      $ref,\n      circularReferenceTracker: new Set(),\n    },\n  });\n};\n","import { getPaginationKeywordsRegExp } from '~/ir/pagination';\nimport type { IR } from '~/ir/types';\nimport type { SchemaType } from '~/openApi/shared/types/schema';\n\nimport type { ParameterObject, RequestBodyObject } from '../types/spec';\nimport type { SchemaObject } from '../types/spec';\nimport { mediaTypeObjects } from './mediaType';\nimport { getSchemaTypes } from './schema';\n\nconst isPaginationType = (\n  schemaTypes: ReadonlyArray<SchemaType<SchemaObject>>,\n): boolean =>\n  schemaTypes.includes('boolean') ||\n  schemaTypes.includes('integer') ||\n  schemaTypes.includes('number') ||\n  schemaTypes.includes('string');\n\n// We handle only simple values for now, up to 1 nested field\nexport const paginationField = ({\n  context,\n  name,\n  schema,\n}: {\n  context: IR.Context;\n  name: string;\n  schema: SchemaObject;\n}): boolean | string => {\n  const paginationRegExp = getPaginationKeywordsRegExp(\n    context.config.parser.pagination,\n  );\n  if (paginationRegExp.test(name)) {\n    return true;\n  }\n\n  if (schema.$ref) {\n    const ref = context.resolveRef<\n      ParameterObject | RequestBodyObject | SchemaObject\n    >(schema.$ref);\n\n    if ('content' in ref || 'in' in ref) {\n      let refSchema: SchemaObject | undefined;\n\n      if ('in' in ref) {\n        refSchema = ref.schema;\n      }\n\n      if (!refSchema) {\n        // parameter or body\n        const contents = mediaTypeObjects({ content: ref.content });\n        // TODO: add support for multiple content types, for now prefer JSON\n        const content =\n          contents.find((content) => content.type === 'json') || contents[0];\n        if (content?.schema) {\n          refSchema = content.schema;\n        }\n      }\n\n      if (!refSchema) {\n        return false;\n      }\n\n      return paginationField({\n        context,\n        name,\n        schema: refSchema,\n      });\n    }\n\n    return paginationField({\n      context,\n      name,\n      schema: ref,\n    });\n  }\n\n  for (const name in schema.properties) {\n    const paginationRegExp = getPaginationKeywordsRegExp(\n      context.config.parser.pagination,\n    );\n\n    if (paginationRegExp.test(name)) {\n      const property = schema.properties[name]!;\n\n      if (typeof property !== 'boolean') {\n        // TODO: resolve deeper references\n        const schemaTypes = getSchemaTypes({ schema: property });\n\n        if (!schemaTypes.length) {\n          const compositionSchemas = property.anyOf ?? property.oneOf;\n          const nonNullCompositionSchemas = (compositionSchemas ?? []).filter(\n            (schema) => schema.type !== 'null',\n          );\n          if (nonNullCompositionSchemas.length === 1) {\n            const schemaTypes = getSchemaTypes({\n              schema: nonNullCompositionSchemas[0]!,\n            });\n            if (isPaginationType(schemaTypes)) {\n              return name;\n            }\n          }\n        }\n\n        if (isPaginationType(schemaTypes)) {\n          return name;\n        }\n      }\n    }\n  }\n\n  for (const allOf of schema.allOf ?? []) {\n    const pagination = paginationField({\n      context,\n      name,\n      schema: allOf,\n    });\n    if (pagination) {\n      return pagination;\n    }\n  }\n\n  return false;\n};\n","import type { IR } from '~/ir/types';\nimport type { State } from '~/openApi/shared/types/state';\nimport type { httpMethods } from '~/openApi/shared/utils/operation';\nimport { operationToId } from '~/openApi/shared/utils/operation';\n\nimport type {\n  OperationObject,\n  RequestBodyObject,\n  ResponseObject,\n  SecuritySchemeObject,\n} from '../types/spec';\nimport { contentToSchema, mediaTypeObjects } from './mediaType';\nimport { paginationField } from './pagination';\nimport { schemaToIrSchema } from './schema';\n\ninterface Operation\n  extends Omit<OperationObject, 'parameters'>,\n    Pick<IR.OperationObject, 'parameters'> {}\n\nconst parseOperationJsDoc = ({\n  irOperation,\n  operation,\n}: {\n  irOperation: IR.OperationObject;\n  operation: Operation;\n}) => {\n  if (operation.deprecated !== undefined) {\n    irOperation.deprecated = operation.deprecated;\n  }\n\n  if (operation.description) {\n    irOperation.description = operation.description;\n  }\n\n  if (operation.summary) {\n    irOperation.summary = operation.summary;\n  }\n\n  if (operation.tags?.length) {\n    irOperation.tags = operation.tags;\n  }\n};\n\nconst initIrOperation = ({\n  context,\n  method,\n  operation,\n  path,\n  state,\n}: Pick<IR.OperationObject, 'method' | 'path'> & {\n  context: IR.Context;\n  operation: Operation;\n  state: State;\n}): IR.OperationObject => {\n  const irOperation: IR.OperationObject = {\n    id: operationToId({\n      context,\n      id: operation.operationId,\n      method,\n      path,\n      state,\n    }),\n    method,\n    path,\n  };\n\n  if (operation.operationId) {\n    irOperation.operationId = operation.operationId;\n  }\n\n  parseOperationJsDoc({\n    irOperation,\n    operation,\n  });\n\n  return irOperation;\n};\n\nconst operationToIrOperation = ({\n  context,\n  method,\n  operation,\n  path,\n  securitySchemesMap,\n  state,\n}: Pick<IR.OperationObject, 'method' | 'path'> & {\n  context: IR.Context;\n  operation: Operation;\n  securitySchemesMap: Map<string, SecuritySchemeObject>;\n  state: State;\n}): IR.OperationObject => {\n  const irOperation = initIrOperation({\n    context,\n    method,\n    operation,\n    path,\n    state,\n  });\n\n  if (operation.parameters) {\n    irOperation.parameters = operation.parameters;\n  }\n\n  if (operation.requestBody) {\n    const requestBody =\n      '$ref' in operation.requestBody\n        ? context.resolveRef<RequestBodyObject>(operation.requestBody.$ref)\n        : operation.requestBody;\n    const contents = mediaTypeObjects({ content: requestBody.content });\n    // TODO: add support for multiple content types, for now prefer JSON\n    const content =\n      contents.find((content) => content.type === 'json') || contents[0];\n\n    if (content) {\n      const pagination = paginationField({\n        context,\n        name: '',\n        schema: {\n          description: requestBody.description,\n          ...content.schema,\n        },\n      });\n\n      irOperation.body = {\n        mediaType: content.mediaType,\n        schema: schemaToIrSchema({\n          context,\n          schema: {\n            description: requestBody.description,\n            ...('$ref' in operation.requestBody\n              ? operation.requestBody\n              : content.schema),\n          },\n          state: undefined,\n        }),\n      };\n\n      if (pagination) {\n        irOperation.body.pagination = pagination;\n      }\n\n      if (requestBody.required) {\n        irOperation.body.required = requestBody.required;\n      }\n\n      if (content.type) {\n        irOperation.body.type = content.type;\n      }\n    }\n  }\n\n  for (const name in operation.responses) {\n    if (!irOperation.responses) {\n      irOperation.responses = {};\n    }\n\n    const response = operation.responses[name]!;\n    const responseObject =\n      '$ref' in response\n        ? context.resolveRef<ResponseObject>(response.$ref)\n        : response;\n    const contents = mediaTypeObjects({ content: responseObject.content });\n    // TODO: add support for multiple content types, for now prefer JSON\n    const content =\n      contents.find((content) => content.type === 'json') || contents[0];\n\n    if (content) {\n      irOperation.responses[name] = {\n        mediaType: content.mediaType,\n        schema: schemaToIrSchema({\n          context,\n          schema: {\n            description: responseObject.description,\n            ...contentToSchema({ content }),\n          },\n          state: undefined,\n        }),\n      };\n    } else {\n      irOperation.responses[name] = {\n        schema: {\n          description: responseObject.description,\n          // TODO: parser - cover all statues with empty response bodies\n          // 1xx, 204, 205, 304\n          type: name === '204' ? 'void' : 'unknown',\n        },\n      };\n    }\n  }\n\n  if (operation.security) {\n    const securitySchemeObjects: Map<string, IR.SecurityObject> = new Map();\n\n    for (const securityRequirementObject of operation.security) {\n      for (const name in securityRequirementObject) {\n        const securitySchemeObject = securitySchemesMap.get(name);\n\n        if (!securitySchemeObject) {\n          continue;\n        }\n\n        securitySchemeObjects.set(name, securitySchemeObject);\n      }\n    }\n\n    if (securitySchemeObjects.size) {\n      irOperation.security = Array.from(securitySchemeObjects.values());\n    }\n  }\n\n  // TODO: parser - handle servers\n  // qux: operation.servers\n\n  return irOperation;\n};\n\nconst parseOperationObject = ({\n  context,\n  method,\n  operation,\n  path,\n  securitySchemesMap,\n  state,\n}: {\n  context: IR.Context;\n  method: (typeof httpMethods)[number];\n  operation: Operation;\n  path: keyof IR.PathsObject;\n  securitySchemesMap: Map<string, SecuritySchemeObject>;\n  state: State;\n}) => {\n  if (operation.servers) {\n    context.ir.servers = [...(context.ir.servers ?? []), ...operation.servers];\n  }\n\n  const parsed = operationToIrOperation({\n    context,\n    method,\n    operation,\n    path,\n    securitySchemesMap,\n    state,\n  });\n\n  return { parsed };\n};\n\nexport const parsePathOperation = ({\n  context,\n  method,\n  path,\n  ...options\n}: {\n  context: IR.Context;\n  method: (typeof httpMethods)[number];\n  operation: Operation;\n  path: keyof IR.PathsObject;\n  securitySchemesMap: Map<string, SecuritySchemeObject>;\n  state: State;\n}) => {\n  if (!context.ir.paths) {\n    context.ir.paths = {};\n  }\n\n  if (!context.ir.paths[path]) {\n    context.ir.paths[path] = {};\n  }\n\n  const { parsed } = parseOperationObject({\n    context,\n    method,\n    path,\n    ...options,\n  });\n\n  context.ir.paths[path][method] = parsed;\n};\n\nexport const parseWebhookOperation = ({\n  context,\n  key,\n  method,\n  ...options\n}: {\n  context: IR.Context;\n  key: string;\n  method: (typeof httpMethods)[number];\n  operation: Operation;\n  securitySchemesMap: Map<string, SecuritySchemeObject>;\n  state: State;\n}) => {\n  if (!context.ir.webhooks) {\n    context.ir.webhooks = {};\n  }\n\n  if (!context.ir.webhooks[key]) {\n    context.ir.webhooks[key] = {};\n  }\n\n  const { parsed } = parseOperationObject({\n    context,\n    method,\n    path: key as `/${string}`,\n    ...options,\n  });\n\n  context.ir.webhooks[key][method] = parsed;\n};\n","import type { IR } from '~/ir/types';\nimport { refToName } from '~/utils/ref';\n\nimport type {\n  ParameterObject,\n  ReferenceObject,\n  SchemaObject,\n} from '../types/spec';\nimport { mediaTypeObjects } from './mediaType';\nimport { paginationField } from './pagination';\nimport { schemaToIrSchema } from './schema';\n\n/**\n * Returns default parameter `allowReserved` based on value of `in`.\n */\nconst defaultAllowReserved = (\n  _in: ParameterObject['in'],\n): boolean | undefined => {\n  switch (_in) {\n    // this keyword only applies to parameters with an `in` value of `query`\n    case 'query':\n      return false;\n    default:\n      return;\n  }\n};\n\n/**\n * Returns default parameter `explode` based on value of `style`.\n */\nconst defaultExplode = (style: Required<ParameterObject>['style']): boolean => {\n  switch (style) {\n    // default value for `deepObject` is `false`, but that behavior is undefined\n    // so we use `true` to make this work with the `client-fetch` package\n    case 'deepObject':\n    case 'form':\n      return true;\n    default:\n      return false;\n  }\n};\n\n/**\n * Returns default parameter `style` based on value of `in`.\n */\nconst defaultStyle = (\n  _in: ParameterObject['in'],\n): Required<ParameterObject>['style'] => {\n  switch (_in) {\n    case 'header':\n    case 'path':\n      return 'simple';\n    case 'cookie':\n    case 'query':\n      return 'form';\n  }\n};\n\nexport const parametersArrayToObject = ({\n  context,\n  parameters,\n}: {\n  context: IR.Context;\n  parameters?: ReadonlyArray<ParameterObject | ReferenceObject>;\n}): IR.ParametersObject | undefined => {\n  if (!parameters || !Object.keys(parameters).length) {\n    return;\n  }\n\n  const parametersObject: IR.ParametersObject = {};\n\n  for (const parameterOrReference of parameters) {\n    const parameter =\n      '$ref' in parameterOrReference\n        ? context.dereference<ParameterObject>(parameterOrReference)\n        : parameterOrReference;\n\n    if (!parametersObject[parameter.in]) {\n      parametersObject[parameter.in] = {};\n    }\n\n    // lowercase keys for case insensitive access\n    parametersObject[parameter.in]![parameter.name.toLocaleLowerCase()] =\n      parameterToIrParameter({\n        $ref: `#/todo/real/path/to/parameter/${parameter.name}`,\n        context,\n        parameter,\n      });\n  }\n\n  return parametersObject;\n};\n\nconst parameterToIrParameter = ({\n  $ref,\n  context,\n  parameter,\n}: {\n  $ref: string;\n  context: IR.Context;\n  parameter: ParameterObject;\n}): IR.ParameterObject => {\n  // TODO: parser - fix\n  let schema = parameter.schema;\n\n  if (!schema) {\n    const contents = mediaTypeObjects({ content: parameter.content });\n    // TODO: add support for multiple content types, for now prefer JSON\n    const content =\n      contents.find((content) => content.type === 'json') || contents[0];\n    if (content) {\n      schema = content.schema;\n    }\n  }\n\n  const finalSchema: SchemaObject = {\n    deprecated: parameter.deprecated,\n    description: parameter.description,\n    ...schema,\n  };\n\n  const pagination = paginationField({\n    context,\n    name: parameter.name,\n    schema: finalSchema,\n  });\n\n  const style = parameter.style || defaultStyle(parameter.in);\n  const explode =\n    parameter.explode !== undefined ? parameter.explode : defaultExplode(style);\n  const allowReserved =\n    parameter.allowReserved !== undefined\n      ? parameter.allowReserved\n      : defaultAllowReserved(parameter.in);\n\n  const irParameter: IR.ParameterObject = {\n    allowReserved,\n    explode,\n    location: parameter.in,\n    name: parameter.name,\n    schema: schemaToIrSchema({\n      context,\n      schema: finalSchema,\n      state: {\n        $ref,\n        circularReferenceTracker: new Set(),\n      },\n    }),\n    style,\n  };\n\n  if (parameter.deprecated) {\n    irParameter.deprecated = parameter.deprecated;\n  }\n\n  if (parameter.description) {\n    irParameter.description = parameter.description;\n  }\n\n  if (pagination) {\n    irParameter.pagination = pagination;\n  }\n\n  if (parameter.required) {\n    irParameter.required = parameter.required;\n  }\n\n  return irParameter;\n};\n\nexport const parseParameter = ({\n  $ref,\n  context,\n  parameter,\n}: {\n  $ref: string;\n  context: IR.Context;\n  parameter: ParameterObject;\n}) => {\n  if (!context.ir.components) {\n    context.ir.components = {};\n  }\n\n  if (!context.ir.components.parameters) {\n    context.ir.components.parameters = {};\n  }\n\n  context.ir.components.parameters[refToName($ref)] = parameterToIrParameter({\n    $ref,\n    context,\n    parameter,\n  });\n};\n","import type { IR } from '~/ir/types';\nimport { refToName } from '~/utils/ref';\n\nimport type { RequestBodyObject, SchemaObject } from '../types/spec';\nimport { mediaTypeObjects } from './mediaType';\nimport { schemaToIrSchema } from './schema';\n\nconst requestBodyToIrRequestBody = ({\n  $ref,\n  context,\n  requestBody,\n}: {\n  $ref: string;\n  context: IR.Context;\n  requestBody: RequestBodyObject;\n}): IR.RequestBodyObject => {\n  // TODO: parser - fix\n  const contents = mediaTypeObjects({ content: requestBody.content });\n  // TODO: add support for multiple content types, for now prefer JSON\n  const content =\n    contents.find((content) => content.type === 'json') || contents[0];\n  const schema = content ? content.schema : undefined;\n\n  const finalSchema: SchemaObject = {\n    description: requestBody.description,\n    ...schema,\n  };\n\n  const irRequestBody: IR.RequestBodyObject = {\n    schema: schemaToIrSchema({\n      context,\n      schema: finalSchema,\n      state: {\n        $ref,\n        circularReferenceTracker: new Set(),\n      },\n    }),\n  };\n\n  if (requestBody.description) {\n    irRequestBody.description = requestBody.description;\n  }\n\n  if (requestBody.required) {\n    irRequestBody.required = requestBody.required;\n  }\n\n  return irRequestBody;\n};\n\nexport const parseRequestBody = ({\n  $ref,\n  context,\n  requestBody,\n}: {\n  $ref: string;\n  context: IR.Context;\n  requestBody: RequestBodyObject;\n}) => {\n  if (!context.ir.components) {\n    context.ir.components = {};\n  }\n\n  if (!context.ir.components.requestBodies) {\n    context.ir.components.requestBodies = {};\n  }\n\n  context.ir.components.requestBodies[refToName($ref)] =\n    requestBodyToIrRequestBody({\n      $ref,\n      context,\n      requestBody,\n    });\n};\n","import type { IR } from '~/ir/types';\nimport { parseUrl } from '~/utils/url';\n\nexport const parseServers = ({ context }: { context: IR.Context }) => {\n  if (context.spec.servers) {\n    context.ir.servers = context.spec.servers;\n    return;\n  }\n\n  for (const input of context.config.input) {\n    if (typeof input.path === 'string') {\n      const url = parseUrl(input.path);\n      context.ir.servers = [\n        {\n          url: `${url.protocol ? `${url.protocol}://` : ''}${url.host}${url.port ? `:${url.port}` : ''}`,\n        },\n      ];\n    }\n  }\n\n  if (!context.ir.servers) {\n    context.ir.servers = [\n      {\n        url: '/',\n      },\n    ];\n  }\n};\n","import { createOperationKey } from '~/ir/operation';\nimport { httpMethods } from '~/openApi/shared/utils/operation';\nimport type {\n  ValidatorIssue,\n  ValidatorResult,\n} from '~/openApi/shared/utils/validator';\nimport type { Logger } from '~/utils/logger';\n\nimport type { OpenApiV3_1_X, PathItemObject, PathsObject } from '../types/spec';\n\nexport const validateOpenApiSpec = (\n  spec: OpenApiV3_1_X,\n  logger: Logger,\n): ValidatorResult => {\n  const eventValidate = logger.timeEvent('validate');\n  const issues: Array<ValidatorIssue> = [];\n  const operationIds = new Map();\n\n  if (spec.paths) {\n    for (const entry of Object.entries(spec.paths)) {\n      const path = entry[0] as keyof PathsObject;\n      const pathItem = entry[1] as PathItemObject;\n      for (const method of httpMethods) {\n        const operation = pathItem[method];\n        if (!operation) {\n          continue;\n        }\n\n        const operationKey = createOperationKey({ method, path });\n\n        if (operation.operationId) {\n          if (!operationIds.has(operation.operationId)) {\n            operationIds.set(operation.operationId, operationKey);\n          } else {\n            issues.push({\n              code: 'duplicate_key',\n              context: {\n                key: 'operationId',\n                value: operation.operationId,\n              },\n              message:\n                'Duplicate `operationId` found. Each `operationId` must be unique.',\n              path: ['paths', path, method, 'operationId'],\n              severity: 'error',\n            });\n          }\n        }\n      }\n    }\n  }\n\n  if (spec.servers) {\n    if (typeof spec.servers !== 'object' || !Array.isArray(spec.servers)) {\n      issues.push({\n        code: 'invalid_type',\n        message: '`servers` must be an array.',\n        path: [],\n        severity: 'error',\n      });\n    }\n\n    for (let index = 0; index < spec.servers.length; index++) {\n      const server = spec.servers[index];\n      if (!server || typeof server !== 'object') {\n        issues.push({\n          code: 'invalid_type',\n          context: {\n            actual: typeof server,\n            expected: 'object',\n          },\n          message: 'Each entry in `servers` must be an object.',\n          path: ['servers', index],\n          severity: 'error',\n        });\n      } else {\n        if (!server.url) {\n          issues.push({\n            code: 'missing_required_field',\n            context: {\n              field: 'url',\n            },\n            message: 'Missing required field `url` in server object.',\n            path: ['servers', index],\n            severity: 'error',\n          });\n        }\n      }\n    }\n  }\n\n  eventValidate.timeEnd();\n  return {\n    issues,\n    valid: !issues.some((issue) => issue.severity === 'error'),\n  };\n};\n","import type { IR } from '~/ir/types';\nimport { mergeParametersObjects } from '~/openApi/shared/utils/parameter';\n\nimport type { OpenApiV3_1_X, PathItemObject } from '../types/spec';\nimport { parseWebhookOperation } from './operation';\nimport { parametersArrayToObject } from './parameter';\n\nexport const parseWebhooks = ({\n  context,\n  securitySchemesMap,\n}: Pick<Parameters<typeof parseWebhookOperation>[0], 'securitySchemesMap'> & {\n  context: IR.Context<OpenApiV3_1_X>;\n}) => {\n  const state: Parameters<typeof parseWebhookOperation>[0]['state'] = {\n    ids: new Map(),\n  };\n\n  for (const key in context.spec.webhooks) {\n    const webhook = context.spec.webhooks[key]!;\n\n    const finalWebhook =\n      '$ref' in webhook\n        ? {\n            ...context.resolveRef<PathItemObject>(webhook.$ref!),\n            ...webhook,\n          }\n        : webhook;\n\n    const operationArgs: Omit<\n      Parameters<typeof parseWebhookOperation>[0],\n      'method'\n    > = {\n      context,\n      key,\n      operation: {\n        description: finalWebhook.description,\n        parameters: parametersArrayToObject({\n          context,\n          parameters: finalWebhook.parameters,\n        }),\n        security: context.spec.security,\n        servers: finalWebhook.servers,\n        summary: finalWebhook.summary,\n      },\n      securitySchemesMap,\n      state,\n    };\n\n    if (finalWebhook.delete) {\n      parseWebhookOperation({\n        ...operationArgs,\n        method: 'delete',\n        operation: {\n          ...operationArgs.operation,\n          ...finalWebhook.delete,\n          parameters: mergeParametersObjects({\n            source: parametersArrayToObject({\n              context,\n              parameters: finalWebhook.delete.parameters,\n            }),\n            target: operationArgs.operation.parameters,\n          }),\n        },\n      });\n    }\n\n    if (finalWebhook.get) {\n      parseWebhookOperation({\n        ...operationArgs,\n        method: 'get',\n        operation: {\n          ...operationArgs.operation,\n          ...finalWebhook.get,\n          parameters: mergeParametersObjects({\n            source: parametersArrayToObject({\n              context,\n              parameters: finalWebhook.get.parameters,\n            }),\n            target: operationArgs.operation.parameters,\n          }),\n        },\n      });\n    }\n\n    if (finalWebhook.head) {\n      parseWebhookOperation({\n        ...operationArgs,\n        method: 'head',\n        operation: {\n          ...operationArgs.operation,\n          ...finalWebhook.head,\n          parameters: mergeParametersObjects({\n            source: parametersArrayToObject({\n              context,\n              parameters: finalWebhook.head.parameters,\n            }),\n            target: operationArgs.operation.parameters,\n          }),\n        },\n      });\n    }\n\n    if (finalWebhook.options) {\n      parseWebhookOperation({\n        ...operationArgs,\n        method: 'options',\n        operation: {\n          ...operationArgs.operation,\n          ...finalWebhook.options,\n          parameters: mergeParametersObjects({\n            source: parametersArrayToObject({\n              context,\n              parameters: finalWebhook.options.parameters,\n            }),\n            target: operationArgs.operation.parameters,\n          }),\n        },\n      });\n    }\n\n    if (finalWebhook.patch) {\n      parseWebhookOperation({\n        ...operationArgs,\n        method: 'patch',\n        operation: {\n          ...operationArgs.operation,\n          ...finalWebhook.patch,\n          parameters: mergeParametersObjects({\n            source: parametersArrayToObject({\n              context,\n              parameters: finalWebhook.patch.parameters,\n            }),\n            target: operationArgs.operation.parameters,\n          }),\n        },\n      });\n    }\n\n    if (finalWebhook.post) {\n      parseWebhookOperation({\n        ...operationArgs,\n        method: 'post',\n        operation: {\n          ...operationArgs.operation,\n          ...finalWebhook.post,\n          parameters: mergeParametersObjects({\n            source: parametersArrayToObject({\n              context,\n              parameters: finalWebhook.post.parameters,\n            }),\n            target: operationArgs.operation.parameters,\n          }),\n        },\n      });\n    }\n\n    if (finalWebhook.put) {\n      parseWebhookOperation({\n        ...operationArgs,\n        method: 'put',\n        operation: {\n          ...operationArgs.operation,\n          ...finalWebhook.put,\n          parameters: mergeParametersObjects({\n            source: parametersArrayToObject({\n              context,\n              parameters: finalWebhook.put.parameters,\n            }),\n            target: operationArgs.operation.parameters,\n          }),\n        },\n      });\n    }\n\n    if (finalWebhook.trace) {\n      parseWebhookOperation({\n        ...operationArgs,\n        method: 'trace',\n        operation: {\n          ...operationArgs.operation,\n          ...finalWebhook.trace,\n          parameters: mergeParametersObjects({\n            source: parametersArrayToObject({\n              context,\n              parameters: finalWebhook.trace.parameters,\n            }),\n            target: operationArgs.operation.parameters,\n          }),\n        },\n      });\n    }\n  }\n};\n","import type { IR } from '~/ir/types';\nimport { buildResourceMetadata } from '~/openApi/shared/graph/meta';\nimport { transformOpenApiSpec } from '~/openApi/shared/transforms';\nimport type { State } from '~/openApi/shared/types/state';\nimport {\n  createFilteredDependencies,\n  createFilters,\n  hasFilters,\n} from '~/openApi/shared/utils/filter';\nimport { buildGraph } from '~/openApi/shared/utils/graph';\nimport { mergeParametersObjects } from '~/openApi/shared/utils/parameter';\nimport { handleValidatorResult } from '~/openApi/shared/utils/validator';\n\nimport type {\n  OpenApiV3_1_X,\n  ParameterObject,\n  PathItemObject,\n  PathsObject,\n  RequestBodyObject,\n  SecuritySchemeObject,\n} from '../types/spec';\nimport { filterSpec } from './filter';\nimport { parsePathOperation } from './operation';\nimport { parametersArrayToObject, parseParameter } from './parameter';\nimport { parseRequestBody } from './requestBody';\nimport { parseSchema } from './schema';\nimport { parseServers } from './server';\nimport { validateOpenApiSpec } from './validate';\nimport { parseWebhooks } from './webhook';\n\nexport const parseV3_1_X = (context: IR.Context<OpenApiV3_1_X>) => {\n  if (context.config.parser.validate_EXPERIMENTAL) {\n    const result = validateOpenApiSpec(context.spec, context.logger);\n    handleValidatorResult({ context, result });\n  }\n\n  const shouldFilterSpec = hasFilters(context.config.parser.filters);\n  if (shouldFilterSpec) {\n    const filters = createFilters(\n      context.config.parser.filters,\n      context.spec,\n      context.logger,\n    );\n    const { graph } = buildGraph(context.spec, context.logger);\n    const { resourceMetadata } = buildResourceMetadata(graph, context.logger);\n    const sets = createFilteredDependencies({\n      filters,\n      logger: context.logger,\n      resourceMetadata,\n    });\n    filterSpec({\n      ...sets,\n      logger: context.logger,\n      preserveOrder: filters.preserveOrder,\n      spec: context.spec,\n    });\n  }\n\n  transformOpenApiSpec({ context });\n\n  const state: State = {\n    ids: new Map(),\n  };\n  const securitySchemesMap = new Map<string, SecuritySchemeObject>();\n\n  // TODO: parser - handle more component types, old parser handles only parameters and schemas\n  if (context.spec.components) {\n    for (const name in context.spec.components.securitySchemes) {\n      const securityOrReference =\n        context.spec.components.securitySchemes[name]!;\n      const securitySchemeObject =\n        '$ref' in securityOrReference\n          ? context.resolveRef<SecuritySchemeObject>(securityOrReference.$ref)\n          : securityOrReference;\n      securitySchemesMap.set(name, securitySchemeObject);\n    }\n\n    for (const name in context.spec.components.parameters) {\n      const $ref = `#/components/parameters/${name}`;\n      const parameterOrReference = context.spec.components.parameters[name]!;\n      const parameter =\n        '$ref' in parameterOrReference\n          ? context.resolveRef<ParameterObject>(parameterOrReference.$ref)\n          : parameterOrReference;\n\n      parseParameter({\n        $ref,\n        context,\n        parameter,\n      });\n    }\n\n    for (const name in context.spec.components.requestBodies) {\n      const $ref = `#/components/requestBodies/${name}`;\n      const requestBodyOrReference =\n        context.spec.components.requestBodies[name]!;\n      const requestBody =\n        '$ref' in requestBodyOrReference\n          ? context.resolveRef<RequestBodyObject>(requestBodyOrReference.$ref)\n          : requestBodyOrReference;\n\n      parseRequestBody({\n        $ref,\n        context,\n        requestBody,\n      });\n    }\n\n    for (const name in context.spec.components.schemas) {\n      const $ref = `#/components/schemas/${name}`;\n      const schema = context.spec.components.schemas[name]!;\n\n      parseSchema({\n        $ref,\n        context,\n        schema,\n      });\n    }\n  }\n\n  parseServers({ context });\n\n  for (const path in context.spec.paths) {\n    const pathItem = context.spec.paths[path as keyof PathsObject]!;\n\n    const finalPathItem = pathItem.$ref\n      ? {\n          ...context.resolveRef<PathItemObject>(pathItem.$ref),\n          ...pathItem,\n        }\n      : pathItem;\n\n    const operationArgs: Omit<\n      Parameters<typeof parsePathOperation>[0],\n      'method'\n    > = {\n      context,\n      operation: {\n        description: finalPathItem.description,\n        parameters: parametersArrayToObject({\n          context,\n          parameters: finalPathItem.parameters,\n        }),\n        security: context.spec.security,\n        servers: finalPathItem.servers,\n        summary: finalPathItem.summary,\n      },\n      path: path as keyof PathsObject,\n      securitySchemesMap,\n      state,\n    };\n\n    if (finalPathItem.delete) {\n      parsePathOperation({\n        ...operationArgs,\n        method: 'delete',\n        operation: {\n          ...operationArgs.operation,\n          ...finalPathItem.delete,\n          parameters: mergeParametersObjects({\n            source: parametersArrayToObject({\n              context,\n              parameters: finalPathItem.delete.parameters,\n            }),\n            target: operationArgs.operation.parameters,\n          }),\n        },\n      });\n    }\n\n    if (finalPathItem.get) {\n      parsePathOperation({\n        ...operationArgs,\n        method: 'get',\n        operation: {\n          ...operationArgs.operation,\n          ...finalPathItem.get,\n          parameters: mergeParametersObjects({\n            source: parametersArrayToObject({\n              context,\n              parameters: finalPathItem.get.parameters,\n            }),\n            target: operationArgs.operation.parameters,\n          }),\n        },\n      });\n    }\n\n    if (finalPathItem.head) {\n      parsePathOperation({\n        ...operationArgs,\n        method: 'head',\n        operation: {\n          ...operationArgs.operation,\n          ...finalPathItem.head,\n          parameters: mergeParametersObjects({\n            source: parametersArrayToObject({\n              context,\n              parameters: finalPathItem.head.parameters,\n            }),\n            target: operationArgs.operation.parameters,\n          }),\n        },\n      });\n    }\n\n    if (finalPathItem.options) {\n      parsePathOperation({\n        ...operationArgs,\n        method: 'options',\n        operation: {\n          ...operationArgs.operation,\n          ...finalPathItem.options,\n          parameters: mergeParametersObjects({\n            source: parametersArrayToObject({\n              context,\n              parameters: finalPathItem.options.parameters,\n            }),\n            target: operationArgs.operation.parameters,\n          }),\n        },\n      });\n    }\n\n    if (finalPathItem.patch) {\n      parsePathOperation({\n        ...operationArgs,\n        method: 'patch',\n        operation: {\n          ...operationArgs.operation,\n          ...finalPathItem.patch,\n          parameters: mergeParametersObjects({\n            source: parametersArrayToObject({\n              context,\n              parameters: finalPathItem.patch.parameters,\n            }),\n            target: operationArgs.operation.parameters,\n          }),\n        },\n      });\n    }\n\n    if (finalPathItem.post) {\n      parsePathOperation({\n        ...operationArgs,\n        method: 'post',\n        operation: {\n          ...operationArgs.operation,\n          ...finalPathItem.post,\n          parameters: mergeParametersObjects({\n            source: parametersArrayToObject({\n              context,\n              parameters: finalPathItem.post.parameters,\n            }),\n            target: operationArgs.operation.parameters,\n          }),\n        },\n      });\n    }\n\n    if (finalPathItem.put) {\n      parsePathOperation({\n        ...operationArgs,\n        method: 'put',\n        operation: {\n          ...operationArgs.operation,\n          ...finalPathItem.put,\n          parameters: mergeParametersObjects({\n            source: parametersArrayToObject({\n              context,\n              parameters: finalPathItem.put.parameters,\n            }),\n            target: operationArgs.operation.parameters,\n          }),\n        },\n      });\n    }\n\n    if (finalPathItem.trace) {\n      parsePathOperation({\n        ...operationArgs,\n        method: 'trace',\n        operation: {\n          ...operationArgs.operation,\n          ...finalPathItem.trace,\n          parameters: mergeParametersObjects({\n            source: parametersArrayToObject({\n              context,\n              parameters: finalPathItem.trace.parameters,\n            }),\n            target: operationArgs.operation.parameters,\n          }),\n        },\n      });\n    }\n  }\n\n  parseWebhooks({ context, securitySchemesMap });\n};\n","export const allowedServiceMethods = [\n  'connect',\n  'delete',\n  'get',\n  'head',\n  'options',\n  'patch',\n  'post',\n  'put',\n  'trace',\n] as const;\n\n/**\n * Convert the service version to 'normal' version.\n * This basically removes any \"v\" prefix from the version string.\n * @param version\n */\nexport function getServiceVersion(version = '1.0'): string {\n  return String(version).replace(/^v/gi, '');\n}\n","import type { OpenApiSchema } from '../interfaces/OpenApiSchema';\n\nexport const inferType = (\n  definition: OpenApiSchema,\n  definitionTypes: string[],\n) => {\n  if (definition.enum && !definitionTypes.includes('boolean')) {\n    return 'enum';\n  }\n  return;\n};\n\nexport const isDefinitionTypeNullable = (\n  definition: Pick<OpenApiSchema, 'type'>,\n) => getDefinitionTypes(definition).includes('null');\n\nexport const isDefinitionNullable = (\n  definition: Pick<OpenApiSchema, 'nullable' | 'type'>,\n) => definition.nullable === true || isDefinitionTypeNullable(definition);\n\nexport const getDefinitionTypes = ({ type }: Pick<OpenApiSchema, 'type'>) => {\n  if (Array.isArray(type)) {\n    return type;\n  }\n  if (type) {\n    return [type];\n  }\n  return [];\n};\n","export const refParametersPartial = '#/components/parameters/';\n\nexport const refSchemasPartial = '#/components/schemas/';\n","import { ensureValidTypeScriptJavaScriptIdentifier } from '~/openApi';\nimport type { Config } from '~/types/config';\n\nimport { getConfig } from './config';\nimport { reservedJavaScriptKeywordsRegExp } from './regexp';\nimport { stringCase } from './stringCase';\n\nexport const transformClassName = ({\n  config,\n  name,\n}: {\n  config: Config;\n  name: string;\n}) => {\n  const plugin = config.plugins['@hey-api/sdk'];\n  if (plugin?.config.classNameBuilder) {\n    let customName = '';\n\n    if (typeof plugin.config.classNameBuilder === 'function') {\n      customName = plugin.config.classNameBuilder(name);\n    } else {\n      customName = plugin.config.classNameBuilder.replace('{{name}}', name);\n    }\n\n    return customName;\n  }\n\n  return name;\n};\n\nexport const transformTypeName = (name: string) => {\n  const config = getConfig();\n  if (config.plugins['@hey-api/typescript']?.config.style === 'PascalCase') {\n    return stringCase({\n      case: 'PascalCase',\n      value: name,\n    });\n  }\n  return name;\n};\n\n/**\n * This method is meant to be used to process definition names\n * and return a cleaned up, transformed version that is legal\n * to use in the output code.\n *\n * For example, a definition with name \"400\" would result in \"_400\",\n * \"import\" would result in \"_import\", etc. This also respects the\n * casing configuration for types.\n *\n * @param name Name of the definition in OpenAPI specification.\n * @returns A cleaned up, transformed name usable in output code.\n */\nexport const cleanAndTransformTypeName = (name: string) => {\n  const transformed = transformTypeName(name);\n  const cleaned = ensureValidTypeScriptJavaScriptIdentifier(transformed);\n  const result = cleaned.replace(reservedJavaScriptKeywordsRegExp, '_$1');\n  return result;\n};\n","/**\n * Strip (OpenAPI) namespaces from values.\n * @param value\n */\nexport const stripNamespace = (value: string): string =>\n  value\n    .trim()\n    .replace(/^#\\/definitions\\//, '')\n    .replace(/^#\\/parameters\\//, '')\n    .replace(/^#\\/responses\\//, '')\n    .replace(/^#\\/securityDefinitions\\//, '')\n    .replace(/^#\\/components\\/schemas\\//, '')\n    .replace(/^#\\/components\\/responses\\//, '')\n    .replace(/^#\\/components\\/parameters\\//, '')\n    .replace(/^#\\/components\\/examples\\//, '')\n    .replace(/^#\\/components\\/requestBodies\\//, '')\n    .replace(/^#\\/components\\/headers\\//, '')\n    .replace(/^#\\/components\\/securitySchemes\\//, '')\n    .replace(/^#\\/components\\/links\\//, '')\n    .replace(/^#\\/components\\/callbacks\\//, '');\n","import { isDefinitionTypeNullable } from '~/openApi/v3/parser/inferType';\nimport { refParametersPartial } from '~/utils/const';\nimport { transformTypeName } from '~/utils/transform';\n\nimport type { Type } from '../interfaces/Type';\nimport { ensureValidTypeScriptJavaScriptIdentifier } from './sanitize';\nimport { stripNamespace } from './stripNamespace';\n\n/**\n * Get mapped type for given type to basic Typescript/Javascript type.\n */\nexport const getMappedType = (\n  type: string,\n  format?: string,\n): string | undefined => {\n  if (format === 'binary') {\n    return 'binary';\n  }\n  switch (type) {\n    case 'any':\n    case 'object':\n    case 'unknown':\n      return 'unknown';\n    case 'array':\n      return 'unknown[]';\n    case 'boolean':\n      return 'boolean';\n    case 'byte':\n    case 'double':\n    case 'float':\n    case 'int':\n    case 'integer':\n    case 'long':\n    case 'number':\n    case 'short':\n      return 'number';\n    case 'char':\n    case 'date':\n    case 'date-time':\n    case 'password':\n    case 'string':\n      return 'string';\n    case 'file':\n      return 'binary';\n    case 'null':\n      return 'null';\n    case 'void':\n      return 'void';\n    default:\n      return;\n  }\n};\n\n/**\n * Matches characters inside square brackets, including the brackets. Does not\n * match if the opening bracket is preceded by \"`1\" which is a syntax for generics\n * from C#.\n *\n * Hello[World] -> matches [World]\n * Hello`1[World] -> no match\n * string[] -> matches []\n */\nexport const hasSquareBracketsRegExp = /(?<!`1)\\[.*\\]$/g;\n\n/**\n * Parse any string value into a type object.\n * @param type String or String[] value like \"integer\", \"Link[Model]\" or [\"string\", \"null\"].\n * @param format String value like \"binary\" or \"date\".\n */\nexport const getType = ({\n  debug,\n  format,\n  type = 'unknown',\n}: {\n  debug?: boolean;\n  format?: string;\n  /**\n   * Type can be the name of a schema component, a ref string, or any definition type.\n   */\n  type?: string | string[];\n}): Type => {\n  const result: Type = {\n    $refs: [],\n    base: 'unknown',\n    imports: [],\n    isNullable: false,\n    template: null,\n    type: 'unknown',\n  };\n\n  // Special case for JSON Schema spec (december 2020, page 17),\n  // that allows type to be an array of primitive types...\n  if (Array.isArray(type)) {\n    const joinedType = type\n      .filter((value) => value !== 'null')\n      .map((value) => getMappedType(value, format))\n      .filter(Boolean)\n      .join(' | ');\n    result.type = joinedType;\n    result.base = joinedType;\n    result.isNullable = isDefinitionTypeNullable({ type });\n    return result;\n  }\n\n  const mapped = getMappedType(type, format);\n  if (mapped) {\n    result.type = mapped;\n    result.base = mapped;\n    return result;\n  }\n\n  const typeWithoutNamespace = decodeURIComponent(stripNamespace(type));\n\n  hasSquareBracketsRegExp.lastIndex = 0;\n  if (hasSquareBracketsRegExp.test(typeWithoutNamespace)) {\n    const matches = typeWithoutNamespace.match(/(.*?)\\[(.*)\\]$/);\n    if (matches?.length) {\n      const match1 = getType({\n        debug,\n        type: ensureValidTypeScriptJavaScriptIdentifier(matches[1]!),\n      });\n      const match2 = getType({\n        debug,\n        type: ensureValidTypeScriptJavaScriptIdentifier(matches[2]!),\n      });\n\n      if (match1.type === 'unknown[]') {\n        result.type = `${match2.type}[]`;\n        result.base = `${match2.type}`;\n        match1.$refs = [];\n        match1.imports = [];\n      } else if (match2.type) {\n        result.type = `${match1.type}<${match2.type}>`;\n        result.base = match1.type;\n        result.template = match2.type;\n      } else {\n        result.type = match1.type;\n        result.base = match1.type;\n        result.template = match1.type;\n      }\n\n      result.$refs = [...result.$refs, ...match1.$refs, ...match2.$refs];\n      result.imports = [\n        ...result.imports,\n        ...match1.imports,\n        ...match2.imports,\n      ];\n      return result;\n    }\n  }\n\n  if (typeWithoutNamespace) {\n    let encodedType = transformTypeName(\n      ensureValidTypeScriptJavaScriptIdentifier(typeWithoutNamespace),\n    );\n    if (type.startsWith(refParametersPartial)) {\n      // prefix parameter names to avoid conflicts, assuming people are mostly\n      // interested in importing schema types and don't care about this naming\n      encodedType = `Parameter${encodedType}`;\n    }\n    result.type = encodedType;\n    result.base = encodedType;\n    if (type.startsWith('#')) {\n      result.$refs = [...result.$refs, decodeURIComponent(type)];\n    }\n    result.imports = [...result.imports, encodedType];\n    return result;\n  }\n\n  return result;\n};\n","export function unique<T>(value: T, index: number, arr: T[]): boolean {\n  return arr.indexOf(value) === index;\n}\n","import { unique } from '~/utils/unique';\n\nimport type { Enum } from '../interfaces/client';\nimport type { WithEnumExtension } from '../interfaces/WithEnumExtension';\n\nexport const getEnums = (\n  definition: WithEnumExtension,\n  values?: ReadonlyArray<string | number>,\n): Enum[] => {\n  if (!Array.isArray(values)) {\n    return [];\n  }\n\n  const descriptions = (definition['x-enum-descriptions'] ?? []).filter(\n    (value) => typeof value === 'string',\n  );\n  const names = (\n    definition['x-enum-varnames'] ??\n    definition['x-enumNames'] ??\n    []\n  ).filter((value) => typeof value === 'string');\n\n  return values\n    .filter(unique)\n    .filter((value) => typeof value === 'number' || typeof value === 'string')\n    .map((value, index) => ({\n      customDescription: descriptions[index],\n      customName: names[index],\n      description: undefined,\n      value,\n    }));\n};\n","/**\n * The spec generates a pattern like this '^\\d{3}-\\d{2}-\\d{4}$'\n * However, to use it in HTML or inside new RegExp() we need to\n * escape the pattern to become: '^\\\\d{3}-\\\\d{2}-\\\\d{4}$' in order\n * to make it a valid regexp string.\n *\n * Also, escape single quote characters, because the output uses single quotes for strings\n *\n * @param pattern\n */\nexport const getPattern = (pattern?: string): string | undefined =>\n  pattern?.replace(/\\\\/g, '\\\\\\\\').replace(/'/g, \"\\\\'\");\n","import type { Model } from '~/openApi/common/interfaces/client';\nimport { getPattern } from '~/openApi/common/parser/getPattern';\nimport { getType } from '~/openApi/common/parser/type';\nimport { escapeName } from '~/utils/escape';\n\nimport type { Client } from '../../../types/client';\nimport type { GetModelFn } from '../interfaces/Model';\nimport type { OpenApi } from '../interfaces/OpenApi';\nimport type { OpenApiSchema } from '../interfaces/OpenApiSchema';\n\nexport const getModelProperties = ({\n  definition,\n  getModel,\n  openApi,\n  types,\n}: {\n  definition: OpenApiSchema;\n  getModel: GetModelFn;\n  openApi: OpenApi;\n  types: Client['types'];\n}): Model[] => {\n  const models: Model[] = [];\n\n  Object.entries(definition.properties ?? {}).forEach(\n    ([propertyName, property]) => {\n      const propertyRequired = Boolean(\n        definition.required?.includes(propertyName),\n      );\n      if (property.$ref) {\n        const model = getType({ type: property.$ref });\n        models.push({\n          $refs: [],\n          base: model.base,\n          description: property.description || null,\n          enum: [],\n          enums: [],\n          exclusiveMaximum: property.exclusiveMaximum,\n          exclusiveMinimum: property.exclusiveMinimum,\n          export: 'reference',\n          format: property.format,\n          imports: model.imports,\n          in: '',\n          isDefinition: false,\n          isNullable: property['x-nullable'] === true,\n          isReadOnly: property.readOnly === true,\n          isRequired: propertyRequired,\n          link: null,\n          maxItems: property.maxItems,\n          maxLength: property.maxLength,\n          maxProperties: property.maxProperties,\n          maximum: property.maximum,\n          minItems: property.minItems,\n          minLength: property.minLength,\n          minProperties: property.minProperties,\n          minimum: property.minimum,\n          multipleOf: property.multipleOf,\n          name: escapeName(propertyName),\n          pattern: getPattern(property.pattern),\n          properties: [],\n          template: model.template,\n          type: model.type,\n          uniqueItems: property.uniqueItems,\n        });\n      } else {\n        const model = getModel({ definition: property, openApi, types });\n        models.push({\n          $refs: [],\n          base: model.base,\n          description: property.description || null,\n          enum: model.enum,\n          enums: model.enums,\n          exclusiveMaximum: property.exclusiveMaximum,\n          exclusiveMinimum: property.exclusiveMinimum,\n          export: model.export,\n          format: property.format,\n          imports: model.imports,\n          in: '',\n          isDefinition: false,\n          isNullable: property['x-nullable'] === true,\n          isReadOnly: property.readOnly === true,\n          isRequired: propertyRequired,\n          link: model.link,\n          maxItems: property.maxItems,\n          maxLength: property.maxLength,\n          maxProperties: property.maxProperties,\n          maximum: property.maximum,\n          minItems: property.minItems,\n          minLength: property.minLength,\n          minProperties: property.minProperties,\n          minimum: property.minimum,\n          multipleOf: property.multipleOf,\n          name: escapeName(propertyName),\n          pattern: getPattern(property.pattern),\n          properties: model.properties,\n          template: model.template,\n          type: model.type,\n          uniqueItems: property.uniqueItems,\n        });\n      }\n    },\n  );\n\n  return models;\n};\n","import type { OpenApiReference as OpenApiReferenceV2 } from '~/openApi/v2/interfaces/OpenApiReference';\nimport type { OpenApiReference as OpenApiReferenceV3 } from '~/openApi/v3/interfaces/OpenApiReference';\n\nimport type { OpenApi } from '../interfaces/OpenApi';\n\nconst ESCAPED_REF_SLASH = /~1/g;\nconst ESCAPED_REF_TILDE = /~0/g;\n\nexport function getRef<T>(\n  openApi: OpenApi,\n  item: T & (OpenApiReferenceV2 | OpenApiReferenceV3),\n): T {\n  if (item.$ref) {\n    // Fetch the paths to the definitions, this converts:\n    // \"#/components/schemas/Form\" to [\"components\", \"schemas\", \"Form\"]\n    const paths = item.$ref.replace(/^#/g, '').split('/').filter(Boolean);\n\n    // Try to find the reference by walking down the path,\n    // if we cannot find it, then we throw an error.\n    let result = openApi;\n    paths.forEach((path) => {\n      const decodedPath = decodeURIComponent(\n        path.replace(ESCAPED_REF_SLASH, '/').replace(ESCAPED_REF_TILDE, '~'),\n      );\n      if (result.hasOwnProperty(decodedPath)) {\n        // @ts-expect-error\n        result = result[decodedPath];\n      } else {\n        throw new Error(`Could not find reference: \"${item.$ref}\"`);\n      }\n    });\n    return result as T;\n  }\n  return item as T;\n}\n","import type { Model } from '~/openApi/common/interfaces/client';\nimport { getRef } from '~/openApi/common/parser/getRef';\n\nimport type { Client } from '../../../types/client';\nimport type { GetModelFn } from '../interfaces/Model';\nimport type { OpenApi } from '../interfaces/OpenApi';\nimport type { OpenApiSchema } from '../interfaces/OpenApiSchema';\n\nexport const getRequiredPropertiesFromComposition = ({\n  definitions,\n  getModel,\n  openApi,\n  required,\n  types,\n}: {\n  definitions: OpenApiSchema[];\n  getModel: GetModelFn;\n  openApi: OpenApi;\n  required: string[];\n  types: Client['types'];\n}): Model[] =>\n  definitions\n    .reduce((properties, definition) => {\n      if (definition.$ref) {\n        const schema = getRef<OpenApiSchema>(openApi, definition);\n        return [\n          ...properties,\n          ...getModel({ definition: schema, openApi, types }).properties,\n        ];\n      }\n      return [\n        ...properties,\n        ...getModel({ definition, openApi, types }).properties,\n      ];\n    }, [] as Model[])\n    .filter(\n      (property) => !property.isRequired && required.includes(property.name),\n    )\n    .map((property) => ({\n      ...property,\n      isRequired: true,\n    }));\n","import type {\n  Model,\n  ModelComposition,\n} from '~/openApi/common/interfaces/client';\n\nimport type { Client } from '../../../types/client';\nimport type { GetModelFn } from '../interfaces/Model';\nimport type { OpenApi } from '../interfaces/OpenApi';\nimport type { OpenApiSchema } from '../interfaces/OpenApiSchema';\nimport { getModelProperties } from './getModelProperties';\nimport { getRequiredPropertiesFromComposition } from './getRequiredPropertiesFromComposition';\n\nexport const getModelComposition = ({\n  definition,\n  definitions,\n  getModel,\n  openApi,\n  type,\n  types,\n}: {\n  definition: OpenApiSchema;\n  definitions: OpenApiSchema[];\n  getModel: GetModelFn;\n  openApi: OpenApi;\n  type: 'one-of' | 'any-of' | 'all-of';\n  types: Client['types'];\n}): ModelComposition => {\n  const composition: ModelComposition = {\n    $refs: [],\n    enums: [],\n    export: type,\n    imports: [],\n    properties: [],\n  };\n\n  const properties: Model[] = [];\n\n  definitions\n    .map((definition) => getModel({ definition, openApi, types }))\n    .filter((model) => {\n      const hasProperties = model.properties.length;\n      const hasEnums = model.enums.length;\n      const isObject = model.type === 'unknown';\n      const isEmpty = isObject && !hasProperties && !hasEnums;\n      return !isEmpty;\n    })\n    .forEach((model) => {\n      composition.imports.push(...model.imports);\n      composition.enums.push(...model.enums);\n      composition.properties.push(model);\n    });\n\n  if (definition.required && type === 'all-of') {\n    const requiredProperties = getRequiredPropertiesFromComposition({\n      definitions,\n      getModel,\n      openApi,\n      required: definition.required,\n      types,\n    });\n    requiredProperties.forEach((requiredProperty) => {\n      composition.imports.push(...requiredProperty.imports);\n      composition.enums.push(...requiredProperty.enums);\n    });\n    properties.push(...requiredProperties);\n  }\n\n  if (definition.properties) {\n    const modelProperties = getModelProperties({\n      definition,\n      getModel,\n      openApi,\n      types,\n    });\n    modelProperties.forEach((modelProperty) => {\n      composition.imports.push(...modelProperty.imports);\n      composition.enums.push(...modelProperty.enums);\n      if (modelProperty.export === 'enum') {\n        composition.enums.push(modelProperty);\n      }\n    });\n    properties.push(...modelProperties);\n  }\n\n  if (properties.length) {\n    composition.properties.push({\n      $refs: [],\n      base: 'unknown',\n      description: '',\n      enum: [],\n      enums: [],\n      export: 'interface',\n      imports: [],\n      in: '',\n      isDefinition: false,\n      isNullable: false,\n      isReadOnly: false,\n      isRequired: false,\n      link: null,\n      name: 'properties',\n      properties,\n      template: null,\n      type: 'unknown',\n    });\n  }\n\n  return composition;\n};\n","import type { Model, ModelMeta } from '~/openApi/common/interfaces/client';\nimport { getEnums } from '~/openApi/common/parser/getEnums';\nimport { getPattern } from '~/openApi/common/parser/getPattern';\nimport { getType } from '~/openApi/common/parser/type';\n\nimport type { Client } from '../../../types/client';\nimport type { OpenApi } from '../interfaces/OpenApi';\nimport type { OpenApiSchema } from '../interfaces/OpenApiSchema';\nimport { getModelComposition } from './getModelComposition';\nimport { getModelProperties } from './getModelProperties';\n\nexport const getModel = ({\n  definition,\n  isDefinition = false,\n  meta,\n  openApi,\n  types,\n}: Pick<Client, 'types'> & {\n  definition: OpenApiSchema;\n  isDefinition?: boolean;\n  meta?: ModelMeta;\n  openApi: OpenApi;\n}): Model => {\n  const model: Model = {\n    $refs: [],\n    base: 'unknown',\n    description: definition.description || null,\n    enum: [],\n    enums: [],\n    exclusiveMaximum: definition.exclusiveMaximum,\n    exclusiveMinimum: definition.exclusiveMinimum,\n    export: 'interface',\n    format: definition.format,\n    imports: [],\n    in: '',\n    isDefinition,\n    isNullable: definition['x-nullable'] === true,\n    isReadOnly: definition.readOnly === true,\n    isRequired: false,\n    link: null,\n    maxItems: definition.maxItems,\n    maxLength: definition.maxLength,\n    maxProperties: definition.maxProperties,\n    maximum: definition.maximum,\n    meta,\n    minItems: definition.minItems,\n    minLength: definition.minLength,\n    minProperties: definition.minProperties,\n    minimum: definition.minimum,\n    multipleOf: definition.multipleOf,\n    name: meta?.name ?? '',\n    pattern: getPattern(definition.pattern),\n    properties: [],\n    template: null,\n    type: 'unknown',\n    uniqueItems: definition.uniqueItems,\n  };\n\n  if (definition.$ref) {\n    const definitionRef = getType({ type: definition.$ref });\n    model.export = 'reference';\n    model.type = definitionRef.type;\n    model.base = definitionRef.base;\n    model.template = definitionRef.template;\n    model.imports.push(...definitionRef.imports);\n    return model;\n  }\n\n  if (definition.enum && definition.type !== 'boolean') {\n    const enums = getEnums(definition, definition.enum);\n    if (enums.length) {\n      model.base = 'string';\n      model.enum = [...model.enum, ...enums];\n      model.export = 'enum';\n      model.type = 'string';\n      return model;\n    }\n  }\n\n  if (definition.type === 'array' && definition.items) {\n    if (definition.items.$ref) {\n      const arrayItems = getType({ type: definition.items.$ref });\n      model.export = 'array';\n      model.type = arrayItems.type;\n      model.base = arrayItems.base;\n      model.template = arrayItems.template;\n      model.imports.push(...arrayItems.imports);\n      return model;\n    } else {\n      const arrayItems = getModel({\n        definition: definition.items,\n        openApi,\n        types,\n      });\n      model.export = 'array';\n      model.type = arrayItems.type;\n      model.base = arrayItems.base;\n      model.template = arrayItems.template;\n      model.link = arrayItems;\n      model.imports.push(...arrayItems.imports);\n      return model;\n    }\n  }\n\n  if (\n    definition.type === 'object' &&\n    typeof definition.additionalProperties === 'object'\n  ) {\n    if (definition.additionalProperties.$ref) {\n      const additionalProperties = getType({\n        type: definition.additionalProperties.$ref,\n      });\n      model.export = 'dictionary';\n      model.type = additionalProperties.type;\n      model.base = additionalProperties.base;\n      model.template = additionalProperties.template;\n      model.imports.push(...additionalProperties.imports);\n      return model;\n    } else {\n      const additionalProperties = getModel({\n        definition: definition.additionalProperties,\n        openApi,\n        types,\n      });\n      model.export = 'dictionary';\n      model.type = additionalProperties.type;\n      model.base = additionalProperties.base;\n      model.template = additionalProperties.template;\n      model.link = additionalProperties;\n      model.imports.push(...additionalProperties.imports);\n      return model;\n    }\n  }\n\n  if (definition.allOf?.length) {\n    const composition = getModelComposition({\n      definition,\n      definitions: definition.allOf,\n      getModel,\n      openApi,\n      type: 'all-of',\n      types,\n    });\n    model.export = composition.export;\n    model.imports.push(...composition.imports);\n    model.properties.push(...composition.properties);\n    model.enums = [...model.enums, ...composition.enums];\n    return model;\n  }\n\n  if (definition.type === 'object') {\n    model.export = 'interface';\n    model.type = 'unknown';\n    model.base = 'unknown';\n\n    if (definition.properties) {\n      const modelProperties = getModelProperties({\n        definition,\n        getModel,\n        openApi,\n        types,\n      });\n      modelProperties.forEach((modelProperty) => {\n        model.imports.push(...modelProperty.imports);\n        model.enums = [...model.enums, ...modelProperty.enums];\n        model.properties.push(modelProperty);\n        if (modelProperty.export === 'enum') {\n          model.enums = [...model.enums, modelProperty];\n        }\n      });\n    }\n    return model;\n  }\n\n  // If the schema has a type than it can be a basic or generic type.\n  if (definition.type) {\n    const definitionType = getType({\n      format: definition.format,\n      type: definition.type,\n    });\n    model.export = 'generic';\n    model.type = definitionType.type;\n    model.base = definitionType.base;\n    model.template = definitionType.template;\n    model.imports.push(...definitionType.imports);\n    return model;\n  }\n\n  return model;\n};\n","import { getType } from '~/openApi/common/parser/type';\nimport { reservedJavaScriptKeywordsRegExp } from '~/utils/regexp';\n\nimport type { Client } from '../../../types/client';\nimport type { OpenApi } from '../interfaces/OpenApi';\nimport { getModel } from './getModel';\n\nexport const getModels = (\n  openApi: OpenApi,\n): Pick<Client, 'models' | 'types'> => {\n  const types: Client['types'] = {};\n  let models: Client['models'] = [];\n\n  Object.entries(openApi.definitions ?? {}).forEach(\n    ([definitionName, definition]) => {\n      const definitionType = getType({ type: definitionName });\n      const name = definitionType.base.replace(\n        reservedJavaScriptKeywordsRegExp,\n        '_$1',\n      );\n      const meta = {\n        $ref: `#/definitions/${definitionName}`,\n        name,\n      };\n      types[name] = meta;\n      const model = getModel({\n        definition,\n        isDefinition: true,\n        meta,\n        openApi,\n        types,\n      });\n      models = [...models, model];\n    },\n  );\n\n  return {\n    models,\n    types,\n  };\n};\n","export function sort(a: string, b: string): number {\n  const nameA = a.toLocaleLowerCase();\n  const nameB = b.toLocaleLowerCase();\n  return nameA.localeCompare(nameB, 'en');\n}\n\nexport const sorterByName = <T extends { name: string }>(a: T, b: T) =>\n  sort(a.name, b.name);\n\nexport function sortByName<T extends { name: string }>(items: T[]): T[] {\n  return items.sort(sorterByName);\n}\n","import type { Enum, Model } from '~/openApi';\nimport { ensureValidTypeScriptJavaScriptIdentifier } from '~/openApi';\n\nimport { unescapeName } from './escape';\nimport { sort } from './sort';\nimport { unique } from './unique';\n\n/**\n * Sanitizes names of enums, so they are valid typescript identifiers of a certain form.\n *\n * 1: Replace all characters not legal as part of identifier with '_'\n * 2: Add '_' prefix if first character of enum name has character not legal for start of identifier\n * 3: Add '_' where the string transitions from lowercase to uppercase\n * 4: Transform the whole string to uppercase\n *\n * Javascript identifier regexp pattern retrieved from https://developer.mozilla.org/docs/Web/JavaScript/Reference/Lexical_grammar#identifiers\n */\nexport const enumKey = (value?: string | number, customName?: string) => {\n  if (customName) {\n    return customName;\n  }\n  // prefix numbers with underscore\n  if (typeof value === 'number') {\n    return `'_${value}'`;\n  }\n\n  let key = '';\n  if (typeof value === 'string') {\n    key = value\n      .replace(/[^$\\u200c\\u200d\\p{ID_Continue}]/gu, '_')\n      .replace(/^([^$_\\p{ID_Start}])/u, '_$1')\n      .replace(/(\\p{Lowercase})(\\p{Uppercase}+)/gu, '$1_$2');\n  }\n  key = key.trim();\n  if (!key) {\n    key = 'empty_string';\n  }\n  return key.toUpperCase();\n};\n\nexport const enumUnionType = (enums: Enum[]) =>\n  enums\n    .map((enumerator) => enumValue(enumerator.value, true))\n    .filter(unique)\n    .join(' | ');\n\nexport const enumValue = (value?: string | number, union: boolean = false) => {\n  if (typeof value === 'string') {\n    if (value.includes(\"'\") && union) {\n      return `\"${value}\"`;\n    }\n    return `'${value}'`;\n  }\n  return value;\n};\n\nexport const enumEntry = (enumerator: Enum) => {\n  const key = enumKey(enumerator.value, enumerator.customName);\n  const value = enumValue(enumerator.value);\n  return { key, value };\n};\n\n/**\n * Represent enum in `meta` object for deduplication\n */\nexport const enumMeta = (model: Model): Required<Model>['meta'] => {\n  // serialize enum values in namespace for quick lookup\n  const serialized = model.enum\n    .map((enumerator) => enumEntry(enumerator))\n    .sort((a, b) => sort(a.key, b.key))\n    .map((enumerator) => `${enumerator.key}=${enumerator.value}`)\n    .join('&');\n  return {\n    $ref: `enum/${model.name}/${serialized}`,\n    name: ensureValidTypeScriptJavaScriptIdentifier(unescapeName(model.name)),\n  };\n};\n","import { getType } from '~/openApi';\n\nimport { refParametersPartial, refSchemasPartial } from './const';\nimport { reservedJavaScriptKeywordsRegExp } from './regexp';\nimport { cleanAndTransformTypeName } from './transform';\n\nexport const getParametersMeta = (definitionName: string) => {\n  const definitionType = getType({ type: definitionName });\n  /**\n   * Prefix parameter names to avoid name conflicts with schemas.\n   * Assuming people are mostly interested in importing schema types\n   * and don't care about this name as much. It should be resolved in\n   * a cleaner way, there just isn't a good deduplication strategy\n   * today. This is a workaround in the meantime, hopefully reducing\n   * the chance of conflicts.\n   *\n   * Example where this would break: schema named `ParameterFoo` and\n   * parameter named `Foo` (this would transform to `ParameterFoo`)\n   *\n   * Note: there's a related code to this workaround in `getType()`\n   * method that needs to be cleaned up when this is addressed.\n   */\n  const name = `Parameter${definitionType.base.replace(reservedJavaScriptKeywordsRegExp, '_$1')}`;\n  const meta = {\n    $ref: refParametersPartial + definitionName,\n    name,\n  };\n  return meta;\n};\n\n/**\n * @param definitionName Name of the schema definition in OpenAPI specification.\n * @returns meta object\n */\nexport const getSchemasMeta = (definitionName: string) => {\n  const name = cleanAndTransformTypeName(definitionName);\n  const meta = {\n    $ref: refSchemasPartial + definitionName,\n    name,\n  };\n  return meta;\n};\n","import type ts from 'typescript';\n\nimport type { Model } from '~/openApi';\nimport { sanitizeOperationParameterName } from '~/openApi';\nimport { type Property, tsc } from '~/tsc';\nimport type { Client } from '~/types/client';\n\nimport { getConfig, isLegacyClient } from './config';\nimport { refSchemasPartial } from './const';\nimport { enumValue } from './enum';\nimport { escapeComment, escapeName, unescapeName } from './escape';\nimport { getSchemasMeta } from './meta';\nimport { reservedJavaScriptKeywordsRegExp } from './regexp';\nimport { stringCase } from './stringCase';\nimport { unique } from './unique';\n\nexport const isModelDate = (model: Model): boolean =>\n  model.format === 'date' || model.format === 'date-time';\n\nconst base = (model: Model) => {\n  const config = getConfig();\n\n  if (model.base === 'binary') {\n    return tsc.typeUnionNode({\n      types: ['Blob', 'File'],\n    });\n  }\n\n  if (\n    config.plugins['@hey-api/transformers']?.config.dates &&\n    isModelDate(model)\n  ) {\n    return tsc.typeNode('Date');\n  }\n\n  return tsc.typeNode(model.base);\n};\n\nconst typeReference = (model: Model) => {\n  // nullable is false when base is null to avoid duplicate null statements\n  const isNullable = model.base === 'null' ? false : model.isNullable;\n  let typeNode = base(model);\n  /**\n   * special handling for single reference. The current approach didn't handle\n   * transformed names, this fixes that. We should add a more robust solution,\n   * but this will work for now.\n   * {@link https://github.com/hey-api/openapi-ts/issues/768}\n   */\n  if (model.export === 'reference' && model.$refs.length === 1) {\n    if (model.$refs[0]!.startsWith(refSchemasPartial)) {\n      const meta = getSchemasMeta(model.base);\n      typeNode = tsc.typeNode(meta.name);\n    }\n  }\n  const unionNode = tsc.typeUnionNode({\n    isNullable,\n    types: [typeNode],\n  });\n  return unionNode;\n};\n\nconst typeArray = (model: Model) => {\n  if (model.link) {\n    // We treat an array of `model.link` as constant size array definition.\n    if (Array.isArray(model.link)) {\n      const types = model.link.map((m) => toType(m));\n      const tuple = tsc.typeTupleNode({\n        isNullable: model.isNullable,\n        types,\n      });\n      return tuple;\n    }\n\n    // Special case where we use tuple to define constant size array.\n    if (\n      model.export === 'array' &&\n      model.maxItems &&\n      model.minItems &&\n      model.maxItems === model.minItems &&\n      model.maxItems <= 100\n    ) {\n      const types = Array(model.maxItems).fill(toType(model.link));\n      const tuple = tsc.typeTupleNode({\n        isNullable: model.isNullable,\n        types,\n      });\n      return tuple;\n    }\n\n    return tsc.typeArrayNode([toType(model.link)], model.isNullable);\n  }\n\n  return tsc.typeArrayNode([base(model)], model.isNullable);\n};\n\nconst typeEnum = (model: Model) => {\n  const values = model.enum.map((enumerator) => enumValue(enumerator.value));\n  return tsc.typeUnionNode({\n    isNullable: model.isNullable,\n    types: values,\n  });\n};\n\nconst typeDict = (model: Model) => {\n  const type =\n    model.link && !Array.isArray(model.link) ? toType(model.link) : base(model);\n  return tsc.typeRecordNode(['string'], [type], model.isNullable, true);\n};\n\nconst typeUnionOrIntersection = ({\n  model,\n  style,\n}: {\n  model: Model;\n  style: 'intersection' | 'union';\n}) => {\n  const types = model.properties\n    .map((model) => {\n      const str = tsc.nodeToString({\n        node: toType(model),\n        unescape: true,\n      });\n      return str;\n    })\n    .filter(unique);\n\n  const node =\n    style === 'union'\n      ? tsc.typeUnionNode({\n          // avoid printing duplicate null statements\n          isNullable:\n            model.isNullable &&\n            !model.properties.find((property) => property.isNullable),\n          types,\n        })\n      : tsc.typeIntersectionNode({\n          isNullable: model.isNullable,\n          types,\n        });\n\n  // top-level models don't need parentheses around them\n  if (model.meta) {\n    return node;\n  }\n\n  return tsc.typeParenthesizedNode({\n    type: node,\n  });\n};\n\nconst typeInterface = (model: Model) => {\n  if (!model.properties.length) {\n    return tsc.typeNode('unknown');\n  }\n\n  const config = getConfig();\n\n  const isLegacy = isLegacyClient(config);\n\n  const properties: Property[] = model.properties.map((property) => {\n    let maybeRequired = property.isRequired ? '' : '?';\n    let value = toType(property);\n    let name = !isLegacy\n      ? escapeName(unescapeName(transformTypeKeyName(property.name)))\n      : // special test for 1XX status codes. We need a more robust system\n        // for escaping values depending on context in which they're printed,\n        // but since this works for client packages, it's not worth it right now\n        /^\\dXX$/.test(property.name)\n        ? escapeName(property.name)\n        : property.name;\n    // special case for additional properties type\n    if (property.name === '[key: string]') {\n      name = property.name;\n      if (maybeRequired) {\n        maybeRequired = '';\n        value = tsc.typeUnionNode({\n          types: [value, 'undefined'],\n        });\n      }\n    }\n    return {\n      comment: [\n        property.description && escapeComment(property.description),\n        property.deprecated && '@deprecated',\n      ],\n      isReadOnly: property.isReadOnly,\n      isRequired: maybeRequired === '',\n      name,\n      type: value,\n    };\n  });\n\n  return tsc.typeInterfaceNode({\n    isNullable: model.isNullable,\n    properties,\n    useLegacyResolution: true,\n  });\n};\n\nexport const toType = (model: Model): ts.TypeNode => {\n  switch (model.export) {\n    case 'all-of':\n      return typeUnionOrIntersection({\n        model,\n        style: 'intersection',\n      });\n    case 'any-of':\n    case 'one-of':\n      return typeUnionOrIntersection({\n        model,\n        style: 'union',\n      });\n    case 'array':\n      return typeArray(model);\n    case 'dictionary':\n      return typeDict(model);\n    case 'enum':\n      return typeEnum(model);\n    case 'interface':\n      return typeInterface(model);\n    case 'const':\n    case 'generic':\n    case 'reference':\n    default:\n      return typeReference(model);\n  }\n};\n\nexport interface SetUniqueTypeNameResult {\n  /**\n   * Did this function add a new property to the `client.types` object?\n   */\n  created: boolean;\n  /**\n   * Unique name for the exported type.\n   */\n  name: string;\n}\n\n/**\n * Generates a unique name for the exported type for given model meta.\n * @param args.client Internal client instance\n * @param args.count Unique key for deduplication\n * @param args.create If a name record does not exist, should it be created?\n * @param args.meta Meta property from the model\n * @param args.nameTransformer Function for transforming name into the final\n * value. In different contexts, a different strategy might be used. For\n * example, slashes `/` are invalid in TypeScript identifiers, but okay in\n * a JavaScript object key name.\n * @returns {SetUniqueTypeNameResult}\n */\nexport const setUniqueTypeName = ({\n  client,\n  count = 1,\n  create = false,\n  meta,\n  nameTransformer,\n}: Pick<Required<Model>, 'meta'> & {\n  client: Client;\n  count?: number;\n  create?: boolean;\n  nameTransformer?: (value: string) => string;\n}): SetUniqueTypeNameResult => {\n  let result: SetUniqueTypeNameResult = {\n    created: false,\n    name: '',\n  };\n  let name = meta.name;\n  if (nameTransformer) {\n    name = nameTransformer(name);\n  }\n  if (count > 1) {\n    name = `${name}${count}`;\n  }\n  const type = client.types[name];\n  if (!type) {\n    if (create) {\n      client.types[name] = meta;\n      result = {\n        created: true,\n        name,\n      };\n    }\n  } else if (type.$ref === meta.$ref) {\n    result = {\n      created: false,\n      name,\n    };\n  } else {\n    result = setUniqueTypeName({\n      client,\n      count: count + 1,\n      create,\n      meta,\n      nameTransformer,\n    });\n  }\n  return result;\n};\n\nexport interface UnsetUniqueTypeNameResult {\n  /**\n   * Did this function delete a property from the `client.types` object?\n   */\n  deleted: boolean;\n  /**\n   * Unique name removed from the `client.types` object.\n   */\n  name: string;\n}\n\nexport const unsetUniqueTypeName = ({\n  client,\n  name,\n}: {\n  client: Client;\n  name: string;\n}): UnsetUniqueTypeNameResult => {\n  let result: UnsetUniqueTypeNameResult = {\n    deleted: false,\n    name: '',\n  };\n  if (!client.types[name]) {\n    return result;\n  }\n  delete client.types[name];\n  result = {\n    deleted: true,\n    name,\n  };\n  return result;\n};\n\n/**\n * Replaces any invalid characters from a parameter name.\n * For example: 'filter.someProperty' becomes 'filterSomeProperty'.\n */\nexport const transformTypeKeyName = (value: string): string => {\n  const config = getConfig();\n\n  // transform only for legacy clients\n  if (!isLegacyClient(config)) {\n    return value;\n  }\n\n  const name = stringCase({\n    case: 'camelCase',\n    value: sanitizeOperationParameterName(value),\n  }).replace(reservedJavaScriptKeywordsRegExp, '_$1');\n  return name;\n};\n","import { getConfig, isLegacyClient } from '~/utils/config';\nimport { stringCase } from '~/utils/stringCase';\nimport { transformTypeKeyName } from '~/utils/type';\n\nimport type { Config } from '../../../types/config';\nimport type {\n  OperationParameter,\n  OperationResponse,\n} from '../interfaces/client';\nimport { sanitizeNamespaceIdentifier } from './sanitize';\n\nexport const getOperationResponseHeader = (\n  operationResponses: OperationResponse[],\n): string | null => {\n  const header = operationResponses.find(\n    (operationResponses) => operationResponses.in === 'header',\n  );\n  if (header) {\n    return header.name;\n  }\n  return null;\n};\n\n/**\n * Does this operation have at least one required parameter?\n * @returns boolean\n */\nexport const isOperationParameterRequired = (\n  parameters: OperationParameter[],\n) => {\n  const isRequired = parameters.some((parameter) => parameter.isRequired);\n  return isRequired;\n};\n\n/**\n * Attempts to parse response status code from string into number.\n * @param value string status code from OpenAPI definition\n * @returns Parsed status code or null if invalid value\n */\nexport const parseResponseStatusCode = (\n  value: string,\n): OperationResponse['code'] | null => {\n  if (value === 'default') {\n    return 'default';\n  }\n\n  if (value === '1XX') {\n    return '1XX';\n  }\n\n  if (value === '2XX') {\n    return '2XX';\n  }\n\n  if (value === '3XX') {\n    return '3XX';\n  }\n\n  if (value === '4XX') {\n    return '4XX';\n  }\n\n  if (value === '5XX') {\n    return '5XX';\n  }\n\n  if (/\\d{3}/g.test(value)) {\n    const code = Number.parseInt(value, 10);\n    if (code >= 100 && code < 600) {\n      return code;\n    }\n  }\n\n  return null;\n};\n\nexport const sorterByResponseStatusCode = (\n  a: OperationResponse,\n  b: OperationResponse,\n) => {\n  if (a.code > b.code) {\n    return 1;\n  }\n\n  if (a.code < b.code) {\n    return -1;\n  }\n\n  return 0;\n};\n\nconst isErrorStatusCode = (code: OperationResponse['code']) =>\n  code === '3XX' ||\n  code === '4XX' ||\n  code === '5XX' ||\n  (typeof code === 'number' && code >= 300);\n\nconst isSuccessStatusCode = (code: OperationResponse['code']) =>\n  code === '2XX' || (typeof code === 'number' && code >= 200 && code < 300);\n\n/**\n * Detects whether default response is meant to be used\n * for error or success response.\n */\nconst inferDefaultResponseTypes = (\n  response: OperationResponse,\n  responses: OperationResponse[],\n) => {\n  let types: Array<'error' | 'success'> = [];\n\n  const addResponseType = (type: (typeof types)[number]) => {\n    if (!types.includes(type)) {\n      types = [...types, type];\n    }\n  };\n\n  const hasSuccessResponse = responses.some(({ code }) =>\n    isSuccessStatusCode(code),\n  );\n  if (!hasSuccessResponse) {\n    addResponseType('success');\n  }\n\n  const description = (response.description ?? '').toLocaleLowerCase();\n  const $refs = response.$refs.join('|').toLocaleLowerCase();\n\n  // must be in lowercase\n  const errorKeywords = ['error', 'problem'];\n  const successKeywords = ['success'];\n\n  if (\n    successKeywords.some(\n      (keyword) => description.includes(keyword) || $refs.includes(keyword),\n    )\n  ) {\n    addResponseType('success');\n  }\n\n  if (\n    errorKeywords.some(\n      (keyword) => description.includes(keyword) || $refs.includes(keyword),\n    )\n  ) {\n    addResponseType('error');\n  }\n\n  if (!types.length) {\n    addResponseType('error');\n  }\n\n  return types;\n};\n\nexport const operationFilterFn = ({\n  config,\n  operationKey,\n}: {\n  config: Config;\n  operationKey: string;\n}): boolean => {\n  const regexp = config.plugins['@hey-api/sdk']?.config.filter\n    ? new RegExp(config.plugins['@hey-api/sdk']?.config.filter)\n    : undefined;\n  return !regexp || regexp.test(operationKey);\n};\n\n/**\n * Convert the input value to a correct operation (method) class name.\n * This will use the operation ID - if available - and otherwise fallback\n * on a generated name from the URL\n */\nexport const operationNameFn = ({\n  config,\n  method,\n  operationId,\n  path,\n}: {\n  config: Config;\n  method: string;\n  operationId: string | undefined;\n  path: string;\n}): string => {\n  if (config.plugins['@hey-api/sdk']?.config.operationId && operationId) {\n    return stringCase({\n      case: 'camelCase',\n      value: sanitizeNamespaceIdentifier(operationId),\n    });\n  }\n\n  let urlWithoutPlaceholders = path;\n\n  // legacy clients ignore the \"api-version\" param since we do not want to\n  // add it as the first/default parameter for each of the service calls\n  if (isLegacyClient(config)) {\n    urlWithoutPlaceholders = urlWithoutPlaceholders.replace(\n      /[^/]*?{api-version}.*?\\//g,\n      '',\n    );\n  }\n\n  urlWithoutPlaceholders = urlWithoutPlaceholders\n    .replace(/{(.*?)}/g, 'by-$1')\n    // replace slashes with hyphens for camelcase method at the end\n    .replace(/[/:+]/g, '-');\n\n  return stringCase({\n    case: 'camelCase',\n    value: `${method}-${urlWithoutPlaceholders}`,\n  });\n};\n\nexport const operationParameterFilterFn = (\n  parameter: OperationParameter,\n): boolean => {\n  const config = getConfig();\n\n  // legacy clients ignore the \"api-version\" param since we do not want to\n  // add it as the first/default parameter for each of the service calls\n  return !isLegacyClient(config) || parameter.prop !== 'api-version';\n};\n\nexport const operationParameterNameFn = (\n  parameter: Omit<OperationParameter, 'name'>,\n): string => {\n  const config = getConfig();\n\n  return !isLegacyClient(config)\n    ? parameter.prop\n    : transformTypeKeyName(parameter.prop);\n};\n\nexport const tagResponseTypes = (responses: OperationResponse[]) =>\n  responses.map((response) => {\n    const { code } = response;\n    if (code === 'default') {\n      response.responseTypes = inferDefaultResponseTypes(response, responses);\n    } else if (isSuccessStatusCode(code)) {\n      response.responseTypes = ['success'];\n    } else if (isErrorStatusCode(code)) {\n      response.responseTypes = ['error'];\n    }\n    return response;\n  });\n","import type { OpenApiParameter } from '~/openApi/v2/interfaces/OpenApiParameter';\nimport type { OpenApiSchema } from '~/openApi/v3/interfaces/OpenApiSchema';\nimport { getDefinitionTypes } from '~/openApi/v3/parser/inferType';\n\nimport type { Model } from '../../common/interfaces/client';\nimport type { OperationParameter } from '../interfaces/client';\n\nexport const getDefault = (\n  definition: OpenApiSchema | OpenApiParameter,\n  model?: Model | OperationParameter,\n): unknown | undefined => {\n  if (definition.default === undefined || definition.default === null) {\n    return definition.default;\n  }\n\n  const definitionTypes = getDefinitionTypes(definition);\n\n  const type =\n    definitionTypes.find((type) => type !== 'null') ||\n    typeof definition.default;\n\n  switch (type) {\n    case 'int':\n    case 'integer':\n    case 'number':\n      if (\n        model?.export === 'enum' &&\n        model.enum?.[definition.default as number]\n      ) {\n        const { value } = model.enum[definition.default as number]!;\n        return value;\n      }\n      return definition.default;\n    case 'array':\n    case 'boolean':\n    case 'object':\n    case 'string':\n      return definition.default;\n    default:\n      return;\n  }\n};\n","import type { OperationParameter } from '~/openApi/common/interfaces/client';\nimport { getDefault } from '~/openApi/common/parser/getDefault';\nimport { getEnums } from '~/openApi/common/parser/getEnums';\nimport { getPattern } from '~/openApi/common/parser/getPattern';\nimport { getRef } from '~/openApi/common/parser/getRef';\nimport { operationParameterNameFn } from '~/openApi/common/parser/operation';\nimport { getType } from '~/openApi/common/parser/type';\n\nimport type { Client } from '../../../types/client';\nimport type { OpenApi } from '../interfaces/OpenApi';\nimport type { OpenApiParameter } from '../interfaces/OpenApiParameter';\nimport type { OpenApiSchema } from '../interfaces/OpenApiSchema';\nimport { getModel } from './getModel';\n\nexport const getOperationParameter = ({\n  openApi,\n  parameter,\n  types,\n}: {\n  openApi: OpenApi;\n  parameter: OpenApiParameter;\n  types: Client['types'];\n}): OperationParameter => {\n  const operationParameterWithoutName: Omit<OperationParameter, 'name'> = {\n    $refs: [],\n    base: 'unknown',\n    description: parameter.description || null,\n    enum: [],\n    enums: [],\n    exclusiveMaximum: parameter.exclusiveMaximum,\n    exclusiveMinimum: parameter.exclusiveMinimum,\n    export: 'interface',\n    format: parameter.format,\n    imports: [],\n    in: parameter.in,\n    isDefinition: false,\n    isNullable: parameter['x-nullable'] === true,\n    isReadOnly: false,\n    isRequired: parameter.required === true,\n    link: null,\n    maxItems: parameter.maxItems,\n    maxLength: parameter.maxLength,\n    maximum: parameter.maximum,\n    mediaType: null,\n    minItems: parameter.minItems,\n    minLength: parameter.minLength,\n    minimum: parameter.minimum,\n    multipleOf: parameter.multipleOf,\n    pattern: getPattern(parameter.pattern),\n    prop: parameter.name,\n    properties: [],\n    template: null,\n    type: 'unknown',\n    uniqueItems: parameter.uniqueItems,\n  };\n  let operationParameter = {\n    ...operationParameterWithoutName,\n    name: operationParameterNameFn(operationParameterWithoutName),\n  };\n\n  if (parameter.$ref) {\n    const model = getType({ type: parameter.$ref });\n    operationParameter = {\n      ...operationParameter,\n      $refs: [...operationParameter.$refs, ...model.$refs],\n      base: model.base,\n      export: 'reference',\n      imports: [...operationParameter.imports, ...model.imports],\n      template: model.template,\n      type: model.type,\n    };\n    operationParameter.default = getDefault(parameter, operationParameter);\n    return operationParameter;\n  }\n\n  if (parameter.enum) {\n    const model = getEnums(parameter, parameter.enum);\n    if (model.length) {\n      operationParameter = {\n        ...operationParameter,\n        base: 'string',\n        enum: [...operationParameter.enum, ...model],\n        export: 'enum',\n        type: 'string',\n      };\n      operationParameter.default = getDefault(parameter, operationParameter);\n      return operationParameter;\n    }\n  }\n\n  if (parameter.type === 'array' && parameter.items) {\n    const model = getType({\n      format: parameter.items.format,\n      type: parameter.items.type,\n    });\n    operationParameter = {\n      ...operationParameter,\n      $refs: [...operationParameter.$refs, ...model.$refs],\n      base: model.base,\n      export: 'array',\n      imports: [...operationParameter.imports, ...model.imports],\n      template: model.template,\n      type: model.type,\n    };\n    operationParameter.default = getDefault(parameter, operationParameter);\n    return operationParameter;\n  }\n\n  if (parameter.type === 'object' && parameter.items) {\n    const model = getType({\n      format: parameter.items.format,\n      type: parameter.items.type,\n    });\n    operationParameter = {\n      ...operationParameter,\n      $refs: [...operationParameter.$refs, ...model.$refs],\n      base: model.base,\n      export: 'dictionary',\n      imports: [...operationParameter.imports, ...model.imports],\n      template: model.template,\n      type: model.type,\n    };\n    operationParameter.default = getDefault(parameter, operationParameter);\n    return operationParameter;\n  }\n\n  let schema = parameter.schema;\n  if (schema) {\n    if (schema.$ref?.startsWith('#/parameters/')) {\n      schema = getRef<OpenApiSchema>(openApi, schema);\n    }\n\n    if (schema.$ref) {\n      const model = getType({ type: schema.$ref });\n      operationParameter = {\n        ...operationParameter,\n        $refs: [...operationParameter.$refs, ...model.$refs],\n        base: model.base,\n        export: 'reference',\n        imports: [...operationParameter.imports, ...model.imports],\n        template: model.template,\n        type: model.type,\n      };\n      operationParameter.default = getDefault(parameter, operationParameter);\n      return operationParameter;\n    }\n\n    const model = getModel({ definition: schema, openApi, types });\n    operationParameter = {\n      ...operationParameter,\n      $refs: [...operationParameter.$refs, ...model.$refs],\n      base: model.base,\n      enum: [...operationParameter.enum, ...model.enum],\n      enums: [...operationParameter.enums, ...model.enums],\n      export: model.export,\n      imports: [...operationParameter.imports, ...model.imports],\n      link: model.link,\n      properties: [...operationParameter.properties, ...model.properties],\n      template: model.template,\n      type: model.type,\n    };\n    operationParameter.default = getDefault(parameter, operationParameter);\n    return operationParameter;\n  }\n\n  // If the parameter has a type than it can be a basic or generic type.\n  if (parameter.type) {\n    const model = getType({\n      format: parameter.format,\n      type: parameter.type,\n    });\n    operationParameter = {\n      ...operationParameter,\n      $refs: [...operationParameter.$refs, ...model.$refs],\n      base: model.base,\n      export: 'generic',\n      imports: [...operationParameter.imports, ...model.imports],\n      template: model.template,\n      type: model.type,\n    };\n    operationParameter.default = getDefault(parameter, operationParameter);\n    return operationParameter;\n  }\n\n  return operationParameter;\n};\n","import type { OperationParameters } from '~/openApi/common/interfaces/client';\nimport { getRef } from '~/openApi/common/parser/getRef';\nimport { operationParameterFilterFn } from '~/openApi/common/parser/operation';\n\nimport type { Client } from '../../../types/client';\nimport type { OpenApi } from '../interfaces/OpenApi';\nimport type { OpenApiParameter } from '../interfaces/OpenApiParameter';\nimport { getOperationParameter } from './getOperationParameter';\n\nconst allowedIn = ['body', 'formData', 'header', 'path', 'query'] as const;\n\nexport const getOperationParameters = ({\n  openApi,\n  parameters,\n  types,\n}: {\n  openApi: OpenApi;\n  parameters: OpenApiParameter[];\n  types: Client['types'];\n}): OperationParameters => {\n  const operationParameters: OperationParameters = {\n    $refs: [],\n    imports: [],\n    parameters: [],\n    parametersBody: null,\n    parametersCookie: [], // not used in v2\n    parametersForm: [],\n    parametersHeader: [],\n    parametersPath: [],\n    parametersQuery: [],\n  };\n\n  parameters.forEach((parameterOrReference) => {\n    const parameterDef = getRef<OpenApiParameter>(\n      openApi,\n      parameterOrReference,\n    );\n    const parameter = getOperationParameter({\n      openApi,\n      parameter: parameterDef,\n      types,\n    });\n\n    const skip = !operationParameterFilterFn(parameter);\n    if (!allowedIn.includes(parameterDef.in) || skip) {\n      return;\n    }\n\n    switch (parameterDef.in) {\n      case 'body':\n        operationParameters.parametersBody = parameter;\n        break;\n      case 'formData':\n        operationParameters.parametersForm = [\n          ...operationParameters.parametersForm,\n          parameter,\n        ];\n        break;\n      case 'header':\n        operationParameters.parametersHeader = [\n          ...operationParameters.parametersHeader,\n          parameter,\n        ];\n        break;\n      case 'path':\n        operationParameters.parametersPath = [\n          ...operationParameters.parametersPath,\n          parameter,\n        ];\n        break;\n      case 'query':\n        operationParameters.parametersQuery = [\n          ...operationParameters.parametersQuery,\n          parameter,\n        ];\n        break;\n    }\n\n    operationParameters.$refs = [\n      ...operationParameters.$refs,\n      ...parameter.$refs,\n    ];\n    operationParameters.imports = [\n      ...operationParameters.imports,\n      ...parameter.imports,\n    ];\n    operationParameters.parameters = [\n      ...operationParameters.parameters,\n      parameter,\n    ];\n  });\n\n  return operationParameters;\n};\n","/**\n * Sort list of values and ensure that required parameters are first so that we do not generate\n * invalid types. Optional parameters cannot be positioned after required ones.\n */\nexport function toSortedByRequired<\n  T extends { default?: unknown; isRequired: boolean },\n>(values: T[]): T[] {\n  return values.sort((a, b) => {\n    const aNeedsValue = a.isRequired && a.default === undefined;\n    const bNeedsValue = b.isRequired && b.default === undefined;\n    if (aNeedsValue && !bNeedsValue) return -1;\n    if (bNeedsValue && !aNeedsValue) return 1;\n    return 0;\n  });\n}\n","import type { OperationResponse } from '~/openApi/common/interfaces/client';\nimport { getPattern } from '~/openApi/common/parser/getPattern';\nimport { getRef } from '~/openApi/common/parser/getRef';\nimport { getType } from '~/openApi/common/parser/type';\n\nimport type { Client } from '../../../types/client';\nimport type { OpenApi } from '../interfaces/OpenApi';\nimport type { OpenApiResponse } from '../interfaces/OpenApiResponse';\nimport type { OpenApiSchema } from '../interfaces/OpenApiSchema';\nimport { getModel } from './getModel';\n\nexport const getOperationResponse = ({\n  code,\n  openApi,\n  response,\n  types,\n}: {\n  code: OperationResponse['code'];\n  openApi: OpenApi;\n  response: OpenApiResponse;\n  types: Client['types'];\n}): OperationResponse => {\n  const operationResponse: OperationResponse = {\n    $refs: [],\n    base: code !== 204 ? 'unknown' : 'void',\n    code,\n    description: response.description || null,\n    enum: [],\n    enums: [],\n    export: 'generic',\n    imports: [],\n    in: 'response',\n    isDefinition: false,\n    isNullable: false,\n    isReadOnly: false,\n    isRequired: false,\n    link: null,\n    name: '',\n    properties: [],\n    responseTypes: [],\n    template: null,\n    type: code !== 204 ? 'unknown' : 'void',\n  };\n\n  let schema = response.schema;\n  if (schema) {\n    if (schema.$ref?.startsWith('#/responses/')) {\n      schema = getRef<OpenApiSchema>(openApi, schema);\n    }\n\n    if (schema.$ref) {\n      const model = getType({ type: schema.$ref });\n      operationResponse.export = 'reference';\n      operationResponse.type = model.type;\n      operationResponse.base = model.base;\n      operationResponse.template = model.template;\n      operationResponse.imports = [\n        ...operationResponse.imports,\n        ...model.imports,\n      ];\n      return operationResponse;\n    }\n\n    const model = getModel({ definition: schema, openApi, types });\n    operationResponse.export = model.export;\n    operationResponse.type = model.type;\n    operationResponse.base = model.base;\n    operationResponse.template = model.template;\n    operationResponse.link = model.link;\n    operationResponse.isReadOnly = model.isReadOnly;\n    operationResponse.isRequired = model.isRequired;\n    operationResponse.isNullable = model.isNullable;\n    operationResponse.format = model.format;\n    operationResponse.maximum = model.maximum;\n    operationResponse.exclusiveMaximum = model.exclusiveMaximum;\n    operationResponse.minimum = model.minimum;\n    operationResponse.exclusiveMinimum = model.exclusiveMinimum;\n    operationResponse.multipleOf = model.multipleOf;\n    operationResponse.maxLength = model.maxLength;\n    operationResponse.minLength = model.minLength;\n    operationResponse.maxItems = model.maxItems;\n    operationResponse.minItems = model.minItems;\n    operationResponse.uniqueItems = model.uniqueItems;\n    operationResponse.maxProperties = model.maxProperties;\n    operationResponse.minProperties = model.minProperties;\n    operationResponse.pattern = getPattern(model.pattern);\n    operationResponse.imports = [\n      ...operationResponse.imports,\n      ...model.imports,\n    ];\n    operationResponse.enum = [...operationResponse.enum, ...model.enum];\n    operationResponse.enums = [...operationResponse.enums, ...model.enums];\n    operationResponse.properties = [\n      ...operationResponse.properties,\n      ...model.properties,\n    ];\n    return operationResponse;\n  }\n\n  // We support basic properties from response headers, since both\n  // fetch and XHR client just support string types.\n  if (response.headers) {\n    for (const name in response.headers) {\n      operationResponse.in = 'header';\n      operationResponse.name = name;\n      operationResponse.type = 'string';\n      operationResponse.base = 'string';\n      return operationResponse;\n    }\n  }\n\n  return operationResponse;\n};\n","import type { OperationResponse } from '~/openApi/common/interfaces/client';\nimport { getRef } from '~/openApi/common/parser/getRef';\nimport {\n  parseResponseStatusCode,\n  sorterByResponseStatusCode,\n  tagResponseTypes,\n} from '~/openApi/common/parser/operation';\n\nimport type { Client } from '../../../types/client';\nimport type { OpenApi } from '../interfaces/OpenApi';\nimport type { OpenApiResponse } from '../interfaces/OpenApiResponse';\nimport type { OpenApiResponses } from '../interfaces/OpenApiResponses';\nimport { getOperationResponse } from './getOperationResponse';\n\nexport const getOperationResponses = ({\n  openApi,\n  responses,\n  types,\n}: {\n  openApi: OpenApi;\n  responses: OpenApiResponses;\n  types: Client['types'];\n}): OperationResponse[] => {\n  let operationResponses: OperationResponse[] = [];\n\n  Object.entries(responses).forEach(([responseCode, responseOrReference]) => {\n    const code = parseResponseStatusCode(responseCode);\n    if (!code) {\n      return;\n    }\n\n    const response = getRef<OpenApiResponse>(openApi, responseOrReference);\n    const operationResponse = getOperationResponse({\n      code,\n      openApi,\n      response,\n      types,\n    });\n    operationResponses = [...operationResponses, operationResponse];\n  });\n\n  operationResponses = tagResponseTypes(operationResponses);\n\n  return operationResponses.sort(sorterByResponseStatusCode);\n};\n","import type {\n  Operation,\n  OperationParameters,\n} from '~/openApi/common/interfaces/client';\nimport {\n  getOperationResponseHeader,\n  operationNameFn,\n} from '~/openApi/common/parser/operation';\nimport { toSortedByRequired } from '~/openApi/common/parser/sort';\nimport { getConfig } from '~/utils/config';\n\nimport type { Client } from '../../../types/client';\nimport type { OpenApi } from '../interfaces/OpenApi';\nimport type { OpenApiOperation } from '../interfaces/OpenApiOperation';\nimport { getOperationParameters } from './getOperationParameters';\nimport { getOperationResponses } from './getOperationResponses';\n\nexport const getOperation = ({\n  method,\n  op,\n  openApi,\n  pathParams,\n  types,\n  url,\n}: {\n  method: Lowercase<Operation['method']>;\n  op: OpenApiOperation;\n  openApi: OpenApi;\n  pathParams: OperationParameters;\n  types: Client['types'];\n  url: string;\n}): Operation => {\n  const operationWithoutName: Omit<Operation, 'name'> = {\n    $refs: [],\n    deprecated: op.deprecated === true,\n    description: op.description || null,\n    id: op.operationId || null,\n    imports: [],\n    method: method.toUpperCase() as Operation['method'],\n    parameters: [...pathParams.parameters],\n    parametersBody: pathParams.parametersBody,\n    parametersCookie: [...pathParams.parametersCookie],\n    parametersForm: [...pathParams.parametersForm],\n    parametersHeader: [...pathParams.parametersHeader],\n    parametersPath: [...pathParams.parametersPath],\n    parametersQuery: [...pathParams.parametersQuery],\n    path: url,\n    responseHeader: null,\n    responses: [],\n    summary: op.summary || null,\n    tags: op.tags || null,\n  };\n  const operation = {\n    ...operationWithoutName,\n    name: operationNameFn({\n      config: getConfig(),\n      method: operationWithoutName.method,\n      operationId: op.operationId,\n      path: operationWithoutName.path,\n    }),\n  };\n\n  if (op.parameters) {\n    const parameters = getOperationParameters({\n      openApi,\n      parameters: op.parameters,\n      types,\n    });\n    operation.$refs = [...operation.$refs, ...parameters.$refs];\n    operation.imports = [...operation.imports, ...parameters.imports];\n    operation.parameters = [...operation.parameters, ...parameters.parameters];\n    operation.parametersBody = parameters.parametersBody;\n    operation.parametersCookie = [\n      ...operation.parametersCookie,\n      ...parameters.parametersCookie,\n    ];\n    operation.parametersForm = [\n      ...operation.parametersForm,\n      ...parameters.parametersForm,\n    ];\n    operation.parametersHeader = [\n      ...operation.parametersHeader,\n      ...parameters.parametersHeader,\n    ];\n    operation.parametersPath = [\n      ...operation.parametersPath,\n      ...parameters.parametersPath,\n    ];\n    operation.parametersQuery = [\n      ...operation.parametersQuery,\n      ...parameters.parametersQuery,\n    ];\n  }\n\n  if (op.responses) {\n    operation.responses = getOperationResponses({\n      openApi,\n      responses: op.responses,\n      types,\n    });\n    const successResponses = operation.responses.filter((response) =>\n      response.responseTypes.includes('success'),\n    );\n\n    operation.responseHeader = getOperationResponseHeader(successResponses);\n\n    successResponses.forEach((response) => {\n      operation.$refs = [...operation.$refs, ...response.$refs];\n      operation.imports = [...operation.imports, ...response.imports];\n    });\n  }\n\n  operation.parameters = toSortedByRequired(operation.parameters);\n\n  return operation;\n};\n","import { createOperationKey } from '~/ir/operation';\nimport type { Client, Operation } from '~/openApi/common/interfaces/client';\nimport { operationFilterFn } from '~/openApi/common/parser/operation';\nimport { allowedServiceMethods } from '~/openApi/common/parser/service';\nimport { getConfig } from '~/utils/config';\n\nimport type { OpenApi } from '../interfaces/OpenApi';\nimport { getOperationParameters } from './getOperationParameters';\nimport { getOperation } from './operation';\n\nexport const getOperations = ({\n  openApi,\n  types,\n}: {\n  openApi: OpenApi;\n  types: Client['types'];\n}): Operation[] => {\n  const operationIds = new Map<string, string>();\n  const operations: Operation[] = [];\n\n  const config = getConfig();\n\n  for (const path in openApi.paths) {\n    const pathItem = openApi.paths[path]!;\n    const pathParameters = getOperationParameters({\n      openApi,\n      parameters: pathItem.parameters ?? [],\n      types,\n    });\n\n    for (const name in pathItem) {\n      const method = name as Lowercase<Operation['method']>;\n\n      const operationKey = createOperationKey({\n        method,\n        path,\n      });\n\n      if (allowedServiceMethods.includes(method)) {\n        const op = pathItem[method]!;\n\n        if (op.operationId) {\n          if (operationIds.has(op.operationId)) {\n            if (config.logs.level !== 'silent') {\n              console.warn(\n                ` Duplicate operationId: ${op.operationId} in ${operationKey}. Please ensure your operation IDs are unique. This behavior is not supported and will likely lead to unexpected results.`,\n              );\n            }\n          } else {\n            operationIds.set(op.operationId, operationKey);\n          }\n        }\n\n        if (\n          operationFilterFn({\n            config,\n            operationKey,\n          })\n        ) {\n          const operation = getOperation({\n            method,\n            op,\n            openApi,\n            pathParams: pathParameters,\n            types,\n            url: path,\n          });\n          operations.push(operation);\n        }\n      }\n    }\n  }\n\n  return operations;\n};\n","import type { OpenApi } from '../interfaces/OpenApi';\n\n/**\n * Get the base server url.\n * @param openApi\n */\nexport const getServer = (openApi: OpenApi): string => {\n  const scheme = openApi.schemes?.[0] || 'http';\n  const host = openApi.host;\n  const basePath = openApi.basePath || '';\n  const url = host ? `${scheme}://${host}${basePath}` : basePath;\n  return url.replace(/\\/$/g, '');\n};\n","import type { Client } from '~/openApi/common/interfaces/client';\nimport { getServiceVersion } from '~/openApi/common/parser/service';\n\nimport type { OpenApi } from './interfaces/OpenApi';\nimport { getModels } from './parser/getModels';\nimport { getOperations } from './parser/getOperations';\nimport { getServer } from './parser/getServer';\n\n/**\n * Parse the OpenAPI specification to a Client model that contains\n * all the models, operations and schema's we should output.\n * @param openApi The OpenAPI spec that we have loaded from disk.\n */\nexport const parse = (openApi: OpenApi): Omit<Client, 'config'> => {\n  const version = getServiceVersion(openApi.info.version);\n  const server = getServer(openApi);\n  const { models, types } = getModels(openApi);\n  const operations = getOperations({ openApi, types });\n\n  return {\n    models,\n    operations,\n    server,\n    types,\n    version,\n  };\n};\n","import type { Model } from '~/openApi/common/interfaces/client';\nimport type { Dictionary } from '~/openApi/common/interfaces/Dictionary';\nimport { stripNamespace } from '~/openApi/common/parser/stripNamespace';\n\nimport type { OpenApi } from '../interfaces/OpenApi';\nimport type { OpenApiDiscriminator } from '../interfaces/OpenApiDiscriminator';\n\nconst inverseDictionary = (map: Dictionary<string>): Dictionary<string> => {\n  const m2: Dictionary<string> = {};\n  for (const name in map) {\n    m2[map[name]!] = name;\n  }\n  return m2;\n};\n\nexport const findOneOfParentDiscriminator = (\n  openApi: OpenApi,\n  parent?: Model,\n): OpenApiDiscriminator | undefined => {\n  if (openApi.components && parent) {\n    for (const definitionName in openApi.components.schemas) {\n      if (openApi.components.schemas.hasOwnProperty(definitionName)) {\n        const schema = openApi.components.schemas[definitionName]!;\n        if (\n          schema.discriminator &&\n          schema.oneOf?.length &&\n          schema.oneOf.some(\n            (definition) =>\n              definition.$ref && stripNamespace(definition.$ref) == parent.name,\n          )\n        ) {\n          return schema.discriminator;\n        }\n      }\n    }\n  }\n  return;\n};\n\nexport const mapPropertyValue = (\n  discriminator: OpenApiDiscriminator,\n  parent: Model,\n): string => {\n  if (discriminator.mapping) {\n    const mapping = inverseDictionary(discriminator.mapping);\n    const key = Object.keys(mapping).find(\n      (item) => stripNamespace(item) == parent.name,\n    );\n    if (key && mapping[key]) {\n      return mapping[key];\n    }\n  }\n  return parent.name;\n};\n","import type { Model } from '~/openApi/common/interfaces/client';\nimport { getDefault } from '~/openApi/common/parser/getDefault';\nimport { getPattern } from '~/openApi/common/parser/getPattern';\nimport { getType } from '~/openApi/common/parser/type';\nimport { escapeName } from '~/utils/escape';\nimport { unique } from '~/utils/unique';\n\nimport type { Client } from '../../../types/client';\nimport type { GetModelFn } from '../interfaces/Model';\nimport type { OpenApi } from '../interfaces/OpenApi';\nimport type { OpenApiSchema } from '../interfaces/OpenApiSchema';\nimport {\n  findOneOfParentDiscriminator,\n  mapPropertyValue,\n} from './discriminator';\nimport { isDefinitionNullable } from './inferType';\n\nexport const getAdditionalPropertiesModel = ({\n  debug,\n  definition,\n  getModel,\n  model,\n  openApi,\n  types,\n}: {\n  debug?: boolean;\n  definition: OpenApiSchema;\n  getModel: GetModelFn;\n  model: Model;\n  openApi: OpenApi;\n  types: Client['types'];\n}): Model => {\n  const ap =\n    typeof definition.additionalProperties === 'object'\n      ? definition.additionalProperties\n      : {};\n  const apModel = getModel({\n    debug,\n    definition: ap,\n    openApi,\n    parentDefinition: definition,\n    types,\n  });\n\n  if (ap.$ref) {\n    const apType = getType({ type: ap.$ref });\n    model.base = apType.base;\n    model.default = getDefault(definition, model);\n    model.export = 'dictionary';\n    model.imports.push(...apType.imports);\n    model.template = apType.template;\n    model.type = apType.type;\n    return model;\n  }\n\n  if (\n    definition.additionalProperties &&\n    definition.properties &&\n    Object.keys(definition.properties).length > 0\n  ) {\n    const additionalPropertiesType =\n      typeof definition.additionalProperties === 'object' &&\n      definition.additionalProperties.type &&\n      !Array.isArray(definition.additionalProperties.type)\n        ? definition.additionalProperties.type\n        : apModel.base;\n    const additionalProperties = [\n      getType({ type: additionalPropertiesType }).base,\n      ...model.properties.map((property) => property.base),\n    ];\n    apModel.base = additionalProperties.filter(unique).join(' | ');\n    apModel.default = getDefault(definition, model);\n    apModel.export = 'generic';\n    apModel.isRequired = definition.additionalProperties === true;\n    apModel.name = '[key: string]';\n    return apModel;\n  }\n\n  model.base = apModel.base;\n  model.default = getDefault(definition, model);\n  model.export = 'dictionary';\n  model.imports.push(...apModel.imports);\n  model.link = apModel;\n  model.template = apModel.template;\n  model.type = apModel.type;\n  return model;\n};\n\nexport const getModelProperties = ({\n  debug,\n  definition,\n  getModel,\n  openApi,\n  parent,\n  types,\n}: {\n  debug?: boolean;\n  definition: OpenApiSchema;\n  getModel: GetModelFn;\n  openApi: OpenApi;\n  parent?: Model;\n  types: Client['types'];\n}): Model[] => {\n  let models: Model[] = [];\n  const discriminator = findOneOfParentDiscriminator(openApi, parent);\n\n  Object.entries(definition.properties ?? {}).forEach(\n    ([propertyName, property]) => {\n      const propertyRequired = Boolean(\n        definition.required?.includes(propertyName),\n      );\n\n      const propertyValues: Omit<\n        Model,\n        | '$refs'\n        | 'base'\n        | 'enum'\n        | 'enums'\n        | 'export'\n        | 'imports'\n        | 'isNullable'\n        | 'link'\n        | 'properties'\n        | 'template'\n        | 'type'\n      > = {\n        default: property.default,\n        deprecated: property.deprecated === true,\n        description: property.description || null,\n        exclusiveMaximum: property.exclusiveMaximum,\n        exclusiveMinimum: property.exclusiveMinimum,\n        format:\n          property.type === 'array'\n            ? (property.items?.format ?? property.format)\n            : property.format,\n        in: '',\n        isDefinition: false,\n        isReadOnly: property.readOnly === true,\n        isRequired: propertyRequired,\n        maxItems: property.maxItems,\n        maxLength: property.maxLength,\n        maxProperties: property.maxProperties,\n        maximum: property.maximum,\n        minItems: property.minItems,\n        minLength: property.minLength,\n        minProperties: property.minProperties,\n        minimum: property.minimum,\n        multipleOf: property.multipleOf,\n        name: escapeName(propertyName),\n        pattern: getPattern(property.pattern),\n        uniqueItems: property.uniqueItems,\n      };\n\n      if (parent && discriminator?.propertyName == propertyName) {\n        models = [\n          ...models,\n          {\n            ...propertyValues,\n            $refs: [],\n            base: `'${mapPropertyValue(discriminator, parent)}'`,\n            enum: [],\n            enums: [],\n            export: 'reference',\n            imports: [],\n            isNullable: isDefinitionNullable(property),\n            link: null,\n            properties: [],\n            template: null,\n            type: 'string',\n          },\n        ];\n        return;\n      }\n\n      if (property.$ref) {\n        const model = getType({ type: property.$ref });\n        models = [\n          ...models,\n          {\n            ...propertyValues,\n            $refs: model.$refs,\n            base: model.base,\n            enum: [],\n            enums: [],\n            export: 'reference',\n            imports: model.imports,\n            isNullable: model.isNullable || isDefinitionNullable(property),\n            link: null,\n            properties: [],\n            template: model.template,\n            type: model.type,\n          },\n        ];\n        return;\n      }\n\n      const model = getModel({\n        debug,\n        definition: property,\n        initialValues: propertyValues,\n        openApi,\n        parentDefinition: definition,\n        types,\n      });\n      model.isNullable = model.isNullable || isDefinitionNullable(property);\n      models = [...models, model];\n    },\n  );\n\n  return models;\n};\n","import type { Model } from '~/openApi/common/interfaces/client';\nimport { getRef } from '~/openApi/common/parser/getRef';\nimport { getType } from '~/openApi/common/parser/type';\n\nimport type { Client } from '../../../types/client';\nimport type { GetModelFn } from '../interfaces/Model';\nimport type { OpenApi } from '../interfaces/OpenApi';\nimport type { OpenApiSchema } from '../interfaces/OpenApiSchema';\n\nexport const getRequiredPropertiesFromComposition = ({\n  debug,\n  definitions,\n  getModel,\n  openApi,\n  required,\n  types,\n}: {\n  debug?: boolean;\n  definitions: OpenApiSchema[];\n  getModel: GetModelFn;\n  openApi: OpenApi;\n  required: string[];\n  types: Client['types'];\n}): Model[] => {\n  const requiredProperties = definitions\n    .reduce((properties, definition) => {\n      if (definition.$ref) {\n        const type = getType({ type: definition.$ref });\n        // avoid circular references if two refs reference each other\n        // if (types[type.base] && types[type.base].$ref === definition.$ref) {\n        //   const schema = getRef<OpenApiSchema>(openApi, definition);\n        //   return [...properties]\n        // }\n\n        const meta = {\n          $ref: definition.$ref,\n          name: type.base,\n        };\n        types[type.base] = meta;\n        const schema = getRef<OpenApiSchema>(openApi, definition);\n        return [\n          ...properties,\n          ...getModel({\n            debug,\n            definition: schema,\n            meta,\n            openApi,\n            types,\n          }).properties,\n        ];\n      }\n\n      return [\n        ...properties,\n        ...getModel({\n          debug,\n          definition,\n          openApi,\n          parentDefinition: definition,\n          types,\n        }).properties,\n      ];\n    }, [] as Model[])\n    .filter(\n      (property) => !property.isRequired && required.includes(property.name),\n    )\n    .map((property) => ({\n      ...property,\n      isRequired: true,\n    }));\n\n  return requiredProperties;\n};\n","import type {\n  Model,\n  ModelComposition,\n} from '~/openApi/common/interfaces/client';\n\nimport type { Client } from '../../../types/client';\nimport type { GetModelFn } from '../interfaces/Model';\nimport type { OpenApi } from '../interfaces/OpenApi';\nimport type { OpenApiSchema } from '../interfaces/OpenApiSchema';\nimport { getModelProperties } from './getModelProperties';\nimport { getRequiredPropertiesFromComposition } from './getRequiredPropertiesFromComposition';\n\ntype Composition = {\n  definitions: OpenApiSchema[];\n  type: ModelComposition['export'];\n};\n\nexport const findModelComposition = (\n  definition: OpenApiSchema,\n): Composition | undefined => {\n  const compositions: ReadonlyArray<{\n    definitions: Composition['definitions'] | undefined;\n    type: Composition['type'];\n  }> = [\n    {\n      definitions: definition.allOf,\n      type: 'all-of',\n    },\n    {\n      definitions: definition.anyOf,\n      type: 'any-of',\n    },\n    {\n      definitions: definition.oneOf,\n      type: 'one-of',\n    },\n  ];\n  return compositions.find(\n    (composition) => composition.definitions?.length,\n  ) as ReturnType<typeof findModelComposition>;\n};\n\nexport const getModelComposition = ({\n  debug,\n  definition,\n  definitions,\n  getModel,\n  model,\n  openApi,\n  type,\n  types,\n}: Composition &\n  Pick<Client, 'types'> & {\n    debug?: boolean;\n    definition: OpenApiSchema;\n    getModel: GetModelFn;\n    model: Model;\n    openApi: OpenApi;\n  }): ModelComposition => {\n  const composition: ModelComposition = {\n    $refs: model.$refs,\n    enums: model.enums,\n    export: type,\n    imports: model.imports,\n    properties: model.properties,\n  };\n\n  let properties: Model[] = [];\n\n  definitions\n    .map((def) => {\n      const modelFromDef = getModel({\n        debug,\n        definition: def,\n        openApi,\n        parentDefinition: definition,\n        types,\n      });\n      return modelFromDef;\n    })\n    .forEach((model) => {\n      composition.$refs = [...composition.$refs, ...model.$refs];\n      composition.imports = [...composition.imports, ...model.imports];\n      composition.enums = [...composition.enums, ...model.enums];\n      composition.properties = [...composition.properties, model];\n    });\n\n  if (definition.required && type === 'all-of') {\n    const requiredProperties = getRequiredPropertiesFromComposition({\n      debug,\n      definitions,\n      getModel,\n      openApi,\n      required: definition.required,\n      types,\n    });\n    requiredProperties.forEach((requiredProperty) => {\n      composition.$refs = [...composition.$refs, ...requiredProperty.$refs];\n      composition.imports = [\n        ...composition.imports,\n        ...requiredProperty.imports,\n      ];\n      composition.enums = [...composition.enums, ...requiredProperty.enums];\n    });\n    properties = [...properties, ...requiredProperties];\n  }\n\n  if (definition.properties) {\n    const modelProperties = getModelProperties({\n      definition,\n      getModel,\n      openApi,\n      types,\n    });\n    modelProperties.forEach((modelProperty) => {\n      composition.$refs = [...composition.$refs, ...modelProperty.$refs];\n      composition.imports = [...composition.imports, ...modelProperty.imports];\n      composition.enums = [...composition.enums, ...modelProperty.enums];\n      if (modelProperty.export === 'enum') {\n        composition.enums = [...composition.enums, modelProperty];\n      }\n    });\n    properties = [...properties, ...modelProperties];\n  }\n\n  if (properties.length) {\n    const foundComposition = findModelComposition(definition);\n    if (foundComposition) {\n      const propertiesProperty: Model = {\n        $refs: [],\n        base: 'unknown',\n        description: '',\n        enum: [],\n        enums: [],\n        export: 'interface',\n        imports: [],\n        in: '',\n        isDefinition: false,\n        isNullable: false,\n        isReadOnly: false,\n        isRequired: false,\n        link: null,\n        name: 'properties',\n        properties,\n        template: null,\n        type: 'unknown',\n      };\n\n      if (foundComposition.type === 'one-of') {\n        composition.properties = [\n          {\n            ...composition,\n            base: '',\n            description: null,\n            enum: [],\n            in: '',\n            isDefinition: false,\n            isNullable: false,\n            isReadOnly: false,\n            isRequired: true,\n            link: null,\n            name: '',\n            template: null,\n            type: '',\n          },\n          propertiesProperty,\n        ];\n        composition.export = 'all-of';\n      } else {\n        composition.properties = [\n          ...composition.properties,\n          propertiesProperty,\n        ];\n      }\n    }\n  }\n\n  return composition;\n};\n","import type { Model, ModelMeta } from '~/openApi/common/interfaces/client';\nimport { getDefault } from '~/openApi/common/parser/getDefault';\nimport { getEnums } from '~/openApi/common/parser/getEnums';\nimport { getPattern } from '~/openApi/common/parser/getPattern';\nimport { getType } from '~/openApi/common/parser/type';\nimport { enumMeta } from '~/utils/enum';\n\nimport type { Client } from '../../../types/client';\nimport type { OpenApi } from '../interfaces/OpenApi';\nimport type { OpenApiSchema } from '../interfaces/OpenApiSchema';\nimport {\n  findModelComposition,\n  getModelComposition,\n} from './getModelComposition';\nimport {\n  getAdditionalPropertiesModel,\n  getModelProperties,\n} from './getModelProperties';\nimport {\n  getDefinitionTypes,\n  inferType,\n  isDefinitionNullable,\n} from './inferType';\n\nexport const getModel = ({\n  debug,\n  definition,\n  initialValues = {},\n  isDefinition = false,\n  meta,\n  openApi,\n  parentDefinition = null,\n  types,\n}: Pick<Client, 'types'> & {\n  debug?: boolean;\n  definition: OpenApiSchema;\n  /**\n   * Pass through initial model values\n   */\n  initialValues?: Partial<Model>;\n  isDefinition?: boolean;\n  meta?: ModelMeta;\n  openApi: OpenApi;\n  parentDefinition?: OpenApiSchema | null;\n}): Model => {\n  const definitionTypes = getDefinitionTypes(definition);\n  const inferredType = inferType(definition, definitionTypes);\n\n  const model: Model = {\n    $refs: [],\n    base: 'unknown',\n    deprecated: Boolean(definition.deprecated),\n    description: definition.description || null,\n    enum: [],\n    enums: [],\n    exclusiveMaximum: definition.exclusiveMaximum,\n    exclusiveMinimum: definition.exclusiveMinimum,\n    export: 'interface',\n    format: definition.format,\n    imports: [],\n    in: '',\n    isDefinition,\n    isNullable: isDefinitionNullable(definition),\n    isReadOnly: definition.readOnly === true,\n    isRequired: false,\n    link: null,\n    maxItems: definition.maxItems,\n    maxLength: definition.maxLength,\n    maxProperties: definition.maxProperties,\n    maximum: definition.maximum,\n    meta,\n    minItems: definition.minItems,\n    minLength: definition.minLength,\n    minProperties: definition.minProperties,\n    minimum: definition.minimum,\n    multipleOf: definition.multipleOf,\n    name: meta?.name ?? '',\n    pattern: getPattern(definition.pattern),\n    properties: [],\n    template: null,\n    type: 'unknown',\n    uniqueItems: definition.uniqueItems,\n    ...initialValues,\n  };\n\n  if (definition.$ref) {\n    const definitionRef = getType({\n      debug,\n      type: definition.$ref,\n    });\n    model.$refs = [...model.$refs, decodeURIComponent(definition.$ref)];\n    model.base = definitionRef.base;\n    model.export = 'reference';\n    model.imports = [...model.imports, ...definitionRef.imports];\n    model.template = definitionRef.template;\n    model.type = definitionRef.type;\n    model.default = getDefault(definition, model);\n    return model;\n  }\n\n  if (inferredType === 'enum') {\n    const enums = getEnums(definition, definition.enum);\n    if (enums.length) {\n      model.base = 'string';\n      model.enum = [...model.enum, ...enums];\n      model.export = 'enum';\n      model.type = 'string';\n      model.default = getDefault(definition, model);\n      if (!model.meta) {\n        model.meta = enumMeta(model);\n      }\n      return model;\n    }\n  }\n\n  if (\n    definitionTypes.includes('array') &&\n    (definition.items || definition.prefixItems)\n  ) {\n    if (definition.prefixItems) {\n      const arrayItems = definition.prefixItems.map((item) =>\n        getModel({\n          definition: item,\n          openApi,\n          parentDefinition: definition,\n          types,\n        }),\n      );\n\n      model.export = 'array';\n      model.$refs = [\n        ...model.$refs,\n        ...arrayItems.reduce(\n          (acc, m) => [...acc, ...m.$refs],\n          [] as Model['$refs'],\n        ),\n      ];\n      model.imports = [\n        ...model.imports,\n        ...arrayItems.reduce(\n          (acc, m) => [...acc, ...m.imports],\n          [] as Model['imports'],\n        ),\n      ];\n      model.link = arrayItems;\n      model.default = getDefault(definition, model);\n      return model;\n    }\n\n    if (!definition.items) {\n      return model;\n    }\n\n    if (definition.items.$ref) {\n      const arrayItems = getType({ type: definition.items.$ref });\n      model.$refs = [...model.$refs, decodeURIComponent(definition.items.$ref)];\n      model.base = arrayItems.base;\n      model.export = 'array';\n      model.imports = [...model.imports, ...arrayItems.imports];\n      model.template = arrayItems.template;\n      model.type = arrayItems.type;\n      model.default = getDefault(definition, model);\n      return model;\n    }\n\n    if (definition.items.anyOf && parentDefinition && parentDefinition.type) {\n      const foundComposition = findModelComposition(parentDefinition);\n      if (\n        foundComposition &&\n        foundComposition.definitions.some(\n          (definition) => !getDefinitionTypes(definition).includes('array'),\n        )\n      ) {\n        return getModel({\n          definition: definition.items,\n          openApi,\n          parentDefinition: definition,\n          types,\n        });\n      }\n    }\n\n    /**\n     * if items are a plain array, infer any-of composition\n     * {@link} https://github.com/ferdikoomen/openapi-typescript-codegen/issues/2062\n     */\n    const arrayItemsDefinition: OpenApiSchema = Array.isArray(definition.items)\n      ? {\n          anyOf: definition.items,\n        }\n      : definition.items;\n    const arrayItems = getModel({\n      definition: arrayItemsDefinition,\n      openApi,\n      parentDefinition: definition,\n      types,\n    });\n    model.base = arrayItems.base;\n    model.export = 'array';\n    model.$refs = [...model.$refs, ...arrayItems.$refs];\n    model.imports = [...model.imports, ...arrayItems.imports];\n    model.link = arrayItems;\n    model.template = arrayItems.template;\n    model.type = arrayItems.type;\n    model.default = getDefault(definition, model);\n    return model;\n  }\n\n  const foundComposition = findModelComposition(definition);\n  if (foundComposition) {\n    const composition = getModelComposition({\n      ...foundComposition,\n      debug,\n      definition,\n      getModel,\n      model,\n      openApi,\n      types,\n    });\n    const result = { ...model, ...composition };\n    return result;\n  }\n\n  if (\n    definitionTypes.includes('object') ||\n    definition.properties ||\n    definition.additionalProperties\n  ) {\n    if (\n      definition.properties &&\n      (Object.keys(definition.properties).length > 0 ||\n        !definition.additionalProperties)\n    ) {\n      model.base = 'unknown';\n      model.export = 'interface';\n      model.type = 'unknown';\n      model.default = getDefault(definition, model);\n\n      const modelProperties = getModelProperties({\n        debug,\n        definition,\n        getModel,\n        openApi,\n        parent: model,\n        types,\n      });\n      modelProperties.forEach((modelProperty) => {\n        model.$refs = [...model.$refs, ...modelProperty.$refs];\n        model.enums = [...model.enums, ...modelProperty.enums];\n        model.imports = [...model.imports, ...modelProperty.imports];\n        model.properties = [...model.properties, modelProperty];\n        if (modelProperty.export === 'enum') {\n          model.enums = [...model.enums, modelProperty];\n        }\n      });\n\n      if (definition.additionalProperties) {\n        const modelProperty = getAdditionalPropertiesModel({\n          debug,\n          definition,\n          getModel,\n          model,\n          openApi,\n          types,\n        });\n        model.properties = [...model.properties, modelProperty];\n      }\n\n      // objects with no explicit properties accept any key/value pair\n      if (\n        !model.properties.length &&\n        model.base === 'unknown' &&\n        model.type === 'unknown'\n      ) {\n        model.export = 'dictionary';\n        if (!model.name) {\n          model.name = '[key: string]';\n        }\n      }\n\n      return model;\n    }\n\n    const result = getAdditionalPropertiesModel({\n      debug,\n      definition,\n      getModel,\n      model,\n      openApi,\n      types,\n    });\n    return result;\n  }\n\n  if (definition.const !== undefined) {\n    const definitionConst = definition.const;\n    const modelConst =\n      typeof definitionConst === 'string'\n        ? `\"${definitionConst}\"`\n        : `${definitionConst}`;\n    model.base = modelConst;\n    model.export = 'const';\n    model.type = modelConst;\n    return model;\n  }\n\n  // If the schema has a type than it can be a basic or generic type.\n  if (definitionTypes.length) {\n    const definitionType = getType({\n      format: definition.format,\n      type: definition.type,\n    });\n    model.base = definitionType.base;\n    model.export = 'generic';\n    model.$refs = [...model.$refs, ...definitionType.$refs];\n    model.imports = [...model.imports, ...definitionType.imports];\n    model.isNullable = definitionType.isNullable || model.isNullable;\n    model.template = definitionType.template;\n    model.type = definitionType.type;\n    model.default = getDefault(definition, model);\n    return model;\n  }\n\n  return model;\n};\n","import type { OpenApiParameter } from '../interfaces/OpenApiParameter';\nimport type { OpenApiSchema } from '../interfaces/OpenApiSchema';\n\nexport const getParameterSchema = (\n  definition: OpenApiParameter,\n): OpenApiSchema | undefined => {\n  if (definition.schema) {\n    return definition.schema;\n  }\n\n  if (definition.content) {\n    // treat every media type the same for now, types should be modified to\n    // preserve this data so client knows which headers to use and how to\n    // parse response bodies\n    const contents = Object.entries(definition.content);\n    for (const [key, mediaTypeObject] of contents) {\n      if (mediaTypeObject.schema) {\n        const mediaType = key as keyof Required<OpenApiParameter>['content'];\n        return definition.content[mediaType].schema;\n      }\n    }\n  }\n\n  return;\n};\n","import { getParametersMeta, getSchemasMeta } from '~/utils/meta';\n\nimport type { Client } from '../../../types/client';\nimport type { OpenApi } from '../interfaces/OpenApi';\nimport { getModel } from './getModel';\nimport { getParameterSchema } from './parameter';\n\nexport const getModels = (\n  openApi: OpenApi,\n): Pick<Client, 'models' | 'types'> => {\n  const types: Client['types'] = {};\n  let models: Client['models'] = [];\n\n  if (!openApi.components) {\n    return {\n      models,\n      types,\n    };\n  }\n\n  Object.entries(openApi.components.schemas ?? {}).forEach(\n    ([definitionName, definition]) => {\n      const meta = getSchemasMeta(definitionName);\n      types[meta.name] = meta;\n      const model = getModel({\n        definition,\n        isDefinition: true,\n        meta,\n        openApi,\n        types,\n      });\n      models = [...models, model];\n    },\n  );\n\n  Object.entries(openApi.components.parameters ?? {}).forEach(\n    ([definitionName, definition]) => {\n      const schema = getParameterSchema(definition);\n      if (!schema) {\n        return;\n      }\n\n      const meta = getParametersMeta(definitionName);\n      types[meta.name] = meta;\n      const model = getModel({\n        definition: schema,\n        isDefinition: true,\n        meta,\n        openApi,\n        types,\n      });\n      model.deprecated = definition.deprecated;\n      model.description = definition.description || null;\n      models = [...models, model];\n    },\n  );\n\n  return {\n    models,\n    types,\n  };\n};\n","import type { OperationParameter } from '~/openApi/common/interfaces/client';\nimport { getDefault } from '~/openApi/common/parser/getDefault';\nimport { getPattern } from '~/openApi/common/parser/getPattern';\nimport { getRef } from '~/openApi/common/parser/getRef';\nimport { operationParameterNameFn } from '~/openApi/common/parser/operation';\nimport { getType } from '~/openApi/common/parser/type';\nimport { refParametersPartial } from '~/utils/const';\nimport { enumMeta } from '~/utils/enum';\n\nimport type { Client } from '../../../types/client';\nimport type { OpenApi } from '../interfaces/OpenApi';\nimport type { OpenApiParameter } from '../interfaces/OpenApiParameter';\nimport type { OpenApiSchema } from '../interfaces/OpenApiSchema';\nimport { getModel } from './getModel';\nimport { isDefinitionNullable } from './inferType';\nimport { getParameterSchema } from './parameter';\n\nexport const getOperationParameter = ({\n  openApi,\n  parameter,\n  types,\n}: {\n  openApi: OpenApi;\n  parameter: OpenApiParameter;\n  types: Client['types'];\n}): OperationParameter => {\n  const operationParameterWithoutName: Omit<OperationParameter, 'name'> = {\n    $refs: [],\n    base: 'unknown',\n    deprecated: parameter.deprecated === true,\n    description: parameter.description || null,\n    enum: [],\n    enums: [],\n    export: 'interface',\n    imports: [],\n    in: parameter.in,\n    isDefinition: false,\n    isNullable: isDefinitionNullable(parameter),\n    isReadOnly: false,\n    isRequired: parameter.required === true,\n    link: null,\n    mediaType: null,\n    prop: parameter.name,\n    properties: [],\n    template: null,\n    type: 'unknown',\n  };\n  let operationParameter = {\n    ...operationParameterWithoutName,\n    name: operationParameterNameFn(operationParameterWithoutName),\n  };\n\n  if (parameter.$ref) {\n    const model = getType({ type: parameter.$ref });\n    operationParameter = {\n      ...operationParameter,\n      $refs: [...operationParameter.$refs, ...model.$refs],\n      base: model.base,\n      export: 'reference',\n      imports: [...operationParameter.imports, ...model.imports],\n      template: model.template,\n      type: model.type,\n    };\n    return operationParameter;\n  }\n\n  let schema = getParameterSchema(parameter);\n  if (schema) {\n    if (schema.$ref?.startsWith(refParametersPartial)) {\n      schema = getRef<OpenApiSchema>(openApi, schema);\n    }\n\n    if (schema.$ref) {\n      const model = getType({ type: schema.$ref });\n      operationParameter = {\n        ...operationParameter,\n        $refs: [...operationParameter.$refs, ...model.$refs],\n        base: model.base,\n        export: 'reference',\n        imports: [...operationParameter.imports, ...model.imports],\n        template: model.template,\n        type: model.type,\n      };\n      operationParameter.default = getDefault(schema);\n      return operationParameter;\n    }\n\n    const model = getModel({ definition: schema, openApi, types });\n    operationParameter = {\n      ...operationParameter,\n      $refs: [...operationParameter.$refs, ...model.$refs],\n      base: model.base,\n      enum: [...operationParameter.enum, ...model.enum],\n      enums: [...operationParameter.enums, ...model.enums],\n      exclusiveMaximum: model.exclusiveMaximum,\n      exclusiveMinimum: model.exclusiveMinimum,\n      export: model.export,\n      format: model.format,\n      imports: [...operationParameter.imports, ...model.imports],\n      isNullable: operationParameter.isNullable || model.isNullable,\n      isReadOnly: model.isReadOnly,\n      isRequired: operationParameter.isRequired || model.isRequired,\n      link: model.link,\n      maxItems: model.maxItems,\n      maxLength: model.maxLength,\n      maxProperties: model.maxProperties,\n      maximum: model.maximum,\n      minItems: model.minItems,\n      minLength: model.minLength,\n      minProperties: model.minProperties,\n      minimum: model.minimum,\n      multipleOf: model.multipleOf,\n      pattern: getPattern(model.pattern),\n      properties: [...operationParameter.properties, ...model.properties],\n      template: model.template,\n      type: model.type,\n      uniqueItems: model.uniqueItems,\n    };\n    if (\n      (operationParameter.enum.length || operationParameter.enums.length) &&\n      !operationParameter.meta\n    ) {\n      operationParameter.meta = enumMeta(operationParameter);\n    }\n    operationParameter.default = model.default;\n    return operationParameter;\n  }\n\n  return operationParameter;\n};\n","import type { OperationParameters } from '~/openApi/common/interfaces/client';\nimport { getRef } from '~/openApi/common/parser/getRef';\nimport { operationParameterFilterFn } from '~/openApi/common/parser/operation';\n\nimport type { Client } from '../../../types/client';\nimport type { OpenApi } from '../interfaces/OpenApi';\nimport type { OpenApiParameter } from '../interfaces/OpenApiParameter';\nimport { getOperationParameter } from './getOperationParameter';\n\nconst allowedIn = ['cookie', 'formData', 'header', 'path', 'query'] as const;\n\nexport const getOperationParameters = ({\n  openApi,\n  parameters,\n  types,\n}: {\n  openApi: OpenApi;\n  parameters: OpenApiParameter[];\n  types: Client['types'];\n}): OperationParameters => {\n  const operationParameters: OperationParameters = {\n    $refs: [],\n    imports: [],\n    parameters: [],\n    parametersBody: null,\n    parametersCookie: [],\n    parametersForm: [],\n    parametersHeader: [],\n    parametersPath: [],\n    parametersQuery: [], // not used in v3 -> @see requestBody\n  };\n\n  parameters.forEach((parameterOrReference) => {\n    const parameterDef = getRef<OpenApiParameter>(\n      openApi,\n      parameterOrReference,\n    );\n    const parameter = getOperationParameter({\n      openApi,\n      parameter: parameterDef,\n      types,\n    });\n\n    const skip = !operationParameterFilterFn(parameter);\n    if (!allowedIn.includes(parameterDef.in) || skip) {\n      return;\n    }\n\n    switch (parameterDef.in) {\n      case 'cookie':\n        operationParameters.parametersCookie = [\n          ...operationParameters.parametersCookie,\n          parameter,\n        ];\n        break;\n      case 'formData':\n        operationParameters.parametersForm = [\n          ...operationParameters.parametersForm,\n          parameter,\n        ];\n        break;\n      case 'header':\n        operationParameters.parametersHeader = [\n          ...operationParameters.parametersHeader,\n          parameter,\n        ];\n        break;\n      case 'path':\n        operationParameters.parametersPath = [\n          ...operationParameters.parametersPath,\n          parameter,\n        ];\n        break;\n      case 'query':\n        operationParameters.parametersQuery = [\n          ...operationParameters.parametersQuery,\n          parameter,\n        ];\n        break;\n    }\n\n    operationParameters.$refs = [\n      ...operationParameters.$refs,\n      ...parameter.$refs,\n    ];\n    operationParameters.imports = [\n      ...operationParameters.imports,\n      ...parameter.imports,\n    ];\n    operationParameters.parameters = [\n      ...operationParameters.parameters,\n      parameter,\n    ];\n  });\n\n  return operationParameters;\n};\n","import type { Dictionary } from '~/openApi/common/interfaces/Dictionary';\n\nimport type { OpenApi } from '../interfaces/OpenApi';\nimport type { OpenApiMediaType } from '../interfaces/OpenApiMediaType';\nimport type { OpenApiSchema } from '../interfaces/OpenApiSchema';\n\nexport interface Content {\n  mediaType: string;\n  schema: OpenApiSchema;\n}\n\nconst BASIC_MEDIA_TYPES = [\n  'application/json-patch+json',\n  'application/json',\n  'application/ld+json',\n  'application/x-www-form-urlencoded',\n  'multipart/batch',\n  'multipart/form-data',\n  'multipart/mixed',\n  'multipart/related',\n  'text/json',\n  'text/plain',\n];\n\nexport const getContent = (\n  _openApi: OpenApi,\n  content: Dictionary<OpenApiMediaType>,\n): Content | undefined => {\n  const basicMediaTypeWithSchema = Object.keys(content)\n    .filter((mediaType) => {\n      const cleanMediaType = mediaType.split(';')[0]!.trim();\n      return BASIC_MEDIA_TYPES.includes(cleanMediaType);\n    })\n    .find((mediaType) => Boolean(content[mediaType]?.schema));\n\n  if (basicMediaTypeWithSchema) {\n    return {\n      mediaType: basicMediaTypeWithSchema,\n      schema: content[basicMediaTypeWithSchema]!.schema as OpenApiSchema,\n    };\n  }\n\n  const firstMediaTypeWithSchema = Object.keys(content).find((mediaType) =>\n    Boolean(content[mediaType]?.schema),\n  );\n\n  if (firstMediaTypeWithSchema) {\n    return {\n      mediaType: firstMediaTypeWithSchema,\n      schema: content[firstMediaTypeWithSchema]!.schema as OpenApiSchema,\n    };\n  }\n\n  return;\n};\n","import type { OperationParameter } from '~/openApi/common/interfaces/client';\nimport { getPattern } from '~/openApi/common/parser/getPattern';\nimport { getType } from '~/openApi/common/parser/type';\n\nimport type { Client } from '../../../types/client';\nimport type { OpenApi } from '../interfaces/OpenApi';\nimport type { OpenApiRequestBody } from '../interfaces/OpenApiRequestBody';\nimport { getContent } from './getContent';\nimport { getModel } from './getModel';\n\nexport const getOperationRequestBody = ({\n  body,\n  debug,\n  openApi,\n  types,\n}: {\n  body: OpenApiRequestBody;\n  debug?: boolean;\n  openApi: OpenApi;\n  types: Client['types'];\n}): OperationParameter => {\n  const name = body['x-body-name'] ?? 'requestBody';\n\n  const requestBody: OperationParameter = {\n    $refs: [],\n    base: 'unknown',\n    default: undefined,\n    description: body.description || null,\n    enum: [],\n    enums: [],\n    export: 'interface',\n    imports: [],\n    in: 'body',\n    isDefinition: false,\n    isNullable: body.nullable === true,\n    isReadOnly: false,\n    isRequired: body.required === true,\n    link: null,\n    mediaType: null,\n    name,\n    prop: name,\n    properties: [],\n    template: null,\n    type: 'unknown',\n  };\n\n  if (!body.content) {\n    return requestBody;\n  }\n\n  const content = getContent(openApi, body.content);\n  if (!content) {\n    return requestBody;\n  }\n\n  requestBody.mediaType = content.mediaType;\n\n  switch (requestBody.mediaType) {\n    case 'application/x-www-form-urlencoded':\n    case 'multipart/form-data':\n      requestBody.in = 'formData';\n      requestBody.name = 'formData';\n      requestBody.prop = 'formData';\n      break;\n  }\n\n  if (content.schema.$ref) {\n    const model = getType({ type: content.schema.$ref });\n    requestBody.export = 'reference';\n    requestBody.type = model.type;\n    requestBody.base = model.base;\n    requestBody.template = model.template;\n    requestBody.$refs = [...requestBody.$refs, ...model.$refs];\n    requestBody.imports = [...requestBody.imports, ...model.imports];\n    return requestBody;\n  }\n\n  const model = getModel({\n    debug,\n    definition: content.schema,\n    openApi,\n    types,\n  });\n  requestBody.$refs = [...requestBody.$refs, ...model.$refs];\n  requestBody.base = model.base;\n  requestBody.enum = [...requestBody.enum, ...model.enum];\n  requestBody.enums = [...requestBody.enums, ...model.enums];\n  requestBody.exclusiveMaximum = model.exclusiveMaximum;\n  requestBody.exclusiveMinimum = model.exclusiveMinimum;\n  requestBody.export = model.export;\n  requestBody.format = model.format;\n  requestBody.imports = [...requestBody.imports, ...model.imports];\n  requestBody.isNullable = requestBody.isNullable || model.isNullable;\n  requestBody.isReadOnly = model.isReadOnly;\n  requestBody.isRequired = requestBody.isRequired || model.isRequired;\n  requestBody.link = model.link;\n  requestBody.maximum = model.maximum;\n  requestBody.maxItems = model.maxItems;\n  requestBody.maxLength = model.maxLength;\n  requestBody.maxProperties = model.maxProperties;\n  requestBody.minimum = model.minimum;\n  requestBody.minItems = model.minItems;\n  requestBody.minLength = model.minLength;\n  requestBody.minProperties = model.minProperties;\n  requestBody.multipleOf = model.multipleOf;\n  requestBody.pattern = getPattern(model.pattern);\n  requestBody.properties = [...requestBody.properties, ...model.properties];\n  requestBody.template = model.template;\n  requestBody.type = model.type;\n  requestBody.uniqueItems = model.uniqueItems;\n  return requestBody;\n};\n","import type { OperationResponse } from '~/openApi/common/interfaces/client';\nimport { getPattern } from '~/openApi/common/parser/getPattern';\nimport { getRef } from '~/openApi/common/parser/getRef';\nimport { getType } from '~/openApi/common/parser/type';\n\nimport type { Client } from '../../../types/client';\nimport type { OpenApi } from '../interfaces/OpenApi';\nimport type { OpenApiResponse } from '../interfaces/OpenApiResponse';\nimport type { OpenApiSchema } from '../interfaces/OpenApiSchema';\nimport { getContent } from './getContent';\nimport { getModel } from './getModel';\n\nexport const getOperationResponse = ({\n  code,\n  openApi,\n  response,\n  types,\n}: {\n  code: OperationResponse['code'];\n  openApi: OpenApi;\n  response: OpenApiResponse;\n  types: Client['types'];\n}): OperationResponse => {\n  const operationResponse: OperationResponse = {\n    $refs: [],\n    base: code !== 204 ? 'unknown' : 'void',\n    code,\n    description: response.description || null,\n    enum: [],\n    enums: [],\n    export: 'generic',\n    imports: [],\n    in: 'response',\n    isDefinition: false,\n    isNullable: false,\n    isReadOnly: false,\n    isRequired: false,\n    link: null,\n    name: '',\n    properties: [],\n    responseTypes: [],\n    template: null,\n    type: code !== 204 ? 'unknown' : 'void',\n  };\n\n  if (response.content) {\n    const content = getContent(openApi, response.content);\n    if (content) {\n      if (content.schema.$ref?.startsWith('#/components/responses/')) {\n        content.schema = getRef<OpenApiSchema>(openApi, content.schema);\n      }\n\n      if (content.schema.$ref) {\n        const model = getType({ type: content.schema.$ref });\n        operationResponse.base = model.base;\n        operationResponse.export = 'reference';\n        operationResponse.$refs = [...operationResponse.$refs, ...model.$refs];\n        operationResponse.imports = [\n          ...operationResponse.imports,\n          ...model.imports,\n        ];\n        operationResponse.template = model.template;\n        operationResponse.type = model.type;\n        return operationResponse;\n      }\n\n      const model = getModel({ definition: content.schema, openApi, types });\n      operationResponse.export = model.export;\n      operationResponse.type = model.type;\n      operationResponse.base = model.base;\n      operationResponse.template = model.template;\n      operationResponse.link = model.link;\n      operationResponse.isReadOnly = model.isReadOnly;\n      operationResponse.isRequired = model.isRequired;\n      operationResponse.isNullable = model.isNullable;\n      operationResponse.format = model.format;\n      operationResponse.maximum = model.maximum;\n      operationResponse.exclusiveMaximum = model.exclusiveMaximum;\n      operationResponse.minimum = model.minimum;\n      operationResponse.exclusiveMinimum = model.exclusiveMinimum;\n      operationResponse.multipleOf = model.multipleOf;\n      operationResponse.maxLength = model.maxLength;\n      operationResponse.minLength = model.minLength;\n      operationResponse.maxItems = model.maxItems;\n      operationResponse.minItems = model.minItems;\n      operationResponse.uniqueItems = model.uniqueItems;\n      operationResponse.maxProperties = model.maxProperties;\n      operationResponse.minProperties = model.minProperties;\n      operationResponse.pattern = getPattern(model.pattern);\n      operationResponse.$refs = [...operationResponse.$refs, ...model.$refs];\n      operationResponse.imports = [\n        ...operationResponse.imports,\n        ...model.imports,\n      ];\n      operationResponse.enum = [...operationResponse.enum, ...model.enum];\n      operationResponse.enums = [...operationResponse.enums, ...model.enums];\n      operationResponse.properties = [\n        ...operationResponse.properties,\n        ...model.properties,\n      ];\n      return operationResponse;\n    }\n  }\n\n  // We support basic properties from response headers, since both\n  // fetch and XHR client just support string types.\n  if (response.headers) {\n    for (const name in response.headers) {\n      operationResponse.in = 'header';\n      operationResponse.name = name;\n      operationResponse.type = 'string';\n      operationResponse.base = 'string';\n      return operationResponse;\n    }\n  }\n\n  return operationResponse;\n};\n","import type { OperationResponse } from '~/openApi/common/interfaces/client';\nimport { getRef } from '~/openApi/common/parser/getRef';\nimport {\n  parseResponseStatusCode,\n  sorterByResponseStatusCode,\n  tagResponseTypes,\n} from '~/openApi/common/parser/operation';\n\nimport type { Client } from '../../../types/client';\nimport type { OpenApi } from '../interfaces/OpenApi';\nimport type { OpenApiResponse } from '../interfaces/OpenApiResponse';\nimport type { OpenApiResponses } from '../interfaces/OpenApiResponses';\nimport { getOperationResponse } from './getOperationResponse';\n\nexport const getOperationResponses = ({\n  openApi,\n  responses,\n  types,\n}: {\n  debug?: boolean;\n  openApi: OpenApi;\n  responses: OpenApiResponses;\n  types: Client['types'];\n}): OperationResponse[] => {\n  let operationResponses: OperationResponse[] = [];\n\n  Object.entries(responses).forEach(([responseCode, responseOrReference]) => {\n    const code = parseResponseStatusCode(responseCode);\n    if (!code) {\n      return;\n    }\n\n    const response = getRef<OpenApiResponse>(openApi, responseOrReference);\n    const operationResponse = getOperationResponse({\n      code,\n      openApi,\n      response,\n      types,\n    });\n    operationResponses = [...operationResponses, operationResponse];\n  });\n\n  operationResponses = tagResponseTypes(operationResponses);\n\n  return operationResponses.sort(sorterByResponseStatusCode);\n};\n","import type {\n  Operation,\n  OperationParameter,\n  OperationParameters,\n} from '~/openApi/common/interfaces/client';\nimport { getRef } from '~/openApi/common/parser/getRef';\nimport {\n  getOperationResponseHeader,\n  operationNameFn,\n} from '~/openApi/common/parser/operation';\nimport { toSortedByRequired } from '~/openApi/common/parser/sort';\nimport { getConfig } from '~/utils/config';\n\nimport type { Client } from '../../../types/client';\nimport type { OpenApi } from '../interfaces/OpenApi';\nimport type { OpenApiOperation } from '../interfaces/OpenApiOperation';\nimport type { OpenApiRequestBody } from '../interfaces/OpenApiRequestBody';\nimport { getOperationParameters } from './getOperationParameters';\nimport { getOperationRequestBody } from './getOperationRequestBody';\nimport { getOperationResponses } from './getOperationResponses';\n\n// add global path parameters, skip duplicate names\nconst mergeParameters = (\n  opParams: OperationParameter[],\n  globalParams: OperationParameter[],\n): OperationParameter[] => {\n  let mergedParameters = [...opParams];\n  let pendingParameters = [...globalParams];\n  while (pendingParameters.length > 0) {\n    const pendingParam = pendingParameters[0]!;\n    pendingParameters = pendingParameters.slice(1);\n    const canMerge = mergedParameters.every(\n      (param) =>\n        param.in !== pendingParam.in || param.name !== pendingParam.name,\n    );\n    if (canMerge) {\n      mergedParameters = [...mergedParameters, pendingParam];\n    }\n  }\n  return mergedParameters;\n};\n\nexport const getOperation = ({\n  debug,\n  method,\n  op,\n  openApi,\n  pathParams,\n  types,\n  url,\n}: {\n  debug?: boolean;\n  method: Lowercase<Operation['method']>;\n  op: OpenApiOperation;\n  openApi: OpenApi;\n  pathParams: OperationParameters;\n  types: Client['types'];\n  url: string;\n}): Operation => {\n  const operationWithoutName: Omit<Operation, 'name'> = {\n    $refs: [],\n    deprecated: Boolean(op.deprecated),\n    description: op.description || null,\n    id: op.operationId || null,\n    imports: [],\n    method: method.toUpperCase() as Operation['method'],\n    parameters: [],\n    parametersBody: pathParams.parametersBody,\n    parametersCookie: [],\n    parametersForm: [],\n    parametersHeader: [],\n    parametersPath: [],\n    parametersQuery: [],\n    path: url,\n    responseHeader: null,\n    responses: [],\n    summary: op.summary || null,\n    tags: op.tags || null,\n  };\n  const operation = {\n    ...operationWithoutName,\n    name: operationNameFn({\n      config: getConfig(),\n      method: operationWithoutName.method,\n      operationId: op.operationId,\n      path: operationWithoutName.path,\n    }),\n  };\n\n  if (op.parameters) {\n    const parameters = getOperationParameters({\n      openApi,\n      parameters: op.parameters,\n      types,\n    });\n    operation.$refs = [...operation.$refs, ...parameters.$refs];\n    operation.imports = [...operation.imports, ...parameters.imports];\n    operation.parameters = [...operation.parameters, ...parameters.parameters];\n    operation.parametersBody = parameters.parametersBody;\n    operation.parametersCookie = [\n      ...operation.parametersCookie,\n      ...parameters.parametersCookie,\n    ];\n    operation.parametersForm = [\n      ...operation.parametersForm,\n      ...parameters.parametersForm,\n    ];\n    operation.parametersHeader = [\n      ...operation.parametersHeader,\n      ...parameters.parametersHeader,\n    ];\n    operation.parametersPath = [\n      ...operation.parametersPath,\n      ...parameters.parametersPath,\n    ];\n    operation.parametersQuery = [\n      ...operation.parametersQuery,\n      ...parameters.parametersQuery,\n    ];\n  }\n\n  if (op.requestBody) {\n    const requestBodyDef = getRef<OpenApiRequestBody>(openApi, op.requestBody);\n    const requestBody = getOperationRequestBody({\n      body: requestBodyDef,\n      debug,\n      openApi,\n      types,\n    });\n    operation.$refs = [...operation.$refs, ...requestBody.$refs];\n    operation.imports = [...operation.imports, ...requestBody.imports];\n    operation.parameters = [...operation.parameters, requestBody];\n    operation.parametersBody = requestBody;\n  }\n\n  if (op.responses) {\n    operation.responses = getOperationResponses({\n      openApi,\n      responses: op.responses,\n      types,\n    });\n    const successResponses = operation.responses.filter((response) =>\n      response.responseTypes.includes('success'),\n    );\n\n    operation.responseHeader = getOperationResponseHeader(successResponses);\n\n    successResponses.forEach((response) => {\n      operation.$refs = [...operation.$refs, ...response.$refs];\n      operation.imports = [...operation.imports, ...response.imports];\n    });\n  }\n\n  operation.parameters = mergeParameters(\n    operation.parameters,\n    pathParams.parameters,\n  );\n  operation.parametersCookie = mergeParameters(\n    operation.parametersCookie,\n    pathParams.parametersCookie,\n  );\n  operation.parametersForm = mergeParameters(\n    operation.parametersForm,\n    pathParams.parametersForm,\n  );\n  operation.parametersHeader = mergeParameters(\n    operation.parametersHeader,\n    pathParams.parametersHeader,\n  );\n  operation.parametersPath = mergeParameters(\n    operation.parametersPath,\n    pathParams.parametersPath,\n  );\n  operation.parametersQuery = mergeParameters(\n    operation.parametersQuery,\n    pathParams.parametersQuery,\n  );\n\n  operation.parameters = toSortedByRequired(operation.parameters);\n\n  return operation;\n};\n","import { createOperationKey } from '~/ir/operation';\nimport type { Client, Operation } from '~/openApi/common/interfaces/client';\nimport { operationFilterFn } from '~/openApi/common/parser/operation';\nimport { allowedServiceMethods } from '~/openApi/common/parser/service';\nimport { getConfig } from '~/utils/config';\n\nimport type { OpenApi } from '../interfaces/OpenApi';\nimport { getOperationParameters } from './getOperationParameters';\nimport { getOperation } from './operation';\n\nexport const getOperations = ({\n  openApi,\n  types,\n}: {\n  openApi: OpenApi;\n  types: Client['types'];\n}): Operation[] => {\n  const operationIds = new Map<string, string>();\n  const operations: Operation[] = [];\n\n  const config = getConfig();\n\n  for (const path in openApi.paths) {\n    const pathItem = openApi.paths[path]!;\n    const pathParameters = getOperationParameters({\n      openApi,\n      parameters: pathItem.parameters ?? [],\n      types,\n    });\n\n    for (const name in pathItem) {\n      const method = name as Lowercase<Operation['method']>;\n\n      const operationKey = createOperationKey({\n        method,\n        path,\n      });\n\n      if (allowedServiceMethods.includes(method)) {\n        const op = pathItem[method]!;\n\n        if (op.operationId) {\n          if (operationIds.has(op.operationId)) {\n            if (config.logs.level !== 'silent') {\n              console.warn(\n                ` Duplicate operationId: ${op.operationId} in ${operationKey}. Please ensure your operation IDs are unique. This behavior is not supported and will likely lead to unexpected results.`,\n              );\n            }\n          } else {\n            operationIds.set(op.operationId, operationKey);\n          }\n        }\n\n        if (\n          operationFilterFn({\n            config,\n            operationKey,\n          })\n        ) {\n          const operation = getOperation({\n            method,\n            op,\n            openApi,\n            pathParams: pathParameters,\n            types,\n            url: path,\n          });\n          operations.push(operation);\n        }\n      }\n    }\n  }\n\n  return operations;\n};\n","import type { OpenApi } from '../interfaces/OpenApi';\n\nexport const getServer = (openApi: OpenApi): string => {\n  const server = openApi.servers?.[0];\n  const variables = server?.variables || {};\n  let url = server?.url || '';\n  Object.entries(variables).forEach(([name, variable]) => {\n    url = url.replace(`{${name}}`, variable.default);\n  });\n  return url.replace(/\\/$/g, '');\n};\n","import type { Client } from '~/openApi/common/interfaces/client';\nimport { getServiceVersion } from '~/openApi/common/parser/service';\n\nimport type { OpenApi } from './interfaces/OpenApi';\nimport { getModels } from './parser/getModels';\nimport { getOperations } from './parser/getOperations';\nimport { getServer } from './parser/getServer';\n\n/**\n * Parse the OpenAPI specification to a Client model that contains\n * all the models, operations and schema's we should output.\n * @param openApi The OpenAPI spec that we have loaded from disk.\n */\nexport const parse = (openApi: OpenApi): Omit<Client, 'config'> => {\n  const version = getServiceVersion(openApi.info.version);\n  const server = getServer(openApi);\n  const { models, types } = getModels(openApi);\n  const operations = getOperations({ openApi, types });\n\n  return {\n    models,\n    operations,\n    server,\n    types,\n    version,\n  };\n};\n","import { satisfies } from '~/config/utils/package';\nimport { Context } from '~/ir/context';\nimport type { IR } from '~/ir/types';\nimport { parseV2_0_X } from '~/openApi/2.0.x';\nimport { parseV3_0_X } from '~/openApi/3.0.x';\nimport { parseV3_1_X } from '~/openApi/3.1.x';\nimport type { Client } from '~/openApi/common/interfaces/client';\nimport type { OpenApi as LegacyOpenApi } from '~/openApi/common/interfaces/OpenApi';\nimport type { OpenApi } from '~/openApi/types';\nimport { parse as parseV2 } from '~/openApi/v2';\nimport { parse as parseV3 } from '~/openApi/v3';\nimport type { Config } from '~/types/config';\nimport type { Logger } from '~/utils/logger';\n\nexport type {\n  Client,\n  Enum,\n  Method,\n  Model,\n  ModelMeta,\n  Operation,\n  OperationParameter,\n  OperationResponse,\n} from './common/interfaces/client';\nexport type { OpenApi } from './common/interfaces/OpenApi';\nexport { isOperationParameterRequired } from './common/parser/operation';\nexport {\n  ensureValidTypeScriptJavaScriptIdentifier,\n  sanitizeNamespaceIdentifier,\n  sanitizeOperationParameterName,\n} from './common/parser/sanitize';\nexport { getType } from './common/parser/type';\nexport type { OpenApiSchema as OpenApiV2Schema } from './v2/interfaces/OpenApiSchema';\nexport type { OpenApiSchema as OpenApiV3Schema } from './v3/interfaces/OpenApiSchema';\n\n/**\n * Parse the OpenAPI specification to a Client model that contains\n * all the models, services and schema's we should output.\n * @param openApi The OpenAPI spec that we have loaded from disk.\n */\nexport function parseLegacy({\n  openApi,\n}: {\n  openApi: unknown;\n}): Omit<Client, 'config'> {\n  const spec = openApi as LegacyOpenApi;\n\n  if ('openapi' in spec) {\n    return parseV3(spec);\n  }\n\n  if ('swagger' in spec) {\n    return parseV2(spec);\n  }\n\n  throw new Error(\n    `Unsupported OpenAPI specification: ${JSON.stringify(spec, null, 2)}`,\n  );\n}\n\n/**\n * @internal\n * Parse the resolved OpenAPI specification. This will populate and return\n * `context` with intermediate representation obtained from the parsed spec.\n */\nexport const parseOpenApiSpec = ({\n  config,\n  dependencies,\n  logger,\n  spec,\n}: {\n  config: Config;\n  dependencies: Record<string, string>;\n  logger: Logger;\n  spec: unknown;\n}): IR.Context | undefined => {\n  const context = new Context({\n    config,\n    dependencies,\n    logger,\n    spec: spec as OpenApi.V2_0_X | OpenApi.V3_0_X | OpenApi.V3_1_X,\n  });\n\n  if ('swagger' in context.spec) {\n    parseV2_0_X(context as IR.Context<OpenApi.V2_0_X>);\n    return context;\n  }\n\n  if (satisfies(context.spec.openapi, '>=3.0.0 <3.1.0')) {\n    parseV3_0_X(context as IR.Context<OpenApi.V3_0_X>);\n    return context;\n  }\n\n  if (satisfies(context.spec.openapi, '>=3.1.0')) {\n    parseV3_1_X(context as IR.Context<OpenApi.V3_1_X>);\n    return context;\n  }\n\n  throw new Error('Unsupported OpenAPI specification');\n};\n","import type { IR } from '~/ir/types';\n\nimport type { Auth } from '../../client-core/bundle/auth';\nimport type { HeyApiSdkPlugin } from '../types';\n\n// TODO: parser - handle more security types\nconst securitySchemeObjectToAuthObject = ({\n  securitySchemeObject,\n}: {\n  securitySchemeObject: IR.SecurityObject;\n}): Auth | undefined => {\n  if (securitySchemeObject.type === 'openIdConnect') {\n    return {\n      scheme: 'bearer',\n      type: 'http',\n    };\n  }\n\n  if (securitySchemeObject.type === 'oauth2') {\n    if (\n      securitySchemeObject.flows.password ||\n      securitySchemeObject.flows.authorizationCode ||\n      securitySchemeObject.flows.clientCredentials ||\n      securitySchemeObject.flows.implicit\n    ) {\n      return {\n        scheme: 'bearer',\n        type: 'http',\n      };\n    }\n\n    return;\n  }\n\n  if (securitySchemeObject.type === 'apiKey') {\n    if (securitySchemeObject.in === 'header') {\n      return {\n        name: securitySchemeObject.name,\n        type: 'apiKey',\n      };\n    }\n\n    if (\n      securitySchemeObject.in === 'query' ||\n      securitySchemeObject.in == 'cookie'\n    ) {\n      return {\n        in: securitySchemeObject.in,\n        name: securitySchemeObject.name,\n        type: 'apiKey',\n      };\n    }\n\n    return;\n  }\n\n  if (securitySchemeObject.type === 'http') {\n    const scheme = securitySchemeObject.scheme.toLowerCase();\n    if (scheme === 'bearer' || scheme === 'basic') {\n      return {\n        scheme: scheme as 'bearer' | 'basic',\n        type: 'http',\n      };\n    }\n\n    return;\n  }\n\n  return;\n};\n\nexport const operationAuth = ({\n  operation,\n  plugin,\n}: {\n  context: IR.Context;\n  operation: IR.OperationObject;\n  plugin: HeyApiSdkPlugin['Instance'];\n}): Array<Auth> => {\n  if (!operation.security || !plugin.config.auth) {\n    return [];\n  }\n\n  const auth: Array<Auth> = [];\n\n  for (const securitySchemeObject of operation.security) {\n    const authObject = securitySchemeObjectToAuthObject({\n      securitySchemeObject,\n    });\n    if (authObject) {\n      auth.push(authObject);\n    } else {\n      console.warn(\n        ` SDK warning: unsupported security scheme. Please open an issue if you'd like it added https://github.com/hey-api/openapi-ts/issues\\n${JSON.stringify(securitySchemeObject, null, 2)}`,\n      );\n    }\n  }\n\n  return auth;\n};\n","export const nuxtTypeComposable = 'TComposable';\nexport const nuxtTypeDefault = 'DefaultT';\nexport const nuxtTypeResponse = 'ResT';\n","import type ts from 'typescript';\n\nimport type { IR } from '~/ir/types';\n\nimport type { HeyApiSdkPlugin } from '../types';\n\ninterface ValidatorProps {\n  operation: IR.OperationObject;\n  plugin: HeyApiSdkPlugin['Instance'];\n}\n\nexport const createRequestValidator = ({\n  operation,\n  plugin,\n}: ValidatorProps): ts.ArrowFunction | undefined => {\n  if (!plugin.config.validator.request) return;\n\n  const validator = plugin.getPluginOrThrow(plugin.config.validator.request);\n  if (!validator.api.createRequestValidator) return;\n\n  return validator.api.createRequestValidator({\n    operation,\n    // @ts-expect-error\n    plugin: validator,\n  });\n};\n\nexport const createResponseValidator = ({\n  operation,\n  plugin,\n}: ValidatorProps): ts.ArrowFunction | undefined => {\n  if (!plugin.config.validator.response) return;\n\n  const validator = plugin.getPluginOrThrow(plugin.config.validator.response);\n  if (!validator.api.createResponseValidator) return;\n\n  return validator.api.createResponseValidator({\n    operation,\n    // @ts-expect-error\n    plugin: validator,\n  });\n};\n","import type ts from 'typescript';\n\nimport { statusCodeToGroup } from '~/ir/operation';\nimport type { IR } from '~/ir/types';\nimport { sanitizeNamespaceIdentifier } from '~/openApi';\nimport { ensureValidIdentifier } from '~/openApi/shared/utils/identifier';\nimport { getClientPlugin } from '~/plugins/@hey-api/client-core/utils';\nimport { tsc } from '~/tsc';\nimport type { FunctionParameter, ObjectValue } from '~/tsc/types';\nimport { reservedJavaScriptKeywordsRegExp } from '~/utils/regexp';\nimport { stringCase } from '~/utils/stringCase';\nimport { transformClassName } from '~/utils/transform';\n\nimport type { Field, Fields } from '../../client-core/bundle/params';\n// import { getSignatureParameters } from './signature';\nimport type { HeyApiSdkPlugin } from '../types';\nimport { operationAuth } from './auth';\nimport { nuxtTypeComposable, nuxtTypeDefault } from './constants';\nimport { createRequestValidator, createResponseValidator } from './validator';\n\ninterface ClassNameEntry {\n  /**\n   * Name of the class where this function appears.\n   */\n  className: string;\n  /**\n   * Name of the function within the class.\n   */\n  methodName: string;\n  /**\n   * JSONPath-like array to class location.\n   */\n  path: ReadonlyArray<string>;\n}\n\nconst operationClassName = ({\n  context,\n  value,\n}: {\n  context: IR.Context;\n  value: string;\n}) => {\n  const name = stringCase({\n    case: 'PascalCase',\n    value: sanitizeNamespaceIdentifier(value),\n  });\n  return transformClassName({\n    config: context.config,\n    name,\n  });\n};\n\nconst getOperationMethodName = ({\n  operation,\n  plugin,\n}: {\n  operation: IR.OperationObject;\n  plugin: {\n    config: Pick<\n      HeyApiSdkPlugin['Instance']['config'],\n      'asClass' | 'methodNameBuilder'\n    >;\n  };\n}) => {\n  if (plugin.config.methodNameBuilder) {\n    return plugin.config.methodNameBuilder(operation);\n  }\n\n  const handleIllegal = !plugin.config.asClass;\n  if (handleIllegal && operation.id.match(reservedJavaScriptKeywordsRegExp)) {\n    return `${operation.id}_`;\n  }\n\n  return operation.id;\n};\n\n/**\n * Returns a list of classes where this operation appears in the generated SDK.\n */\nexport const operationClasses = ({\n  context,\n  operation,\n  plugin,\n}: {\n  context: IR.Context;\n  operation: IR.OperationObject;\n  plugin: {\n    config: Pick<\n      HeyApiSdkPlugin['Instance']['config'],\n      'asClass' | 'classStructure' | 'instance'\n    >;\n  };\n}): Map<string, ClassNameEntry> => {\n  const classNames = new Map<string, ClassNameEntry>();\n\n  let className: string | undefined;\n  let methodName: string | undefined;\n  let classCandidates: Array<string> = [];\n\n  if (plugin.config.classStructure === 'auto' && operation.operationId) {\n    classCandidates = operation.operationId.split(/[./]/).filter(Boolean);\n    if (classCandidates.length > 1) {\n      const methodCandidate = classCandidates.pop()!;\n      methodName = stringCase({\n        case: 'camelCase',\n        value: sanitizeNamespaceIdentifier(methodCandidate),\n      });\n      className = classCandidates.pop()!;\n    }\n  }\n\n  const rootClasses = plugin.config.instance\n    ? [plugin.config.instance as string]\n    : (operation.tags ?? ['default']);\n\n  for (const rootClass of rootClasses) {\n    const finalClassName = operationClassName({\n      context,\n      value: className || rootClass,\n    });\n\n    // Default path\n    let path = [rootClass];\n    if (className) {\n      // If root class is already within classCandidates or the same as className\n      // do not add it again as this will cause a recursion issue.\n      if (classCandidates.includes(rootClass) || rootClass === className) {\n        path = [...classCandidates, className];\n      } else {\n        path = [rootClass, ...classCandidates, className];\n      }\n    }\n\n    classNames.set(rootClass, {\n      className: finalClassName,\n      methodName: methodName || getOperationMethodName({ operation, plugin }),\n      path: path.map((value) =>\n        operationClassName({\n          context,\n          value,\n        }),\n      ),\n    });\n  }\n\n  return classNames;\n};\n\nexport const operationOptionsType = ({\n  operation,\n  plugin,\n  throwOnError,\n}: {\n  operation: IR.OperationObject;\n  plugin: HeyApiSdkPlugin['Instance'];\n  throwOnError?: string;\n}) => {\n  const client = getClientPlugin(plugin.context.config);\n  const isNuxtClient = client.name === '@hey-api/client-nuxt';\n\n  const pluginTypeScript = plugin.getPluginOrThrow('@hey-api/typescript');\n\n  const symbolDataType = plugin.getSymbol(\n    pluginTypeScript.api.selector('data', operation.id),\n  );\n  const dataType = symbolDataType?.placeholder || 'unknown';\n\n  const symbolOptions = plugin.referenceSymbol(plugin.api.selector('Options'));\n\n  if (isNuxtClient) {\n    const symbolResponseType = plugin.getSymbol(\n      pluginTypeScript.api.selector('response', operation.id),\n    );\n    const responseType = symbolResponseType?.placeholder || 'unknown';\n    return `${symbolOptions.placeholder}<${nuxtTypeComposable}, ${dataType}, ${responseType}, ${nuxtTypeDefault}>`;\n  }\n\n  // TODO: refactor this to be more generic, works for now\n  if (throwOnError) {\n    return `${symbolOptions.placeholder}<${dataType}, ${throwOnError}>`;\n  }\n  return symbolDataType\n    ? `${symbolOptions.placeholder}<${symbolDataType.placeholder}>`\n    : symbolOptions.placeholder;\n};\n\ntype OperationParameters = {\n  argNames: Array<string>;\n  fields: Array<Field | Fields>;\n  parameters: Array<FunctionParameter>;\n};\n\nexport const operationParameters = ({\n  isRequiredOptions,\n  operation,\n  plugin,\n}: {\n  isRequiredOptions: boolean;\n  operation: IR.OperationObject;\n  plugin: HeyApiSdkPlugin['Instance'];\n}): OperationParameters => {\n  // getSignatureParameters({ operation });\n\n  const result: OperationParameters = {\n    argNames: [],\n    fields: [],\n    parameters: [],\n  };\n\n  const pluginTypeScript = plugin.getPluginOrThrow('@hey-api/typescript');\n  const client = getClientPlugin(plugin.context.config);\n  const isNuxtClient = client.name === '@hey-api/client-nuxt';\n\n  if (plugin.config.params_EXPERIMENTAL === 'experiment') {\n    if (operation.parameters?.path) {\n      for (const key in operation.parameters.path) {\n        const parameter = operation.parameters.path[key]!;\n        const name = ensureValidIdentifier(parameter.name);\n        // TODO: detect duplicates\n        result.argNames.push(name);\n        result.fields.push({\n          in: 'path',\n          key: name,\n        });\n        result.parameters.push({\n          isRequired: parameter.required,\n          name,\n          type: pluginTypeScript.api.schemaToType({\n            plugin: pluginTypeScript,\n            schema: parameter.schema,\n            state: {\n              path: {\n                value: [],\n              },\n            },\n          }),\n        });\n      }\n    }\n\n    if (operation.parameters?.query) {\n      for (const key in operation.parameters.query) {\n        const parameter = operation.parameters.query[key]!;\n        const name = ensureValidIdentifier(parameter.name);\n        // TODO: detect duplicates\n        result.argNames.push(name);\n        result.fields.push({\n          in: 'path',\n          key: name,\n        });\n        result.parameters.push({\n          isRequired: parameter.required,\n          name,\n          type: pluginTypeScript.api.schemaToType({\n            plugin: pluginTypeScript,\n            schema: parameter.schema,\n            state: {\n              path: {\n                value: [],\n              },\n            },\n          }),\n        });\n      }\n    }\n\n    if (operation.body) {\n      const name = 'body';\n      // TODO: detect duplicates\n      result.argNames.push(name);\n      result.fields.push({ in: 'body' });\n      result.parameters.push({\n        isRequired: operation.body.required,\n        name,\n        type: pluginTypeScript.api.schemaToType({\n          plugin: pluginTypeScript,\n          schema: operation.body.schema,\n          state: {\n            path: {\n              value: [],\n            },\n          },\n        }),\n      });\n    }\n  }\n\n  result.parameters.push({\n    isRequired: isRequiredOptions,\n    name: 'options',\n    // TODO: ensure no path, body, query\n    type: operationOptionsType({\n      operation,\n      plugin,\n      throwOnError: isNuxtClient ? undefined : 'ThrowOnError',\n    }),\n  });\n\n  return result;\n};\n\n/**\n * Infers `responseType` value from provided response content type. This is\n * an adapted version of `getParseAs()` from the Fetch API client.\n *\n * From Axios documentation:\n * `responseType` indicates the type of data that the server will respond with\n * options are: 'arraybuffer', 'document', 'json', 'text', 'stream'\n * browser only: 'blob'\n */\nconst getResponseType = (\n  contentType: string | null | undefined,\n):\n  | 'arraybuffer'\n  | 'blob'\n  | 'document'\n  | 'json'\n  | 'stream'\n  | 'text'\n  | undefined => {\n  if (!contentType) {\n    return;\n  }\n\n  const cleanContent = contentType.split(';')[0]?.trim();\n\n  if (!cleanContent) {\n    return;\n  }\n\n  if (\n    cleanContent.startsWith('application/json') ||\n    cleanContent.endsWith('+json')\n  ) {\n    return 'json';\n  }\n\n  // Axios does not handle form data out of the box\n  // if (cleanContent === 'multipart/form-data') {\n  //   return 'formData';\n  // }\n\n  if (\n    ['application/', 'audio/', 'image/', 'video/'].some((type) =>\n      cleanContent.startsWith(type),\n    )\n  ) {\n    return 'blob';\n  }\n\n  if (cleanContent.startsWith('text/')) {\n    return 'text';\n  }\n\n  return;\n};\n\nexport const operationStatements = ({\n  isRequiredOptions,\n  opParameters,\n  operation,\n  plugin,\n}: {\n  isRequiredOptions: boolean;\n  opParameters: OperationParameters;\n  operation: IR.OperationObject;\n  plugin: HeyApiSdkPlugin['Instance'];\n}): Array<ts.Statement> => {\n  const client = getClientPlugin(plugin.context.config);\n  const isNuxtClient = client.name === '@hey-api/client-nuxt';\n\n  const pluginTypeScript = plugin.getPluginOrThrow('@hey-api/typescript');\n\n  const symbolResponseType = plugin.getSymbol(\n    pluginTypeScript.api.selector(\n      isNuxtClient ? 'response' : 'responses',\n      operation.id,\n    ),\n  );\n  const responseType = symbolResponseType?.placeholder || 'unknown';\n\n  const symbolErrorType = plugin.getSymbol(\n    pluginTypeScript.api.selector(\n      isNuxtClient ? 'error' : 'errors',\n      operation.id,\n    ),\n  );\n  const errorType = symbolErrorType?.placeholder || 'unknown';\n\n  // TODO: transform parameters\n  // const query = {\n  //   BarBaz: options.query.bar_baz,\n  //   qux_quux: options.query.qux_quux,\n  //   fooBar: options.query.foo_bar,\n  // };\n\n  // if (operation.parameters) {\n  //   for (const name in operation.parameters.query) {\n  //     const parameter = operation.parameters.query[name]\n  //     if (parameter.name !== fieldName({ context, name: parameter.name })) {\n  //       console.warn(parameter.name)\n  //     }\n  //   }\n  // }\n\n  const requestOptions: Array<ObjectValue> = [];\n\n  if (operation.body) {\n    switch (operation.body.type) {\n      case 'form-data': {\n        const symbol = plugin.referenceSymbol(\n          plugin.api.selector('formDataBodySerializer'),\n        );\n        requestOptions.push({ spread: symbol.placeholder });\n        break;\n      }\n      case 'json':\n        // jsonBodySerializer is the default, no need to specify\n        break;\n      case 'text':\n      case 'octet-stream':\n        // ensure we don't use any serializer by default\n        requestOptions.push({\n          key: 'bodySerializer',\n          value: null,\n        });\n        break;\n      case 'url-search-params': {\n        const symbol = plugin.referenceSymbol(\n          plugin.api.selector('urlSearchParamsBodySerializer'),\n        );\n        requestOptions.push({ spread: symbol.placeholder });\n        break;\n      }\n    }\n  }\n\n  // TODO: parser - set parseAs to skip inference if every response has the same\n  // content type. currently impossible because successes do not contain\n  // header information\n\n  const parameterSerializers: Array<ObjectValue> = [];\n\n  for (const name in operation.parameters?.query) {\n    const parameter = operation.parameters.query[name]!;\n\n    if (\n      parameter.schema.type === 'array' ||\n      parameter.schema.type === 'tuple'\n    ) {\n      if (parameter.style !== 'form' || !parameter.explode) {\n        // override the default settings for array serialization\n        parameterSerializers.push({\n          key: parameter.name,\n          value: [\n            {\n              key: 'array',\n              value: [\n                {\n                  key: 'explode',\n                  value:\n                    parameter.explode !== true ? parameter.explode : undefined,\n                },\n                {\n                  key: 'style',\n                  value:\n                    parameter.style !== 'form' ? parameter.style : undefined,\n                },\n              ].filter(({ value }) => value !== undefined),\n            },\n          ],\n        });\n      }\n    } else if (parameter.schema.type === 'object') {\n      if (parameter.style !== 'deepObject' || !parameter.explode) {\n        // override the default settings for object serialization\n        parameterSerializers.push({\n          key: parameter.name,\n          value: [\n            {\n              key: 'object',\n              value: [\n                {\n                  key: 'explode',\n                  value:\n                    parameter.explode !== true ? parameter.explode : undefined,\n                },\n                {\n                  key: 'style',\n                  value:\n                    parameter.style !== 'deepObject'\n                      ? parameter.style\n                      : undefined,\n                },\n              ].filter(({ value }) => value !== undefined),\n            },\n          ],\n        });\n      }\n    }\n  }\n\n  if (parameterSerializers.length) {\n    // TODO: if all parameters have the same serialization,\n    // apply it globally to reduce output size\n    requestOptions.push({\n      key: 'querySerializer',\n      value: [\n        {\n          key: 'parameters',\n          value: parameterSerializers,\n        },\n      ],\n    });\n  }\n\n  const requestValidator = createRequestValidator({ operation, plugin });\n  if (requestValidator) {\n    requestOptions.push({\n      key: 'requestValidator',\n      value: requestValidator,\n    });\n  }\n\n  if (plugin.config.transformer === '@hey-api/transformers') {\n    const pluginTransformers = plugin.getPluginOrThrow(\n      plugin.config.transformer,\n    );\n    const selector = pluginTransformers.api.selector('response', operation.id);\n    if (plugin.isSymbolRegistered(selector)) {\n      const ref = plugin.referenceSymbol(selector);\n      requestOptions.push({\n        key: 'responseTransformer',\n        value: ref.placeholder,\n      });\n    }\n  }\n\n  let hasServerSentEvents = false;\n  let responseTypeValue: ReturnType<typeof getResponseType> | undefined;\n\n  for (const statusCode in operation.responses) {\n    const response = operation.responses[statusCode]!;\n\n    // try to infer `responseType` option for Axios. We don't need this in\n    // Fetch API client because it automatically detects the correct response\n    // during runtime.\n    if (!responseTypeValue && client.name === '@hey-api/client-axios') {\n      // this doesn't handle default status code for now\n      if (statusCodeToGroup({ statusCode }) === '2XX') {\n        responseTypeValue = getResponseType(response.mediaType);\n        if (responseTypeValue) {\n          requestOptions.push({\n            key: 'responseType',\n            value: responseTypeValue,\n          });\n        }\n      }\n    }\n\n    if (response.mediaType === 'text/event-stream') {\n      hasServerSentEvents = true;\n    }\n  }\n\n  const responseValidator = createResponseValidator({ operation, plugin });\n  if (responseValidator) {\n    requestOptions.push({\n      key: 'responseValidator',\n      value: responseValidator,\n    });\n  }\n\n  if (plugin.config.responseStyle === 'data') {\n    requestOptions.push({\n      key: 'responseStyle',\n      value: plugin.config.responseStyle,\n    });\n  }\n\n  const auth = operationAuth({ context: plugin.context, operation, plugin });\n  if (auth.length) {\n    requestOptions.push({\n      key: 'security',\n      value: tsc.arrayLiteralExpression({ elements: auth }),\n    });\n  }\n\n  requestOptions.push({\n    key: 'url',\n    value: operation.path,\n  });\n\n  // options must go last to allow overriding parameters above\n  requestOptions.push({ spread: 'options' });\n\n  const statements: Array<ts.Statement> = [];\n  const hasParams = opParameters.argNames.length;\n\n  if (hasParams) {\n    const args: Array<unknown> = [];\n    const config: Array<unknown> = [];\n    for (const argName of opParameters.argNames) {\n      args.push(tsc.identifier({ text: argName }));\n    }\n    for (const field of opParameters.fields) {\n      const obj: Array<Record<string, unknown>> = [];\n      if ('in' in field) {\n        obj.push({\n          key: 'in',\n          value: field.in,\n        });\n        if (field.key) {\n          obj.push({\n            key: 'key',\n            value: field.key,\n          });\n        }\n        if (field.map) {\n          obj.push({\n            key: 'map',\n            value: field.map,\n          });\n        }\n      }\n      config.push(tsc.objectExpression({ obj }));\n    }\n    const symbol = plugin.referenceSymbol(\n      plugin.api.selector('buildClientParams'),\n    );\n    statements.push(\n      tsc.constVariable({\n        expression: tsc.callExpression({\n          functionName: symbol.placeholder,\n          parameters: [\n            tsc.arrayLiteralExpression({ elements: args }),\n            tsc.arrayLiteralExpression({ elements: config }),\n          ],\n        }),\n        name: 'params',\n      }),\n    );\n    requestOptions.push({ spread: 'params' });\n  }\n\n  if (operation.body) {\n    const parameterContentType = operation.parameters?.header?.['content-type'];\n    const hasRequiredContentType = Boolean(parameterContentType?.required);\n    // spreading required Content-Type on generated header would throw a TypeScript error\n    if (!hasRequiredContentType) {\n      const headersValue: Array<unknown> = [\n        {\n          key: parameterContentType?.name ?? 'Content-Type',\n          // form-data does not need Content-Type header, browser will set it automatically\n          value:\n            operation.body.type === 'form-data'\n              ? null\n              : operation.body.mediaType,\n        },\n        {\n          spread: tsc.propertyAccessExpression({\n            expression: tsc.identifier({ text: 'options' }),\n            isOptional: !isRequiredOptions,\n            name: 'headers',\n          }),\n        },\n      ];\n      if (hasParams) {\n        headersValue.push({\n          spread: tsc.propertyAccessExpression({\n            expression: tsc.identifier({ text: 'params' }),\n            name: 'headers',\n          }),\n        });\n      }\n      requestOptions.push({\n        key: 'headers',\n        value: headersValue,\n      });\n    }\n  }\n\n  const symbolClient =\n    plugin.config.client && client.api && 'selector' in client.api\n      ? plugin.getSymbol(\n          // @ts-expect-error\n          client.api.selector('client'),\n        )\n      : undefined;\n\n  const optionsClient = tsc.propertyAccessExpression({\n    expression: tsc.identifier({ text: 'options' }),\n    isOptional: !isRequiredOptions,\n    name: 'client',\n  });\n\n  let clientExpression: ts.Expression;\n  if (plugin.config.instance) {\n    clientExpression = tsc.binaryExpression({\n      left: optionsClient,\n      operator: '??',\n      right: tsc.propertyAccessExpression({\n        expression: tsc.this(),\n        name: '_client',\n      }),\n    });\n  } else if (symbolClient) {\n    clientExpression = tsc.binaryExpression({\n      left: optionsClient,\n      operator: '??',\n      right: symbolClient.placeholder,\n    });\n  } else {\n    clientExpression = optionsClient;\n  }\n\n  const types: Array<string | ts.StringLiteral> = [];\n  if (isNuxtClient) {\n    types.push(\n      nuxtTypeComposable,\n      `${responseType} | ${nuxtTypeDefault}`,\n      errorType,\n      nuxtTypeDefault,\n    );\n  } else {\n    types.push(responseType, errorType, 'ThrowOnError');\n  }\n\n  if (plugin.config.responseStyle === 'data') {\n    types.push(tsc.stringLiteral({ text: plugin.config.responseStyle }));\n  }\n\n  let functionName = hasServerSentEvents\n    ? tsc.propertyAccessExpression({\n        expression: clientExpression,\n        name: tsc.identifier({ text: 'sse' }),\n      })\n    : clientExpression;\n\n  functionName = tsc.propertyAccessExpression({\n    expression: functionName,\n    name: tsc.identifier({ text: operation.method }),\n  });\n\n  statements.push(\n    tsc.returnFunctionCall({\n      args: [\n        tsc.objectExpression({\n          identifiers: ['responseTransformer'],\n          obj: requestOptions,\n        }),\n      ],\n      name: functionName,\n      types,\n    }),\n  );\n\n  return statements;\n};\n","import { hasOperationDataRequired } from '~/ir/operation';\nimport type { IR } from '~/ir/types';\nimport { getClientPlugin } from '~/plugins/@hey-api/client-core/utils';\nimport type { Comments } from '~/tsc';\nimport { escapeComment } from '~/utils/escape';\n\nexport const createOperationComment = ({\n  operation,\n}: {\n  operation: IR.OperationObject;\n}): Comments | undefined => {\n  const comments: Array<string> = [];\n\n  if (operation.summary) {\n    comments.push(escapeComment(operation.summary));\n  }\n\n  if (operation.description) {\n    if (comments.length) {\n      comments.push(''); // Add an empty line between summary and description\n    }\n\n    comments.push(escapeComment(operation.description));\n  }\n\n  if (operation.deprecated) {\n    if (comments.length) {\n      comments.push(''); // Add an empty line before deprecated\n    }\n\n    comments.push('@deprecated');\n  }\n\n  if (!comments.length) {\n    return;\n  }\n\n  return comments;\n};\n\nexport const isOperationOptionsRequired = ({\n  context,\n  operation,\n}: {\n  context: IR.Context;\n  operation: IR.OperationObject;\n}): boolean => {\n  const client = getClientPlugin(context.config);\n  const isNuxtClient = client.name === '@hey-api/client-nuxt';\n  const plugin = context.config.plugins['@hey-api/sdk'];\n  return (\n    (plugin && !plugin.config.client && !plugin.config.instance) ||\n    isNuxtClient ||\n    hasOperationDataRequired(operation)\n  );\n};\n\nexport const hasOperationSse = ({\n  operation,\n}: {\n  operation: IR.OperationObject;\n}): boolean => {\n  for (const statusCode in operation.responses) {\n    const response = operation.responses[statusCode]!;\n    if (response.mediaType === 'text/event-stream') {\n      return true;\n    }\n  }\n  return false;\n};\n","import type { Symbol } from '@hey-api/codegen-core';\nimport type ts from 'typescript';\n\nimport type { IR } from '~/ir/types';\nimport { buildName } from '~/openApi/shared/utils/name';\nimport { getClientPlugin } from '~/plugins/@hey-api/client-core/utils';\nimport { operationClasses } from '~/plugins/@hey-api/sdk/shared/operation';\nimport {\n  createOperationComment,\n  isOperationOptionsRequired,\n} from '~/plugins/shared/utils/operation';\nimport { tsc } from '~/tsc';\nimport { stringCase } from '~/utils/stringCase';\n\nimport type { AngularCommonPlugin } from './types';\n\ninterface AngularRequestClassEntry {\n  className: string;\n  classes: Set<string>;\n  methods: Set<string>;\n  nodes: Array<ts.ClassElement>;\n  root: boolean;\n}\n\nconst generateAngularClassRequests = ({\n  plugin,\n}: {\n  plugin: AngularCommonPlugin['Instance'];\n}) => {\n  const requestClasses = new Map<string, AngularRequestClassEntry>();\n  const generatedClasses = new Set<string>();\n\n  const sdkPlugin = plugin.getPluginOrThrow('@hey-api/sdk');\n\n  plugin.forEach(\n    'operation',\n    ({ operation }) => {\n      const isRequiredOptions = isOperationOptionsRequired({\n        context: plugin.context,\n        operation,\n      });\n\n      const classes = operationClasses({\n        context: plugin.context,\n        operation,\n        plugin: sdkPlugin,\n      });\n\n      for (const entry of classes.values()) {\n        entry.path.forEach((currentClassName, index) => {\n          if (!requestClasses.has(currentClassName)) {\n            requestClasses.set(currentClassName, {\n              className: currentClassName,\n              classes: new Set(),\n              methods: new Set(),\n              nodes: [],\n              root: !index,\n            });\n          }\n\n          const parentClassName = entry.path[index - 1];\n          if (parentClassName && parentClassName !== currentClassName) {\n            const parentClass = requestClasses.get(parentClassName)!;\n            parentClass.classes.add(currentClassName);\n            requestClasses.set(parentClassName, parentClass);\n          }\n\n          const isLast = entry.path.length === index + 1;\n          if (!isLast) {\n            return;\n          }\n\n          const currentClass = requestClasses.get(currentClassName)!;\n\n          const requestMethodName =\n            plugin.config.httpRequests.methodNameBuilder(operation);\n\n          if (currentClass.methods.has(requestMethodName)) {\n            return;\n          }\n\n          const methodNode = generateAngularRequestMethod({\n            isRequiredOptions,\n            methodName: requestMethodName,\n            operation,\n            plugin,\n          });\n\n          if (!currentClass.nodes.length) {\n            currentClass.nodes.push(methodNode);\n          } else {\n            // @ts-expect-error\n            currentClass.nodes.push(tsc.identifier({ text: '\\n' }), methodNode);\n          }\n\n          currentClass.methods.add(requestMethodName);\n          requestClasses.set(currentClassName, currentClass);\n        });\n      }\n    },\n    {\n      order: 'declarations',\n    },\n  );\n\n  const generateClass = (currentClass: AngularRequestClassEntry) => {\n    if (generatedClasses.has(currentClass.className)) {\n      return;\n    }\n\n    if (currentClass.classes.size) {\n      for (const childClassName of currentClass.classes) {\n        const childClass = requestClasses.get(childClassName)!;\n        generateClass(childClass);\n\n        currentClass.nodes.push(\n          tsc.propertyDeclaration({\n            initializer: tsc.newExpression({\n              argumentsArray: [],\n              expression: tsc.identifier({\n                text: buildName({\n                  config: {\n                    case: 'preserve',\n                    name: plugin.config.httpRequests.classNameBuilder,\n                  },\n                  name: childClass.className,\n                }),\n              }),\n            }),\n            name: stringCase({\n              case: 'camelCase',\n              value: childClass.className,\n            }),\n          }),\n        );\n      }\n    }\n\n    const symbolInjectable = plugin.referenceSymbol(\n      plugin.api.selector('Injectable'),\n    );\n    const symbolClass = plugin.registerSymbol({\n      exported: true,\n      name: buildName({\n        config: {\n          case: 'preserve',\n          name: plugin.config.httpRequests.classNameBuilder,\n        },\n        name: currentClass.className,\n      }),\n      selector: plugin.api.selector('class', currentClass.className),\n    });\n    const node = tsc.classDeclaration({\n      decorator: currentClass.root\n        ? {\n            args: [{ providedIn: 'root' }],\n            name: symbolInjectable.placeholder,\n          }\n        : undefined,\n      exportClass: symbolClass.exported,\n      name: symbolClass.placeholder,\n      nodes: currentClass.nodes,\n    });\n    plugin.setSymbolValue(symbolClass, node);\n\n    generatedClasses.add(currentClass.className);\n  };\n\n  for (const requestClass of requestClasses.values()) {\n    generateClass(requestClass);\n  }\n};\n\nconst generateAngularFunctionRequests = ({\n  plugin,\n}: {\n  plugin: AngularCommonPlugin['Instance'];\n}) => {\n  plugin.forEach(\n    'operation',\n    ({ operation }) => {\n      const isRequiredOptions = isOperationOptionsRequired({\n        context: plugin.context,\n        operation,\n      });\n\n      const symbol = plugin.registerSymbol({\n        exported: true,\n        name: plugin.config.httpRequests.methodNameBuilder(operation),\n        selector: plugin.api.selector('httpRequest', operation.id),\n      });\n      const node = generateAngularRequestFunction({\n        isRequiredOptions,\n        operation,\n        plugin,\n        symbol,\n      });\n      plugin.setSymbolValue(symbol, node);\n    },\n    {\n      order: 'declarations',\n    },\n  );\n};\n\nconst generateRequestCallExpression = ({\n  operation,\n  plugin,\n}: {\n  operation: IR.OperationObject;\n  plugin: AngularCommonPlugin['Instance'];\n}) => {\n  const client = getClientPlugin(plugin.context.config);\n  const symbolClient =\n    client.api && 'selector' in client.api\n      ? plugin.getSymbol(\n          // @ts-expect-error\n          client.api.selector('client'),\n        )\n      : undefined;\n\n  const optionsClient = tsc.propertyAccessExpression({\n    expression: tsc.identifier({ text: 'options' }),\n    isOptional: true,\n    name: 'client',\n  });\n\n  let clientExpression: ts.Expression;\n  if (symbolClient) {\n    clientExpression = tsc.binaryExpression({\n      left: optionsClient,\n      operator: '??',\n      right: symbolClient.placeholder,\n    });\n  } else {\n    clientExpression = optionsClient;\n  }\n\n  return tsc.callExpression({\n    functionName: tsc.propertyAccessExpression({\n      expression: clientExpression,\n      name: 'requestOptions',\n    }),\n    parameters: [\n      tsc.objectExpression({\n        obj: [\n          {\n            key: 'responseStyle',\n            value: tsc.identifier({ text: \"'data'\" }),\n          },\n          {\n            key: 'method',\n            value: tsc.identifier({\n              text: `'${operation.method.toUpperCase()}'`,\n            }),\n          },\n          {\n            key: 'url',\n            value: tsc.identifier({ text: `'${operation.path}'` }),\n          },\n          {\n            spread: 'options',\n          },\n        ],\n      }),\n    ],\n  });\n};\n\nconst generateAngularRequestMethod = ({\n  isRequiredOptions,\n  methodName,\n  operation,\n  plugin,\n}: {\n  isRequiredOptions: boolean;\n  methodName: string;\n  operation: IR.OperationObject;\n  plugin: AngularCommonPlugin['Instance'];\n}) => {\n  const pluginTypeScript = plugin.getPluginOrThrow('@hey-api/typescript');\n\n  const symbolHttpRequest = plugin.referenceSymbol(\n    plugin.api.selector('HttpRequest'),\n  );\n\n  const sdkPlugin = plugin.getPluginOrThrow('@hey-api/sdk');\n  const symbolOptions = plugin.referenceSymbol(\n    sdkPlugin.api.selector('Options'),\n  );\n\n  const symbolDataType = plugin.getSymbol(\n    pluginTypeScript.api.selector('data', operation.id),\n  );\n  const dataType = symbolDataType?.placeholder || 'unknown';\n\n  return tsc.methodDeclaration({\n    accessLevel: 'public',\n    comment: createOperationComment({ operation }),\n    name: methodName,\n    parameters: [\n      {\n        isRequired: isRequiredOptions,\n        name: 'options',\n        type: `${symbolOptions.placeholder}<${dataType}, ThrowOnError>`,\n      },\n    ],\n    returnType: `${symbolHttpRequest.placeholder}<unknown>`,\n    statements: [\n      tsc.returnStatement({\n        expression: generateRequestCallExpression({\n          operation,\n          plugin,\n        }),\n      }),\n    ],\n    types: [\n      {\n        default: false,\n        extends: 'boolean',\n        name: 'ThrowOnError',\n      },\n    ],\n  });\n};\n\nconst generateAngularRequestFunction = ({\n  isRequiredOptions,\n  operation,\n  plugin,\n  symbol,\n}: {\n  isRequiredOptions: boolean;\n  operation: IR.OperationObject;\n  plugin: AngularCommonPlugin['Instance'];\n  symbol: Symbol;\n}) => {\n  const pluginTypeScript = plugin.getPluginOrThrow('@hey-api/typescript');\n\n  const symbolHttpRequest = plugin.referenceSymbol(\n    plugin.api.selector('HttpRequest'),\n  );\n\n  const sdkPlugin = plugin.getPluginOrThrow('@hey-api/sdk');\n  const symbolOptions = plugin.referenceSymbol(\n    sdkPlugin.api.selector('Options'),\n  );\n\n  const symbolDataType = plugin.getSymbol(\n    pluginTypeScript.api.selector('data', operation.id),\n  );\n  const dataType = symbolDataType?.placeholder || 'unknown';\n\n  return tsc.constVariable({\n    comment: createOperationComment({ operation }),\n    exportConst: symbol.exported,\n    expression: tsc.arrowFunction({\n      parameters: [\n        {\n          isRequired: isRequiredOptions,\n          name: 'options',\n          type: `${symbolOptions.placeholder}<${dataType}, ThrowOnError>`,\n        },\n      ],\n      returnType: `${symbolHttpRequest.placeholder}<unknown>`,\n      statements: [\n        tsc.returnStatement({\n          expression: generateRequestCallExpression({\n            operation,\n            plugin,\n          }),\n        }),\n      ],\n      types: [\n        {\n          default: false,\n          extends: 'boolean',\n          name: 'ThrowOnError',\n        },\n      ],\n    }),\n    name: symbol.placeholder,\n  });\n};\n\nexport const createHttpRequests: AngularCommonPlugin['Handler'] = ({\n  plugin,\n}) => {\n  if (plugin.config.httpRequests.asClass) {\n    generateAngularClassRequests({ plugin });\n  } else {\n    generateAngularFunctionRequests({ plugin });\n  }\n};\n","import type { Symbol } from '@hey-api/codegen-core';\nimport type ts from 'typescript';\n\nimport type { IR } from '~/ir/types';\nimport { buildName } from '~/openApi/shared/utils/name';\nimport { operationClasses } from '~/plugins/@hey-api/sdk/shared/operation';\nimport {\n  createOperationComment,\n  isOperationOptionsRequired,\n} from '~/plugins/shared/utils/operation';\nimport { tsc } from '~/tsc';\nimport { stringCase } from '~/utils/stringCase';\n\nimport type { AngularCommonPlugin } from './types';\n\ninterface AngularServiceClassEntry {\n  className: string;\n  classes: Set<string>;\n  methods: Set<string>;\n  nodes: Array<ts.ClassElement>;\n  root: boolean;\n}\n\nconst generateAngularClassServices = ({\n  plugin,\n}: {\n  plugin: AngularCommonPlugin['Instance'];\n}) => {\n  const serviceClasses = new Map<string, AngularServiceClassEntry>();\n  const generatedClasses = new Set<string>();\n\n  const sdkPlugin = plugin.getPluginOrThrow('@hey-api/sdk');\n\n  plugin.forEach(\n    'operation',\n    ({ operation }) => {\n      const isRequiredOptions = isOperationOptionsRequired({\n        context: plugin.context,\n        operation,\n      });\n\n      const classes = operationClasses({\n        context: plugin.context,\n        operation,\n        plugin: sdkPlugin,\n      });\n\n      for (const entry of classes.values()) {\n        entry.path.forEach((currentClassName, index) => {\n          if (!serviceClasses.has(currentClassName)) {\n            serviceClasses.set(currentClassName, {\n              className: currentClassName,\n              classes: new Set(),\n              methods: new Set(),\n              nodes: [],\n              root: !index,\n            });\n          }\n\n          const parentClassName = entry.path[index - 1];\n          if (parentClassName && parentClassName !== currentClassName) {\n            const parentClass = serviceClasses.get(parentClassName)!;\n            parentClass.classes.add(currentClassName);\n            serviceClasses.set(parentClassName, parentClass);\n          }\n\n          const isLast = entry.path.length === index + 1;\n          if (!isLast) {\n            return;\n          }\n\n          const currentClass = serviceClasses.get(currentClassName)!;\n\n          const resourceMethodName =\n            plugin.config.httpResources.methodNameBuilder(operation);\n\n          if (currentClass.methods.has(resourceMethodName)) {\n            return;\n          }\n\n          const methodNode = generateAngularResourceMethod({\n            isRequiredOptions,\n            methodName: resourceMethodName,\n            operation,\n            plugin,\n          });\n\n          if (!currentClass.nodes.length) {\n            currentClass.nodes.push(methodNode);\n          } else {\n            // @ts-expect-error\n            currentClass.nodes.push(tsc.identifier({ text: '\\n' }), methodNode);\n          }\n\n          currentClass.methods.add(resourceMethodName);\n          serviceClasses.set(currentClassName, currentClass);\n        });\n      }\n    },\n    {\n      order: 'declarations',\n    },\n  );\n\n  const generateClass = (currentClass: AngularServiceClassEntry) => {\n    if (generatedClasses.has(currentClass.className)) {\n      return;\n    }\n\n    if (currentClass.classes.size) {\n      for (const childClassName of currentClass.classes) {\n        const childClass = serviceClasses.get(childClassName)!;\n        generateClass(childClass);\n\n        currentClass.nodes.push(\n          tsc.propertyDeclaration({\n            initializer: tsc.newExpression({\n              argumentsArray: [],\n              expression: tsc.identifier({\n                text: buildName({\n                  config: {\n                    case: 'preserve',\n                    name: plugin.config.httpResources.classNameBuilder,\n                  },\n                  name: childClass.className,\n                }),\n              }),\n            }),\n            name: stringCase({\n              case: 'camelCase',\n              value: childClass.className,\n            }),\n          }),\n        );\n      }\n    }\n\n    const symbolInjectable = plugin.referenceSymbol(\n      plugin.api.selector('Injectable'),\n    );\n    const symbolClass = plugin.registerSymbol({\n      exported: true,\n      name: buildName({\n        config: {\n          case: 'preserve',\n          name: plugin.config.httpResources.classNameBuilder,\n        },\n        name: currentClass.className,\n      }),\n    });\n    const node = tsc.classDeclaration({\n      decorator: currentClass.root\n        ? {\n            args: [{ providedIn: 'root' }],\n            name: symbolInjectable.placeholder,\n          }\n        : undefined,\n      exportClass: symbolClass.exported,\n      name: symbolClass.placeholder,\n      nodes: currentClass.nodes,\n    });\n    plugin.setSymbolValue(symbolClass, node);\n\n    generatedClasses.add(currentClass.className);\n  };\n\n  for (const serviceClass of serviceClasses.values()) {\n    generateClass(serviceClass);\n  }\n};\n\nconst generateAngularFunctionServices = ({\n  plugin,\n}: {\n  plugin: AngularCommonPlugin['Instance'];\n}) => {\n  plugin.forEach(\n    'operation',\n    ({ operation }) => {\n      const isRequiredOptions = isOperationOptionsRequired({\n        context: plugin.context,\n        operation,\n      });\n\n      const symbol = plugin.registerSymbol({\n        exported: true,\n        name: plugin.config.httpResources.methodNameBuilder(operation),\n      });\n      const node = generateAngularResourceFunction({\n        isRequiredOptions,\n        operation,\n        plugin,\n        symbol,\n      });\n      plugin.setSymbolValue(symbol, node);\n    },\n    {\n      order: 'declarations',\n    },\n  );\n};\n\nconst generateResourceCallExpression = ({\n  operation,\n  plugin,\n}: {\n  operation: IR.OperationObject;\n  plugin: AngularCommonPlugin['Instance'];\n}) => {\n  const sdkPlugin = plugin.getPluginOrThrow('@hey-api/sdk');\n  const pluginTypeScript = plugin.getPluginOrThrow('@hey-api/typescript');\n\n  const symbolHttpResource = plugin.referenceSymbol(\n    plugin.api.selector('httpResource'),\n  );\n\n  const symbolResponseType = plugin.getSymbol(\n    pluginTypeScript.api.selector('response', operation.id),\n  );\n  const responseType = symbolResponseType?.placeholder || 'unknown';\n\n  if (plugin.config.httpRequests.asClass) {\n    // For class-based request methods, use inject and class hierarchy\n    const classes = operationClasses({\n      context: plugin.context,\n      operation,\n      plugin: sdkPlugin,\n    });\n\n    const firstEntry = Array.from(classes.values())[0];\n    if (firstEntry) {\n      // Import the root class from HTTP requests\n      const rootClassName = firstEntry.path[0]!;\n      const symbolClass = plugin.referenceSymbol(\n        plugin.api.selector('class', rootClassName),\n      );\n\n      // Build the method access path using inject\n      const symbolInject = plugin.referenceSymbol(\n        plugin.api.selector('inject'),\n      );\n      let methodAccess: ts.Expression = tsc.callExpression({\n        functionName: symbolInject.placeholder,\n        parameters: [tsc.identifier({ text: symbolClass.placeholder })],\n      });\n\n      // Navigate through the class hierarchy\n      for (let i = 1; i < firstEntry.path.length; i++) {\n        const className = firstEntry.path[i];\n        if (className) {\n          methodAccess = tsc.propertyAccessExpression({\n            expression: methodAccess,\n            name: stringCase({\n              case: 'camelCase',\n              value: className,\n            }),\n          });\n        }\n      }\n\n      methodAccess = tsc.propertyAccessExpression({\n        expression: methodAccess,\n        name: plugin.config.httpRequests.methodNameBuilder(operation),\n      });\n\n      return tsc.callExpression({\n        functionName: symbolHttpResource.placeholder,\n        parameters: [\n          tsc.arrowFunction({\n            parameters: [],\n            statements: [\n              tsc.constVariable({\n                expression: tsc.conditionalExpression({\n                  condition: tsc.identifier({ text: 'options' }),\n                  whenFalse: tsc.identifier({ text: 'undefined' }),\n                  whenTrue: tsc.callExpression({\n                    functionName: 'options',\n                    parameters: [],\n                  }),\n                }),\n                name: 'opts',\n              }),\n              tsc.returnStatement({\n                expression: tsc.conditionalExpression({\n                  condition: tsc.identifier({ text: 'opts' }),\n                  whenFalse: tsc.identifier({ text: 'undefined' }),\n                  whenTrue: tsc.callExpression({\n                    functionName: methodAccess,\n                    parameters: [tsc.identifier({ text: 'opts' })],\n                  }),\n                }),\n              }),\n            ],\n          }),\n        ],\n        types: [tsc.typeNode(responseType)],\n      });\n    }\n  } else {\n    const symbolHttpRequest = plugin.referenceSymbol(\n      plugin.api.selector('httpRequest', operation.id),\n    );\n\n    return tsc.callExpression({\n      functionName: symbolHttpResource.placeholder,\n      parameters: [\n        tsc.arrowFunction({\n          parameters: [],\n          statements: [\n            tsc.constVariable({\n              expression: tsc.conditionalExpression({\n                condition: tsc.identifier({ text: 'options' }),\n                whenFalse: tsc.identifier({ text: 'undefined' }),\n                whenTrue: tsc.callExpression({\n                  functionName: 'options',\n                  parameters: [],\n                }),\n              }),\n              name: 'opts',\n            }),\n            tsc.returnStatement({\n              expression: tsc.conditionalExpression({\n                condition: tsc.identifier({ text: 'opts' }),\n                whenFalse: tsc.identifier({ text: 'undefined' }),\n                whenTrue: tsc.callExpression({\n                  functionName: symbolHttpRequest.placeholder,\n                  parameters: [tsc.identifier({ text: 'opts' })],\n                }),\n              }),\n            }),\n          ],\n        }),\n      ],\n      types: [tsc.typeNode(responseType)],\n    });\n  }\n\n  // Fallback return (should not reach here)\n  return tsc.callExpression({\n    functionName: symbolHttpResource.placeholder,\n    parameters: [\n      tsc.arrowFunction({\n        parameters: [],\n        statements: [\n          tsc.returnStatement({\n            expression: tsc.identifier({ text: 'undefined' }),\n          }),\n        ],\n      }),\n    ],\n    types: [tsc.typeNode(responseType)],\n  });\n};\n\nconst generateAngularResourceMethod = ({\n  isRequiredOptions,\n  methodName,\n  operation,\n  plugin,\n}: {\n  isRequiredOptions: boolean;\n  methodName: string;\n  operation: IR.OperationObject;\n  plugin: AngularCommonPlugin['Instance'];\n}) => {\n  const pluginTypeScript = plugin.getPluginOrThrow('@hey-api/typescript');\n\n  const sdkPlugin = plugin.getPluginOrThrow('@hey-api/sdk');\n  const symbolOptions = plugin.referenceSymbol(\n    sdkPlugin.api.selector('Options'),\n  );\n\n  const symbolDataType = plugin.getSymbol(\n    pluginTypeScript.api.selector('data', operation.id),\n  );\n  const dataType = symbolDataType?.placeholder || 'unknown';\n\n  return tsc.methodDeclaration({\n    accessLevel: 'public',\n    comment: createOperationComment({ operation }),\n    name: methodName,\n    parameters: [\n      {\n        isRequired: isRequiredOptions,\n        name: 'options',\n        type: `() => ${symbolOptions.placeholder}<${dataType}, ThrowOnError> | undefined`,\n      },\n    ],\n    returnType: undefined,\n    statements: [\n      tsc.returnStatement({\n        expression: generateResourceCallExpression({\n          operation,\n          plugin,\n        }),\n      }),\n    ],\n    types: [\n      {\n        default: false,\n        extends: 'boolean',\n        name: 'ThrowOnError',\n      },\n    ],\n  });\n};\n\nconst generateAngularResourceFunction = ({\n  isRequiredOptions,\n  operation,\n  plugin,\n  symbol,\n}: {\n  isRequiredOptions: boolean;\n  operation: IR.OperationObject;\n  plugin: AngularCommonPlugin['Instance'];\n  symbol: Symbol;\n}) => {\n  const pluginTypeScript = plugin.getPluginOrThrow('@hey-api/typescript');\n\n  const sdkPlugin = plugin.getPluginOrThrow('@hey-api/sdk');\n  const symbolOptions = plugin.referenceSymbol(\n    sdkPlugin.api.selector('Options'),\n  );\n\n  const symbolDataType = plugin.getSymbol(\n    pluginTypeScript.api.selector('data', operation.id),\n  );\n  const dataType = symbolDataType?.placeholder || 'unknown';\n\n  return tsc.constVariable({\n    comment: createOperationComment({ operation }),\n    exportConst: symbol.exported,\n    expression: tsc.arrowFunction({\n      parameters: [\n        {\n          isRequired: isRequiredOptions,\n          name: 'options',\n          type: `() => ${symbolOptions.placeholder}<${dataType}, ThrowOnError> | undefined`,\n        },\n      ],\n      statements: [\n        tsc.returnStatement({\n          expression: generateResourceCallExpression({\n            operation,\n            plugin,\n          }),\n        }),\n      ],\n      types: [\n        {\n          default: false,\n          extends: 'boolean',\n          name: 'ThrowOnError',\n        },\n      ],\n    }),\n    name: symbol.placeholder,\n  });\n};\n\nexport const createHttpResources: AngularCommonPlugin['Handler'] = ({\n  plugin,\n}) => {\n  if (plugin.config.httpResources.asClass) {\n    generateAngularClassServices({ plugin });\n  } else {\n    generateAngularFunctionServices({ plugin });\n  }\n};\n","import { createHttpRequests } from './httpRequests';\nimport { createHttpResources } from './httpResources';\nimport type { AngularCommonPlugin } from './types';\n\nexport const handler: AngularCommonPlugin['Handler'] = ({ plugin }) => {\n  plugin.registerSymbol({\n    external: '@angular/common/http',\n    meta: {\n      kind: 'type',\n    },\n    name: 'HttpRequest',\n    selector: plugin.api.selector('HttpRequest'),\n  });\n  plugin.registerSymbol({\n    external: '@angular/core',\n    name: 'inject',\n    selector: plugin.api.selector('inject'),\n  });\n  plugin.registerSymbol({\n    external: '@angular/core',\n    name: 'Injectable',\n    selector: plugin.api.selector('Injectable'),\n  });\n  plugin.registerSymbol({\n    external: '@angular/common/http',\n    name: 'httpResource',\n    selector: plugin.api.selector('httpResource'),\n  });\n\n  if (plugin.config.httpRequests.enabled) {\n    createHttpRequests({ plugin });\n  }\n\n  if (plugin.config.httpResources.enabled) {\n    createHttpResources({ plugin });\n  }\n};\n","import { definePluginConfig } from '~/plugins/shared/utils/config';\n\nimport { Api } from './api';\nimport { handler } from './plugin';\nimport type { AngularCommonPlugin } from './types';\n\nexport const defaultConfig: AngularCommonPlugin['Config'] = {\n  api: new Api({\n    name: '@angular/common',\n  }),\n  config: {\n    exportFromIndex: false,\n  },\n  dependencies: ['@hey-api/client-angular', '@hey-api/sdk'],\n  handler,\n  name: '@angular/common',\n  output: '@angular/common',\n  resolveConfig: (plugin, context) => {\n    plugin.config.httpRequests = context.valueToObject({\n      defaultValue: {\n        asClass: false,\n        classNameBuilder: '{{name}}Requests',\n        enabled: true,\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n      },\n      value: plugin.config.httpRequests,\n    });\n\n    if (!plugin.config.httpRequests.methodNameBuilder) {\n      const { asClass } = plugin.config.httpRequests;\n      plugin.config.httpRequests.methodNameBuilder = (operation) =>\n        asClass ? String(operation.id) : `${String(operation.id)}Request`;\n    }\n\n    plugin.config.httpResources = context.valueToObject({\n      defaultValue: {\n        asClass: false,\n        classNameBuilder: '{{name}}Resources',\n        enabled: true,\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n      },\n      value: plugin.config.httpResources,\n    });\n\n    if (!plugin.config.httpResources.methodNameBuilder) {\n      const { asClass } = plugin.config.httpResources;\n      plugin.config.httpResources.methodNameBuilder = (operation) =>\n        asClass ? String(operation.id) : `${String(operation.id)}Resource`;\n    }\n  },\n};\n\n/**\n * Type helper for `@angular/common` plugin, returns {@link Plugin.Config} object\n */\nexport const defineConfig = definePluginConfig(defaultConfig);\n","export const clientDefaultConfig = {\n  baseUrl: true,\n  bundle: true,\n  exportFromIndex: false,\n} as const;\n\nexport const clientDefaultMeta = {\n  dependencies: ['@hey-api/typescript'],\n  tags: ['client'],\n} as const;\n","import fs from 'node:fs';\nimport path from 'node:path';\nimport { fileURLToPath } from 'node:url';\n\nimport type { IProject, ProjectRenderMeta } from '@hey-api/codegen-core';\n\nimport type { DefinePlugin } from '~/plugins';\nimport type { Client } from '~/plugins/@hey-api/client-core/types';\nimport { getClientPlugin } from '~/plugins/@hey-api/client-core/utils';\nimport type { Config } from '~/types/config';\n\nimport { ensureDirSync, relativeModulePath } from './utils';\n\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = path.dirname(__filename);\n\n/**\n * Returns path to the client module. When using client packages, this will be\n * simply the name of the package. When bundling a client, this will be a\n * relative path to the bundled client folder.\n *\n * @deprecated\n */\nexport const clientModulePath = ({\n  config,\n  sourceOutput,\n}: {\n  config: Config;\n  sourceOutput: string;\n}): string => {\n  const client = getClientPlugin(config);\n\n  if ('bundle' in client.config && client.config.bundle) {\n    return relativeModulePath({\n      moduleOutput: 'client',\n      sourceOutput,\n    });\n  }\n\n  if (path.isAbsolute(client.name)) {\n    const clientSrcPath = path.dirname(client.name);\n    const outputPath = path.resolve(config.output.path);\n    return path.relative(outputPath, clientSrcPath).replace(/\\\\/g, '/');\n  }\n\n  return client.name;\n};\n\n/**\n * Returns absolute path to the client folder. This is hard-coded for now.\n */\nexport const clientFolderAbsolutePath = (config: Config): string => {\n  const client = getClientPlugin(config);\n\n  if ('bundle' in client.config && client.config.bundle) {\n    // not proud of this one\n    const renamed: Map<string, string> | undefined =\n      // @ts-expect-error\n      config._FRAGILE_CLIENT_BUNDLE_RENAMED;\n    return path.resolve(\n      config.output.path,\n      'client',\n      `${renamed?.get('index') ?? 'index'}.ts`,\n    );\n  }\n\n  return client.name;\n};\n\n/**\n * Recursively copies files and directories.\n * This is a PnP-compatible alternative to fs.cpSync that works with Yarn PnP's\n * virtualized filesystem.\n */\nconst copyRecursivePnP = (src: string, dest: string) => {\n  const stat = fs.statSync(src);\n\n  if (stat.isDirectory()) {\n    if (!fs.existsSync(dest)) {\n      fs.mkdirSync(dest, { recursive: true });\n    }\n\n    const files = fs.readdirSync(src);\n    for (const file of files) {\n      copyRecursivePnP(path.join(src, file), path.join(dest, file));\n    }\n  } else {\n    const content = fs.readFileSync(src);\n    fs.writeFileSync(dest, content);\n  }\n};\n\nconst renameFile = ({\n  filePath,\n  project,\n  renamed,\n}: {\n  filePath: string;\n  project: IProject;\n  renamed: Map<string, string>;\n}) => {\n  const extension = path.extname(filePath);\n  const name = path.basename(filePath, extension);\n  const renamedName = project.fileName?.(name) || name;\n  if (renamedName !== name) {\n    const outputPath = path.dirname(filePath);\n    fs.renameSync(\n      filePath,\n      path.resolve(outputPath, `${renamedName}${extension}`),\n    );\n    renamed.set(name, renamedName);\n  }\n};\n\nconst replaceImports = ({\n  filePath,\n  meta,\n  renamed,\n}: {\n  filePath: string;\n  meta: ProjectRenderMeta;\n  renamed: Map<string, string>;\n}) => {\n  let content = fs.readFileSync(filePath, 'utf8');\n\n  content = content.replace(\n    /from\\s+['\"](\\.\\.?\\/[^'\"]*?)['\"]/g,\n    (match, importPath) => {\n      const importIndex = match.indexOf(importPath);\n      const extension = path.extname(importPath);\n      const fileName = path.basename(importPath, extension);\n      const importDir = path.dirname(importPath);\n      const replacedName =\n        (renamed.get(fileName) ?? fileName) +\n        (meta.importFileExtension ? meta.importFileExtension : extension);\n      const replacedMatch =\n        match.slice(0, importIndex) +\n        [importDir, replacedName].filter(Boolean).join('/') +\n        match.slice(importIndex + importPath.length);\n      return replacedMatch;\n    },\n  );\n\n  const header = '// This file is auto-generated by @hey-api/openapi-ts\\n\\n';\n\n  content = `${header}${content}`;\n\n  fs.writeFileSync(filePath, content, 'utf8');\n};\n\n/**\n * Creates a `client` folder containing the same modules as the client package.\n */\nexport const generateClientBundle = ({\n  meta,\n  outputPath,\n  plugin,\n  project,\n}: {\n  meta: ProjectRenderMeta;\n  outputPath: string;\n  plugin: DefinePlugin<Client.Config & { name: string }>['Config'];\n  project?: IProject;\n}): Map<string, string> | undefined => {\n  const renamed = new Map<string, string>();\n\n  // copy Hey API clients to output\n  const isHeyApiClientPlugin = plugin.name.startsWith('@hey-api/client-');\n  if (isHeyApiClientPlugin) {\n    // copy client core\n    const coreOutputPath = path.resolve(outputPath, 'core');\n    ensureDirSync(coreOutputPath);\n    const coreDistPath = path.resolve(__dirname, 'clients', 'core');\n    copyRecursivePnP(coreDistPath, coreOutputPath);\n\n    // copy client bundle\n    const clientOutputPath = path.resolve(outputPath, 'client');\n    ensureDirSync(clientOutputPath);\n    const clientDistFolderName = plugin.name.slice('@hey-api/client-'.length);\n    const clientDistPath = path.resolve(\n      __dirname,\n      'clients',\n      clientDistFolderName,\n    );\n    copyRecursivePnP(clientDistPath, clientOutputPath);\n\n    if (project) {\n      const copiedCoreFiles = fs.readdirSync(coreOutputPath);\n      for (const file of copiedCoreFiles) {\n        renameFile({\n          filePath: path.resolve(coreOutputPath, file),\n          project,\n          renamed,\n        });\n      }\n\n      const copiedClientFiles = fs.readdirSync(clientOutputPath);\n      for (const file of copiedClientFiles) {\n        renameFile({\n          filePath: path.resolve(clientOutputPath, file),\n          project,\n          renamed,\n        });\n      }\n    }\n\n    const coreFiles = fs.readdirSync(coreOutputPath);\n    for (const file of coreFiles) {\n      replaceImports({\n        filePath: path.resolve(coreOutputPath, file),\n        meta,\n        renamed,\n      });\n    }\n\n    const clientFiles = fs.readdirSync(clientOutputPath);\n    for (const file of clientFiles) {\n      replaceImports({\n        filePath: path.resolve(clientOutputPath, file),\n        meta,\n        renamed,\n      });\n    }\n    return renamed;\n  }\n\n  const clientSrcPath = path.isAbsolute(plugin.name)\n    ? path.dirname(plugin.name)\n    : undefined;\n\n  // copy custom local client to output\n  if (clientSrcPath) {\n    const dirPath = path.resolve(outputPath, 'client');\n    ensureDirSync(dirPath);\n    copyRecursivePnP(clientSrcPath, dirPath);\n    return;\n  }\n\n  // copy third-party client to output\n  const clientModulePath = path.normalize(require.resolve(plugin.name));\n  const clientModulePathComponents = clientModulePath.split(path.sep);\n  const clientDistPath = clientModulePathComponents\n    .slice(0, clientModulePathComponents.indexOf('dist') + 1)\n    .join(path.sep);\n\n  const indexJsFile =\n    clientModulePathComponents[clientModulePathComponents.length - 1];\n  const distFiles = [indexJsFile!, 'index.d.ts', 'index.d.cts'];\n  const dirPath = path.resolve(outputPath, 'client');\n  ensureDirSync(dirPath);\n  for (const file of distFiles) {\n    fs.copyFileSync(\n      path.resolve(clientDistPath, file),\n      path.resolve(dirPath, file),\n    );\n  }\n\n  return;\n};\n","import { clientFolderAbsolutePath } from '~/generate/client';\nimport { tsc } from '~/tsc';\nimport { parseUrl } from '~/utils/url';\n\nimport type { PluginHandler } from './types';\nimport { getClientBaseUrlKey } from './utils';\n\nconst resolveBaseUrlString = ({\n  plugin,\n}: Parameters<PluginHandler>[0]): string | undefined => {\n  const { baseUrl } = plugin.config;\n\n  if (baseUrl === false) {\n    return;\n  }\n\n  if (typeof baseUrl === 'string') {\n    return baseUrl;\n  }\n\n  const { servers } = plugin.context.ir;\n\n  if (!servers) {\n    return;\n  }\n\n  return servers[typeof baseUrl === 'number' ? baseUrl : 0]?.url;\n};\n\nexport const createClient: PluginHandler = ({ plugin }) => {\n  const clientModule = clientFolderAbsolutePath(plugin.context.config);\n  const symbolCreateClient = plugin.registerSymbol({\n    external: clientModule,\n    name: 'createClient',\n  });\n  const symbolCreateConfig = plugin.registerSymbol({\n    external: clientModule,\n    name: 'createConfig',\n  });\n  const pluginTypeScript = plugin.getPluginOrThrow('@hey-api/typescript');\n  const symbolClientOptions = plugin.referenceSymbol(\n    pluginTypeScript.api.selector('ClientOptions'),\n  );\n\n  const { runtimeConfigPath } = plugin.config;\n  const symbolCreateClientConfig = runtimeConfigPath\n    ? plugin.registerSymbol({\n        external: runtimeConfigPath,\n        name: 'createClientConfig',\n      })\n    : undefined;\n\n  const defaultValues: Array<unknown> = [];\n\n  const resolvedBaseUrl = resolveBaseUrlString({\n    plugin: plugin as any,\n  });\n  if (resolvedBaseUrl) {\n    const url = parseUrl(resolvedBaseUrl);\n    if (url.protocol && url.host && !resolvedBaseUrl.includes('{')) {\n      defaultValues.push({\n        key: getClientBaseUrlKey(plugin.context.config),\n        value: resolvedBaseUrl,\n      });\n    } else if (resolvedBaseUrl !== '/' && resolvedBaseUrl.startsWith('/')) {\n      const baseUrl = resolvedBaseUrl.endsWith('/')\n        ? resolvedBaseUrl.slice(0, -1)\n        : resolvedBaseUrl;\n      defaultValues.push({\n        key: getClientBaseUrlKey(plugin.context.config),\n        value: baseUrl,\n      });\n    }\n  }\n\n  if ('throwOnError' in plugin.config && plugin.config.throwOnError) {\n    defaultValues.push({\n      key: 'throwOnError',\n      value: true,\n    });\n  }\n\n  const createConfigParameters = [\n    tsc.callExpression({\n      functionName: symbolCreateConfig.placeholder,\n      parameters: defaultValues.length\n        ? [tsc.objectExpression({ obj: defaultValues })]\n        : undefined,\n      types: [\n        tsc.typeReferenceNode({ typeName: symbolClientOptions.placeholder }),\n      ],\n    }),\n  ];\n\n  const symbolClient = plugin.registerSymbol({\n    meta: {\n      path: [],\n    },\n    name: 'client',\n    selector: plugin.api.selector('client'),\n  });\n  const statement = tsc.constVariable({\n    exportConst: true,\n    expression: tsc.callExpression({\n      functionName: symbolCreateClient.placeholder,\n      parameters: symbolCreateClientConfig\n        ? [\n            tsc.callExpression({\n              functionName: symbolCreateClientConfig.placeholder,\n              parameters: createConfigParameters,\n            }),\n          ]\n        : createConfigParameters,\n    }),\n    name: symbolClient.placeholder,\n  });\n  plugin.setSymbolValue(symbolClient, statement);\n};\n","import { clientFolderAbsolutePath } from '~/generate/client';\nimport { tsc } from '~/tsc';\n\nimport type { PluginHandler } from './types';\n\nexport const createClientConfigType = ({\n  plugin,\n}: Parameters<PluginHandler>[0]) => {\n  const clientModule = clientFolderAbsolutePath(plugin.context.config);\n  const pluginTypeScript = plugin.getPluginOrThrow('@hey-api/typescript');\n  const symbolClientOptions = plugin.referenceSymbol(\n    pluginTypeScript.api.selector('ClientOptions'),\n  );\n  const symbolConfig = plugin.registerSymbol({\n    external: clientModule,\n    meta: {\n      kind: 'type',\n    },\n    name: 'Config',\n  });\n  const symbolDefaultClientOptions = plugin.registerSymbol({\n    external: clientModule,\n    meta: {\n      kind: 'type',\n    },\n    name: 'ClientOptions',\n  });\n  const symbolCreateClientConfig = plugin.registerSymbol({\n    exported: true,\n    meta: {\n      kind: 'type',\n      path: [],\n    },\n    name: 'CreateClientConfig',\n  });\n\n  const defaultClientOptionsType = tsc.typeReferenceNode({\n    typeName: symbolDefaultClientOptions.placeholder,\n  });\n  const tType = tsc.typeReferenceNode({ typeName: 'T' });\n  const typeCreateClientConfig = tsc.typeAliasDeclaration({\n    comment: [\n      'The `createClientConfig()` function will be called on client initialization',\n      \"and the returned object will become the client's initial configuration.\",\n      '',\n      'You may want to initialize your client this way instead of calling',\n      \"`setConfig()`. This is useful for example if you're using Next.js\",\n      'to ensure your client always has the correct values.',\n    ],\n    exportType: symbolCreateClientConfig.exported,\n    name: symbolCreateClientConfig.placeholder,\n    type: tsc.functionTypeNode({\n      parameters: [\n        tsc.parameterDeclaration({\n          name: 'override',\n          required: false,\n          type: tsc.typeReferenceNode({\n            typeArguments: [\n              tsc.typeIntersectionNode({\n                types: [defaultClientOptionsType, tType],\n              }),\n            ],\n            typeName: symbolConfig.placeholder,\n          }),\n        }),\n      ],\n      returnType: tsc.typeReferenceNode({\n        typeArguments: [\n          tsc.typeIntersectionNode({\n            types: [\n              tsc.typeReferenceNode({\n                typeArguments: [defaultClientOptionsType],\n                typeName: 'Required',\n              }),\n              tType,\n            ],\n          }),\n        ],\n        typeName: symbolConfig.placeholder,\n      }),\n    }),\n    typeParameters: [\n      {\n        default: tsc.typeReferenceNode({\n          typeName: symbolClientOptions.placeholder,\n        }),\n        extends: defaultClientOptionsType,\n        name: 'T',\n      },\n    ],\n  });\n  plugin.setSymbolValue(symbolCreateClientConfig, typeCreateClientConfig);\n};\n","import { createClient } from './client';\nimport { createClientConfigType } from './createClientConfig';\nimport type { PluginHandler } from './types';\n\nexport const clientPluginHandler = ({\n  plugin,\n}: Parameters<PluginHandler>[0]) => {\n  createClientConfigType({ plugin });\n  createClient({ plugin });\n};\n","import type { Selector } from '@hey-api/codegen-core';\n\nimport type { Plugin } from '~/plugins';\n\ntype SelectorType = 'client';\n\nexport type IApi = {\n  /**\n   * @param type Selector type.\n   * @param value Depends on `type`:\n   *  - `client`: never\n   * @returns Selector array\n   */\n  selector: (type: SelectorType, value?: string) => Selector;\n};\n\nexport class Api implements IApi {\n  constructor(public meta: Plugin.Name<'@hey-api/client-angular'>) {}\n\n  selector(...args: ReadonlyArray<string | undefined>): Selector {\n    return [this.meta.name, ...(args as Selector)];\n  }\n}\n","import {\n  clientDefaultConfig,\n  clientDefaultMeta,\n} from '~/plugins/@hey-api/client-core/config';\nimport { clientPluginHandler } from '~/plugins/@hey-api/client-core/plugin';\nimport { definePluginConfig } from '~/plugins/shared/utils/config';\n\nimport { Api } from './api';\nimport type { HeyApiClientAngularPlugin } from './types';\n\nexport const defaultConfig: HeyApiClientAngularPlugin['Config'] = {\n  ...clientDefaultMeta,\n  api: new Api({\n    name: '@hey-api/client-angular',\n  }),\n  config: {\n    ...clientDefaultConfig,\n    throwOnError: false,\n  },\n  handler: clientPluginHandler,\n  name: '@hey-api/client-angular',\n};\n\n/**\n * Type helper for `@hey-api/client-angular` plugin, returns {@link Plugin.Config} object\n */\nexport const defineConfig = definePluginConfig(defaultConfig);\n","import type { Selector } from '@hey-api/codegen-core';\n\nimport type { Plugin } from '~/plugins';\n\ntype SelectorType = 'client';\n\nexport type IApi = {\n  /**\n   * @param type Selector type.\n   * @param value Depends on `type`:\n   *  - `client`: never\n   * @returns Selector array\n   */\n  selector: (type: SelectorType, value?: string) => Selector;\n};\n\nexport class Api implements IApi {\n  constructor(public meta: Plugin.Name<'@hey-api/client-axios'>) {}\n\n  selector(...args: ReadonlyArray<string | undefined>): Selector {\n    return [this.meta.name, ...(args as Selector)];\n  }\n}\n","import {\n  clientDefaultConfig,\n  clientDefaultMeta,\n} from '~/plugins/@hey-api/client-core/config';\nimport { clientPluginHandler } from '~/plugins/@hey-api/client-core/plugin';\nimport { definePluginConfig } from '~/plugins/shared/utils/config';\n\nimport { Api } from './api';\nimport type { HeyApiClientAxiosPlugin } from './types';\n\nexport const defaultConfig: HeyApiClientAxiosPlugin['Config'] = {\n  ...clientDefaultMeta,\n  api: new Api({\n    name: '@hey-api/client-axios',\n  }),\n  config: {\n    ...clientDefaultConfig,\n    throwOnError: false,\n  },\n  handler: clientPluginHandler,\n  name: '@hey-api/client-axios',\n};\n\n/**\n * Type helper for `@hey-api/client-axios` plugin, returns {@link Plugin.Config} object\n */\nexport const defineConfig = definePluginConfig(defaultConfig);\n","import type { Selector } from '@hey-api/codegen-core';\n\nimport type { Plugin } from '~/plugins';\n\ntype SelectorType = 'client';\n\nexport type IApi = {\n  /**\n   * @param type Selector type.\n   * @param value Depends on `type`:\n   *  - `client`: never\n   * @returns Selector array\n   */\n  selector: (type: SelectorType, value?: string) => Selector;\n};\n\nexport class Api implements IApi {\n  constructor(public meta: Plugin.Name<'@hey-api/client-fetch'>) {}\n\n  selector(...args: ReadonlyArray<string | undefined>): Selector {\n    return [this.meta.name, ...(args as Selector)];\n  }\n}\n","import {\n  clientDefaultConfig,\n  clientDefaultMeta,\n} from '~/plugins/@hey-api/client-core/config';\nimport { clientPluginHandler } from '~/plugins/@hey-api/client-core/plugin';\nimport { definePluginConfig } from '~/plugins/shared/utils/config';\n\nimport { Api } from './api';\nimport type { HeyApiClientFetchPlugin } from './types';\n\nexport const defaultConfig: HeyApiClientFetchPlugin['Config'] = {\n  ...clientDefaultMeta,\n  api: new Api({\n    name: '@hey-api/client-fetch',\n  }),\n  config: {\n    ...clientDefaultConfig,\n    throwOnError: false,\n  },\n  handler: clientPluginHandler,\n  name: '@hey-api/client-fetch',\n};\n\n/**\n * Type helper for `@hey-api/client-fetch` plugin, returns {@link Plugin.Config} object\n */\nexport const defineConfig = definePluginConfig(defaultConfig);\n","import type { Selector } from '@hey-api/codegen-core';\n\nimport type { Plugin } from '~/plugins';\n\ntype SelectorType = 'client';\n\nexport type IApi = {\n  /**\n   * @param type Selector type.\n   * @param value Depends on `type`:\n   *  - `client`: never\n   * @returns Selector array\n   */\n  selector: (type: SelectorType, value?: string) => Selector;\n};\n\nexport class Api implements IApi {\n  constructor(public meta: Plugin.Name<'@hey-api/client-next'>) {}\n\n  selector(...args: ReadonlyArray<string | undefined>): Selector {\n    return [this.meta.name, ...(args as Selector)];\n  }\n}\n","import {\n  clientDefaultConfig,\n  clientDefaultMeta,\n} from '~/plugins/@hey-api/client-core/config';\nimport { clientPluginHandler } from '~/plugins/@hey-api/client-core/plugin';\nimport { definePluginConfig } from '~/plugins/shared/utils/config';\n\nimport { Api } from './api';\nimport type { HeyApiClientNextPlugin } from './types';\n\nexport const defaultConfig: HeyApiClientNextPlugin['Config'] = {\n  ...clientDefaultMeta,\n  api: new Api({\n    name: '@hey-api/client-next',\n  }),\n  config: {\n    ...clientDefaultConfig,\n    throwOnError: false,\n  },\n  handler: clientPluginHandler,\n  name: '@hey-api/client-next',\n};\n\n/**\n * Type helper for `@hey-api/client-next` plugin, returns {@link Plugin.Config} object\n */\nexport const defineConfig = definePluginConfig(defaultConfig);\n","import type { Selector } from '@hey-api/codegen-core';\n\nimport type { Plugin } from '~/plugins';\n\ntype SelectorType = 'client';\n\nexport type IApi = {\n  /**\n   * @param type Selector type.\n   * @param value Depends on `type`:\n   *  - `client`: never\n   * @returns Selector array\n   */\n  selector: (type: SelectorType, value?: string) => Selector;\n};\n\nexport class Api implements IApi {\n  constructor(public meta: Plugin.Name<'@hey-api/client-nuxt'>) {}\n\n  selector(...args: ReadonlyArray<string | undefined>): Selector {\n    return [this.meta.name, ...(args as Selector)];\n  }\n}\n","import {\n  clientDefaultConfig,\n  clientDefaultMeta,\n} from '~/plugins/@hey-api/client-core/config';\nimport { clientPluginHandler } from '~/plugins/@hey-api/client-core/plugin';\nimport { definePluginConfig } from '~/plugins/shared/utils/config';\n\nimport { Api } from './api';\nimport type { HeyApiClientNuxtPlugin } from './types';\n\nexport const defaultConfig: HeyApiClientNuxtPlugin['Config'] = {\n  ...clientDefaultMeta,\n  api: new Api({\n    name: '@hey-api/client-nuxt',\n  }),\n  config: clientDefaultConfig,\n  handler: clientPluginHandler,\n  name: '@hey-api/client-nuxt',\n};\n\n/**\n * Type helper for `@hey-api/client-nuxt` plugin, returns {@link Plugin.Config} object\n */\nexport const defineConfig = definePluginConfig(defaultConfig);\n","import type { Selector } from '@hey-api/codegen-core';\n\nimport type { Plugin } from '~/plugins';\n\ntype SelectorType = 'client';\n\nexport type IApi = {\n  /**\n   * @param type Selector type.\n   * @param value Depends on `type`:\n   *  - `client`: never\n   * @returns Selector array\n   */\n  selector: (type: SelectorType, value?: string) => Selector;\n};\n\nexport class Api implements IApi {\n  constructor(public meta: Plugin.Name<'@hey-api/client-ofetch'>) {}\n\n  selector(...args: ReadonlyArray<string | undefined>): Selector {\n    return [this.meta.name, ...(args as Selector)];\n  }\n}\n","import {\n  clientDefaultConfig,\n  clientDefaultMeta,\n} from '~/plugins/@hey-api/client-core/config';\nimport { clientPluginHandler } from '~/plugins/@hey-api/client-core/plugin';\nimport { definePluginConfig } from '~/plugins/shared/utils/config';\n\nimport { Api } from './api';\nimport type { HeyApiClientOfetchPlugin } from './types';\n\nexport const defaultConfig: HeyApiClientOfetchPlugin['Config'] = {\n  ...clientDefaultMeta,\n  api: new Api({\n    name: '@hey-api/client-ofetch',\n  }),\n  config: {\n    ...clientDefaultConfig,\n    throwOnError: false,\n  },\n  handler: clientPluginHandler,\n  name: '@hey-api/client-ofetch',\n};\n\n/**\n * Type helper for `@hey-api/client-ofetch` plugin, returns {@link Plugin.Config} object\n */\nexport const defineConfig = definePluginConfig(defaultConfig);\n","import { definePluginConfig } from '~/plugins/shared/utils/config';\n\nimport type { HeyApiClientLegacyAngularPlugin } from './types';\n\nexport const defaultConfig: HeyApiClientLegacyAngularPlugin['Config'] = {\n  config: {},\n  handler: () => {},\n  name: 'legacy/angular',\n  output: 'client',\n  tags: ['client'],\n};\n\n/**\n * Type helper for `legacy/angular` plugin, returns {@link Plugin.Config} object\n */\nexport const defineConfig = definePluginConfig(defaultConfig);\n","import { definePluginConfig } from '~/plugins/shared/utils/config';\n\nimport type { HeyApiClientLegacyAxiosPlugin } from './types';\n\nexport const defaultConfig: HeyApiClientLegacyAxiosPlugin['Config'] = {\n  config: {},\n  handler: () => {},\n  name: 'legacy/axios',\n  output: 'client',\n  tags: ['client'],\n};\n\n/**\n * Type helper for `legacy/axios` plugin, returns {@link Plugin.Config} object\n */\nexport const defineConfig = definePluginConfig(defaultConfig);\n","import { definePluginConfig } from '~/plugins/shared/utils/config';\n\nimport type { HeyApiClientLegacyFetchPlugin } from './types';\n\nexport const defaultConfig: HeyApiClientLegacyFetchPlugin['Config'] = {\n  config: {},\n  handler: () => {},\n  name: 'legacy/fetch',\n  output: 'client',\n  tags: ['client'],\n};\n\n/**\n * Type helper for `legacy/fetch` plugin, returns {@link Plugin.Config} object\n */\nexport const defineConfig = definePluginConfig(defaultConfig);\n","import { definePluginConfig } from '~/plugins/shared/utils/config';\n\nimport type { HeyApiClientLegacyNodePlugin } from './types';\n\nexport const defaultConfig: HeyApiClientLegacyNodePlugin['Config'] = {\n  config: {},\n  handler: () => {},\n  name: 'legacy/node',\n  output: 'client',\n  tags: ['client'],\n};\n\n/**\n * Type helper for `legacy/node` plugin, returns {@link Plugin.Config} object\n */\nexport const defineConfig = definePluginConfig(defaultConfig);\n","import { definePluginConfig } from '~/plugins/shared/utils/config';\n\nimport type { HeyApiClientLegacyXhrPlugin } from './types';\n\nexport const defaultConfig: HeyApiClientLegacyXhrPlugin['Config'] = {\n  config: {},\n  handler: () => {},\n  name: 'legacy/xhr',\n  output: 'client',\n  tags: ['client'],\n};\n\n/**\n * Type helper for `legacy/xhr` plugin, returns {@link Plugin.Config} object\n */\nexport const defineConfig = definePluginConfig(defaultConfig);\n","import type { Selector } from '@hey-api/codegen-core';\n\nimport type { Plugin } from '~/plugins';\n\ntype SelectorType = 'ref';\n\nexport type IApi = {\n  /**\n   * @param type Selector type.\n   * @param value Depends on `type`:\n   *  - `ref`: `$ref` JSON pointer\n   * @returns Selector array\n   */\n  selector: (type: SelectorType, value?: string) => Selector;\n};\n\nexport class Api implements IApi {\n  constructor(public meta: Plugin.Name<'@hey-api/schemas'>) {}\n\n  selector(...args: ReadonlyArray<string | undefined>): Selector {\n    return [this.meta.name, ...(args as Selector)];\n  }\n}\n","import { satisfies } from '~/config/utils/package';\nimport type { IR } from '~/ir/types';\nimport type { OpenApiV2_0_XTypes } from '~/openApi/2.0.x';\nimport type { OpenApiV3_0_XTypes } from '~/openApi/3.0.x';\nimport type { OpenApiV3_1_XTypes } from '~/openApi/3.1.x';\nimport { ensureValidIdentifier } from '~/openApi/shared/utils/identifier';\nimport type { OpenApi } from '~/openApi/types';\nimport { tsc } from '~/tsc';\n\nimport type { HeyApiSchemasPlugin } from './types';\n\nconst stripSchema = ({\n  plugin,\n  schema,\n}: {\n  plugin: HeyApiSchemasPlugin['Instance'];\n  schema:\n    | OpenApiV2_0_XTypes['SchemaObject']\n    | OpenApiV3_0_XTypes['SchemaObject']\n    | OpenApiV3_1_XTypes['SchemaObject'];\n}) => {\n  if (plugin.config.type === 'form') {\n    if (schema.description) {\n      delete schema.description;\n    }\n\n    if (schema['x-enum-descriptions']) {\n      delete schema['x-enum-descriptions'];\n    }\n\n    if (schema['x-enum-varnames']) {\n      delete schema['x-enum-varnames'];\n    }\n\n    if (schema['x-enumNames']) {\n      delete schema['x-enumNames'];\n    }\n\n    if (schema.title) {\n      delete schema.title;\n    }\n  }\n};\n\nconst schemaToJsonSchemaDraft_04 = ({\n  context,\n  plugin,\n  schema: _schema,\n}: {\n  context: IR.Context;\n  plugin: HeyApiSchemasPlugin['Instance'];\n  schema: OpenApiV2_0_XTypes['SchemaObject'];\n}): OpenApiV2_0_XTypes['SchemaObject'] => {\n  if (Array.isArray(_schema)) {\n    return _schema.map((item) =>\n      schemaToJsonSchemaDraft_04({\n        context,\n        plugin,\n        schema: item,\n      }),\n    ) as unknown as OpenApiV2_0_XTypes['SchemaObject'];\n  }\n\n  const schema = structuredClone(_schema);\n\n  if (schema.$ref) {\n    // refs using unicode characters become encoded, didn't investigate why\n    // but the suspicion is this comes from `@hey-api/json-schema-ref-parser`\n    schema.$ref = decodeURI(schema.$ref);\n    return schema;\n  }\n\n  stripSchema({ plugin, schema });\n\n  if (\n    schema.additionalProperties &&\n    typeof schema.additionalProperties !== 'boolean'\n  ) {\n    schema.additionalProperties = schemaToJsonSchemaDraft_04({\n      context,\n      plugin,\n      schema: schema.additionalProperties,\n    });\n  }\n\n  if (schema.allOf) {\n    schema.allOf = schema.allOf.map((item) =>\n      schemaToJsonSchemaDraft_04({\n        context,\n        plugin,\n        schema: item,\n      }),\n    );\n  }\n\n  if (schema.items) {\n    schema.items = schemaToJsonSchemaDraft_04({\n      context,\n      plugin,\n      schema: schema.items as OpenApiV2_0_XTypes['SchemaObject'],\n    });\n  }\n\n  if (schema.properties) {\n    for (const name in schema.properties) {\n      const property = schema.properties[name]!;\n\n      if (typeof property !== 'boolean') {\n        schema.properties[name] = schemaToJsonSchemaDraft_04({\n          context,\n          plugin,\n          schema: property,\n        });\n      }\n    }\n  }\n\n  return schema;\n};\n\nconst schemaToJsonSchemaDraft_05 = ({\n  context,\n  plugin,\n  schema: _schema,\n}: {\n  context: IR.Context;\n  plugin: HeyApiSchemasPlugin['Instance'];\n  schema:\n    | OpenApiV3_0_XTypes['SchemaObject']\n    | OpenApiV3_0_XTypes['ReferenceObject'];\n}):\n  | OpenApiV3_0_XTypes['SchemaObject']\n  | OpenApiV3_0_XTypes['ReferenceObject'] => {\n  if (Array.isArray(_schema)) {\n    return _schema.map((item) =>\n      schemaToJsonSchemaDraft_05({\n        context,\n        plugin,\n        schema: item,\n      }),\n    ) as\n      | OpenApiV3_0_XTypes['SchemaObject']\n      | OpenApiV3_0_XTypes['ReferenceObject'];\n  }\n\n  const schema = structuredClone(_schema);\n\n  if ('$ref' in schema) {\n    // refs using unicode characters become encoded, didn't investigate why\n    // but the suspicion is this comes from `@hey-api/json-schema-ref-parser`\n    schema.$ref = decodeURI(schema.$ref);\n    return schema;\n  }\n\n  stripSchema({ plugin, schema });\n\n  if (\n    schema.additionalProperties &&\n    typeof schema.additionalProperties !== 'boolean'\n  ) {\n    schema.additionalProperties = schemaToJsonSchemaDraft_05({\n      context,\n      plugin,\n      schema: schema.additionalProperties,\n    });\n  }\n\n  if (schema.allOf) {\n    schema.allOf = schema.allOf.map((item) =>\n      schemaToJsonSchemaDraft_05({\n        context,\n        plugin,\n        schema: item,\n      }),\n    );\n  }\n\n  if (schema.anyOf) {\n    schema.anyOf = schema.anyOf.map((item) =>\n      schemaToJsonSchemaDraft_05({\n        context,\n        plugin,\n        schema: item,\n      }),\n    );\n  }\n\n  if (schema.items) {\n    schema.items = schemaToJsonSchemaDraft_05({\n      context,\n      plugin,\n      schema: schema.items,\n    });\n  }\n\n  if (schema.oneOf) {\n    schema.oneOf = schema.oneOf.map((item) =>\n      schemaToJsonSchemaDraft_05({\n        context,\n        plugin,\n        schema: item,\n      }),\n    );\n  }\n\n  if (schema.properties) {\n    for (const name in schema.properties) {\n      const property = schema.properties[name]!;\n\n      if (typeof property !== 'boolean') {\n        schema.properties[name] = schemaToJsonSchemaDraft_05({\n          context,\n          plugin,\n          schema: property,\n        });\n      }\n    }\n  }\n\n  return schema;\n};\n\nconst schemaToJsonSchema2020_12 = ({\n  context,\n  plugin,\n  schema: _schema,\n}: {\n  context: IR.Context;\n  plugin: HeyApiSchemasPlugin['Instance'];\n  schema: OpenApiV3_1_XTypes['SchemaObject'];\n}): OpenApiV3_1_XTypes['SchemaObject'] => {\n  if (Array.isArray(_schema)) {\n    return _schema.map((item) =>\n      schemaToJsonSchema2020_12({\n        context,\n        plugin,\n        schema: item,\n      }),\n    ) as OpenApiV3_1_XTypes['SchemaObject'];\n  }\n\n  const schema = structuredClone(_schema);\n\n  stripSchema({ plugin, schema });\n\n  if (schema.$ref) {\n    // refs using unicode characters become encoded, didn't investigate why\n    // but the suspicion is this comes from `@hey-api/json-schema-ref-parser`\n    schema.$ref = decodeURI(schema.$ref);\n  }\n\n  if (\n    schema.additionalProperties &&\n    typeof schema.additionalProperties !== 'boolean'\n  ) {\n    schema.additionalProperties = schemaToJsonSchema2020_12({\n      context,\n      plugin,\n      schema: schema.additionalProperties,\n    });\n  }\n\n  if (schema.allOf) {\n    schema.allOf = schema.allOf.map((item) =>\n      schemaToJsonSchema2020_12({\n        context,\n        plugin,\n        schema: item,\n      }),\n    );\n  }\n\n  if (schema.anyOf) {\n    schema.anyOf = schema.anyOf.map((item) =>\n      schemaToJsonSchema2020_12({\n        context,\n        plugin,\n        schema: item,\n      }),\n    );\n  }\n\n  if (schema.items) {\n    schema.items = schemaToJsonSchema2020_12({\n      context,\n      plugin,\n      schema: schema.items,\n    });\n  }\n\n  if (schema.oneOf) {\n    schema.oneOf = schema.oneOf.map((item) =>\n      schemaToJsonSchema2020_12({\n        context,\n        plugin,\n        schema: item,\n      }),\n    );\n  }\n\n  if (schema.prefixItems) {\n    schema.prefixItems = schema.prefixItems.map((item) =>\n      schemaToJsonSchema2020_12({\n        context,\n        plugin,\n        schema: item,\n      }),\n    );\n  }\n\n  if (schema.properties) {\n    for (const name in schema.properties) {\n      const property = schema.properties[name]!;\n\n      if (typeof property !== 'boolean') {\n        schema.properties[name] = schemaToJsonSchema2020_12({\n          context,\n          plugin,\n          schema: property,\n        });\n      }\n    }\n  }\n\n  return schema;\n};\n\nconst schemaName = ({\n  name,\n  plugin,\n  schema,\n}: {\n  name: string;\n  plugin: HeyApiSchemasPlugin['Instance'];\n  schema:\n    | OpenApiV2_0_XTypes['SchemaObject']\n    | OpenApiV3_0_XTypes['ReferenceObject']\n    | OpenApiV3_0_XTypes['SchemaObject']\n    | OpenApiV3_1_XTypes['SchemaObject'];\n}): string => {\n  let customName = '';\n\n  if (plugin.config.nameBuilder) {\n    if (typeof plugin.config.nameBuilder === 'function') {\n      customName = plugin.config.nameBuilder(name, schema);\n    } else {\n      customName = plugin.config.nameBuilder.replace('{{name}}', name);\n    }\n  }\n\n  if (!customName) {\n    customName = `${name}Schema`;\n  }\n\n  return ensureValidIdentifier(customName);\n};\n\nconst schemasV2_0_X = ({\n  context,\n  plugin,\n}: {\n  context: IR.Context<OpenApi.V2_0_X>;\n  plugin: HeyApiSchemasPlugin['Instance'];\n}) => {\n  if (!context.spec.definitions) {\n    return;\n  }\n\n  for (const name in context.spec.definitions) {\n    const schema = context.spec.definitions[name]!;\n    const symbol = plugin.registerSymbol({\n      exported: true,\n      name: schemaName({ name, plugin, schema }),\n      selector: plugin.api.selector('ref', name),\n    });\n    const obj = schemaToJsonSchemaDraft_04({\n      context,\n      plugin,\n      schema,\n    });\n    const statement = tsc.constVariable({\n      assertion: 'const',\n      exportConst: symbol.exported,\n      expression: tsc.objectExpression({ obj }),\n      name: symbol.placeholder,\n    });\n    plugin.setSymbolValue(symbol, statement);\n  }\n};\n\nconst schemasV3_0_X = ({\n  context,\n  plugin,\n}: {\n  context: IR.Context<OpenApi.V3_0_X>;\n  plugin: HeyApiSchemasPlugin['Instance'];\n}) => {\n  if (!context.spec.components) {\n    return;\n  }\n\n  for (const name in context.spec.components.schemas) {\n    const schema = context.spec.components.schemas[name]!;\n    const symbol = plugin.registerSymbol({\n      exported: true,\n      name: schemaName({ name, plugin, schema }),\n      selector: plugin.api.selector('ref', name),\n    });\n    const obj = schemaToJsonSchemaDraft_05({\n      context,\n      plugin,\n      schema,\n    });\n    const statement = tsc.constVariable({\n      assertion: 'const',\n      exportConst: symbol.exported,\n      expression: tsc.objectExpression({ obj }),\n      name: symbol.placeholder,\n    });\n    plugin.setSymbolValue(symbol, statement);\n  }\n};\n\nconst schemasV3_1_X = ({\n  context,\n  plugin,\n}: {\n  context: IR.Context<OpenApi.V3_1_X>;\n  plugin: HeyApiSchemasPlugin['Instance'];\n}) => {\n  if (!context.spec.components) {\n    return;\n  }\n\n  for (const name in context.spec.components.schemas) {\n    const schema = context.spec.components.schemas[name]!;\n    const symbol = plugin.registerSymbol({\n      exported: true,\n      name: schemaName({ name, plugin, schema }),\n      selector: plugin.api.selector('ref', name),\n    });\n    const obj = schemaToJsonSchema2020_12({\n      context,\n      plugin,\n      schema,\n    });\n    const statement = tsc.constVariable({\n      assertion: 'const',\n      exportConst: symbol.exported,\n      expression: tsc.objectExpression({ obj }),\n      name: symbol.placeholder,\n    });\n    plugin.setSymbolValue(symbol, statement);\n  }\n};\n\nexport const handler: HeyApiSchemasPlugin['Handler'] = ({ plugin }) => {\n  if ('swagger' in plugin.context.spec) {\n    schemasV2_0_X({\n      context: plugin.context as IR.Context<OpenApi.V2_0_X>,\n      plugin,\n    });\n    return;\n  }\n\n  if (satisfies(plugin.context.spec.openapi, '>=3.0.0 <3.1.0')) {\n    schemasV3_0_X({\n      context: plugin.context as IR.Context<OpenApi.V3_0_X>,\n      plugin,\n    });\n    return;\n  }\n\n  if (satisfies(plugin.context.spec.openapi, '>=3.1.0')) {\n    schemasV3_1_X({\n      context: plugin.context as IR.Context<OpenApi.V3_1_X>,\n      plugin,\n    });\n    return;\n  }\n\n  throw new Error('Unsupported OpenAPI specification');\n};\n","import fs from 'node:fs';\nimport path from 'node:path';\n\nimport ts from 'typescript';\n\nimport { tsc } from '~/tsc';\nimport { type ImportExportItemObject, tsNodeToString } from '~/tsc/utils';\n\nimport { ensureDirSync } from './utils';\n\ntype FileImportResult<\n  Name extends string | undefined = string | undefined,\n  Alias extends string | undefined = undefined,\n> = {\n  asType?: boolean;\n  name: Alias extends string ? Alias : Name;\n};\n\n/**\n * TODO: remove, it's used by legacy plugins\n *\n * @deprecated\n */\nexport class GeneratedFile {\n  /**\n   * Should the exports from this file be re-exported in the index barrel file?\n   */\n  private _exportFromIndex: boolean;\n  private _headers: Array<string> = [];\n  private _id: string;\n  private _imports = new Map<string, Map<string, ImportExportItemObject>>();\n  private _items: Array<ts.Node | string> = [];\n  private _name: string;\n  private _path: string;\n\n  public constructor({\n    dir,\n    exportFromIndex = false,\n    header = true,\n    id,\n    name,\n  }: {\n    dir: string;\n    /**\n     * Should the exports from this file be re-exported in the index barrel file?\n     */\n    exportFromIndex?: boolean;\n    header?: boolean;\n    /**\n     * Unique file ID. Used to generate correct relative paths to the file.\n     * This should be refactored later as it's basically the file name unless\n     * nested inside another folder.\n     */\n    id: string;\n    name: string;\n  }) {\n    this._exportFromIndex = exportFromIndex;\n    this._id = id;\n    this._name = this._setName(name);\n    this._path = path.resolve(dir, this._name);\n\n    if (header) {\n      this._headers.push(\n        '// This file is auto-generated by @hey-api/openapi-ts',\n      );\n    }\n  }\n\n  public add(...nodes: Array<ts.Node | string>) {\n    this._items = this._items.concat(nodes);\n  }\n\n  public get exportFromIndex(): boolean {\n    return this._exportFromIndex;\n  }\n\n  public get id(): string {\n    return this._id;\n  }\n\n  /**\n   * Adds an import to the provided module. Handles duplication, returns added\n   * import. Returns the imported name. If we import an aliased export, `name`\n   * will be equal to the specified `alias`.\n   */\n  public import<\n    Name extends string | undefined = string | undefined,\n    Alias extends string | undefined = undefined,\n  >({\n    module,\n    ...importedItem\n  }: ImportExportItemObject<Name, Alias> & {\n    module: string;\n  }): FileImportResult<Name, Alias> {\n    if (!importedItem.name) {\n      return {\n        name: undefined as any,\n      };\n    }\n\n    let moduleMap = this._imports.get(module);\n\n    if (!moduleMap) {\n      moduleMap = new Map<string, ImportExportItemObject>();\n      this._imports.set(module, moduleMap);\n    }\n\n    const match = moduleMap.get(importedItem.name);\n    if (match) {\n      return {\n        ...match,\n        name: (match.alias || match.name) as any,\n      };\n    }\n\n    moduleMap.set(importedItem.name, importedItem as any);\n    return {\n      ...importedItem,\n      name: (importedItem.alias || importedItem.name) as any,\n    };\n  }\n\n  public isEmpty() {\n    return !this._items.length;\n  }\n\n  public nameWithoutExtension() {\n    const { name } = splitNameAndExtension(this._name);\n    return name;\n  }\n\n  public remove(options?: Parameters<typeof fs.rmSync>[1]) {\n    fs.rmSync(this._path, options);\n  }\n\n  /**\n   * Removes last node form the stack. Works as undo.\n   *\n   * @deprecated\n   */\n  public removeNode_LEGACY() {\n    this._items = this._items.slice(0, this._items.length - 1);\n  }\n\n  private _setName(fileName: string) {\n    if (fileName.includes('index')) {\n      return fileName;\n    }\n\n    const { extension, name } = splitNameAndExtension(fileName);\n    return [name, 'gen', extension].filter(Boolean).join('.');\n  }\n\n  private _toString(separator: string, tsConfig: ts.ParsedCommandLine | null) {\n    let output: Array<string> = [];\n    if (this._headers.length) {\n      output.push(this._headers.join('\\n'));\n    }\n\n    const shouldAppendJs =\n      tsConfig?.options.moduleResolution === ts.ModuleResolutionKind.NodeNext;\n\n    const importsStringArray: Array<string> = [];\n\n    for (const [_module, moduleMap] of this._imports.entries()) {\n      const imports = Array.from(moduleMap.values());\n\n      let resolvedModule = _module;\n      if (\n        shouldAppendJs &&\n        (resolvedModule.startsWith('./') || resolvedModule.startsWith('../'))\n      ) {\n        if (resolvedModule === './client') {\n          resolvedModule = './client/index.js';\n        } else {\n          resolvedModule = `${resolvedModule}.js`;\n        }\n      }\n\n      const node = tsc.namedImportDeclarations({\n        imports,\n        module: resolvedModule,\n      });\n      importsStringArray.push(tsNodeToString({ node }));\n    }\n    if (importsStringArray.length) {\n      output.push(importsStringArray.join('\\n'));\n    }\n    output = output.concat(\n      this._items.map((node) =>\n        typeof node === 'string'\n          ? node\n          : tsNodeToString({ node, unescape: true }),\n      ),\n    );\n    return output.join(separator);\n  }\n\n  public write(separator = '\\n', tsConfig: ts.ParsedCommandLine | null = null) {\n    if (this.isEmpty()) {\n      this.remove({ force: true });\n      return;\n    }\n\n    let dir = this._path;\n    if (typeof this._path === 'string') {\n      const parts = this._path.split(path.sep);\n      dir = parts.slice(0, parts.length - 1).join(path.sep);\n    }\n    ensureDirSync(dir);\n    fs.writeFileSync(this._path, this._toString(separator, tsConfig));\n  }\n}\n\nexport const splitNameAndExtension = (fileName: string) => {\n  const match = fileName.match(/\\.[0-9a-z]+$/i);\n  const extension = match ? match[0].slice(1) : '';\n  const name = fileName.slice(\n    0,\n    fileName.length - (extension ? extension.length + 1 : 0),\n  );\n  return { extension, name };\n};\n","import { GeneratedFile } from '~/generate/file';\nimport type { OpenApiV2Schema, OpenApiV3Schema } from '~/openApi';\nimport { ensureValidTypeScriptJavaScriptIdentifier } from '~/openApi';\nimport { tsc } from '~/tsc';\nimport { getConfig } from '~/utils/config';\n\nimport type { HeyApiSchemasPlugin } from './types';\n\nconst ensureValidSchemaOutput = (\n  schema: unknown,\n  parentKey?: string,\n): object => {\n  const config = getConfig();\n\n  if (Array.isArray(schema)) {\n    return schema.map((item) => ensureValidSchemaOutput(item));\n  }\n\n  if (typeof schema !== 'object' || schema === null) {\n    return schema as object;\n  }\n\n  const result = { ...schema };\n  Object.entries(result).forEach(([key, value]) => {\n    if (config.plugins['@hey-api/schemas']?.config.type === 'form') {\n      if (\n        [\n          'description',\n          'x-enum-descriptions',\n          'x-enum-varnames',\n          'x-enumNames',\n          'title',\n        ].includes(key) &&\n        parentKey !== 'properties'\n      ) {\n        // @ts-expect-error\n        delete result[key];\n        return;\n      }\n    }\n\n    // refs are encoded probably by json-schema-ref-parser, didn't investigate\n    // further\n    if (key === '$ref' && typeof value === 'string') {\n      // @ts-expect-error\n      result[key] = decodeURIComponent(value);\n    }\n\n    if (value && typeof value === 'object') {\n      // @ts-expect-error\n      result[key] = ensureValidSchemaOutput(value, key);\n    }\n  });\n  return result;\n};\n\nconst toSchemaName = (\n  name: string,\n  schema: OpenApiV2Schema | OpenApiV3Schema,\n): string => {\n  const config = getConfig();\n\n  const validName = ensureValidTypeScriptJavaScriptIdentifier(name);\n\n  const plugin = config.plugins['@hey-api/schemas'];\n\n  if (plugin?.config.nameBuilder) {\n    if (typeof plugin.config.nameBuilder === 'function') {\n      return plugin.config.nameBuilder(validName, schema);\n    } else {\n      return plugin.config.nameBuilder.replace('{{name}}', validName);\n    }\n  }\n\n  return `${validName}Schema`;\n};\n\nexport const handlerLegacy: HeyApiSchemasPlugin['LegacyHandler'] = ({\n  files,\n  openApi,\n  plugin,\n}) => {\n  const config = getConfig();\n\n  files.schemas = new GeneratedFile({\n    dir: config.output.path,\n    exportFromIndex: plugin.config.exportFromIndex,\n    id: 'schemas',\n    name: 'schemas.ts',\n  });\n\n  const addSchema = (\n    name: string,\n    schema: OpenApiV2Schema | OpenApiV3Schema,\n  ) => {\n    const obj = ensureValidSchemaOutput(schema);\n    const expression = tsc.objectExpression({ obj });\n    const statement = tsc.constVariable({\n      assertion: 'const',\n      exportConst: true,\n      expression,\n      name: toSchemaName(name, schema),\n    });\n    files.schemas!.add(statement);\n  };\n\n  // OpenAPI 2.0\n  if ('swagger' in openApi) {\n    Object.entries(openApi.definitions ?? {}).forEach(([name, definition]) => {\n      addSchema(name, definition);\n    });\n  }\n\n  // OpenAPI 3.x\n  if ('openapi' in openApi) {\n    Object.entries(openApi.components?.schemas ?? {}).forEach(\n      ([name, schema]) => {\n        addSchema(name, schema);\n      },\n    );\n  }\n};\n","import { definePluginConfig } from '~/plugins/shared/utils/config';\n\nimport { Api } from './api';\nimport { handler } from './plugin';\nimport { handlerLegacy } from './plugin-legacy';\nimport type { HeyApiSchemasPlugin } from './types';\n\nexport const defaultConfig: HeyApiSchemasPlugin['Config'] = {\n  api: new Api({\n    name: '@hey-api/schemas',\n  }),\n  config: {\n    exportFromIndex: false,\n    nameBuilder: (name) => `${name}Schema`,\n    type: 'json',\n  },\n  handler,\n  handlerLegacy,\n  name: '@hey-api/schemas',\n};\n\n/**\n * Type helper for `@hey-api/schemas` plugin, returns {@link Plugin.Config} object\n */\nexport const defineConfig = definePluginConfig(defaultConfig);\n","import type { Selector } from '@hey-api/codegen-core';\n\nimport type { Plugin } from '~/plugins';\n\ntype SelectorType =\n  | 'buildClientParams'\n  | 'class'\n  | 'Client'\n  | 'Composable'\n  | 'formDataBodySerializer'\n  | 'function'\n  | 'Injectable'\n  | 'Options'\n  | 'urlSearchParamsBodySerializer';\n\nexport type IApi = {\n  /**\n   * @param type Selector type.\n   * @param value Depends on `type`:\n   *  - `buildClientParams`: never\n   *  - `class`: current class name\n   *  - `Client`: never\n   *  - `Composable`: never\n   *  - `formDataBodySerializer`: never\n   *  - `function`: `operation.id` string\n   *  - `Injectable`: never\n   *  - `Options`: never\n   *  - `urlSearchParamsBodySerializer`: never\n   * @returns Selector array\n   */\n  selector: (type: SelectorType, value?: string) => Selector;\n};\n\nexport class Api implements IApi {\n  constructor(public meta: Plugin.Name<'@hey-api/sdk'>) {}\n\n  selector(...args: ReadonlyArray<string | undefined>): Selector {\n    return [this.meta.name, ...(args as Selector)];\n  }\n}\n","import type ts from 'typescript';\n\nimport { getClientPlugin } from '~/plugins/@hey-api/client-core/utils';\nimport {\n  createOperationComment,\n  isOperationOptionsRequired,\n} from '~/plugins/shared/utils/operation';\nimport { tsc } from '~/tsc';\nimport { stringCase } from '~/utils/stringCase';\n\nimport type { HeyApiSdkPlugin } from '../types';\nimport { nuxtTypeComposable, nuxtTypeDefault } from './constants';\nimport {\n  operationClasses,\n  operationParameters,\n  operationStatements,\n} from './operation';\n\ntype SdkClassEntry = {\n  /**\n   * Name of the class.\n   */\n  className: string;\n  /**\n   * Symbol IDs for child classes located inside this class.\n   */\n  classes: Set<number>;\n  /**\n   * Symbol ID for the class.\n   */\n  id: number;\n  /**\n   * Track unique added method nodes.\n   */\n  methods: Set<string>;\n  /**\n   * List of class nodes containing methods.\n   */\n  nodes: Array<ts.ClassElement>;\n  /**\n   * Is this a root class?\n   */\n  root: boolean;\n};\n\nconst createClientClassNodes = ({\n  plugin,\n}: {\n  plugin: HeyApiSdkPlugin['Instance'];\n}): ReadonlyArray<ts.ClassElement> => {\n  const clientAssignmentStatement = tsc.expressionToStatement({\n    expression: tsc.binaryExpression({\n      left: tsc.propertyAccessExpression({\n        expression: tsc.this(),\n        name: '_client',\n      }),\n      operator: '=',\n      right: tsc.propertyAccessExpression({\n        expression: tsc.identifier({ text: 'args' }),\n        name: 'client',\n      }),\n    }),\n  });\n\n  const symbolClient = plugin.referenceSymbol(plugin.api.selector('Client'));\n  const client = getClientPlugin(plugin.context.config);\n  const symClient =\n    client.api && 'selector' in client.api\n      ? plugin.getSymbol(\n          // @ts-expect-error\n          client.api.selector('client'),\n        )\n      : undefined;\n\n  return [\n    tsc.propertyDeclaration({\n      initializer: symClient\n        ? tsc.identifier({ text: symClient.placeholder })\n        : undefined,\n      modifier: 'protected',\n      name: '_client',\n      type: tsc.typeReferenceNode({ typeName: symbolClient.placeholder }),\n    }),\n    // @ts-expect-error\n    tsc.identifier({ text: '\\n' }),\n    tsc.constructorDeclaration({\n      multiLine: true,\n      parameters: [\n        {\n          isRequired: !plugin.config.client,\n          name: 'args',\n          type: tsc.typeInterfaceNode({\n            properties: [\n              {\n                isRequired: !plugin.config.client,\n                name: 'client',\n                type: symbolClient.placeholder,\n              },\n            ],\n            useLegacyResolution: false,\n          }),\n        },\n      ],\n      statements: [\n        !plugin.config.client\n          ? clientAssignmentStatement\n          : tsc.ifStatement({\n              expression: tsc.propertyAccessExpression({\n                expression: tsc.identifier({ text: 'args' }),\n                isOptional: true,\n                name: 'client',\n              }),\n              thenStatement: tsc.block({\n                statements: [clientAssignmentStatement],\n              }),\n            }),\n      ],\n    }),\n  ];\n};\n\nexport const generateClassSdk = ({\n  plugin,\n}: {\n  plugin: HeyApiSdkPlugin['Instance'];\n}): void => {\n  const client = getClientPlugin(plugin.context.config);\n  const isAngularClient = client.name === '@hey-api/client-angular';\n  const isNuxtClient = client.name === '@hey-api/client-nuxt';\n  const sdkClasses = new Map<number, SdkClassEntry>();\n  /**\n   * Track unique added classes.\n   */\n  const generatedClasses = new Set<number>();\n\n  const clientClassNodes = plugin.config.instance\n    ? createClientClassNodes({ plugin })\n    : [];\n\n  plugin.forEach(\n    'operation',\n    ({ operation }) => {\n      const isRequiredOptions = isOperationOptionsRequired({\n        context: plugin.context,\n        operation,\n      });\n      const pluginTypeScript = plugin.getPluginOrThrow('@hey-api/typescript');\n      const symbolResponse = isNuxtClient\n        ? plugin.getSymbol(\n            pluginTypeScript.api.selector('response', operation.id),\n          )\n        : undefined;\n\n      const classes = operationClasses({\n        context: plugin.context,\n        operation,\n        plugin,\n      });\n\n      for (const entry of classes.values()) {\n        entry.path.forEach((currentClassName, index) => {\n          const symbolCurrentClass = plugin.referenceSymbol(\n            plugin.api.selector('class', currentClassName),\n          );\n          if (!sdkClasses.has(symbolCurrentClass.id)) {\n            sdkClasses.set(symbolCurrentClass.id, {\n              className: currentClassName,\n              classes: new Set(),\n              id: symbolCurrentClass.id,\n              methods: new Set(),\n              nodes: [],\n              root: !index,\n            });\n          }\n\n          const parentClassName = entry.path[index - 1];\n          if (parentClassName) {\n            const symbolParentClass = plugin.referenceSymbol(\n              plugin.api.selector('class', parentClassName),\n            );\n            if (\n              symbolParentClass.placeholder !== symbolCurrentClass.placeholder\n            ) {\n              const parentClass = sdkClasses.get(symbolParentClass.id)!;\n              parentClass.classes.add(symbolCurrentClass.id);\n              sdkClasses.set(symbolParentClass.id, parentClass);\n            }\n          }\n\n          const isLast = entry.path.length === index + 1;\n          // add methods only to the last class\n          if (!isLast) {\n            return;\n          }\n\n          const currentClass = sdkClasses.get(symbolCurrentClass.id)!;\n\n          // avoid duplicate methods\n          if (currentClass.methods.has(entry.methodName)) {\n            return;\n          }\n\n          const opParameters = operationParameters({\n            isRequiredOptions,\n            operation,\n            plugin,\n          });\n          const statements = operationStatements({\n            isRequiredOptions,\n            opParameters,\n            operation,\n            plugin,\n          });\n          const functionNode = tsc.methodDeclaration({\n            accessLevel: 'public',\n            comment: createOperationComment({ operation }),\n            isStatic: isAngularClient ? false : !plugin.config.instance,\n            name: entry.methodName,\n            parameters: opParameters.parameters,\n            returnType: undefined,\n            statements,\n            types: isNuxtClient\n              ? [\n                  {\n                    default: tsc.ots.string('$fetch'),\n                    extends: tsc.typeNode(\n                      plugin.referenceSymbol(plugin.api.selector('Composable'))\n                        .placeholder,\n                    ),\n                    name: nuxtTypeComposable,\n                  },\n                  {\n                    default: symbolResponse\n                      ? tsc.typeReferenceNode({\n                          typeName: symbolResponse.placeholder,\n                        })\n                      : tsc.typeNode('undefined'),\n                    extends: symbolResponse\n                      ? tsc.typeReferenceNode({\n                          typeName: symbolResponse.placeholder,\n                        })\n                      : undefined,\n                    name: nuxtTypeDefault,\n                  },\n                ]\n              : [\n                  {\n                    default:\n                      ('throwOnError' in client.config\n                        ? client.config.throwOnError\n                        : false) ?? false,\n                    extends: 'boolean',\n                    name: 'ThrowOnError',\n                  },\n                ],\n          });\n\n          if (!currentClass.nodes.length) {\n            currentClass.nodes.push(functionNode);\n          } else {\n            currentClass.nodes.push(\n              // @ts-expect-error\n              tsc.identifier({ text: '\\n' }),\n              functionNode,\n            );\n          }\n\n          currentClass.methods.add(entry.methodName);\n\n          sdkClasses.set(symbolCurrentClass.id, currentClass);\n        });\n      }\n    },\n    {\n      order: 'declarations',\n    },\n  );\n\n  const symbolHeyApiClient = plugin.registerSymbol({\n    exported: false,\n    meta: {\n      path: [],\n    },\n    name: '_HeyApiClient',\n  });\n\n  const generateClass = (currentClass: SdkClassEntry) => {\n    if (generatedClasses.has(currentClass.id)) {\n      return;\n    }\n\n    if (currentClass.classes.size) {\n      for (const childClassName of currentClass.classes) {\n        const childClass = sdkClasses.get(childClassName)!;\n        generateClass(childClass);\n\n        currentClass.nodes.push(\n          tsc.propertyDeclaration({\n            initializer: plugin.config.instance\n              ? tsc.newExpression({\n                  argumentsArray: plugin.config.instance\n                    ? [\n                        tsc.objectExpression({\n                          multiLine: false,\n                          obj: [\n                            {\n                              key: 'client',\n                              value: tsc.propertyAccessExpression({\n                                expression: tsc.this(),\n                                name: '_client',\n                              }),\n                            },\n                          ],\n                        }),\n                      ]\n                    : [],\n                  expression: tsc.identifier({\n                    text: plugin.referenceSymbol(childClass.id).placeholder,\n                  }),\n                })\n              : tsc.identifier({\n                  text: plugin.referenceSymbol(childClass.id).placeholder,\n                }),\n            modifier: plugin.config.instance ? undefined : 'static',\n            name: stringCase({\n              case: 'camelCase',\n              value: childClass.className,\n            }),\n          }),\n        );\n      }\n    }\n\n    const symbol = plugin.registerSymbol({\n      exported: true,\n      meta: {\n        path: [],\n      },\n      name: currentClass.className,\n      selector: plugin.api.selector('class', currentClass.className),\n    });\n    const node = tsc.classDeclaration({\n      decorator:\n        currentClass.root && isAngularClient\n          ? {\n              args: [\n                {\n                  providedIn: 'root',\n                },\n              ],\n              name: plugin.referenceSymbol(plugin.api.selector('Injectable'))\n                .placeholder,\n            }\n          : undefined,\n      exportClass: symbol.exported,\n      extendedClasses: plugin.config.instance\n        ? [symbolHeyApiClient.placeholder]\n        : undefined,\n      name: symbol.placeholder,\n      nodes: currentClass.nodes,\n    });\n    plugin.setSymbolValue(symbol, node);\n    generatedClasses.add(symbol.id);\n  };\n\n  if (clientClassNodes.length) {\n    const node = tsc.classDeclaration({\n      exportClass: symbolHeyApiClient.exported,\n      name: symbolHeyApiClient.placeholder,\n      nodes: clientClassNodes,\n    });\n    plugin.setSymbolValue(symbolHeyApiClient, node);\n  }\n\n  for (const sdkClass of sdkClasses.values()) {\n    generateClass(sdkClass);\n  }\n};\n","import type ts from 'typescript';\n\nimport { clientModulePath } from '~/generate/client';\nimport { GeneratedFile } from '~/generate/file';\nimport type { IR } from '~/ir/types';\nimport { isOperationParameterRequired } from '~/openApi';\nimport { getClientPlugin } from '~/plugins/@hey-api/client-core/utils';\nimport type { Comments, FunctionParameter } from '~/tsc';\nimport { tsc } from '~/tsc';\nimport type { FunctionTypeParameter, ObjectValue } from '~/tsc/types';\nimport type {\n  Client,\n  Model,\n  Operation,\n  OperationParameter,\n  Service,\n} from '~/types/client';\nimport type { Config as ClientConfig } from '~/types/config';\nimport {\n  getConfig,\n  isLegacyClient,\n  legacyNameFromConfig,\n} from '~/utils/config';\nimport { escapeComment, escapeName } from '~/utils/escape';\nimport { reservedJavaScriptKeywordsRegExp } from '~/utils/regexp';\nimport { stringCase } from '~/utils/stringCase';\nimport { transformClassName } from '~/utils/transform';\nimport { setUniqueTypeName } from '~/utils/type';\nimport { unique } from '~/utils/unique';\n\nimport type { HeyApiSdkPlugin } from './types';\n\ntype OnNode = (node: ts.Node) => void;\ntype OnImport = (name: string) => void;\n\nexport const generateImport = ({\n  meta,\n  onImport,\n  ...setUniqueTypeNameArgs\n}: Pick<Parameters<typeof setUniqueTypeName>[0], 'client' | 'nameTransformer'> &\n  Pick<Model, 'meta'> & {\n    onImport: OnImport;\n  }) => {\n  // generate imports only for top-level models\n  if (!meta) {\n    // TODO: this used to return undefined. We could refactor this function to\n    // return undefined again, but we will need to improve types so we can safely\n    // do `const { name } = generateImport({ meta: ... })` (note when meta is defined\n    // we guarantee the response to be an object). For now, nothing relies on this\n    // response shape except for plugins, so it was acceptable to patch it that way\n    return { created: false, name: '' };\n  }\n\n  const { created, name } = setUniqueTypeName({\n    meta,\n    ...setUniqueTypeNameArgs,\n  });\n  if (name) {\n    onImport(name);\n  }\n  return { created, name };\n};\n\nexport const modelResponseTransformerTypeName = (name: string) =>\n  `${name}ModelResponseTransformer`;\n\nexport const operationDataTypeName = (name: string) =>\n  `${stringCase({\n    case: 'PascalCase',\n    value: name,\n  })}Data`;\n\nexport const operationErrorTypeName = (name: string) =>\n  `${stringCase({\n    case: 'PascalCase',\n    value: name,\n  })}Error`;\n\n// operation response type ends with \"Response\", it's enough to append \"Transformer\"\nexport const operationResponseTransformerTypeName = (name: string) =>\n  `${name}Transformer`;\n\nexport const operationResponseTypeName = (name: string) =>\n  `${stringCase({\n    case: 'PascalCase',\n    value: name,\n  })}Response`;\n\n/**\n * @param importedType unique type name returned from `setUniqueTypeName()`\n * @returns options type\n */\nexport const operationOptionsLegacyParserType = ({\n  importedType,\n  throwOnError,\n}: {\n  importedType?: string | false;\n  throwOnError?: string;\n}) => {\n  const optionsName = 'OptionsLegacyParser';\n  // TODO: refactor this to be more generic, works for now\n  if (throwOnError) {\n    return `${optionsName}<${importedType || 'unknown'}, ${throwOnError}>`;\n  }\n  return importedType ? `${optionsName}<${importedType}>` : optionsName;\n};\n\nconst toOperationParamType = (\n  client: Client,\n  operation: Operation,\n): FunctionParameter[] => {\n  const config = getConfig();\n\n  const { name: importedType } = setUniqueTypeName({\n    client,\n    meta: {\n      // TODO: this should be exact ref to operation for consistency,\n      // but name should work too as operation ID is unique\n      $ref: operation.name,\n      name: operation.name,\n    },\n    nameTransformer: operationDataTypeName,\n  });\n\n  const isRequired = isOperationParameterRequired(operation.parameters);\n\n  if (!isLegacyClient(config)) {\n    return [\n      {\n        isRequired,\n        name: 'options',\n        type: operationOptionsLegacyParserType({\n          importedType,\n          throwOnError: 'ThrowOnError',\n        }),\n      },\n    ];\n  }\n\n  if (!operation.parameters.length) {\n    return [];\n  }\n\n  const getDefaultPrintable = (\n    p: OperationParameter | Model,\n  ): string | undefined => {\n    if (p.default === undefined) {\n      return;\n    }\n    return JSON.stringify(p.default, null, 4);\n  };\n\n  // legacy configuration\n  if (!config.useOptions) {\n    return operation.parameters.map((p) => {\n      const typePath = `${importedType}['${p.name}']`;\n      return {\n        default: p?.default,\n        isRequired:\n          (!p.isRequired && !getDefaultPrintable(p) ? '?' : '') === '',\n        name: p.name,\n        type: typePath,\n      };\n    });\n  }\n\n  return [\n    {\n      default: isRequired ? undefined : {},\n      name: 'data',\n      type: importedType,\n    },\n  ];\n};\n\nconst toOperationReturnType = (client: Client, operation: Operation) => {\n  const config = getConfig();\n\n  let returnType = tsc.typeNode('void');\n\n  const successResponses = operation.responses.filter((response) =>\n    response.responseTypes.includes('success'),\n  );\n\n  // TODO: we should return nothing when successes don't exist\n  // can't remove this logic without removing request/name config\n  // as it complicates things\n  if (successResponses.length) {\n    const { name: importedType } = setUniqueTypeName({\n      client,\n      meta: {\n        // TODO: this should be exact ref to operation for consistency,\n        // but name should work too as operation ID is unique\n        $ref: operation.name,\n        name: operation.name,\n      },\n      nameTransformer: operationResponseTypeName,\n    });\n    returnType = tsc.typeUnionNode({\n      types: [importedType],\n    });\n  }\n\n  if (\n    config.useOptions &&\n    config.plugins['@hey-api/sdk']?.config.response === 'response'\n  ) {\n    returnType = tsc.typeNode('ApiResult', [returnType]);\n  }\n\n  const clientPlugin = getClientPlugin(config);\n  if (clientPlugin.name === 'legacy/angular') {\n    returnType = tsc.typeNode('Observable', [returnType]);\n  } else {\n    returnType = tsc.typeNode('CancelablePromise', [returnType]);\n  }\n\n  return returnType;\n};\n\nconst toOperationComment = (operation: Operation): Comments => {\n  const config = getConfig();\n\n  if (!isLegacyClient(config)) {\n    const comment = [\n      operation.deprecated && '@deprecated',\n      operation.summary && escapeComment(operation.summary),\n      operation.description && escapeComment(operation.description),\n    ];\n    return comment;\n  }\n\n  let params: string[] = [];\n\n  if (operation.parameters.length) {\n    if (config.useOptions) {\n      params = [\n        '@param data The data for the request.',\n        ...operation.parameters.map(\n          (parameter) =>\n            `@param data.${parameter.name} ${parameter.description ? escapeComment(parameter.description) : ''}`,\n        ),\n      ];\n    } else {\n      params = operation.parameters.map(\n        (parameter) =>\n          `@param ${parameter.name} ${parameter.description ? escapeComment(parameter.description) : ''}`,\n      );\n    }\n  }\n\n  const successResponses = operation.responses.filter((response) =>\n    response.responseTypes.includes('success'),\n  );\n\n  const comment = [\n    operation.deprecated && '@deprecated',\n    operation.summary && escapeComment(operation.summary),\n    operation.description && escapeComment(operation.description),\n    ...params,\n    ...successResponses.map(\n      (response) =>\n        `@returns ${response.type} ${response.description ? escapeComment(response.description) : ''}`,\n    ),\n    '@throws ApiError',\n  ];\n  return comment;\n};\n\nconst toRequestOptions = ({\n  client,\n  onClientImport,\n  onImport,\n  operation,\n}: {\n  client: Client;\n  onClientImport: OnImport | undefined;\n  onImport: OnImport;\n  operation: Operation;\n}) => {\n  const config = getConfig();\n\n  const name = operationResponseTypeName(operation.name);\n  const { name: responseTransformerName } = setUniqueTypeName({\n    client,\n    meta: {\n      $ref: `transformers/${name}`,\n      name,\n    },\n    nameTransformer: operationResponseTransformerTypeName,\n  });\n\n  if (responseTransformerName) {\n    onImport(responseTransformerName);\n  }\n\n  if (!isLegacyClient(config)) {\n    let obj: ObjectValue[] = [\n      {\n        spread: 'options',\n      },\n    ];\n\n    const bodyParameters = operation.parameters.filter(\n      (parameter) => parameter.in === 'body' || parameter.in === 'formData',\n    );\n    const contents = bodyParameters\n      .map(\n        (parameter) =>\n          parameter.mediaType ||\n          (parameter.in === 'formData' ? 'multipart/form-data' : undefined),\n      )\n      .filter(Boolean)\n      .filter(unique);\n    if (contents.length === 1) {\n      if (contents[0] === 'multipart/form-data') {\n        obj = [\n          ...obj,\n          {\n            spread: 'formDataBodySerializer',\n          },\n          {\n            key: 'headers',\n            value: [\n              {\n                // no need for Content-Type header, browser will set it automatically\n                key: 'Content-Type',\n                value: null,\n              },\n              {\n                spread: 'options?.headers',\n              },\n            ],\n          },\n        ];\n        onClientImport?.('formDataBodySerializer');\n      }\n\n      if (contents[0] === 'application/x-www-form-urlencoded') {\n        obj = [\n          ...obj,\n          {\n            spread: 'urlSearchParamsBodySerializer',\n          },\n          {\n            key: 'headers',\n            value: [\n              {\n                key: 'Content-Type',\n                value: contents[0],\n              },\n              {\n                spread: 'options?.headers',\n              },\n            ],\n          },\n        ];\n        onClientImport?.('urlSearchParamsBodySerializer');\n      }\n    }\n\n    // TODO: set parseAs to skip inference if every result has the same\n    // content type. currently impossible because successes do not contain\n    // header information\n\n    obj = [\n      ...obj,\n      {\n        key: 'url',\n        value: operation.path,\n      },\n    ];\n\n    if (responseTransformerName) {\n      obj = [\n        ...obj,\n        {\n          key: 'responseTransformer',\n          value: responseTransformerName,\n        },\n      ];\n    }\n\n    return tsc.objectExpression({\n      identifiers: ['responseTransformer'],\n      obj,\n    });\n  }\n\n  const toObj = (parameters: OperationParameter[]) =>\n    parameters.reduce(\n      (prev, curr) => {\n        const key = curr.prop;\n        const value = config.useOptions ? `data.${curr.name}` : curr.name;\n        if (key === value) {\n          prev[key] = key;\n        } else if (escapeName(key) === key) {\n          prev[key] = value;\n        } else {\n          prev[`'${key}'`] = value;\n        }\n        return prev;\n      },\n      {} as Record<string, unknown>,\n    );\n\n  const obj: Record<string, any> = {\n    method: operation.method,\n    url: operation.path,\n  };\n\n  if (operation.parametersPath.length) {\n    obj.path = toObj(operation.parametersPath);\n  }\n\n  if (operation.parametersCookie.length) {\n    obj.cookies = toObj(operation.parametersCookie);\n  }\n\n  if (operation.parametersHeader.length) {\n    obj.headers = toObj(operation.parametersHeader);\n  }\n\n  if (operation.parametersQuery.length) {\n    obj.query = toObj(operation.parametersQuery);\n  }\n\n  if (operation.parametersForm.length) {\n    obj.formData = toObj(operation.parametersForm);\n  }\n\n  if (operation.parametersBody) {\n    if (operation.parametersBody.in === 'formData') {\n      if (config.useOptions) {\n        obj.formData = `data.${operation.parametersBody.name}`;\n      } else {\n        obj.formData = operation.parametersBody.name;\n      }\n    }\n    if (operation.parametersBody.in === 'body') {\n      if (config.useOptions) {\n        obj.body = `data.${operation.parametersBody.name}`;\n      } else {\n        obj.body = operation.parametersBody.name;\n      }\n    }\n  }\n\n  if (operation.parametersBody?.mediaType) {\n    obj.mediaType = operation.parametersBody?.mediaType;\n  }\n\n  if (operation.responseHeader) {\n    obj.responseHeader = operation.responseHeader;\n  }\n\n  if (responseTransformerName) {\n    obj.responseTransformer = responseTransformerName;\n  }\n\n  const errorResponses = operation.responses.filter((response) =>\n    response.responseTypes.includes('error'),\n  );\n  if (errorResponses.length > 0) {\n    const errors: Record<number | string, string> = {};\n    errorResponses.forEach((response) => {\n      errors[response.code] = response.description ?? '';\n    });\n    obj.errors = errors;\n  }\n\n  return tsc.objectExpression({\n    identifiers: [\n      'body',\n      'cookies',\n      'formData',\n      'headers',\n      'path',\n      'query',\n      'responseTransformer',\n    ],\n    obj,\n    shorthand: true,\n  });\n};\n\nexport const serviceFunctionIdentifier = ({\n  config,\n  handleIllegal,\n  id,\n  operation,\n}: {\n  config: ClientConfig;\n  handleIllegal?: boolean;\n  id: string;\n  operation: IR.OperationObject | Operation;\n}) => {\n  if (config.plugins['@hey-api/sdk']?.config.methodNameBuilder) {\n    return config.plugins['@hey-api/sdk'].config.methodNameBuilder(operation);\n  }\n\n  if (handleIllegal && id.match(reservedJavaScriptKeywordsRegExp)) {\n    return `${id}_`;\n  }\n\n  return id;\n};\n\nconst toOperationStatements = ({\n  client,\n  onClientImport,\n  onImport,\n  operation,\n}: {\n  client: Client;\n  onClientImport?: OnImport;\n  onImport: OnImport;\n  operation: Operation;\n}) => {\n  const config = getConfig();\n\n  const options = toRequestOptions({\n    client,\n    onClientImport,\n    onImport,\n    operation,\n  });\n\n  if (!isLegacyClient(config)) {\n    const errorType = setUniqueTypeName({\n      client,\n      meta: {\n        // TODO: this should be exact ref to operation for consistency,\n        // but name should work too as operation ID is unique\n        $ref: operation.name,\n        name: operation.name,\n      },\n      nameTransformer: operationErrorTypeName,\n    }).name;\n    const successResponses = operation.responses.filter((response) =>\n      response.responseTypes.includes('success'),\n    );\n    const responseType = successResponses.length\n      ? setUniqueTypeName({\n          client,\n          meta: {\n            // TODO: this should be exact ref to operation for consistency,\n            // but name should work too as operation ID is unique\n            $ref: operation.name,\n            name: operation.name,\n          },\n          nameTransformer: operationResponseTypeName,\n        }).name\n      : 'void';\n    return [\n      tsc.returnFunctionCall({\n        args: [options],\n        name: `(options?.client ?? client).${operation.method.toLocaleLowerCase()}`,\n        types:\n          errorType && responseType\n            ? [responseType, errorType, 'ThrowOnError']\n            : errorType\n              ? ['unknown', errorType, 'ThrowOnError']\n              : responseType\n                ? [responseType, 'unknown', 'ThrowOnError']\n                : [],\n      }),\n    ];\n  }\n\n  if (legacyNameFromConfig(config)) {\n    return [\n      tsc.returnFunctionCall({\n        args: [options],\n        name: 'this.httpRequest.request',\n      }),\n    ];\n  }\n\n  const clientPlugin = getClientPlugin(config);\n  if (clientPlugin.name === 'legacy/angular') {\n    return [\n      tsc.returnFunctionCall({\n        args: ['OpenAPI', 'this.http', options],\n        name: '__request',\n      }),\n    ];\n  }\n\n  return [\n    tsc.returnFunctionCall({\n      args: ['OpenAPI', options],\n      name: '__request',\n    }),\n  ];\n};\n\nconst processService = ({\n  client,\n  onClientImport,\n  onImport,\n  onNode,\n  service,\n}: {\n  client: Client;\n  onClientImport: OnImport;\n  onImport: OnImport;\n  onNode: OnNode;\n  service: Service;\n}) => {\n  const config = getConfig();\n\n  const clientPlugin = getClientPlugin(config);\n  const isLegacy = isLegacyClient(config);\n\n  for (const operation of service.operations) {\n    if (operation.parameters.length) {\n      generateImport({\n        client,\n        meta: {\n          // TODO: this should be exact ref to operation for consistency,\n          // but name should work too as operation ID is unique\n          $ref: operation.name,\n          name: operation.name,\n        },\n        nameTransformer: operationDataTypeName,\n        onImport,\n      });\n    }\n\n    if (!isLegacy) {\n      generateImport({\n        client,\n        meta: {\n          // TODO: this should be exact ref to operation for consistency,\n          // but name should work too as operation ID is unique\n          $ref: operation.name,\n          name: operation.name,\n        },\n        nameTransformer: operationErrorTypeName,\n        onImport,\n      });\n    }\n\n    const successResponses = operation.responses.filter((response) =>\n      response.responseTypes.includes('success'),\n    );\n    if (successResponses.length) {\n      generateImport({\n        client,\n        meta: {\n          // TODO: this should be exact ref to operation for consistency,\n          // but name should work too as operation ID is unique\n          $ref: operation.name,\n          name: operation.name,\n        },\n        nameTransformer: operationResponseTypeName,\n        onImport,\n      });\n    }\n  }\n\n  const throwOnErrorTypeGeneric: FunctionTypeParameter = {\n    default:\n      ('throwOnError' in clientPlugin.config\n        ? clientPlugin.config.throwOnError\n        : false) ?? false,\n    extends: 'boolean',\n    name: 'ThrowOnError',\n  };\n\n  if (\n    !config.plugins['@hey-api/sdk']?.config.asClass &&\n    !legacyNameFromConfig(config)\n  ) {\n    for (const operation of service.operations) {\n      const compileFunctionParams = {\n        parameters: toOperationParamType(client, operation),\n        returnType: !isLegacy\n          ? undefined\n          : toOperationReturnType(client, operation),\n        statements: toOperationStatements({\n          client,\n          onClientImport,\n          onImport,\n          operation,\n        }),\n        types: !isLegacy ? [throwOnErrorTypeGeneric] : undefined,\n      };\n      const expression =\n        clientPlugin.name === 'legacy/angular'\n          ? tsc.anonymousFunction(compileFunctionParams)\n          : tsc.arrowFunction(compileFunctionParams);\n      const statement = tsc.constVariable({\n        comment: toOperationComment(operation),\n        exportConst: true,\n        expression,\n        name: serviceFunctionIdentifier({\n          config,\n          handleIllegal: true,\n          id: operation.name,\n          operation,\n        }),\n      });\n      onNode(statement);\n    }\n    return;\n  }\n\n  let members: ts.ClassElement[] = service.operations.map((operation) => {\n    const node = tsc.methodDeclaration({\n      accessLevel: 'public',\n      comment: toOperationComment(operation),\n      isStatic:\n        legacyNameFromConfig(config) === undefined &&\n        clientPlugin.name !== 'legacy/angular',\n      name: serviceFunctionIdentifier({\n        config,\n        id: operation.name,\n        operation,\n      }),\n      parameters: toOperationParamType(client, operation),\n      returnType: !isLegacy\n        ? undefined\n        : toOperationReturnType(client, operation),\n      statements: toOperationStatements({\n        client,\n        onClientImport,\n        onImport,\n        operation,\n      }),\n      types: !isLegacy ? [throwOnErrorTypeGeneric] : undefined,\n    });\n    return node;\n  });\n\n  if (!members.length) {\n    return;\n  }\n\n  // Push constructor to front if needed\n  if (legacyNameFromConfig(config)) {\n    members = [\n      tsc.constructorDeclaration({\n        multiLine: false,\n        parameters: [\n          {\n            accessLevel: 'public',\n            isReadOnly: true,\n            name: 'httpRequest',\n            type: 'BaseHttpRequest',\n          },\n        ],\n      }),\n      ...members,\n    ];\n  } else if (clientPlugin.name === 'legacy/angular') {\n    members = [\n      tsc.constructorDeclaration({\n        multiLine: false,\n        parameters: [\n          {\n            accessLevel: 'public',\n            isReadOnly: true,\n            name: 'http',\n            type: 'HttpClient',\n          },\n        ],\n      }),\n      ...members,\n    ];\n  }\n\n  const _members: Array<ts.ClassElement> = [];\n  members.forEach((member, index) => {\n    // add newline between each class member\n    if (index) {\n      // @ts-expect-error\n      _members.push(tsc.identifier({ text: '\\n' }));\n    }\n\n    _members.push(member);\n  });\n\n  const statement = tsc.classDeclaration({\n    decorator:\n      clientPlugin.name === 'legacy/angular'\n        ? { args: [{ providedIn: 'root' }], name: 'Injectable' }\n        : undefined,\n    exportClass: true,\n    name: transformClassName({\n      config,\n      name: service.name,\n    }),\n    nodes: _members,\n  });\n  onNode(statement);\n};\n\nexport const handlerLegacy: HeyApiSdkPlugin['LegacyHandler'] = ({\n  client,\n  files,\n  plugin,\n}) => {\n  const config = getConfig();\n\n  const isLegacy = isLegacyClient(config);\n\n  const sdkOutput = 'sdk';\n\n  files.sdk = new GeneratedFile({\n    dir: config.output.path,\n    exportFromIndex: plugin.config.exportFromIndex,\n    id: 'sdk',\n    name: `${sdkOutput}.ts`,\n  });\n\n  // Import required packages and core files.\n  if (!isLegacy) {\n    files.sdk.import({\n      module: clientModulePath({ config, sourceOutput: sdkOutput }),\n      name: 'createClient',\n    });\n    files.sdk.import({\n      module: clientModulePath({ config, sourceOutput: sdkOutput }),\n      name: 'createConfig',\n    });\n    files.sdk.import({\n      asType: true,\n      module: clientModulePath({ config, sourceOutput: sdkOutput }),\n      name: 'OptionsLegacyParser',\n    });\n  } else {\n    const clientPlugin = getClientPlugin(config);\n    if (clientPlugin.name === 'legacy/angular') {\n      files.sdk.import({\n        module: '@angular/core',\n        name: 'Injectable',\n      });\n\n      if (!legacyNameFromConfig(config)) {\n        files.sdk.import({\n          module: '@angular/common/http',\n          name: 'HttpClient',\n        });\n      }\n\n      files.sdk.import({\n        asType: true,\n        module: 'rxjs',\n        name: 'Observable',\n      });\n    } else {\n      files.sdk.import({\n        asType: true,\n        module: './core/CancelablePromise',\n        name: 'CancelablePromise',\n      });\n    }\n\n    if (config.plugins['@hey-api/sdk']?.config.response === 'response') {\n      files.sdk.import({\n        asType: true,\n        module: './core/ApiResult',\n        name: 'ApiResult',\n      });\n    }\n\n    if (legacyNameFromConfig(config)) {\n      const clientPlugin = getClientPlugin(config);\n      files.sdk.import({\n        asType: clientPlugin.name !== 'legacy/angular',\n        module: './core/BaseHttpRequest',\n        name: 'BaseHttpRequest',\n      });\n    } else {\n      files.sdk.import({\n        module: './core/OpenAPI',\n        name: 'OpenAPI',\n      });\n      files.sdk.import({\n        alias: '__request',\n        module: './core/request',\n        name: 'request',\n      });\n    }\n  }\n\n  // define client first\n  if (!isLegacy) {\n    const clientPlugin = getClientPlugin(config);\n    const statement = tsc.constVariable({\n      exportConst: true,\n      expression: tsc.callExpression({\n        functionName: 'createClient',\n        parameters: [\n          tsc.callExpression({\n            functionName: 'createConfig',\n            parameters: [\n              'throwOnError' in clientPlugin && clientPlugin.throwOnError\n                ? tsc.objectExpression({\n                    obj: [\n                      {\n                        key: 'throwOnError',\n                        value: true,\n                      },\n                    ],\n                  })\n                : undefined,\n            ],\n          }),\n        ],\n      }),\n      name: 'client',\n    });\n    files.sdk.add(statement);\n  }\n\n  for (const service of client.services) {\n    processService({\n      client,\n      onClientImport: (imported) => {\n        files.sdk!.import({\n          module: clientModulePath({ config, sourceOutput: sdkOutput }),\n          name: imported,\n        });\n      },\n      onImport: (imported) => {\n        files.sdk!.import({\n          // this detection could be done safer, but it shouldn't cause any issues\n          asType: !imported.endsWith('Transformer'),\n          module: `./${files.types!.nameWithoutExtension()}`,\n          name: imported,\n        });\n      },\n      onNode: (node) => {\n        files.sdk!.add(node);\n      },\n      service,\n    });\n  }\n};\n","import { getClientPlugin } from '~/plugins/@hey-api/client-core/utils';\nimport {\n  createOperationComment,\n  isOperationOptionsRequired,\n} from '~/plugins/shared/utils/operation';\nimport { tsc } from '~/tsc';\n\nimport { serviceFunctionIdentifier } from '../plugin-legacy';\nimport type { HeyApiSdkPlugin } from '../types';\nimport { nuxtTypeComposable, nuxtTypeDefault } from './constants';\nimport { operationParameters, operationStatements } from './operation';\n\nexport const generateFlatSdk = ({\n  plugin,\n}: {\n  plugin: HeyApiSdkPlugin['Instance'];\n}): void => {\n  const client = getClientPlugin(plugin.context.config);\n  const isNuxtClient = client.name === '@hey-api/client-nuxt';\n\n  plugin.forEach(\n    'operation',\n    (event) => {\n      const { operation } = event;\n      const isRequiredOptions = isOperationOptionsRequired({\n        context: plugin.context,\n        operation,\n      });\n      const pluginTypeScript = plugin.getPluginOrThrow('@hey-api/typescript');\n      const symbolResponse = isNuxtClient\n        ? plugin.getSymbol(\n            pluginTypeScript.api.selector('response', operation.id),\n          )\n        : undefined;\n      const opParameters = operationParameters({\n        isRequiredOptions,\n        operation,\n        plugin,\n      });\n      const statements = operationStatements({\n        isRequiredOptions,\n        opParameters,\n        operation,\n        plugin,\n      });\n      const symbol = plugin.registerSymbol({\n        meta: {\n          path: event._path,\n          tags: event.tags,\n        },\n        name: serviceFunctionIdentifier({\n          config: plugin.context.config,\n          handleIllegal: true,\n          id: operation.id,\n          operation,\n        }),\n        selector: plugin.api.selector('function', operation.id),\n      });\n      const node = tsc.constVariable({\n        comment: createOperationComment({ operation }),\n        exportConst: true,\n        expression: tsc.arrowFunction({\n          parameters: opParameters.parameters,\n          returnType: undefined,\n          statements,\n          types: isNuxtClient\n            ? [\n                {\n                  default: tsc.ots.string('$fetch'),\n                  extends: tsc.typeNode(\n                    plugin.referenceSymbol(plugin.api.selector('Composable'))\n                      .placeholder,\n                  ),\n                  name: nuxtTypeComposable,\n                },\n                {\n                  default: symbolResponse\n                    ? tsc.typeReferenceNode({\n                        typeName: symbolResponse.placeholder,\n                      })\n                    : tsc.typeNode('undefined'),\n                  extends: symbolResponse\n                    ? tsc.typeReferenceNode({\n                        typeName: symbolResponse.placeholder,\n                      })\n                    : undefined,\n                  name: nuxtTypeDefault,\n                },\n              ]\n            : [\n                {\n                  default:\n                    ('throwOnError' in client.config\n                      ? client.config.throwOnError\n                      : false) ?? false,\n                  extends: 'boolean',\n                  name: 'ThrowOnError',\n                },\n              ],\n        }),\n        name: symbol.placeholder,\n      });\n      plugin.setSymbolValue(symbol, node);\n    },\n    {\n      order: 'declarations',\n    },\n  );\n};\n","import { clientFolderAbsolutePath } from '~/generate/client';\nimport { getClientPlugin } from '~/plugins/@hey-api/client-core/utils';\nimport { tsc } from '~/tsc';\n\nimport type { HeyApiSdkPlugin } from '../types';\nimport { nuxtTypeDefault, nuxtTypeResponse } from './constants';\n\nexport const createTypeOptions = ({\n  plugin,\n}: {\n  plugin: HeyApiSdkPlugin['Instance'];\n}) => {\n  const clientModule = clientFolderAbsolutePath(plugin.context.config);\n  const client = getClientPlugin(plugin.context.config);\n  const isNuxtClient = client.name === '@hey-api/client-nuxt';\n\n  const symbolTDataShape = plugin.registerSymbol({\n    external: clientModule,\n    meta: {\n      kind: 'type',\n      path: [],\n    },\n    name: 'TDataShape',\n  });\n  const symbolClient = plugin.registerSymbol({\n    external: clientModule,\n    meta: {\n      kind: 'type',\n      path: [],\n    },\n    name: 'Client',\n    selector: plugin.api.selector('Client'),\n  });\n  const symbolClientOptions = plugin.registerSymbol({\n    external: clientModule,\n    meta: {\n      kind: 'type',\n      path: [],\n    },\n    name: 'Options',\n  });\n  const symbolOptions = plugin.registerSymbol({\n    exported: true,\n    meta: {\n      kind: 'type',\n      path: [],\n    },\n    name: 'Options',\n    selector: plugin.api.selector('Options'),\n  });\n\n  const typeOptions = tsc.typeAliasDeclaration({\n    exportType: symbolOptions.exported,\n    name: symbolOptions.placeholder,\n    type: tsc.typeIntersectionNode({\n      types: [\n        tsc.typeReferenceNode({\n          typeArguments: isNuxtClient\n            ? [\n                tsc.typeReferenceNode({ typeName: 'TComposable' }),\n                tsc.typeReferenceNode({ typeName: 'TData' }),\n                tsc.typeReferenceNode({ typeName: nuxtTypeResponse }),\n                tsc.typeReferenceNode({ typeName: nuxtTypeDefault }),\n              ]\n            : [\n                tsc.typeReferenceNode({ typeName: 'TData' }),\n                tsc.typeReferenceNode({ typeName: 'ThrowOnError' }),\n              ],\n          typeName: symbolClientOptions.placeholder,\n        }),\n        tsc.typeInterfaceNode({\n          properties: [\n            {\n              comment: [\n                'You can provide a client instance returned by `createClient()` instead of',\n                'individual options. This might be also useful if you want to implement a',\n                'custom client.',\n              ],\n              isRequired: !plugin.config.client,\n              name: 'client',\n              type: tsc.typeReferenceNode({\n                typeName: symbolClient.placeholder,\n              }),\n            },\n            {\n              comment: [\n                'You can pass arbitrary values through the `meta` object. This can be',\n                \"used to access values that aren't defined as part of the SDK function.\",\n              ],\n              isRequired: false,\n              name: 'meta',\n              type: tsc.typeReferenceNode({\n                typeArguments: [\n                  tsc.keywordTypeNode({ keyword: 'string' }),\n                  tsc.keywordTypeNode({ keyword: 'unknown' }),\n                ],\n                typeName: 'Record',\n              }),\n            },\n          ],\n          useLegacyResolution: false,\n        }),\n      ],\n    }),\n    typeParameters: isNuxtClient\n      ? [\n          tsc.typeParameterDeclaration({\n            constraint: tsc.typeReferenceNode({\n              typeName: plugin.referenceSymbol(\n                plugin.api.selector('Composable'),\n              ).placeholder,\n            }),\n            defaultType: tsc.typeNode(\"'$fetch'\"),\n            name: 'TComposable',\n          }),\n          tsc.typeParameterDeclaration({\n            constraint: tsc.typeReferenceNode({\n              typeName: symbolTDataShape.placeholder,\n            }),\n            defaultType: tsc.typeReferenceNode({\n              typeName: symbolTDataShape.placeholder,\n            }),\n            name: 'TData',\n          }),\n          tsc.typeParameterDeclaration({\n            defaultType: tsc.keywordTypeNode({ keyword: 'unknown' }),\n            name: nuxtTypeResponse,\n          }),\n          tsc.typeParameterDeclaration({\n            defaultType: tsc.keywordTypeNode({ keyword: 'undefined' }),\n            name: nuxtTypeDefault,\n          }),\n        ]\n      : [\n          tsc.typeParameterDeclaration({\n            constraint: tsc.typeReferenceNode({\n              typeName: symbolTDataShape.placeholder,\n            }),\n            defaultType: tsc.typeReferenceNode({\n              typeName: symbolTDataShape.placeholder,\n            }),\n            name: 'TData',\n          }),\n          tsc.typeParameterDeclaration({\n            constraint: tsc.keywordTypeNode({ keyword: 'boolean' }),\n            defaultType: tsc.keywordTypeNode({ keyword: 'boolean' }),\n            name: 'ThrowOnError',\n          }),\n        ],\n  });\n  plugin.setSymbolValue(symbolOptions, typeOptions);\n};\n","import { clientFolderAbsolutePath } from '~/generate/client';\nimport { getClientPlugin } from '~/plugins/@hey-api/client-core/utils';\n\nimport { generateClassSdk } from '../shared/class';\nimport { generateFlatSdk } from '../shared/functions';\nimport { createTypeOptions } from '../shared/typeOptions';\nimport type { HeyApiSdkPlugin } from '../types';\n\nexport const handlerV1: HeyApiSdkPlugin['Handler'] = ({ plugin }) => {\n  const clientModule = clientFolderAbsolutePath(plugin.context.config);\n  plugin.registerSymbol({\n    external: clientModule,\n    name: 'formDataBodySerializer',\n    selector: plugin.api.selector('formDataBodySerializer'),\n  });\n  plugin.registerSymbol({\n    external: clientModule,\n    name: 'urlSearchParamsBodySerializer',\n    selector: plugin.api.selector('urlSearchParamsBodySerializer'),\n  });\n  plugin.registerSymbol({\n    external: clientModule,\n    name: 'buildClientParams',\n    selector: plugin.api.selector('buildClientParams'),\n  });\n\n  const client = getClientPlugin(plugin.context.config);\n  const isAngularClient = client.name === '@hey-api/client-angular';\n  const isNuxtClient = client.name === '@hey-api/client-nuxt';\n  if (isNuxtClient) {\n    plugin.registerSymbol({\n      external: clientModule,\n      meta: {\n        kind: 'type',\n      },\n      name: 'Composable',\n      selector: plugin.api.selector('Composable'),\n    });\n  }\n\n  if (isAngularClient && plugin.config.asClass) {\n    plugin.registerSymbol({\n      external: '@angular/core',\n      name: 'Injectable',\n      selector: plugin.api.selector('Injectable'),\n    });\n  }\n\n  createTypeOptions({ plugin });\n\n  if (plugin.config.asClass) {\n    generateClassSdk({ plugin });\n  } else {\n    generateFlatSdk({ plugin });\n  }\n};\n","import type { HeyApiSdkPlugin } from './types';\nimport { handlerV1 } from './v1/plugin';\n\nexport const handler: HeyApiSdkPlugin['Handler'] = (args) => handlerV1(args);\n","import { definePluginConfig } from '~/plugins/shared/utils/config';\n\nimport { Api } from './api';\nimport { handler } from './plugin';\nimport { handlerLegacy } from './plugin-legacy';\nimport type { HeyApiSdkPlugin } from './types';\n\nexport const defaultConfig: HeyApiSdkPlugin['Config'] = {\n  api: new Api({\n    name: '@hey-api/sdk',\n  }),\n  config: {\n    asClass: false,\n    auth: true,\n    classNameBuilder: '{{name}}',\n    classStructure: 'auto',\n    client: true,\n    exportFromIndex: true,\n    instance: false,\n    operationId: true,\n    params_EXPERIMENTAL: 'default',\n    response: 'body',\n    responseStyle: 'fields',\n    transformer: false,\n    validator: false,\n  },\n  dependencies: ['@hey-api/typescript'],\n  handler,\n  handlerLegacy,\n  name: '@hey-api/sdk',\n  resolveConfig: (plugin, context) => {\n    if (plugin.config.client) {\n      if (typeof plugin.config.client === 'boolean') {\n        plugin.config.client = context.pluginByTag('client', {\n          defaultPlugin: '@hey-api/client-fetch',\n        });\n      }\n\n      plugin.dependencies.add(plugin.config.client!);\n    } else {\n      plugin.config.client = false;\n    }\n\n    if (plugin.config.transformer) {\n      if (typeof plugin.config.transformer === 'boolean') {\n        plugin.config.transformer = context.pluginByTag('transformer');\n      }\n\n      plugin.dependencies.add(plugin.config.transformer!);\n    } else {\n      plugin.config.transformer = false;\n    }\n\n    if (typeof plugin.config.validator !== 'object') {\n      plugin.config.validator = {\n        request: plugin.config.validator,\n        response: plugin.config.validator,\n      };\n    }\n\n    if (plugin.config.validator.request) {\n      if (typeof plugin.config.validator.request === 'boolean') {\n        plugin.config.validator.request = context.pluginByTag('validator');\n      }\n\n      plugin.dependencies.add(plugin.config.validator.request!);\n    } else {\n      plugin.config.validator.request = false;\n    }\n\n    if (plugin.config.validator.response) {\n      if (typeof plugin.config.validator.response === 'boolean') {\n        plugin.config.validator.response = context.pluginByTag('validator');\n      }\n\n      plugin.dependencies.add(plugin.config.validator.response!);\n    } else {\n      plugin.config.validator.response = false;\n    }\n\n    if (plugin.config.instance) {\n      if (typeof plugin.config.instance !== 'string') {\n        plugin.config.instance = 'Sdk';\n      }\n\n      plugin.config.asClass = true;\n    } else {\n      plugin.config.instance = false;\n    }\n\n    // Set default classNameBuilder based on client type\n    if (plugin.config.classNameBuilder === '{{name}}') {\n      if (plugin.config.client === '@hey-api/client-angular') {\n        plugin.config.classNameBuilder = '{{name}}Service';\n      }\n    }\n  },\n};\n\n/**\n * Type helper for `@hey-api/sdk` plugin, returns {@link Plugin.Config} object\n */\nexport const defineConfig = definePluginConfig(defaultConfig);\n","import type { Selector } from '@hey-api/codegen-core';\n\nimport type { Plugin } from '~/plugins';\n\ntype SelectorType = 'response' | 'response-ref';\n\nexport type IApi = {\n  /**\n   * @param type Selector type.\n   * @param value Depends on `type`:\n   *  - `response`: `operation.id` string\n   *  - `response-ref`: `$ref` JSON pointer\n   * @returns Selector array\n   */\n  selector: (type: SelectorType, value?: string) => Selector;\n};\n\nexport class Api implements IApi {\n  constructor(public meta: Plugin.Name<'@hey-api/transformers'>) {}\n\n  selector(...args: ReadonlyArray<string | undefined>): Selector {\n    return [this.meta.name, ...(args as Selector)];\n  }\n}\n","import type ts from 'typescript';\n\nimport type { IR } from '~/ir/types';\nimport { tsc } from '~/tsc';\n\nimport type { UserConfig } from './types';\n\nexport type ExpressionTransformer = ({\n  config,\n  dataExpression,\n  schema,\n}: {\n  config: Omit<UserConfig, 'name'>;\n  dataExpression?: ts.Expression | string;\n  schema: IR.SchemaObject;\n}) => Array<ts.Expression> | undefined;\n\nexport const bigIntExpressions: ExpressionTransformer = ({\n  dataExpression,\n  schema,\n}) => {\n  if (schema.type !== 'integer' || schema.format !== 'int64') {\n    return;\n  }\n\n  const bigIntCallExpression =\n    dataExpression !== undefined\n      ? tsc.callExpression({\n          functionName: 'BigInt',\n          parameters: [\n            tsc.callExpression({\n              functionName: tsc.propertyAccessExpression({\n                expression: dataExpression,\n                name: 'toString',\n              }),\n            }),\n          ],\n        })\n      : undefined;\n\n  if (bigIntCallExpression) {\n    if (typeof dataExpression === 'string') {\n      return [bigIntCallExpression];\n    }\n\n    if (dataExpression) {\n      return [\n        tsc.assignment({\n          left: dataExpression,\n          right: bigIntCallExpression,\n        }),\n      ];\n    }\n  }\n\n  return;\n};\n\nexport const dateExpressions: ExpressionTransformer = ({\n  dataExpression,\n  schema,\n}) => {\n  if (\n    schema.type !== 'string' ||\n    !(schema.format === 'date' || schema.format === 'date-time')\n  ) {\n    return;\n  }\n\n  const identifierDate = tsc.identifier({ text: 'Date' });\n\n  if (typeof dataExpression === 'string') {\n    return [\n      tsc.newExpression({\n        argumentsArray: [tsc.identifier({ text: dataExpression })],\n        expression: identifierDate,\n      }),\n    ];\n  }\n\n  if (dataExpression) {\n    return [\n      tsc.assignment({\n        left: dataExpression,\n        right: tsc.newExpression({\n          argumentsArray: [dataExpression],\n          expression: identifierDate,\n        }),\n      }),\n    ];\n  }\n\n  return;\n};\n","import ts from 'typescript';\n\nimport { createOperationKey, operationResponsesMap } from '~/ir/operation';\nimport type { IR } from '~/ir/types';\nimport { buildName } from '~/openApi/shared/utils/name';\nimport { tsc } from '~/tsc';\nimport { refToName } from '~/utils/ref';\n\nimport type { HeyApiTransformersPlugin } from './types';\n\nconst dataVariableName = 'data';\n\nconst ensureStatements = (\n  nodes: Array<ts.Expression | ts.Statement>,\n): Array<ts.Statement> =>\n  nodes.map((node) =>\n    ts.isStatement(node)\n      ? node\n      : tsc.expressionToStatement({ expression: node }),\n  );\n\nconst isNodeReturnStatement = ({\n  node,\n}: {\n  node: ts.Expression | ts.Statement;\n}) => node.kind === ts.SyntaxKind.ReturnStatement;\n\nconst schemaResponseTransformerNodes = ({\n  plugin,\n  schema,\n}: {\n  plugin: HeyApiTransformersPlugin['Instance'];\n  schema: IR.SchemaObject;\n}): Array<ts.Expression | ts.Statement> => {\n  const identifierData = tsc.identifier({ text: dataVariableName });\n  const nodes = processSchemaType({\n    dataExpression: identifierData,\n    plugin,\n    schema,\n  });\n  // append return statement if one does not already exist\n  if (\n    nodes.length &&\n    !isNodeReturnStatement({ node: nodes[nodes.length - 1]! })\n  ) {\n    nodes.push(tsc.returnStatement({ expression: identifierData }));\n  }\n  return nodes;\n};\n\nconst processSchemaType = ({\n  dataExpression,\n  plugin,\n  schema,\n}: {\n  dataExpression?: ts.Expression | string;\n  plugin: HeyApiTransformersPlugin['Instance'];\n  schema: IR.SchemaObject;\n}): Array<ts.Expression | ts.Statement> => {\n  if (schema.$ref) {\n    const selector = plugin.api.selector('response-ref', schema.$ref);\n\n    if (!plugin.getSymbol(selector)) {\n      // TODO: remove\n      // create each schema response transformer only once\n\n      // Register symbol early to prevent infinite recursion with self-referential schemas\n      const symbol = plugin.registerSymbol({\n        name: buildName({\n          config: {\n            case: 'camelCase',\n            name: '{{name}}SchemaResponseTransformer',\n          },\n          name: refToName(schema.$ref),\n        }),\n        selector,\n      });\n\n      const refSchema = plugin.context.resolveIrRef<IR.SchemaObject>(\n        schema.$ref,\n      );\n      const nodes = schemaResponseTransformerNodes({\n        plugin,\n        schema: refSchema,\n      });\n      if (nodes.length) {\n        const node = tsc.constVariable({\n          expression: tsc.arrowFunction({\n            async: false,\n            multiLine: true,\n            parameters: [\n              {\n                name: dataVariableName,\n                // TODO: parser - add types, generate types without transforms\n                type: tsc.keywordTypeNode({ keyword: 'any' }),\n              },\n            ],\n            statements: ensureStatements(nodes),\n          }),\n          name: symbol.placeholder,\n        });\n        plugin.setSymbolValue(symbol, node);\n      }\n    }\n\n    if (plugin.isSymbolRegistered(selector)) {\n      const ref = plugin.referenceSymbol(selector);\n      const callExpression = tsc.callExpression({\n        functionName: ref.placeholder,\n        parameters: [dataExpression],\n      });\n\n      if (dataExpression) {\n        // In a map callback, the item needs to be returned, not just the transformation result\n        if (typeof dataExpression === 'string' && dataExpression === 'item') {\n          return [\n            tsc.returnStatement({\n              expression: callExpression,\n            }),\n          ];\n        }\n\n        return [\n          typeof dataExpression === 'string'\n            ? callExpression\n            : tsc.assignment({\n                left: dataExpression,\n                right: callExpression,\n              }),\n        ];\n      }\n    }\n\n    return [];\n  }\n\n  if (schema.type === 'array') {\n    if (!dataExpression || typeof dataExpression === 'string') {\n      return [];\n    }\n\n    // TODO: parser - handle tuples and complex arrays\n    const nodes = !schema.items\n      ? []\n      : processSchemaType({\n          dataExpression: 'item',\n          plugin,\n          schema: schema.items?.[0]\n            ? schema.items[0]\n            : {\n                ...schema,\n                type: undefined,\n              },\n        });\n\n    if (!nodes.length) {\n      return [];\n    }\n\n    // Ensure the map callback has a return statement for the item\n    const mapCallbackStatements = ensureStatements(nodes);\n    const hasReturnStatement = mapCallbackStatements.some((stmt) =>\n      isNodeReturnStatement({ node: stmt }),\n    );\n\n    if (!hasReturnStatement) {\n      mapCallbackStatements.push(\n        tsc.returnStatement({\n          expression: tsc.identifier({ text: 'item' }),\n        }),\n      );\n    }\n\n    return [\n      tsc.assignment({\n        left: dataExpression,\n        right: tsc.callExpression({\n          functionName: tsc.propertyAccessExpression({\n            expression: dataExpression,\n            name: 'map',\n          }),\n          parameters: [\n            tsc.arrowFunction({\n              multiLine: true,\n              parameters: [\n                {\n                  name: 'item',\n                  type: 'any',\n                },\n              ],\n              statements: mapCallbackStatements,\n            }),\n          ],\n        }),\n      }),\n    ];\n  }\n\n  if (schema.type === 'object') {\n    let nodes: Array<ts.Expression | ts.Statement> = [];\n    const required = schema.required ?? [];\n\n    for (const name in schema.properties) {\n      const property = schema.properties[name]!;\n      const propertyAccessExpression = tsc.propertyAccessExpression({\n        expression: dataExpression || dataVariableName,\n        name,\n      });\n      const propertyNodes = processSchemaType({\n        dataExpression: propertyAccessExpression,\n        plugin,\n        schema: property,\n      });\n      if (!propertyNodes.length) {\n        continue;\n      }\n      const noNullableTypesInSchema = !property.items?.find(\n        (x) => x.type === 'null',\n      );\n      const requiredField = required.includes(name);\n      // Cannot fully rely on required fields\n      // Such value has to be present, but it doesn't guarantee that this value is not nullish\n      if (requiredField && noNullableTypesInSchema) {\n        nodes = nodes.concat(propertyNodes);\n      } else {\n        nodes.push(\n          // todo: Probably, it would make more sense to go with if(x !== undefined && x !== null) instead of if(x)\n          // this place influences all underlying transformers, while it's not exactly transformer itself\n          // Keep in mind that !!0 === false, so it already makes output for Bigint undesirable\n          tsc.ifStatement({\n            expression: propertyAccessExpression,\n            thenStatement: tsc.block({\n              statements: ensureStatements(propertyNodes),\n            }),\n          }),\n        );\n      }\n    }\n\n    return nodes;\n  }\n\n  if (schema.items) {\n    if (schema.items.length === 1) {\n      return processSchemaType({\n        dataExpression: 'item',\n        plugin,\n        schema: schema.items[0]!,\n      });\n    }\n\n    let arrayNodes: Array<ts.Expression | ts.Statement> = [];\n    // process 2 items if one of them is null\n    if (\n      schema.logicalOperator === 'and' ||\n      (schema.items.length === 2 &&\n        schema.items.find(\n          (item) => item.type === 'null' || item.type === 'void',\n        ))\n    ) {\n      for (const item of schema.items) {\n        const nodes = processSchemaType({\n          dataExpression: dataExpression || 'item',\n          plugin,\n          schema: item,\n        });\n        if (nodes.length) {\n          if (dataExpression) {\n            arrayNodes = arrayNodes.concat(nodes);\n          } else {\n            const identifierItem = tsc.identifier({ text: 'item' });\n            // processed means the item was transformed\n            arrayNodes.push(\n              tsc.ifStatement({\n                expression: identifierItem,\n                thenStatement: tsc.block({\n                  statements: ensureStatements(nodes),\n                }),\n              }),\n              tsc.returnStatement({ expression: identifierItem }),\n            );\n          }\n        }\n      }\n      return arrayNodes;\n    }\n\n    // assume enums do not contain transformable values\n    if (schema.type !== 'enum') {\n      if (\n        !(schema.items ?? []).every((item) =>\n          (\n            ['boolean', 'integer', 'null', 'number', 'string'] as ReadonlyArray<\n              typeof item.type\n            >\n          ).includes(item.type),\n        )\n      ) {\n        console.warn(\n          ` Transformers warning: schema ${JSON.stringify(schema)} is too complex and won't be currently processed. This will likely produce an incomplete transformer which is not what you want. Please open an issue if you'd like this improved https://github.com/hey-api/openapi-ts/issues`,\n        );\n      }\n    }\n  }\n\n  for (const transformer of plugin.config.transformers) {\n    const t = transformer({\n      config: plugin.config,\n      dataExpression,\n      schema,\n    });\n    if (t) {\n      return t;\n    }\n  }\n\n  return [];\n};\n\n// handles only response transformers for now\nexport const handler: HeyApiTransformersPlugin['Handler'] = ({ plugin }) => {\n  plugin.forEach(\n    'operation',\n    ({ operation }) => {\n      const { response } = operationResponsesMap(operation);\n      if (!response) return;\n\n      if (response.items && response.items.length > 1) {\n        if (plugin.context.config.logs.level === 'debug') {\n          console.warn(\n            ` Transformers warning: route ${createOperationKey(operation)} has ${response.items.length} non-void success responses. This is currently not handled and we will not generate a response transformer. Please open an issue if you'd like this feature https://github.com/hey-api/openapi-ts/issues`,\n          );\n        }\n        return;\n      }\n\n      const pluginTypeScript = plugin.getPluginOrThrow('@hey-api/typescript');\n      const symbolResponse = plugin.getSymbol(\n        pluginTypeScript.api.selector('response', operation.id),\n      );\n      if (!symbolResponse) return;\n\n      // TODO: parser - consider handling simple string response which is also a date\n      const nodes = schemaResponseTransformerNodes({\n        plugin,\n        schema: response,\n      });\n      if (!nodes.length) return;\n      const symbol = plugin.registerSymbol({\n        exported: true,\n        name: buildName({\n          config: {\n            case: 'camelCase',\n            name: '{{name}}ResponseTransformer',\n          },\n          name: operation.id,\n        }),\n        selector: plugin.api.selector('response', operation.id),\n      });\n      const value = tsc.constVariable({\n        exportConst: symbol.exported,\n        expression: tsc.arrowFunction({\n          async: true,\n          multiLine: true,\n          parameters: [\n            {\n              name: dataVariableName,\n              // TODO: parser - add types, generate types without transforms\n              type: tsc.keywordTypeNode({ keyword: 'any' }),\n            },\n          ],\n          returnType: tsc.typeReferenceNode({\n            typeArguments: [\n              tsc.typeReferenceNode({ typeName: symbolResponse.placeholder }),\n            ],\n            typeName: 'Promise',\n          }),\n          statements: ensureStatements(nodes),\n        }),\n        name: symbol.placeholder,\n      });\n      plugin.setSymbolValue(symbol, value);\n    },\n    {\n      order: 'declarations',\n    },\n  );\n};\n","import type ts from 'typescript';\n\nimport { GeneratedFile } from '~/generate/file';\nimport { isOperationParameterRequired } from '~/openApi';\nimport {\n  operationDataTypeName,\n  operationErrorTypeName,\n  operationResponseTypeName,\n} from '~/plugins/@hey-api/sdk/plugin-legacy';\nimport { type Comments, tsc } from '~/tsc';\nimport type { Client, Method, Model, OperationParameter } from '~/types/client';\nimport { getConfig, isLegacyClient } from '~/utils/config';\nimport { enumEntry, enumUnionType } from '~/utils/enum';\nimport { escapeComment } from '~/utils/escape';\nimport { sortByName, sorterByName } from '~/utils/sort';\nimport {\n  setUniqueTypeName,\n  type SetUniqueTypeNameResult,\n  toType,\n} from '~/utils/type';\n\nimport type { HeyApiTypeScriptPlugin } from './types';\n\nexport interface TypesProps {\n  client: Client;\n  model: Model;\n  onNode: (node: ts.Node) => void;\n  onRemoveNode?: VoidFunction;\n}\n\nconst treeName = '$OpenApiTs';\n\nexport const emptyModel: Model = {\n  $refs: [],\n  base: '',\n  description: null,\n  enum: [],\n  enums: [],\n  export: 'interface',\n  imports: [],\n  in: '',\n  isDefinition: false,\n  isNullable: false,\n  isReadOnly: false,\n  isRequired: false,\n  link: null,\n  name: '',\n  properties: [],\n  template: null,\n  type: '',\n};\n\nconst generateEnum = ({\n  comments,\n  leadingComment,\n  meta,\n  obj,\n  onNode,\n  ...setUniqueTypeNameArgs\n}: Omit<Parameters<typeof tsc.enumDeclaration>[0], 'name'> &\n  Pick<Parameters<typeof setUniqueTypeName>[0], 'client' | 'nameTransformer'> &\n  Pick<Model, 'meta'> &\n  Pick<TypesProps, 'onNode'>) => {\n  // generate types only for top-level models\n  if (!meta) {\n    return;\n  }\n\n  const { created, name } = setUniqueTypeName({\n    create: true,\n    meta,\n    ...setUniqueTypeNameArgs,\n  });\n  if (created) {\n    const config = getConfig();\n    const pluginTypeScript = config.plugins['@hey-api/typescript'];\n    const node = tsc.enumDeclaration({\n      asConst:\n        typeof pluginTypeScript?.config.enums === 'object' &&\n        pluginTypeScript.config.enums.mode === 'typescript-const',\n      comments,\n      leadingComment,\n      name,\n      obj,\n    });\n    onNode(node);\n  }\n};\n\nexport const generateType = ({\n  comment,\n  meta,\n  onCreated,\n  onNode,\n  type,\n  ...setUniqueTypeNameArgs\n}: Omit<Parameters<typeof tsc.typeAliasDeclaration>[0], 'name'> &\n  Pick<Parameters<typeof setUniqueTypeName>[0], 'client' | 'nameTransformer'> &\n  Pick<Model, 'meta'> &\n  Pick<TypesProps, 'onNode'> & {\n    onCreated?: (name: string) => void;\n  }): SetUniqueTypeNameResult => {\n  // generate types only for top-level models\n  if (!meta) {\n    return {\n      created: false,\n      name: '',\n    };\n  }\n\n  const result = setUniqueTypeName({\n    create: true,\n    meta,\n    ...setUniqueTypeNameArgs,\n  });\n  const { created, name } = result;\n  if (created) {\n    const node = tsc.typeAliasDeclaration({\n      comment,\n      exportType: true,\n      name,\n      type,\n    });\n    onNode(node);\n\n    onCreated?.(name);\n  }\n  return result;\n};\n\nconst processComposition = (props: TypesProps) => {\n  const enumDeclarations = [] as ts.EnumDeclaration[];\n\n  processType(props);\n\n  props.model.enums.forEach((enumerator) =>\n    processScopedEnum({\n      ...props,\n      model: enumerator,\n      onNode: (node) => {\n        enumDeclarations.push(node as ts.EnumDeclaration);\n      },\n    }),\n  );\n\n  if (enumDeclarations.length) {\n    props.onNode(\n      tsc.namespaceDeclaration({\n        name: props.model.name,\n        statements: enumDeclarations,\n      }),\n    );\n  }\n};\n\nconst processEnum = ({ client, model, onNode }: TypesProps) => {\n  const config = getConfig();\n\n  const properties: Record<string | number, unknown> = {};\n  const comments: Record<string | number, Comments> = {};\n  model.enum.forEach((enumerator) => {\n    const { key, value } = enumEntry(enumerator);\n    properties[key] = value;\n    const comment = enumerator.customDescription || enumerator.description;\n    if (comment) {\n      comments[key] = [escapeComment(comment)];\n    }\n  });\n\n  const comment = [\n    model.description && escapeComment(model.description),\n    model.deprecated && '@deprecated',\n  ];\n\n  const pluginTypeScript = config.plugins['@hey-api/typescript'];\n  if (\n    pluginTypeScript?.config &&\n    typeof pluginTypeScript.config.enums === 'object' &&\n    pluginTypeScript.config.enums.enabled &&\n    (pluginTypeScript.config.enums.mode === 'typescript' ||\n      pluginTypeScript.config.enums.mode === 'typescript-const')\n  ) {\n    generateEnum({\n      asConst: pluginTypeScript.config.enums.mode === 'typescript-const',\n      client,\n      comments,\n      leadingComment: comment,\n      meta: model.meta,\n      obj: properties,\n      onNode,\n    });\n    return;\n  }\n\n  generateType({\n    client,\n    comment,\n    meta: model.meta,\n    onCreated: (name) => {\n      // create a separate JavaScript object export\n      const pluginTypeScript = config.plugins['@hey-api/typescript'];\n      if (\n        pluginTypeScript?.config &&\n        typeof pluginTypeScript.config.enums === 'object' &&\n        pluginTypeScript.config.enums.enabled &&\n        pluginTypeScript.config.enums.mode === 'javascript'\n      ) {\n        const expression = tsc.objectExpression({\n          multiLine: true,\n          obj: Object.entries(properties).map(([key, value]) => ({\n            comments: comments[key],\n            key,\n            value,\n          })),\n          unescape: true,\n        });\n        const node = tsc.constVariable({\n          assertion: 'const',\n          comment,\n          exportConst: true,\n          expression,\n          name,\n        });\n        onNode(node);\n      }\n    },\n    onNode,\n    type: enumUnionType(model.enum),\n  });\n};\n\nconst processScopedEnum = ({ model, onNode }: TypesProps) => {\n  const properties: Record<string | number, unknown> = {};\n  const comments: Record<string | number, Comments> = {};\n  model.enum.forEach((enumerator) => {\n    const { key, value } = enumEntry(enumerator);\n    properties[key] = value;\n    const comment = enumerator.customDescription || enumerator.description;\n    if (comment) {\n      comments[key] = [escapeComment(comment)];\n    }\n  });\n  const config = getConfig();\n  const pluginTypeScript = config.plugins['@hey-api/typescript'];\n  onNode(\n    tsc.enumDeclaration({\n      asConst:\n        typeof pluginTypeScript?.config.enums === 'object' &&\n        pluginTypeScript.config.enums.mode === 'typescript-const',\n      comments,\n      leadingComment: [\n        model.description && escapeComment(model.description),\n        model.deprecated && '@deprecated',\n      ],\n      name: model.meta?.name || model.name,\n      obj: properties,\n    }),\n  );\n};\n\nconst processType = ({ client, model, onNode }: TypesProps) => {\n  generateType({\n    client,\n    comment: [\n      model.description && escapeComment(model.description),\n      model.deprecated && '@deprecated',\n    ],\n    meta: model.meta,\n    onNode,\n    type: toType(model),\n  });\n};\n\nconst processModel = (props: TypesProps) => {\n  switch (props.model.export) {\n    case 'all-of':\n    case 'any-of':\n    case 'one-of':\n    case 'interface':\n      return processComposition(props);\n    case 'enum':\n      return processEnum(props);\n    default:\n      return processType(props);\n  }\n};\n\ninterface MethodMap {\n  $ref?: string;\n  req?: OperationParameter[];\n  res?: Record<number | string, Model>;\n}\n\ntype PathMap = {\n  [method in Method]?: MethodMap;\n};\n\ntype PathsMap = Record<string, PathMap>;\n\nconst processServiceTypes = ({\n  client,\n  onNode,\n}: Pick<TypesProps, 'client' | 'onNode'>) => {\n  const pathsMap: PathsMap = {};\n\n  const config = getConfig();\n\n  if (\n    !config.plugins['@hey-api/sdk'] &&\n    !config.plugins['@hey-api/typescript']?.config.tree\n  ) {\n    return;\n  }\n\n  const isLegacy = isLegacyClient(config);\n\n  for (const service of client.services) {\n    for (const operation of service.operations) {\n      if (!operation.parameters.length && !operation.responses.length) {\n        continue;\n      }\n\n      if (!pathsMap[operation.path]) {\n        pathsMap[operation.path] = {};\n      }\n      const pathMap = pathsMap[operation.path]!;\n\n      if (!pathMap[operation.method]) {\n        pathMap[operation.method] = {};\n      }\n      const methodMap = pathMap[operation.method]!;\n      methodMap.$ref = operation.name;\n\n      if (operation.responses.length > 0) {\n        if (!methodMap.res) {\n          methodMap.res = {};\n        }\n\n        if (Array.isArray(methodMap.res)) {\n          continue;\n        }\n\n        operation.responses.forEach((response) => {\n          methodMap.res![response.code] = response;\n        });\n      }\n\n      if (operation.parameters.length > 0) {\n        let bodyParameters: OperationParameter = {\n          mediaType: null,\n          ...emptyModel,\n          in: 'body',\n          name: 'body',\n          prop: 'body',\n        };\n        let bodyParameter = operation.parameters.filter(\n          (parameter) => parameter.in === 'body',\n        );\n        if (!bodyParameter.length) {\n          bodyParameter = operation.parameters.filter(\n            (parameter) => parameter.in === 'formData',\n          );\n        }\n\n        if (bodyParameter.length === 1) {\n          bodyParameters = {\n            ...emptyModel,\n            ...bodyParameter[0]!,\n            in: 'body',\n            isRequired: bodyParameter[0]!.isRequired,\n            name: 'body',\n            prop: 'body',\n          };\n          // assume we have multiple formData parameters from Swagger 2.0\n        } else if (bodyParameter.length > 1) {\n          bodyParameters = {\n            ...emptyModel,\n            in: 'body',\n            isRequired: bodyParameter.some((parameter) => parameter.isRequired),\n            mediaType: 'multipart/form-data',\n            name: 'body',\n            prop: 'body',\n            properties: bodyParameter,\n          };\n        }\n\n        const headerParameters: OperationParameter = {\n          ...emptyModel,\n          in: 'header',\n          isRequired: isOperationParameterRequired(\n            operation.parameters.filter(\n              (parameter) => parameter.in === 'header',\n            ),\n          ),\n          mediaType: null,\n          name: isLegacy ? 'header' : 'headers',\n          prop: isLegacy ? 'header' : 'headers',\n          properties: operation.parameters\n            .filter((parameter) => parameter.in === 'header')\n            .sort(sorterByName),\n        };\n        const pathParameters: OperationParameter = {\n          ...emptyModel,\n          in: 'path',\n          isRequired: isOperationParameterRequired(\n            operation.parameters.filter((parameter) => parameter.in === 'path'),\n          ),\n          mediaType: null,\n          name: 'path',\n          prop: 'path',\n          properties: operation.parameters\n            .filter((parameter) => parameter.in === 'path')\n            .sort(sorterByName),\n        };\n        const queryParameters: OperationParameter = {\n          ...emptyModel,\n          in: 'query',\n          isRequired: isOperationParameterRequired(\n            operation.parameters.filter(\n              (parameter) => parameter.in === 'query',\n            ),\n          ),\n          mediaType: null,\n          name: 'query',\n          prop: 'query',\n          properties: operation.parameters\n            .filter((parameter) => parameter.in === 'query')\n            .sort(sorterByName),\n        };\n        const operationProperties = !isLegacy\n          ? [\n              bodyParameters,\n              headerParameters,\n              pathParameters,\n              queryParameters,\n            ].filter(\n              (param) =>\n                param.properties.length ||\n                param.$refs.length ||\n                param.mediaType,\n            )\n          : sortByName([...operation.parameters]);\n\n        methodMap.req = operationProperties;\n\n        // create type export for operation data\n        generateType({\n          client,\n          meta: {\n            // TODO: this should be exact ref to operation for consistency,\n            // but name should work too as operation ID is unique\n            $ref: operation.name,\n            name: operation.name,\n          },\n          nameTransformer: operationDataTypeName,\n          onNode,\n          type: toType({\n            ...emptyModel,\n            isRequired: true,\n            properties: operationProperties,\n          }),\n        });\n      }\n\n      const successResponses = operation.responses.filter((response) =>\n        response.responseTypes.includes('success'),\n      );\n\n      if (successResponses.length > 0) {\n        // create type export for operation response\n        generateType({\n          client,\n          meta: {\n            // TODO: this should be exact ref to operation for consistency,\n            // but name should work too as operation ID is unique\n            $ref: operation.name,\n            name: operation.name,\n          },\n          nameTransformer: operationResponseTypeName,\n          onNode,\n          type: toType({\n            ...emptyModel,\n            export: 'any-of',\n            isRequired: true,\n            properties: successResponses,\n          }),\n        });\n\n        const errorResponses = operation.responses.filter((response) =>\n          response.responseTypes.includes('error'),\n        );\n\n        if (!isLegacy) {\n          // create type export for operation error\n          generateType({\n            client,\n            meta: {\n              // TODO: this should be exact ref to operation for consistency,\n              // but name should work too as operation ID is unique\n              $ref: operation.name,\n              name: operation.name,\n            },\n            nameTransformer: operationErrorTypeName,\n            onNode,\n            type: toType(\n              errorResponses.length\n                ? {\n                    ...emptyModel,\n                    export: 'one-of',\n                    isRequired: true,\n                    properties: errorResponses,\n                  }\n                : {\n                    ...emptyModel,\n                    base: 'unknown',\n                    isRequired: true,\n                    type: 'unknown',\n                  },\n            ),\n          });\n        }\n      }\n    }\n  }\n\n  const properties = Object.entries(pathsMap).map(([path, pathMap]) => {\n    const pathParameters = Object.entries(pathMap)\n      .map(([_method, methodMap]) => {\n        const method = _method as Method;\n\n        let methodParameters: Model[] = [];\n\n        if (methodMap.req) {\n          const operationName = methodMap.$ref!;\n          const { name: base } = setUniqueTypeName({\n            client,\n            meta: {\n              // TODO: this should be exact ref to operation for consistency,\n              // but name should work too as operation ID is unique\n              $ref: operationName,\n              name: operationName,\n            },\n            nameTransformer: operationDataTypeName,\n          });\n          const reqKey: Model = {\n            ...emptyModel,\n            base,\n            export: 'reference',\n            isRequired: true,\n            name: 'req',\n            properties: [],\n            type: base,\n          };\n          methodParameters = [...methodParameters, reqKey];\n        }\n\n        if (methodMap.res) {\n          const reqResParameters = Object.entries(methodMap.res).map(\n            ([code, base]) => {\n              // TODO: move query params into separate query key\n              const value: Model = {\n                ...emptyModel,\n                ...base,\n                isRequired: true,\n                name: String(code),\n              };\n              return value;\n            },\n          );\n\n          const resKey: Model = {\n            ...emptyModel,\n            isRequired: true,\n            name: 'res',\n            properties: reqResParameters,\n          };\n          methodParameters = [...methodParameters, resKey];\n        }\n\n        const methodKey: Model = {\n          ...emptyModel,\n          isRequired: true,\n          name: method.toLocaleLowerCase(),\n          properties: methodParameters,\n        };\n        return methodKey;\n      })\n      .filter(Boolean);\n    const pathKey: Model = {\n      ...emptyModel,\n      isRequired: true,\n      name: `'${path}'`,\n      properties: pathParameters as Model[],\n    };\n    return pathKey;\n  });\n\n  if (config.plugins['@hey-api/typescript']?.config.tree) {\n    generateType({\n      client,\n      meta: {\n        $ref: '@hey-api/openapi-ts',\n        name: treeName,\n      },\n      onNode,\n      type: toType({\n        ...emptyModel,\n        properties,\n      }),\n    });\n  }\n};\n\nexport const handlerLegacy: HeyApiTypeScriptPlugin['LegacyHandler'] = ({\n  client,\n  files,\n  plugin,\n}) => {\n  const config = getConfig();\n\n  files.types = new GeneratedFile({\n    dir: config.output.path,\n    exportFromIndex: plugin.config.exportFromIndex,\n    id: 'types',\n    name: 'types.ts',\n  });\n\n  const onNode: TypesProps['onNode'] = (node) => {\n    files.types?.add(node);\n  };\n\n  for (const model of client.models) {\n    processModel({ client, model, onNode });\n  }\n\n  processServiceTypes({ client, onNode });\n};\n","import type ts from 'typescript';\n\nimport { createOperationKey } from '~/ir/operation';\nimport {\n  modelResponseTransformerTypeName,\n  operationResponseTransformerTypeName,\n  operationResponseTypeName,\n} from '~/plugins/@hey-api/sdk/plugin-legacy';\nimport {\n  generateType,\n  type TypesProps,\n} from '~/plugins/@hey-api/typescript/plugin-legacy';\nimport { tsc } from '~/tsc';\nimport type { ModelMeta, OperationResponse } from '~/types/client';\nimport { getConfig } from '~/utils/config';\nimport { isModelDate, unsetUniqueTypeName } from '~/utils/type';\n\nimport type { HeyApiTransformersPlugin } from './types';\n\ninterface ModelProps extends TypesProps {\n  meta?: ModelMeta;\n  path: Array<string>;\n}\n\nconst dataVariableName = 'data';\n\nconst isVoidResponse = (response: OperationResponse) =>\n  response.base === 'unknown' &&\n  response.export === 'generic' &&\n  response.type === 'unknown';\n\nconst getRefModels = ({\n  client,\n  model,\n}: Pick<TypesProps, 'client' | 'model'>) => {\n  const refModels = model.$refs.map((ref) => {\n    const refModel = client.models.find((model) => model.meta?.$ref === ref);\n    if (!refModel) {\n      throw new Error(\n        `Ref ${ref} could not be found. Transformers cannot be generated without having access to all refs.`,\n      );\n    }\n    return refModel;\n  });\n  return refModels;\n};\n\nconst ensureModelResponseTransformerExists = (\n  props: Omit<ModelProps, 'path'>,\n) => {\n  const modelName = props.model.meta!.name;\n\n  const { name } = generateType({\n    ...props,\n    meta: {\n      $ref: `transformers/${modelName}`,\n      name: modelName,\n    },\n    nameTransformer: modelResponseTransformerTypeName,\n    onCreated: (name) => {\n      const statements = processModel({\n        ...props,\n        meta: {\n          $ref: `transformers/${modelName}`,\n          name,\n        },\n        path: [dataVariableName],\n      });\n      generateResponseTransformer({\n        ...props,\n        async: false,\n        name,\n        statements,\n      });\n    },\n    type: `(${dataVariableName}: any) => ${modelName}`,\n  });\n\n  const result = {\n    created: Boolean(props.client.types[name]),\n    name,\n  };\n  return result;\n};\n\nconst processArray = (props: ModelProps) => {\n  const { model } = props;\n  const refModels = getRefModels(props);\n\n  if (refModels.length === 1) {\n    const { created, name: nameModelResponseTransformer } =\n      ensureModelResponseTransformerExists({ ...props, model: refModels[0]! });\n\n    if (!created) {\n      return [];\n    }\n\n    return [\n      tsc.transformArrayMutation({\n        path: props.path,\n        transformerName: nameModelResponseTransformer,\n      }),\n    ];\n  }\n\n  if (\n    isModelDate(model) ||\n    (model.link &&\n      !Array.isArray(model.link) &&\n      model.link.export === 'any-of' &&\n      model.link.properties.find((property) => isModelDate(property)))\n  ) {\n    return [\n      tsc.transformArrayMap({\n        path: props.path,\n        transformExpression: tsc.conditionalExpression({\n          condition: tsc.identifier({ text: 'item' }),\n          whenFalse: tsc.identifier({ text: 'item' }),\n          whenTrue: tsc.transformNewDate({\n            parameterName: 'item',\n          }),\n        }),\n      }),\n    ];\n  }\n\n  // Not transform for this type\n  return [];\n};\n\nconst processProperty = (props: ModelProps) => {\n  const { model } = props;\n  const path = [...props.path, model.name];\n\n  if (\n    model.type === 'string' &&\n    model.export !== 'array' &&\n    isModelDate(model)\n  ) {\n    return [tsc.transformDateMutation({ path })];\n  }\n\n  // otherwise we recurse in case it's an object/array, and if it's not that will just bail with []\n  return processModel({\n    ...props,\n    model,\n    path,\n  });\n};\n\nconst processModel = (props: ModelProps): ts.Statement[] => {\n  const { model } = props;\n\n  switch (model.export) {\n    case 'array':\n      return processArray(props);\n    case 'interface':\n      return model.properties.flatMap((property) =>\n        processProperty({ ...props, model: property }),\n      );\n    case 'reference': {\n      if (model.$refs.length !== 1) {\n        return [];\n      }\n      const refModels = getRefModels(props);\n\n      const { created, name: nameModelResponseTransformer } =\n        ensureModelResponseTransformerExists({\n          ...props,\n          model: refModels[0]!,\n        });\n\n      if (!created) {\n        return [];\n      }\n\n      return model.in === 'response'\n        ? [\n            tsc.expressionToStatement({\n              expression: tsc.callExpression({\n                functionName: nameModelResponseTransformer,\n                parameters: [dataVariableName],\n              }),\n            }),\n          ]\n        : tsc.transformFunctionMutation({\n            path: props.path,\n            transformerName: nameModelResponseTransformer,\n          });\n    }\n    // unsupported\n    default:\n      return [];\n  }\n};\n\nconst generateResponseTransformer = ({\n  async,\n  client,\n  name,\n  onNode,\n  onRemoveNode,\n  statements,\n}: Pick<TypesProps, 'client' | 'onNode' | 'onRemoveNode'> & {\n  async: boolean;\n  name: string;\n  statements: Array<ts.Statement>;\n}) => {\n  const result = {\n    created: false,\n    name,\n  };\n\n  if (!statements.length) {\n    // clean up created type for response transformer if it turns out\n    // the transformer was never generated\n    unsetUniqueTypeName({\n      client,\n      name,\n    });\n    onRemoveNode?.();\n    return result;\n  }\n\n  const expression = tsc.arrowFunction({\n    async,\n    multiLine: true,\n    parameters: [\n      {\n        name: dataVariableName,\n      },\n    ],\n    statements: [\n      ...statements,\n      tsc.returnVariable({\n        expression: dataVariableName,\n      }),\n    ],\n  });\n  const statement = tsc.constVariable({\n    exportConst: true,\n    expression,\n    name,\n    typeName: name,\n  });\n  onNode(statement);\n\n  return {\n    created: true,\n    name,\n  };\n};\n\n// handles only response transformers for now\nexport const handlerLegacy: HeyApiTransformersPlugin['LegacyHandler'] = ({\n  client,\n  files,\n}) => {\n  const config = getConfig();\n\n  const onNode: TypesProps['onNode'] = (node) => {\n    files.types?.add(node);\n  };\n  const onRemoveNode: TypesProps['onRemoveNode'] = () => {\n    files.types?.removeNode_LEGACY();\n  };\n\n  for (const service of client.services) {\n    for (const operation of service.operations) {\n      const successResponses = operation.responses.filter((response) =>\n        response.responseTypes.includes('success'),\n      );\n\n      if (!successResponses.length) {\n        continue;\n      }\n\n      const nonVoidResponses = successResponses.filter(\n        (response) => !isVoidResponse(response),\n      );\n\n      if (!nonVoidResponses.length) {\n        continue;\n      }\n\n      if (nonVoidResponses.length > 1) {\n        if (config.logs.level === 'debug') {\n          console.warn(\n            ` Transformers warning: route ${createOperationKey(operation)} has ${nonVoidResponses.length} non-void success responses. This is currently not handled and we will not generate a response transformer. Please open an issue if you'd like this feature https://github.com/hey-api/openapi-ts/issues`,\n          );\n        }\n        continue;\n      }\n\n      const name = operationResponseTypeName(operation.name);\n      generateType({\n        client,\n        meta: {\n          $ref: `transformers/${name}`,\n          name,\n        },\n        nameTransformer: operationResponseTransformerTypeName,\n        onCreated: (nameCreated) => {\n          const statements =\n            successResponses.length > 1\n              ? successResponses.flatMap((response) => {\n                  const statements = processModel({\n                    client,\n                    meta: {\n                      $ref: `transformers/${name}`,\n                      name,\n                    },\n                    model: response,\n                    onNode,\n                    onRemoveNode,\n                    path: [dataVariableName],\n                  });\n\n                  // assume unprocessed responses are void\n                  if (!statements.length) {\n                    return [];\n                  }\n\n                  return [\n                    tsc.ifStatement({\n                      expression: tsc.safeAccessExpression(['data']),\n                      thenStatement: tsc.block({ statements }),\n                    }),\n                  ];\n                })\n              : processModel({\n                  client,\n                  meta: {\n                    $ref: `transformers/${name}`,\n                    name,\n                  },\n                  model: successResponses[0]!,\n                  onNode,\n                  onRemoveNode,\n                  path: [dataVariableName],\n                });\n          generateResponseTransformer({\n            async: true,\n            client,\n            name: nameCreated,\n            onNode,\n            onRemoveNode,\n            statements,\n          });\n        },\n        onNode,\n        type: `(${dataVariableName}: any) => Promise<${name}>`,\n      });\n    }\n  }\n};\n","import { definePluginConfig } from '~/plugins/shared/utils/config';\n\nimport { Api } from './api';\nimport { bigIntExpressions, dateExpressions } from './expressions';\nimport { handler } from './plugin';\nimport { handlerLegacy } from './plugin-legacy';\nimport type { HeyApiTransformersPlugin } from './types';\n\nexport const defaultConfig: HeyApiTransformersPlugin['Config'] = {\n  api: new Api({\n    name: '@hey-api/transformers',\n  }),\n  config: {\n    bigInt: true,\n    dates: true,\n    exportFromIndex: false,\n    transformers: [],\n    typeTransformers: [],\n  },\n  dependencies: ['@hey-api/typescript'],\n  handler,\n  handlerLegacy,\n  name: '@hey-api/transformers',\n  resolveConfig: (plugin) => {\n    if (!plugin.config.transformers) {\n      plugin.config.transformers = [];\n    }\n\n    if (plugin.config.dates) {\n      plugin.config.transformers = [\n        ...plugin.config.transformers,\n        dateExpressions,\n      ];\n    }\n\n    if (plugin.config.bigInt) {\n      plugin.config.transformers = [\n        ...plugin.config.transformers,\n        bigIntExpressions,\n      ];\n    }\n  },\n  tags: ['transformer'],\n};\n\n/**\n * Type helper for `@hey-api/transformers`, returns {@link Plugin.Config} object\n */\nexport const defineConfig = definePluginConfig(defaultConfig);\n","import type { FromRefs, ToRefs } from '../types/refs';\n\n/**\n * Wraps a single value in a Ref object.\n *\n * @example\n * ```ts\n * const r = toRef(123); // { value: 123 }\n * console.log(r.value); // 123\n * ```\n */\nexport const toRef = <T>(value: T): { value: T } => ({ value });\n\n/**\n * Unwraps a single Ref object to its value.\n *\n * @example\n * ```ts\n * const r = { value: 42 };\n * const n = fromRef(r); // 42\n * console.log(n); // 42\n * ```\n */\nexport const fromRef = <T>(ref: { value: T }): T => ref.value;\n\n/**\n * Converts an object of Refs back to a plain object (unwraps all refs).\n *\n * @example\n * ```ts\n * const refs = { a: { value: 1 }, b: { value: \"x\" } };\n * const plain = fromRefs(refs); // { a: 1, b: \"x\" }\n * ```\n */\nexport const fromRefs = <T extends ToRefs<Record<string, unknown>>>(\n  obj: T,\n): FromRefs<T> => {\n  const result = {} as FromRefs<T>;\n  for (const key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      result[key] = fromRef(obj[key]!) as (typeof result)[typeof key];\n    }\n  }\n  return result;\n};\n\n/**\n * Converts a plain object to an object of Refs (deep, per property).\n *\n * @example\n * ```ts\n * const obj = { a: 1, b: \"x\" };\n * const refs = toRefs(obj); // { a: { value: 1 }, b: { value: \"x\" } }\n * ```\n */\nexport const toRefs = <T extends Record<string, unknown>>(\n  obj: T,\n): ToRefs<T> => {\n  const result = {} as ToRefs<T>;\n  for (const key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      result[key] = toRef(obj[key]);\n    }\n  }\n  return result;\n};\n","import type { Symbol } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport type { IR } from '~/ir/types';\nimport {\n  getClientBaseUrlKey,\n  getClientPlugin,\n} from '~/plugins/@hey-api/client-core/utils';\nimport { tsc } from '~/tsc';\nimport { parseUrl } from '~/utils/url';\n\nimport type { HeyApiTypeScriptPlugin } from '../types';\n\nconst stringType = tsc.keywordTypeNode({ keyword: 'string' });\n\nconst serverToBaseUrlType = ({ server }: { server: IR.ServerObject }) => {\n  const url = parseUrl(server.url);\n\n  if (url.protocol && url.host) {\n    return tsc.literalTypeNode({\n      literal: tsc.stringLiteral({ text: server.url }),\n    });\n  }\n\n  return tsc.templateLiteralType({\n    value: [\n      url.protocol || stringType,\n      '://',\n      url.host || stringType,\n      url.port ? `:${url.port}` : '',\n      url.path || '',\n    ],\n  });\n};\n\nexport const createClientOptions = ({\n  plugin,\n  servers,\n  symbolClientOptions,\n}: {\n  plugin: HeyApiTypeScriptPlugin['Instance'];\n  servers: ReadonlyArray<IR.ServerObject>;\n  symbolClientOptions: Symbol;\n}) => {\n  const client = getClientPlugin(plugin.context.config);\n\n  const types: Array<ts.TypeNode> = servers.map((server) =>\n    serverToBaseUrlType({ server }),\n  );\n\n  if (!servers.length) {\n    types.push(stringType);\n  } else if (\n    !('strictBaseUrl' in client.config && client.config.strictBaseUrl)\n  ) {\n    types.push(\n      tsc.typeIntersectionNode({\n        types: [stringType, ts.factory.createTypeLiteralNode([])],\n      }),\n    );\n  }\n\n  const type = tsc.typeInterfaceNode({\n    properties: [\n      {\n        name: getClientBaseUrlKey(plugin.context.config),\n        type: tsc.typeUnionNode({ types }),\n      },\n    ],\n    useLegacyResolution: false,\n  });\n  const node = tsc.typeAliasDeclaration({\n    exportType: symbolClientOptions.exported,\n    name: symbolClientOptions.placeholder,\n    type,\n  });\n  plugin.setSymbolValue(symbolClientOptions, node);\n};\n","import type { IR } from '~/ir/types';\nimport type { Comments } from '~/tsc';\nimport { escapeComment } from '~/utils/escape';\n\nexport const createSchemaComment = ({\n  schema,\n}: {\n  schema: IR.SchemaObject;\n}): Comments | undefined => {\n  const comments: Array<string> = [];\n\n  if (schema.title) {\n    comments.push(escapeComment(schema.title));\n  }\n\n  if (schema.description) {\n    if (comments.length) {\n      comments.push(''); // Add an empty line between title and description\n    }\n    comments.push(escapeComment(schema.description));\n  }\n\n  if (schema.deprecated) {\n    if (comments.length) {\n      comments.push(''); // Add an empty line before deprecated\n    }\n    comments.push('@deprecated');\n  }\n\n  return comments.length ? comments : undefined;\n};\n","import type { Symbol } from '@hey-api/codegen-core';\nimport type ts from 'typescript';\n\nimport type { IR } from '~/ir/types';\nimport { createSchemaComment } from '~/plugins/shared/utils/schema';\nimport { tsc } from '~/tsc';\nimport { numberRegExp } from '~/utils/regexp';\nimport { stringCase } from '~/utils/stringCase';\n\nimport type { HeyApiTypeScriptPlugin } from '../types';\n\nconst schemaToEnumObject = ({\n  plugin,\n  schema,\n}: {\n  plugin: HeyApiTypeScriptPlugin['Instance'];\n  schema: IR.SchemaObject;\n}) => {\n  const typeofItems: Array<\n    | 'bigint'\n    | 'boolean'\n    | 'function'\n    | 'number'\n    | 'object'\n    | 'string'\n    | 'symbol'\n    | 'undefined'\n  > = [];\n\n  const obj = (schema.items ?? []).map((item, index) => {\n    const typeOfItemConst = typeof item.const;\n\n    if (!typeofItems.includes(typeOfItemConst)) {\n      // track types of enum values because some modes support\n      // only enums with string and number types\n      typeofItems.push(typeOfItemConst);\n    }\n\n    let key: string | undefined;\n    if (item.title) {\n      key = item.title;\n    } else if (typeOfItemConst === 'number' || typeOfItemConst === 'string') {\n      key = `${item.const}`;\n    } else if (typeOfItemConst === 'boolean') {\n      key = item.const ? 'true' : 'false';\n    } else if (item.const === null) {\n      key = 'null';\n    } else {\n      key = `${index}`;\n    }\n\n    if (key) {\n      key = stringCase({\n        case: plugin.config.enums.case,\n        stripLeadingSeparators: false,\n        value: key,\n      });\n\n      numberRegExp.lastIndex = 0;\n      // TypeScript enum keys cannot be numbers\n      if (\n        numberRegExp.test(key) &&\n        plugin.config.enums.enabled &&\n        (plugin.config.enums.mode === 'typescript' ||\n          plugin.config.enums.mode === 'typescript-const')\n      ) {\n        key = `_${key}`;\n      }\n    }\n\n    return {\n      comments: createSchemaComment({ schema: item }),\n      key,\n      value: item.const,\n    };\n  });\n\n  return {\n    obj,\n    typeofItems,\n  };\n};\n\nexport const exportType = ({\n  plugin,\n  schema,\n  symbol,\n  type,\n}: {\n  plugin: HeyApiTypeScriptPlugin['Instance'];\n  schema: IR.SchemaObject;\n  symbol: Symbol;\n  type: ts.TypeNode;\n}) => {\n  // root enums have an additional export\n  if (schema.type === 'enum' && plugin.config.enums.enabled) {\n    const enumObject = schemaToEnumObject({ plugin, schema });\n\n    if (plugin.config.enums.mode === 'javascript') {\n      // JavaScript enums might want to ignore null values\n      if (\n        plugin.config.enums.constantsIgnoreNull &&\n        enumObject.typeofItems.includes('object')\n      ) {\n        enumObject.obj = enumObject.obj.filter((item) => item.value !== null);\n      }\n\n      const objectNode = tsc.constVariable({\n        assertion: 'const',\n        comment: createSchemaComment({ schema }),\n        exportConst: true,\n        expression: tsc.objectExpression({\n          multiLine: true,\n          obj: enumObject.obj,\n        }),\n        name: symbol.placeholder,\n      });\n\n      const typeofType = tsc.typeOfExpression({\n        text: symbol.placeholder,\n      }) as unknown as ts.TypeNode;\n      const node = tsc.typeAliasDeclaration({\n        comment: createSchemaComment({ schema }),\n        exportType: true,\n        name: symbol.placeholder,\n        type: tsc.indexedAccessTypeNode({\n          indexType: tsc.typeOperatorNode({\n            operator: 'keyof',\n            type: typeofType,\n          }),\n          objectType: typeofType,\n        }),\n      });\n      plugin.setSymbolValue(symbol, [objectNode, node]);\n      return;\n    } else if (\n      plugin.config.enums.mode === 'typescript' ||\n      plugin.config.enums.mode === 'typescript-const'\n    ) {\n      // TypeScript enums support only string and number values\n      const shouldCreateTypeScriptEnum = !enumObject.typeofItems.some(\n        (type) => type !== 'number' && type !== 'string',\n      );\n      if (shouldCreateTypeScriptEnum) {\n        const enumNode = tsc.enumDeclaration({\n          asConst: plugin.config.enums.mode === 'typescript-const',\n          leadingComment: createSchemaComment({ schema }),\n          name: symbol.placeholder,\n          obj: enumObject.obj,\n        });\n        plugin.setSymbolValue(symbol, enumNode);\n        return;\n      }\n    }\n  }\n\n  const node = tsc.typeAliasDeclaration({\n    comment: createSchemaComment({ schema }),\n    exportType: symbol.exported,\n    name: symbol.placeholder,\n    type,\n  });\n  plugin.setSymbolValue(symbol, node);\n};\n","import { operationResponsesMap } from '~/ir/operation';\nimport { deduplicateSchema } from '~/ir/schema';\nimport type { IR } from '~/ir/types';\nimport { buildName } from '~/openApi/shared/utils/name';\nimport { tsc } from '~/tsc';\n\nimport { irSchemaToAst } from '../v1/plugin';\nimport type { IrSchemaToAstOptions } from './types';\n\nconst irParametersToIrSchema = ({\n  parameters,\n}: {\n  parameters: Record<string, IR.ParameterObject>;\n}): IR.SchemaObject => {\n  const irSchema: IR.SchemaObject = {\n    type: 'object',\n  };\n\n  if (parameters) {\n    const properties: Record<string, IR.SchemaObject> = {};\n    const required: Array<string> = [];\n\n    for (const key in parameters) {\n      const parameter = parameters[key]!;\n\n      properties[parameter.name] = deduplicateSchema({\n        detectFormat: false,\n        schema: parameter.schema,\n      });\n\n      if (parameter.required) {\n        required.push(parameter.name);\n      }\n    }\n\n    irSchema.properties = properties;\n\n    if (required.length) {\n      irSchema.required = required;\n    }\n  }\n\n  return irSchema;\n};\n\nconst operationToDataType = ({\n  operation,\n  plugin,\n  state,\n}: IrSchemaToAstOptions & {\n  operation: IR.OperationObject;\n}) => {\n  const data: IR.SchemaObject = {\n    type: 'object',\n  };\n  const dataRequired: Array<string> = [];\n\n  if (!data.properties) {\n    data.properties = {};\n  }\n\n  if (operation.body) {\n    data.properties.body = operation.body.schema;\n\n    if (operation.body.required) {\n      dataRequired.push('body');\n    }\n  } else {\n    data.properties.body = {\n      type: 'never',\n    };\n  }\n\n  // TODO: parser - handle cookie parameters\n\n  // do not set headers to never so we can always pass arbitrary values\n  if (operation.parameters?.header) {\n    data.properties.headers = irParametersToIrSchema({\n      parameters: operation.parameters.header,\n    });\n\n    if (data.properties.headers.required) {\n      dataRequired.push('headers');\n    }\n  }\n\n  if (operation.parameters?.path) {\n    data.properties.path = irParametersToIrSchema({\n      parameters: operation.parameters.path,\n    });\n\n    if (data.properties.path.required) {\n      dataRequired.push('path');\n    }\n  } else {\n    data.properties.path = {\n      type: 'never',\n    };\n  }\n\n  if (operation.parameters?.query) {\n    data.properties.query = irParametersToIrSchema({\n      parameters: operation.parameters.query,\n    });\n\n    if (data.properties.query.required) {\n      dataRequired.push('query');\n    }\n  } else {\n    data.properties.query = {\n      type: 'never',\n    };\n  }\n\n  data.properties.url = {\n    const: operation.path,\n    type: 'string',\n  };\n  dataRequired.push('url');\n\n  data.required = dataRequired;\n\n  const symbol = plugin.registerSymbol({\n    exported: true,\n    meta: {\n      kind: 'type',\n      path: state.path.value,\n      tags: state.tags?.value,\n    },\n    name: buildName({\n      config: plugin.config.requests,\n      name: operation.id,\n    }),\n    selector: plugin.api.selector('data', operation.id),\n  });\n  const type = irSchemaToAst({\n    plugin,\n    schema: data,\n    state,\n  });\n  const node = tsc.typeAliasDeclaration({\n    exportType: symbol.exported,\n    name: symbol.placeholder,\n    type,\n  });\n  plugin.setSymbolValue(symbol, node);\n};\n\nexport const operationToType = ({\n  operation,\n  plugin,\n  state,\n}: IrSchemaToAstOptions & {\n  operation: IR.OperationObject;\n}) => {\n  operationToDataType({ operation, plugin, state });\n\n  const { error, errors, response, responses } =\n    operationResponsesMap(operation);\n\n  if (errors) {\n    const symbolErrors = plugin.registerSymbol({\n      exported: true,\n      meta: {\n        kind: 'type',\n        path: state.path.value,\n        tags: state.tags?.value,\n      },\n      name: buildName({\n        config: plugin.config.errors,\n        name: operation.id,\n      }),\n      selector: plugin.api.selector('errors', operation.id),\n    });\n    const type = irSchemaToAst({\n      plugin,\n      schema: errors,\n      state,\n    });\n    const node = tsc.typeAliasDeclaration({\n      exportType: symbolErrors.exported,\n      name: symbolErrors.placeholder,\n      type,\n    });\n    plugin.setSymbolValue(symbolErrors, node);\n\n    if (error) {\n      const symbol = plugin.registerSymbol({\n        exported: true,\n        meta: {\n          kind: 'type',\n          path: state.path.value,\n          tags: state.tags?.value,\n        },\n        name: buildName({\n          config: {\n            case: plugin.config.errors.case,\n            name: plugin.config.errors.error,\n          },\n          name: operation.id,\n        }),\n        selector: plugin.api.selector('error', operation.id),\n      });\n      const type = tsc.indexedAccessTypeNode({\n        indexType: tsc.typeOperatorNode({\n          operator: 'keyof',\n          type: tsc.typeReferenceNode({ typeName: symbolErrors.placeholder }),\n        }),\n        objectType: tsc.typeReferenceNode({\n          typeName: symbolErrors.placeholder,\n        }),\n      });\n      const node = tsc.typeAliasDeclaration({\n        exportType: symbol.exported,\n        name: symbol.placeholder,\n        type,\n      });\n      plugin.setSymbolValue(symbol, node);\n    }\n  }\n\n  if (responses) {\n    const symbolResponses = plugin.registerSymbol({\n      exported: true,\n      meta: {\n        kind: 'type',\n        path: state.path.value,\n        tags: state.tags?.value,\n      },\n      name: buildName({\n        config: plugin.config.responses,\n        name: operation.id,\n      }),\n      selector: plugin.api.selector('responses', operation.id),\n    });\n    const type = irSchemaToAst({\n      plugin,\n      schema: responses,\n      state,\n    });\n    const node = tsc.typeAliasDeclaration({\n      exportType: symbolResponses.exported,\n      name: symbolResponses.placeholder,\n      type,\n    });\n    plugin.setSymbolValue(symbolResponses, node);\n\n    if (response) {\n      const symbol = plugin.registerSymbol({\n        exported: true,\n        meta: {\n          kind: 'type',\n          path: state.path.value,\n          tags: state.tags?.value,\n        },\n        name: buildName({\n          config: {\n            case: plugin.config.responses.case,\n            name: plugin.config.responses.response,\n          },\n          name: operation.id,\n        }),\n        selector: plugin.api.selector('response', operation.id),\n      });\n      const type = tsc.indexedAccessTypeNode({\n        indexType: tsc.typeOperatorNode({\n          operator: 'keyof',\n          type: tsc.typeReferenceNode({\n            typeName: symbolResponses.placeholder,\n          }),\n        }),\n        objectType: tsc.typeReferenceNode({\n          typeName: symbolResponses.placeholder,\n        }),\n      });\n      const node = tsc.typeAliasDeclaration({\n        exportType: symbol.exported,\n        name: symbol.placeholder,\n        type,\n      });\n      plugin.setSymbolValue(symbol, node);\n    }\n  }\n};\n","import type { IR } from '~/ir/types';\nimport { buildName } from '~/openApi/shared/utils/name';\nimport { createSchemaComment } from '~/plugins/shared/utils/schema';\nimport { tsc } from '~/tsc';\n\nimport { irSchemaToAst } from '../v1/plugin';\nimport type { IrSchemaToAstOptions } from './types';\n\nconst operationToDataType = ({\n  operation,\n  plugin,\n  state,\n}: IrSchemaToAstOptions & {\n  operation: IR.OperationObject;\n}): string => {\n  const data: IR.SchemaObject = {\n    type: 'object',\n  };\n  const dataRequired: Array<string> = [];\n\n  if (!data.properties) {\n    data.properties = {};\n  }\n\n  if (operation.body) {\n    const symbolWebhookPayload = plugin.registerSymbol({\n      exported: true,\n      meta: {\n        kind: 'type',\n        path: state.path.value,\n        tags: state.tags?.value,\n      },\n      name: buildName({\n        config: {\n          case: plugin.config.webhooks.case,\n          name: plugin.config.webhooks.payload,\n        },\n        name: operation.id,\n      }),\n      selector: plugin.api.selector('webhook-payload', operation.id),\n    });\n    const type = irSchemaToAst({\n      plugin,\n      schema: operation.body.schema,\n      state,\n    });\n    const node = tsc.typeAliasDeclaration({\n      comment: createSchemaComment({ schema: operation.body.schema }),\n      exportType: symbolWebhookPayload.exported,\n      name: symbolWebhookPayload.placeholder,\n      type,\n    });\n    plugin.setSymbolValue(symbolWebhookPayload, node);\n\n    plugin.registerSymbol({\n      exported: true,\n      meta: {\n        kind: 'type',\n        path: state.path.value,\n        tags: state.tags?.value,\n      },\n      name: symbolWebhookPayload.name,\n      placeholder: symbolWebhookPayload.placeholder,\n      selector: plugin.api.selector('ref', symbolWebhookPayload.placeholder),\n    });\n    data.properties.body = { $ref: symbolWebhookPayload.placeholder };\n    dataRequired.push('body');\n  } else {\n    data.properties.body = { type: 'never' };\n  }\n\n  data.properties.key = {\n    const: operation.path,\n    type: 'string',\n  };\n  dataRequired.push('key');\n\n  data.properties.path = { type: 'never' };\n  data.properties.query = { type: 'never' };\n\n  data.required = dataRequired;\n\n  const symbolWebhookRequest = plugin.registerSymbol({\n    exported: true,\n    meta: {\n      kind: 'type',\n      path: state.path.value,\n      tags: state.tags?.value,\n    },\n    name: buildName({\n      config: plugin.config.webhooks,\n      name: operation.id,\n    }),\n    selector: plugin.api.selector('webhook-request', operation.id),\n  });\n  const type = irSchemaToAst({\n    plugin,\n    schema: data,\n    state,\n  });\n  const node = tsc.typeAliasDeclaration({\n    exportType: symbolWebhookRequest.exported,\n    name: symbolWebhookRequest.placeholder,\n    type,\n  });\n  plugin.setSymbolValue(symbolWebhookRequest, node);\n\n  return symbolWebhookRequest.placeholder;\n};\n\nexport const webhookToType = ({\n  operation,\n  plugin,\n  state,\n}: IrSchemaToAstOptions & {\n  operation: IR.OperationObject;\n}): string => {\n  const name = operationToDataType({ operation, plugin, state });\n  return name;\n\n  // don't handle webhook responses for now, users only need requestBody\n};\n","import type { Symbol } from '@hey-api/codegen-core';\n\nimport { tsc } from '~/tsc';\n\nimport type { HeyApiTypeScriptPlugin } from '../types';\n\nexport const createWebhooks = ({\n  plugin,\n  symbolWebhooks,\n  webhookNames,\n}: {\n  plugin: HeyApiTypeScriptPlugin['Instance'];\n  symbolWebhooks: Symbol;\n  webhookNames: ReadonlyArray<string>;\n}) => {\n  if (!webhookNames.length) return;\n\n  const type = tsc.typeUnionNode({\n    types: webhookNames.map((name) =>\n      tsc.typeReferenceNode({ typeName: name }),\n    ),\n  });\n  const node = tsc.typeAliasDeclaration({\n    exportType: symbolWebhooks.exported,\n    name: symbolWebhooks.placeholder,\n    type,\n  });\n  plugin.setSymbolValue(symbolWebhooks, node);\n};\n","import type ts from 'typescript';\n\nimport { deduplicateSchema } from '~/ir/schema';\nimport type { SchemaWithType } from '~/plugins';\nimport { toRef } from '~/plugins/shared/utils/refs';\nimport { tsc } from '~/tsc';\n\nimport type { IrSchemaToAstOptions } from '../../shared/types';\nimport { irSchemaToAst } from '../plugin';\n\nexport const arrayToAst = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'array'>;\n}): ts.TypeNode => {\n  if (!schema.items) {\n    return tsc.typeArrayNode(\n      tsc.keywordTypeNode({ keyword: plugin.config.topType }),\n    );\n  }\n\n  schema = deduplicateSchema({ detectFormat: true, schema });\n\n  const itemTypes: Array<ts.TypeNode> = [];\n\n  if (schema.items) {\n    schema.items.forEach((item, index) => {\n      const type = irSchemaToAst({\n        plugin,\n        schema: item,\n        state: {\n          ...state,\n          path: toRef([...state.path.value, 'items', index]),\n        },\n      });\n      itemTypes.push(type);\n    });\n  }\n\n  if (itemTypes.length === 1) {\n    return tsc.typeArrayNode(itemTypes[0]!);\n  }\n\n  if (schema.logicalOperator === 'and') {\n    return tsc.typeArrayNode(tsc.typeIntersectionNode({ types: itemTypes }));\n  }\n\n  return tsc.typeArrayNode(tsc.typeUnionNode({ types: itemTypes }));\n};\n","import type ts from 'typescript';\n\nimport type { SchemaWithType } from '~/plugins';\nimport { tsc } from '~/tsc';\n\nimport type { IrSchemaToAstOptions } from '../../shared/types';\n\nexport const booleanToAst = ({\n  schema,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'boolean'>;\n}): ts.TypeNode => {\n  if (schema.const !== undefined) {\n    return tsc.literalTypeNode({\n      literal: tsc.ots.boolean(schema.const as boolean),\n    });\n  }\n\n  return tsc.keywordTypeNode({\n    keyword: 'boolean',\n  });\n};\n","import type ts from 'typescript';\n\nimport type { SchemaWithType } from '~/plugins';\n\nimport type { IrSchemaToAstOptions } from '../../shared/types';\nimport { irSchemaToAst } from '../plugin';\n\nexport const enumToAst = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'enum'>;\n}): ts.TypeNode => {\n  const type = irSchemaToAst({\n    plugin,\n    schema: {\n      ...schema,\n      type: undefined,\n    },\n    state,\n  });\n  return type;\n};\n","import type ts from 'typescript';\n\nimport type { SchemaWithType } from '~/plugins';\nimport { tsc } from '~/tsc';\n\nimport type { IrSchemaToAstOptions } from '../../shared/types';\n\nexport const neverToAst = (\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _args: IrSchemaToAstOptions & {\n    schema: SchemaWithType<'never'>;\n  },\n): ts.TypeNode => {\n  const node = tsc.keywordTypeNode({\n    keyword: 'never',\n  });\n  return node;\n};\n","import type ts from 'typescript';\n\nimport type { SchemaWithType } from '~/plugins';\nimport { tsc } from '~/tsc';\n\nimport type { IrSchemaToAstOptions } from '../../shared/types';\n\nexport const nullToAst = (\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _args: IrSchemaToAstOptions & {\n    schema: SchemaWithType<'null'>;\n  },\n): ts.TypeNode => {\n  const node = tsc.literalTypeNode({\n    literal: tsc.null(),\n  });\n  return node;\n};\n","import type ts from 'typescript';\n\nimport type { SchemaWithType } from '~/plugins';\nimport { tsc } from '~/tsc';\n\nimport type { IrSchemaToAstOptions } from '../../shared/types';\n\nexport const numberToAst = ({\n  plugin,\n  schema,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'integer' | 'number'>;\n}): ts.TypeNode => {\n  if (schema.const !== undefined) {\n    return tsc.literalTypeNode({\n      literal: tsc.ots.number(schema.const as number),\n    });\n  }\n\n  if (schema.type === 'integer' && schema.format === 'int64') {\n    // TODO: parser - add ability to skip type transformers\n    if (plugin.getPlugin('@hey-api/transformers')?.config.bigInt) {\n      return tsc.typeReferenceNode({ typeName: 'bigint' });\n    }\n  }\n\n  return tsc.keywordTypeNode({\n    keyword: 'number',\n  });\n};\n","import ts from 'typescript';\n\nimport type { IR } from '~/ir/types';\nimport { numberRegExp } from '~/utils/regexp';\nimport { stringCase } from '~/utils/stringCase';\n\n/**\n * Returns final field name for object properties. This might differ from the\n * original value as applying case transform function might alter it.\n */\nexport const fieldName = ({\n  context,\n  name,\n}: {\n  context: IR.Context;\n  name: string;\n}) => {\n  numberRegExp.lastIndex = 0;\n  if (numberRegExp.test(name)) {\n    // For negative numbers, use string literals instead\n    if (name.startsWith('-')) {\n      return ts.factory.createStringLiteral(name);\n    }\n    return ts.factory.createNumericLiteral(name);\n  }\n\n  // if (typeof context.config.output.case === 'function') {\n  //   return context.config.output.case({ value: name });\n  // }\n\n  return stringCase({ case: context.config.output.case, value: name });\n};\n","import type ts from 'typescript';\n\nimport type { IR } from '~/ir/types';\nimport type { SchemaWithType } from '~/plugins';\nimport { fieldName } from '~/plugins/shared/utils/case';\nimport { toRef } from '~/plugins/shared/utils/refs';\nimport { createSchemaComment } from '~/plugins/shared/utils/schema';\nimport type { Property } from '~/tsc';\nimport { tsc } from '~/tsc';\n\nimport type { IrSchemaToAstOptions } from '../../shared/types';\nimport { irSchemaToAst } from '../plugin';\n\nexport const objectToAst = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'object'>;\n}): ts.TypeNode => {\n  // TODO: parser - handle constants\n  let indexKey: ts.TypeReferenceNode | undefined;\n  let indexProperty: Property | undefined;\n  const schemaProperties: Array<Property> = [];\n  let indexPropertyItems: Array<IR.SchemaObject> = [];\n  const required = schema.required ?? [];\n  let hasOptionalProperties = false;\n\n  for (const name in schema.properties) {\n    const property = schema.properties[name]!;\n    const propertyType = irSchemaToAst({\n      plugin,\n      schema: property,\n      state: {\n        ...state,\n        path: toRef([...state.path.value, 'properties', name]),\n      },\n    });\n    const isRequired = required.includes(name);\n    schemaProperties.push({\n      comment: createSchemaComment({ schema: property }),\n      isReadOnly: property.accessScope === 'read',\n      isRequired,\n      name: fieldName({ context: plugin.context, name }),\n      type: propertyType,\n    });\n    indexPropertyItems.push(property);\n\n    if (!isRequired) {\n      hasOptionalProperties = true;\n    }\n  }\n\n  // include pattern value schemas into the index union\n  if (schema.patternProperties) {\n    for (const pattern in schema.patternProperties) {\n      const ir = schema.patternProperties[pattern]!;\n      indexPropertyItems.unshift(ir);\n    }\n  }\n\n  const hasPatterns =\n    !!schema.patternProperties &&\n    Object.keys(schema.patternProperties).length > 0;\n\n  const addPropsRaw = schema.additionalProperties;\n  const addPropsObj =\n    addPropsRaw !== false && addPropsRaw\n      ? (addPropsRaw as IR.SchemaObject)\n      : undefined;\n  const shouldCreateIndex =\n    hasPatterns ||\n    (!!addPropsObj &&\n      (addPropsObj.type !== 'never' || !indexPropertyItems.length));\n\n  if (shouldCreateIndex) {\n    // only inject additionalProperties when its not \"never\"\n    const addProps = addPropsObj;\n    if (addProps && addProps.type !== 'never') {\n      indexPropertyItems.unshift(addProps);\n    } else if (\n      !hasPatterns &&\n      !indexPropertyItems.length &&\n      addProps &&\n      addProps.type === 'never'\n    ) {\n      // keep \"never\" only when there are NO patterns and NO explicit properties\n      indexPropertyItems = [addProps];\n    }\n\n    if (hasOptionalProperties) {\n      indexPropertyItems.push({\n        type: 'undefined',\n      });\n    }\n\n    indexProperty = {\n      isRequired: !schema.propertyNames,\n      name: 'key',\n      type:\n        indexPropertyItems.length === 1\n          ? irSchemaToAst({\n              plugin,\n              schema: indexPropertyItems[0]!,\n              state,\n            })\n          : irSchemaToAst({\n              plugin,\n              schema: { items: indexPropertyItems, logicalOperator: 'or' },\n              state,\n            }),\n    };\n\n    if (schema.propertyNames?.$ref) {\n      indexKey = irSchemaToAst({\n        plugin,\n        schema: {\n          $ref: schema.propertyNames.$ref,\n        },\n        state,\n      }) as ts.TypeReferenceNode;\n    }\n  }\n\n  return tsc.typeInterfaceNode({\n    indexKey,\n    indexProperty,\n    properties: schemaProperties,\n    useLegacyResolution: false,\n  });\n};\n","import type ts from 'typescript';\n\nimport type { SchemaWithType } from '~/plugins';\nimport { tsc } from '~/tsc';\nimport { stringCase } from '~/utils/stringCase';\n\nimport type { IrSchemaToAstOptions } from '../../shared/types';\n\nexport const stringToAst = ({\n  plugin,\n  schema,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'string'>;\n}): ts.TypeNode => {\n  if (schema.const !== undefined) {\n    return tsc.literalTypeNode({\n      literal: tsc.stringLiteral({ text: schema.const as string }),\n    });\n  }\n\n  if (schema.format) {\n    if (schema.format === 'binary') {\n      return tsc.typeUnionNode({\n        types: [\n          tsc.typeReferenceNode({\n            typeName: 'Blob',\n          }),\n          tsc.typeReferenceNode({\n            typeName: 'File',\n          }),\n        ],\n      });\n    }\n\n    if (schema.format === 'date-time' || schema.format === 'date') {\n      // TODO: parser - add ability to skip type transformers\n      if (plugin.getPlugin('@hey-api/transformers')?.config.dates) {\n        return tsc.typeReferenceNode({ typeName: 'Date' });\n      }\n    }\n\n    if (schema.format === 'typeid' && typeof schema.example === 'string') {\n      const parts = String(schema.example).split('_');\n      parts.pop(); // remove the ID part\n      const type = parts.join('_');\n\n      const selector = plugin.api.selector('TypeID', type);\n      if (!plugin.getSymbol(selector)) {\n        const selectorTypeId = plugin.api.selector('TypeID');\n\n        if (!plugin.getSymbol(selectorTypeId)) {\n          const symbolTypeId = plugin.registerSymbol({\n            exported: true,\n            meta: {\n              kind: 'type',\n              path: [],\n            },\n            name: 'TypeID',\n            selector: selectorTypeId,\n          });\n          const nodeTypeId = tsc.typeAliasDeclaration({\n            exportType: symbolTypeId.exported,\n            name: symbolTypeId.placeholder,\n            type: tsc.templateLiteralType({\n              value: [\n                tsc.typeReferenceNode({ typeName: 'T' }),\n                '_',\n                tsc.keywordTypeNode({ keyword: 'string' }),\n              ],\n            }),\n            typeParameters: [\n              tsc.typeParameterDeclaration({\n                constraint: tsc.keywordTypeNode({\n                  keyword: 'string',\n                }),\n                name: 'T',\n              }),\n            ],\n          });\n          plugin.setSymbolValue(symbolTypeId, nodeTypeId);\n        }\n\n        const symbolTypeId = plugin.referenceSymbol(selectorTypeId);\n        const symbolTypeName = plugin.registerSymbol({\n          exported: true,\n          meta: {\n            kind: 'type',\n            path: [],\n          },\n          name: stringCase({\n            case: plugin.config.case,\n            value: `${type}_id`,\n          }),\n          selector,\n        });\n        const node = tsc.typeAliasDeclaration({\n          exportType: symbolTypeName.exported,\n          name: symbolTypeName.placeholder,\n          type: tsc.typeReferenceNode({\n            typeArguments: [\n              tsc.literalTypeNode({\n                literal: tsc.stringLiteral({ text: type }),\n              }),\n            ],\n            typeName: symbolTypeId.placeholder,\n          }),\n        });\n        plugin.setSymbolValue(symbolTypeName, node);\n      }\n      const symbol = plugin.referenceSymbol(selector);\n      return tsc.typeReferenceNode({ typeName: symbol.placeholder });\n    }\n  }\n\n  return tsc.keywordTypeNode({\n    keyword: 'string',\n  });\n};\n","import type ts from 'typescript';\n\nimport type { SchemaWithType } from '~/plugins';\nimport { toRef } from '~/plugins/shared/utils/refs';\nimport { tsc } from '~/tsc';\n\nimport type { IrSchemaToAstOptions } from '../../shared/types';\nimport { irSchemaToAst } from '../plugin';\n\nexport const tupleToAst = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'tuple'>;\n}): ts.TypeNode => {\n  let itemTypes: Array<ts.Expression | ts.TypeNode> = [];\n\n  if (schema.const && Array.isArray(schema.const)) {\n    itemTypes = schema.const.map((value) => {\n      const expression = tsc.valueToExpression({ value });\n      return expression ?? tsc.identifier({ text: plugin.config.topType });\n    });\n  } else if (schema.items) {\n    schema.items.forEach((item, index) => {\n      const type = irSchemaToAst({\n        plugin,\n        schema: item,\n        state: {\n          ...state,\n          path: toRef([...state.path.value, 'items', index]),\n        },\n      });\n      itemTypes.push(type);\n    });\n  }\n\n  return tsc.typeTupleNode({\n    types: itemTypes,\n  });\n};\n","import type ts from 'typescript';\n\nimport type { SchemaWithType } from '~/plugins';\nimport { tsc } from '~/tsc';\n\nimport type { IrSchemaToAstOptions } from '../../shared/types';\n\nexport const undefinedToAst = (\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _args: IrSchemaToAstOptions & {\n    schema: SchemaWithType<'undefined'>;\n  },\n): ts.TypeNode => {\n  const node = tsc.keywordTypeNode({\n    keyword: 'undefined',\n  });\n  return node;\n};\n","import type ts from 'typescript';\n\nimport type { SchemaWithType } from '~/plugins';\nimport { tsc } from '~/tsc';\n\nimport type { IrSchemaToAstOptions } from '../../shared/types';\n\nexport const unknownToAst = ({\n  plugin,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'unknown'>;\n}): ts.TypeNode => {\n  const node = tsc.keywordTypeNode({\n    keyword: plugin.config.topType,\n  });\n  return node;\n};\n","import type ts from 'typescript';\n\nimport type { SchemaWithType } from '~/plugins';\nimport { tsc } from '~/tsc';\n\nimport type { IrSchemaToAstOptions } from '../../shared/types';\n\nexport const voidToAst = (\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _args: IrSchemaToAstOptions & {\n    schema: SchemaWithType<'void'>;\n  },\n): ts.TypeNode => {\n  const node = tsc.keywordTypeNode({\n    keyword: 'void',\n  });\n  return node;\n};\n","import type ts from 'typescript';\n\nimport type { SchemaWithType } from '~/plugins';\n\nimport type { IrSchemaToAstOptions } from '../../shared/types';\nimport { arrayToAst } from './array';\nimport { booleanToAst } from './boolean';\nimport { enumToAst } from './enum';\nimport { neverToAst } from './never';\nimport { nullToAst } from './null';\nimport { numberToAst } from './number';\nimport { objectToAst } from './object';\nimport { stringToAst } from './string';\nimport { tupleToAst } from './tuple';\nimport { undefinedToAst } from './undefined';\nimport { unknownToAst } from './unknown';\nimport { voidToAst } from './void';\n\nexport const irSchemaWithTypeToAst = ({\n  schema,\n  ...args\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType;\n}): ts.TypeNode => {\n  const transformersPlugin = args.plugin.getPlugin('@hey-api/transformers');\n  if (transformersPlugin?.config.typeTransformers) {\n    for (const typeTransformer of transformersPlugin.config.typeTransformers) {\n      const typeNode = typeTransformer({ schema });\n      if (typeNode) {\n        return typeNode;\n      }\n    }\n  }\n\n  switch (schema.type) {\n    case 'array':\n      return arrayToAst({\n        ...args,\n        schema: schema as SchemaWithType<'array'>,\n      });\n    case 'boolean':\n      return booleanToAst({\n        ...args,\n        schema: schema as SchemaWithType<'boolean'>,\n      });\n    case 'enum':\n      return enumToAst({\n        ...args,\n        schema: schema as SchemaWithType<'enum'>,\n      });\n    case 'integer':\n    case 'number':\n      return numberToAst({\n        ...args,\n        schema: schema as SchemaWithType<'integer' | 'number'>,\n      });\n    case 'never':\n      return neverToAst({\n        ...args,\n        schema: schema as SchemaWithType<'never'>,\n      });\n    case 'null':\n      return nullToAst({\n        ...args,\n        schema: schema as SchemaWithType<'null'>,\n      });\n    case 'object':\n      return objectToAst({\n        ...args,\n        schema: schema as SchemaWithType<'object'>,\n      });\n    case 'string':\n      return stringToAst({\n        ...args,\n        schema: schema as SchemaWithType<'string'>,\n      });\n    case 'tuple':\n      return tupleToAst({\n        ...args,\n        schema: schema as SchemaWithType<'tuple'>,\n      });\n    case 'undefined':\n      return undefinedToAst({\n        ...args,\n        schema: schema as SchemaWithType<'undefined'>,\n      });\n    case 'unknown':\n      return unknownToAst({\n        ...args,\n        schema: schema as SchemaWithType<'unknown'>,\n      });\n    case 'void':\n      return voidToAst({\n        ...args,\n        schema: schema as SchemaWithType<'void'>,\n      });\n  }\n};\n","import type ts from 'typescript';\n\nimport { deduplicateSchema } from '~/ir/schema';\nimport type { IR } from '~/ir/types';\nimport { buildName } from '~/openApi/shared/utils/name';\nimport type { SchemaWithType } from '~/plugins';\nimport { toRefs } from '~/plugins/shared/utils/refs';\nimport { tsc } from '~/tsc';\nimport { pathToJsonPointer, refToName } from '~/utils/ref';\n\nimport { createClientOptions } from '../shared/clientOptions';\nimport { exportType } from '../shared/export';\nimport { operationToType } from '../shared/operation';\nimport type { IrSchemaToAstOptions, PluginState } from '../shared/types';\nimport { webhookToType } from '../shared/webhook';\nimport { createWebhooks } from '../shared/webhooks';\nimport type { HeyApiTypeScriptPlugin } from '../types';\nimport { irSchemaWithTypeToAst } from './toAst';\n\nexport const irSchemaToAst = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: IR.SchemaObject;\n}): ts.TypeNode => {\n  if (schema.$ref) {\n    const symbol = plugin.referenceSymbol(\n      plugin.api.selector('ref', schema.$ref),\n    );\n    return tsc.typeReferenceNode({ typeName: symbol.placeholder });\n  }\n\n  if (schema.type) {\n    return irSchemaWithTypeToAst({\n      plugin,\n      schema: schema as SchemaWithType,\n      state,\n    });\n  }\n\n  if (schema.items) {\n    schema = deduplicateSchema({ detectFormat: false, schema });\n    if (schema.items) {\n      const itemTypes: Array<ts.TypeNode> = [];\n\n      for (const item of schema.items) {\n        const type = irSchemaToAst({ plugin, schema: item, state });\n        itemTypes.push(type);\n      }\n\n      return schema.logicalOperator === 'and'\n        ? tsc.typeIntersectionNode({ types: itemTypes })\n        : tsc.typeUnionNode({ types: itemTypes });\n    }\n\n    return irSchemaToAst({ plugin, schema, state });\n  }\n\n  // catch-all fallback for failed schemas\n  return irSchemaWithTypeToAst({\n    plugin,\n    schema: {\n      type: 'unknown',\n    },\n    state,\n  });\n};\n\nconst handleComponent = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: IR.SchemaObject;\n}) => {\n  const type = irSchemaToAst({ plugin, schema, state });\n\n  // Don't tag enums as 'type' since they export runtime artifacts (values)\n  const isEnum = schema.type === 'enum' && plugin.config.enums.enabled;\n\n  const $ref = pathToJsonPointer(state.path.value);\n  const symbol = plugin.registerSymbol({\n    exported: true,\n    meta: {\n      kind: isEnum ? undefined : 'type',\n      path: state.path.value,\n      tags: state.tags?.value,\n    },\n    name: buildName({\n      config: plugin.config.definitions,\n      name: refToName($ref),\n    }),\n    selector: plugin.api.selector('ref', $ref),\n  });\n  exportType({\n    plugin,\n    schema,\n    symbol,\n    type,\n  });\n};\n\nexport const handlerV1: HeyApiTypeScriptPlugin['Handler'] = ({ plugin }) => {\n  // reserve identifier for ClientOptions\n  const symbolClientOptions = plugin.registerSymbol({\n    exported: true,\n    meta: {\n      kind: 'type',\n      path: [],\n    },\n    name: buildName({\n      config: {\n        case: plugin.config.case,\n      },\n      name: 'ClientOptions',\n    }),\n    selector: plugin.api.selector('ClientOptions'),\n  });\n  // reserve identifier for Webhooks\n  const symbolWebhooks = plugin.registerSymbol({\n    exported: true,\n    meta: {\n      kind: 'type',\n      path: [],\n    },\n    name: buildName({\n      config: {\n        case: plugin.config.case,\n      },\n      name: 'Webhooks',\n    }),\n    selector: plugin.api.selector('Webhooks'),\n  });\n\n  const servers: Array<IR.ServerObject> = [];\n  const webhookNames: Array<string> = [];\n\n  plugin.forEach(\n    'operation',\n    'parameter',\n    'requestBody',\n    'schema',\n    'server',\n    'webhook',\n    (event) => {\n      const state = toRefs<PluginState>({\n        path: event._path,\n        tags: event.tags,\n      });\n      switch (event.type) {\n        case 'operation':\n          operationToType({\n            operation: event.operation,\n            plugin,\n            state,\n          });\n          break;\n        case 'parameter':\n          handleComponent({\n            plugin,\n            schema: event.parameter.schema,\n            state,\n          });\n          break;\n        case 'requestBody':\n          handleComponent({\n            plugin,\n            schema: event.requestBody.schema,\n            state,\n          });\n          break;\n        case 'schema':\n          handleComponent({\n            plugin,\n            schema: event.schema,\n            state,\n          });\n          break;\n        case 'server':\n          servers.push(event.server);\n          break;\n        case 'webhook':\n          webhookNames.push(\n            webhookToType({\n              operation: event.operation,\n              plugin,\n              state,\n            }),\n          );\n          break;\n      }\n    },\n    {\n      order: 'declarations',\n    },\n  );\n\n  createClientOptions({ plugin, servers, symbolClientOptions });\n  createWebhooks({ plugin, symbolWebhooks, webhookNames });\n};\n","import type { Selector } from '@hey-api/codegen-core';\nimport type ts from 'typescript';\n\nimport type { Plugin } from '~/plugins';\n\nimport { irSchemaToAstV1 } from './v1/api';\n\ntype SelectorType =\n  | 'ClientOptions'\n  | 'data'\n  | 'error'\n  | 'errors'\n  | 'ref'\n  | 'response'\n  | 'responses'\n  | 'TypeID'\n  | 'webhook-payload'\n  | 'webhook-request'\n  | 'Webhooks';\n\nexport type IApi = {\n  schemaToType: (args: Parameters<typeof irSchemaToAstV1>[0]) => ts.TypeNode;\n  /**\n   * @param type Selector type.\n   * @param value Depends on `type`:\n   *  - `ClientOptions`: never\n   *  - `data`: `operation.id` string\n   *  - `error`: `operation.id` string\n   *  - `errors`: `operation.id` string\n   *  - `ref`: `$ref` JSON pointer\n   *  - `response`: `operation.id` string\n   *  - `responses`: `operation.id` string\n   *  - `TypeID`: `type` name string\n   *  - `webhook-payload`: `operation.id` string\n   *  - `webhook-request`: `operation.id` string\n   *  - `Webhooks`: never\n   * @returns Selector array\n   */\n  selector: (type: SelectorType, value?: string) => Selector;\n};\n\nexport class Api implements IApi {\n  constructor(public meta: Plugin.Name<'@hey-api/typescript'>) {}\n\n  selector(...args: ReadonlyArray<string | undefined>): Selector {\n    return [this.meta.name, ...(args as Selector)];\n  }\n\n  schemaToType(args: Parameters<typeof irSchemaToAstV1>[0]): ts.TypeNode {\n    return irSchemaToAstV1(args);\n  }\n}\n","import type { HeyApiTypeScriptPlugin } from './types';\nimport { handlerV1 } from './v1/plugin';\n\nexport const handler: HeyApiTypeScriptPlugin['Handler'] = (args) =>\n  handlerV1(args);\n","import { definePluginConfig } from '~/plugins/shared/utils/config';\n\nimport { Api } from './api';\nimport { handler } from './plugin';\nimport { handlerLegacy } from './plugin-legacy';\nimport type { HeyApiTypeScriptPlugin } from './types';\n\nexport const defaultConfig: HeyApiTypeScriptPlugin['Config'] = {\n  api: new Api({\n    name: '@hey-api/typescript',\n  }),\n  config: {\n    case: 'PascalCase',\n    exportFromIndex: true,\n    style: 'preserve',\n    topType: 'unknown',\n    tree: false,\n  },\n  handler,\n  handlerLegacy,\n  name: '@hey-api/typescript',\n  resolveConfig: (plugin, context) => {\n    plugin.config.definitions = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'PascalCase',\n        name: '{{name}}',\n      },\n      mappers: {\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.definitions,\n    });\n\n    plugin.config.enums = context.valueToObject({\n      defaultValue: {\n        case: 'SCREAMING_SNAKE_CASE',\n        constantsIgnoreNull: false,\n        enabled: Boolean(plugin.config.enums),\n        mode: 'javascript',\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        string: (mode) => ({ mode }),\n      },\n      value: plugin.config.enums,\n    });\n\n    plugin.config.errors = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'PascalCase',\n        error: '{{name}}Error',\n        name: '{{name}}Errors',\n      },\n      mappers: {\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.errors,\n    });\n\n    plugin.config.requests = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'PascalCase',\n        name: '{{name}}Data',\n      },\n      mappers: {\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.requests,\n    });\n\n    plugin.config.responses = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'PascalCase',\n        name: '{{name}}Responses',\n        response: '{{name}}Response',\n      },\n      mappers: {\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.responses,\n    });\n\n    plugin.config.webhooks = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'PascalCase',\n        name: '{{name}}WebhookRequest',\n        payload: '{{name}}WebhookPayload',\n      },\n      mappers: {\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.webhooks,\n    });\n  },\n};\n\n/**\n * Type helper for `@hey-api/typescript` plugin, returns {@link Plugin.Config} object\n */\nexport const defineConfig = definePluginConfig(defaultConfig);\n","import type { Selector } from '@hey-api/codegen-core';\n\nimport type { Plugin } from '~/plugins';\n\ntype SelectorType =\n  | '_JSONValue'\n  | 'AxiosError'\n  | 'createQueryKey'\n  | 'defineQueryOptions'\n  | 'QueryKey'\n  | 'queryOptionsFn'\n  | 'serializeQueryKeyValue'\n  | 'UseMutationOptions'\n  | 'UseQueryOptions';\n\nexport type IApi = {\n  /**\n   * @param type Selector type.\n   * @param value Depends on `type`:\n   *  - `_JSONValue`: never\n   *  - `AxiosError`: never\n   *  - `createQueryKey`: never\n   *  - `defineQueryOptions`: never\n   *  - `QueryKey`: never\n   *  - `queryOptionsFn`: `operation.id` string\n   *  - `serializeQueryKeyValue`: never\n   *  - `UseMutationOptions`: never\n   *  - `UseQueryOptions`: never\n   * @returns Selector array\n   */\n  selector: (type: SelectorType, value?: string) => Selector;\n};\n\nexport class Api implements IApi {\n  constructor(public meta: Plugin.Name<'@pinia/colada'>) {}\n\n  selector(...args: ReadonlyArray<string | undefined>): Selector {\n    return [this.meta.name, ...(args as Selector)];\n  }\n}\n","import type ts from 'typescript';\n\nimport type { IR } from '~/ir/types';\nimport { tsc } from '~/tsc';\n\nimport type { PiniaColadaPlugin } from './types';\n\nexport const handleMeta = (\n  plugin: PiniaColadaPlugin['Instance'],\n  operation: IR.OperationObject,\n  configPath: 'queryOptions' | 'mutationOptions',\n): ts.Expression | undefined => {\n  const metaFn = plugin.config[configPath].meta;\n  if (!metaFn) return;\n\n  const metaObject = metaFn(operation);\n  if (!Object.keys(metaObject).length) return;\n\n  return tsc.valueToExpression({ value: metaObject });\n};\n","import type { IR } from '~/ir/types';\nimport { getClientPlugin } from '~/plugins/@hey-api/client-core/utils';\nimport { operationOptionsType } from '~/plugins/@hey-api/sdk/shared/operation';\n\nimport type { PiniaColadaPlugin } from './types';\n\nexport const useTypeData = ({\n  operation,\n  plugin,\n}: {\n  operation: IR.OperationObject;\n  plugin: PiniaColadaPlugin['Instance'];\n}): string => {\n  const pluginSdk = plugin.getPluginOrThrow('@hey-api/sdk');\n  const typeData = operationOptionsType({ operation, plugin: pluginSdk });\n  return typeData;\n};\n\nexport const useTypeError = ({\n  operation,\n  plugin,\n}: {\n  operation: IR.OperationObject;\n  plugin: PiniaColadaPlugin['Instance'];\n}): string => {\n  const client = getClientPlugin(plugin.context.config);\n  const pluginTypeScript = plugin.getPluginOrThrow('@hey-api/typescript');\n\n  const symbolErrorType = plugin.getSymbol(\n    pluginTypeScript.api.selector('error', operation.id),\n  );\n\n  let typeErrorName: string | undefined = symbolErrorType?.placeholder;\n  if (!typeErrorName) {\n    typeErrorName = 'Error';\n  }\n  if (client.name === '@hey-api/client-axios') {\n    const symbol = plugin.referenceSymbol(plugin.api.selector('AxiosError'));\n    typeErrorName = `${symbol.placeholder}<${typeErrorName}>`;\n  }\n  return typeErrorName;\n};\n\nexport const useTypeResponse = ({\n  operation,\n  plugin,\n}: {\n  operation: IR.OperationObject;\n  plugin: PiniaColadaPlugin['Instance'];\n}): string => {\n  const pluginTypeScript = plugin.getPluginOrThrow('@hey-api/typescript');\n  const symbolResponseType = plugin.getSymbol(\n    pluginTypeScript.api.selector('response', operation.id),\n  );\n  return symbolResponseType?.placeholder || 'unknown';\n};\n","import { getClientPlugin } from '~/plugins/@hey-api/client-core/utils';\n\nimport type { PiniaColadaPlugin } from './types';\n\nexport const getPublicTypeData = ({\n  plugin,\n  typeData,\n}: {\n  plugin: PiniaColadaPlugin['Instance'];\n  typeData: string;\n}) => {\n  const client = getClientPlugin(plugin.context.config);\n  const isNuxtClient = client.name === '@hey-api/client-nuxt';\n  const strippedTypeData = isNuxtClient\n    ? `Omit<${typeData}, 'composable'>`\n    : typeData;\n\n  return { isNuxtClient, strippedTypeData };\n};\n","import type ts from 'typescript';\n\nimport type { IR } from '~/ir/types';\nimport { buildName } from '~/openApi/shared/utils/name';\nimport { createOperationComment } from '~/plugins/shared/utils/operation';\nimport { tsc } from '~/tsc';\n\nimport { handleMeta } from './meta';\nimport type { PiniaColadaPlugin } from './types';\nimport { useTypeData, useTypeError, useTypeResponse } from './useType';\nimport { getPublicTypeData } from './utils';\n\nexport const createMutationOptions = ({\n  operation,\n  plugin,\n  queryFn,\n}: {\n  operation: IR.OperationObject;\n  plugin: PiniaColadaPlugin['Instance'];\n  queryFn: string;\n}): void => {\n  const symbolMutationOptionsType = plugin.referenceSymbol(\n    plugin.api.selector('UseMutationOptions'),\n  );\n\n  const typeData = useTypeData({ operation, plugin });\n  const typeError = useTypeError({ operation, plugin });\n  const typeResponse = useTypeResponse({ operation, plugin });\n  const { isNuxtClient, strippedTypeData } = getPublicTypeData({\n    plugin,\n    typeData,\n  });\n  // TODO: better types syntax\n  const mutationType = isNuxtClient\n    ? `${symbolMutationOptionsType.placeholder}<${typeResponse}, ${strippedTypeData}, ${typeError}>`\n    : `${symbolMutationOptionsType.placeholder}<${typeResponse}, ${typeData}, ${typeError}>`;\n\n  const fnOptions = 'fnOptions';\n\n  const awaitSdkExpression = tsc.awaitExpression({\n    expression: tsc.callExpression({\n      functionName: queryFn,\n      parameters: [\n        tsc.objectExpression({\n          multiLine: true,\n          obj: [\n            {\n              spread: 'options',\n            },\n            {\n              spread: fnOptions,\n            },\n            {\n              key: 'throwOnError',\n              value: true,\n            },\n          ],\n        }),\n      ],\n    }),\n  });\n\n  const statements: Array<ts.Statement> = [];\n\n  if (plugin.getPluginOrThrow('@hey-api/sdk').config.responseStyle === 'data') {\n    statements.push(\n      tsc.returnVariable({\n        expression: awaitSdkExpression,\n      }),\n    );\n  } else {\n    statements.push(\n      tsc.constVariable({\n        destructure: true,\n        expression: awaitSdkExpression,\n        name: 'data',\n      }),\n      tsc.returnVariable({\n        expression: 'data',\n      }),\n    );\n  }\n\n  const mutationOptionsObj: Array<{ key: string; value: ts.Expression }> = [\n    {\n      key: 'mutation',\n      value: tsc.arrowFunction({\n        async: true,\n        multiLine: true,\n        parameters: [\n          isNuxtClient\n            ? {\n                name: fnOptions,\n                type: `Partial<${strippedTypeData}>`,\n              }\n            : { name: fnOptions },\n        ],\n        statements,\n      }),\n    },\n  ];\n\n  const meta = handleMeta(plugin, operation, 'mutationOptions');\n\n  if (meta) {\n    mutationOptionsObj.push({\n      key: 'meta',\n      value: meta,\n    });\n  }\n\n  const symbolMutationOptions = plugin.registerSymbol({\n    exported: true,\n    name: buildName({\n      config: plugin.config.mutationOptions,\n      name: operation.id,\n    }),\n  });\n  const statement = tsc.constVariable({\n    comment: plugin.config.comments\n      ? createOperationComment({ operation })\n      : undefined,\n    exportConst: symbolMutationOptions.exported,\n    expression: tsc.arrowFunction({\n      parameters: [\n        {\n          isRequired: false,\n          name: 'options',\n          type: `Partial<${strippedTypeData}>`,\n        },\n      ],\n      returnType: mutationType,\n      statements: [\n        tsc.returnStatement({\n          expression: tsc.objectExpression({\n            obj: mutationOptionsObj,\n          }),\n        }),\n      ],\n    }),\n    name: symbolMutationOptions.placeholder,\n  });\n  plugin.setSymbolValue(symbolMutationOptions, statement);\n};\n","import type { Symbol } from '@hey-api/codegen-core';\nimport type { Expression } from 'typescript';\n\nimport { clientFolderAbsolutePath } from '~/generate/client';\nimport { hasOperationDataRequired } from '~/ir/operation';\nimport type { IR } from '~/ir/types';\nimport { buildName } from '~/openApi/shared/utils/name';\nimport {\n  getClientBaseUrlKey,\n  getClientPlugin,\n} from '~/plugins/@hey-api/client-core/utils';\nimport { type Property, tsc } from '~/tsc';\n\nimport type { PiniaColadaPlugin } from './types';\nimport { useTypeData } from './useType';\nimport { getPublicTypeData } from './utils';\n\nconst TOptionsType = 'TOptions';\n\nconst optionsIdentifier = tsc.identifier({ text: 'options' });\n\nexport const createQueryKeyFunction = ({\n  plugin,\n}: {\n  plugin: PiniaColadaPlugin['Instance'];\n}) => {\n  const symbolCreateQueryKey = plugin.registerSymbol({\n    name: buildName({\n      config: {\n        case: plugin.config.case,\n      },\n      name: 'createQueryKey',\n    }),\n    selector: plugin.api.selector('createQueryKey'),\n  });\n  const symbolQueryKeyType = plugin.referenceSymbol(\n    plugin.api.selector('QueryKey'),\n  );\n  const symbolJsonValue = plugin.referenceSymbol(\n    plugin.api.selector('_JSONValue'),\n  );\n\n  const returnType = tsc.indexedAccessTypeNode({\n    indexType: tsc.literalTypeNode({\n      literal: tsc.ots.number(0),\n    }),\n    objectType: tsc.typeReferenceNode({\n      typeArguments: [tsc.typeReferenceNode({ typeName: TOptionsType })],\n      typeName: symbolQueryKeyType.placeholder,\n    }),\n  });\n\n  const baseUrlKey = getClientBaseUrlKey(plugin.context.config);\n\n  const sdkPlugin = plugin.getPluginOrThrow('@hey-api/sdk');\n  const symbolOptions = plugin.referenceSymbol(\n    sdkPlugin.api.selector('Options'),\n  );\n  const client = getClientPlugin(plugin.context.config);\n  const symbolClient =\n    client.api && 'selector' in client.api\n      ? plugin.getSymbol(\n          // @ts-expect-error\n          client.api.selector('client'),\n        )\n      : undefined;\n\n  const clientModule = clientFolderAbsolutePath(plugin.context.config);\n  const symbolSerializeQueryValue = plugin.registerSymbol({\n    external: clientModule,\n    name: 'serializeQueryKeyValue',\n  });\n\n  const fn = tsc.constVariable({\n    expression: tsc.arrowFunction({\n      multiLine: true,\n      parameters: [\n        {\n          name: 'id',\n          type: tsc.typeReferenceNode({ typeName: 'string' }),\n        },\n        {\n          isRequired: false,\n          name: 'options',\n          type: tsc.typeReferenceNode({ typeName: TOptionsType }),\n        },\n        {\n          isRequired: false,\n          name: 'tags',\n          type: tsc.typeReferenceNode({ typeName: 'ReadonlyArray<string>' }),\n        },\n      ],\n      returnType: tsc.typeTupleNode({\n        types: [returnType],\n      }),\n      statements: [\n        tsc.constVariable({\n          assertion: returnType,\n          expression: tsc.objectExpression({\n            multiLine: false,\n            obj: [\n              { key: '_id', value: tsc.identifier({ text: 'id' }) },\n              {\n                key: baseUrlKey,\n                value: tsc.identifier({\n                  text: `options?.${baseUrlKey} || (options?.client ?? ${symbolClient?.placeholder}).getConfig().${baseUrlKey}`,\n                }),\n              },\n            ],\n          }),\n          name: 'params',\n          typeName: returnType,\n        }),\n        tsc.ifStatement({\n          expression: tsc.identifier({ text: 'tags' }),\n          thenStatement: tsc.block({\n            statements: [\n              tsc.expressionToStatement({\n                expression: tsc.binaryExpression({\n                  left: tsc.propertyAccessExpression({\n                    expression: 'params',\n                    name: 'tags',\n                  }),\n                  right: tsc.asExpression({\n                    expression: tsc.asExpression({\n                      expression: tsc.identifier({ text: 'tags' }),\n                      type: tsc.keywordTypeNode({ keyword: 'unknown' }),\n                    }),\n                    type: tsc.typeReferenceNode({\n                      typeName: symbolJsonValue.placeholder,\n                    }),\n                  }),\n                }),\n              }),\n            ],\n          }),\n        }),\n        tsc.ifStatement({\n          expression: tsc.binaryExpression({\n            left: tsc.propertyAccessExpression({\n              expression: optionsIdentifier,\n              isOptional: true,\n              name: tsc.identifier({ text: 'body' }),\n            }),\n            operator: '!==',\n            right: 'undefined',\n          }),\n          thenStatement: tsc.block({\n            statements: [\n              tsc.constVariable({\n                expression: tsc.callExpression({\n                  functionName: symbolSerializeQueryValue.placeholder,\n                  parameters: [\n                    tsc.propertyAccessExpression({\n                      expression: 'options',\n                      name: 'body',\n                    }),\n                  ],\n                }),\n                name: 'normalizedBody',\n              }),\n              tsc.ifStatement({\n                expression: tsc.binaryExpression({\n                  left: tsc.identifier({ text: 'normalizedBody' }),\n                  operator: '!==',\n                  right: 'undefined',\n                }),\n                thenStatement: tsc.block({\n                  statements: [\n                    tsc.expressionToStatement({\n                      expression: tsc.binaryExpression({\n                        left: tsc.propertyAccessExpression({\n                          expression: 'params',\n                          name: 'body',\n                        }),\n                        right: tsc.identifier({ text: 'normalizedBody' }),\n                      }),\n                    }),\n                  ],\n                }),\n              }),\n            ],\n          }),\n        }),\n        tsc.ifStatement({\n          expression: tsc.propertyAccessExpression({\n            expression: optionsIdentifier,\n            isOptional: true,\n            name: tsc.identifier({ text: 'path' }),\n          }),\n          thenStatement: tsc.block({\n            statements: [\n              tsc.expressionToStatement({\n                expression: tsc.binaryExpression({\n                  left: tsc.propertyAccessExpression({\n                    expression: 'params',\n                    name: 'path',\n                  }),\n                  right: tsc.propertyAccessExpression({\n                    expression: 'options',\n                    name: 'path',\n                  }),\n                }),\n              }),\n            ],\n          }),\n        }),\n        tsc.ifStatement({\n          expression: tsc.binaryExpression({\n            left: tsc.propertyAccessExpression({\n              expression: optionsIdentifier,\n              isOptional: true,\n              name: tsc.identifier({ text: 'query' }),\n            }),\n            operator: '!==',\n            right: 'undefined',\n          }),\n          thenStatement: tsc.block({\n            statements: [\n              tsc.constVariable({\n                expression: tsc.callExpression({\n                  functionName: symbolSerializeQueryValue.placeholder,\n                  parameters: [\n                    tsc.propertyAccessExpression({\n                      expression: 'options',\n                      name: 'query',\n                    }),\n                  ],\n                }),\n                name: 'normalizedQuery',\n              }),\n              tsc.ifStatement({\n                expression: tsc.binaryExpression({\n                  left: tsc.identifier({ text: 'normalizedQuery' }),\n                  operator: '!==',\n                  right: 'undefined',\n                }),\n                thenStatement: tsc.block({\n                  statements: [\n                    tsc.expressionToStatement({\n                      expression: tsc.binaryExpression({\n                        left: tsc.propertyAccessExpression({\n                          expression: 'params',\n                          name: 'query',\n                        }),\n                        right: tsc.identifier({ text: 'normalizedQuery' }),\n                      }),\n                    }),\n                  ],\n                }),\n              }),\n            ],\n          }),\n        }),\n        tsc.returnStatement({\n          expression: tsc.arrayLiteralExpression({\n            elements: [tsc.identifier({ text: 'params' })],\n          }),\n        }),\n      ],\n      types: [\n        {\n          extends: tsc.typeReferenceNode({\n            typeName: tsc.identifier({ text: symbolOptions.placeholder }),\n          }),\n          name: TOptionsType,\n        },\n      ],\n    }),\n    name: symbolCreateQueryKey.placeholder,\n  });\n  plugin.setSymbolValue(symbolCreateQueryKey, fn);\n};\n\nconst createQueryKeyLiteral = ({\n  id,\n  operation,\n  plugin,\n}: {\n  id: string;\n  operation: IR.OperationObject;\n  plugin: PiniaColadaPlugin['Instance'];\n}) => {\n  const config = plugin.config.queryKeys;\n  let tagsExpression: Expression | undefined;\n  if (config.tags && operation.tags && operation.tags.length > 0) {\n    tagsExpression = tsc.arrayLiteralExpression({\n      elements: operation.tags.map((tag) => tsc.stringLiteral({ text: tag })),\n    });\n  }\n\n  const symbolCreateQueryKey = plugin.referenceSymbol(\n    plugin.api.selector('createQueryKey'),\n  );\n  const createQueryKeyCallExpression = tsc.callExpression({\n    functionName: symbolCreateQueryKey.placeholder,\n    parameters: [tsc.ots.string(id), 'options', tagsExpression],\n  });\n  return createQueryKeyCallExpression;\n};\n\nexport const createQueryKeyType = ({\n  plugin,\n}: {\n  plugin: PiniaColadaPlugin['Instance'];\n}) => {\n  const symbolJsonValue = plugin.referenceSymbol(\n    plugin.api.selector('_JSONValue'),\n  );\n\n  const properties: Array<Property> = [\n    { name: '_id', type: tsc.keywordTypeNode({ keyword: 'string' }) },\n    {\n      isRequired: false,\n      name: getClientBaseUrlKey(plugin.context.config),\n      type: tsc.typeReferenceNode({ typeName: symbolJsonValue.placeholder }),\n    },\n    {\n      isRequired: false,\n      name: 'body',\n      type: tsc.typeReferenceNode({ typeName: symbolJsonValue.placeholder }),\n    },\n    {\n      isRequired: false,\n      name: 'query',\n      type: tsc.typeReferenceNode({ typeName: symbolJsonValue.placeholder }),\n    },\n    {\n      isRequired: false,\n      name: 'tags',\n      type: tsc.typeReferenceNode({ typeName: symbolJsonValue.placeholder }),\n    },\n  ];\n\n  const sdkPlugin = plugin.getPluginOrThrow('@hey-api/sdk');\n  const symbolOptions = plugin.referenceSymbol(\n    sdkPlugin.api.selector('Options'),\n  );\n  const symbolQueryKeyType = plugin.registerSymbol({\n    exported: true,\n    meta: { kind: 'type' },\n    name: 'QueryKey',\n    selector: plugin.api.selector('QueryKey'),\n  });\n  const queryKeyType = tsc.typeAliasDeclaration({\n    exportType: symbolQueryKeyType.exported,\n    name: symbolQueryKeyType.placeholder,\n    type: tsc.typeTupleNode({\n      types: [\n        tsc.typeIntersectionNode({\n          types: [\n            tsc.typeReferenceNode({\n              typeName: `Pick<${TOptionsType}, 'path'>`,\n            }),\n            tsc.typeInterfaceNode({\n              properties,\n              useLegacyResolution: true,\n            }),\n          ],\n        }),\n      ],\n    }),\n    typeParameters: [\n      {\n        extends: tsc.typeReferenceNode({\n          typeName: tsc.identifier({ text: symbolOptions.placeholder }),\n        }),\n        name: TOptionsType,\n      },\n    ],\n  });\n  plugin.setSymbolValue(symbolQueryKeyType, queryKeyType);\n};\n\nexport const queryKeyStatement = ({\n  operation,\n  plugin,\n  symbol,\n}: {\n  operation: IR.OperationObject;\n  plugin: PiniaColadaPlugin['Instance'];\n  symbol: Symbol;\n}) => {\n  const typeData = useTypeData({ operation, plugin });\n  const { strippedTypeData } = getPublicTypeData({ plugin, typeData });\n  const statement = tsc.constVariable({\n    exportConst: symbol.exported,\n    expression: tsc.arrowFunction({\n      parameters: [\n        {\n          isRequired: hasOperationDataRequired(operation),\n          name: 'options',\n          type: strippedTypeData,\n        },\n      ],\n      statements: createQueryKeyLiteral({\n        id: operation.id,\n        operation,\n        plugin,\n      }),\n    }),\n    name: symbol.placeholder,\n  });\n  return statement;\n};\n","import type ts from 'typescript';\n\nimport type { IR } from '~/ir/types';\nimport { buildName } from '~/openApi/shared/utils/name';\nimport {\n  createOperationComment,\n  hasOperationSse,\n  isOperationOptionsRequired,\n} from '~/plugins/shared/utils/operation';\nimport { tsc } from '~/tsc';\n\nimport { handleMeta } from './meta';\nimport {\n  createQueryKeyFunction,\n  createQueryKeyType,\n  queryKeyStatement,\n} from './queryKey';\nimport type { PiniaColadaPlugin } from './types';\nimport { useTypeData } from './useType';\nimport { getPublicTypeData } from './utils';\n\nconst optionsParamName = 'options';\nconst fnOptions = 'context';\n\nexport const createQueryOptions = ({\n  operation,\n  plugin,\n  queryFn,\n}: {\n  operation: IR.OperationObject;\n  plugin: PiniaColadaPlugin['Instance'];\n  queryFn: string;\n}): void => {\n  if (hasOperationSse({ operation })) {\n    return;\n  }\n\n  const isRequiredOptions = isOperationOptionsRequired({\n    context: plugin.context,\n    operation,\n  });\n  if (!plugin.getSymbol(plugin.api.selector('createQueryKey'))) {\n    createQueryKeyType({ plugin });\n    createQueryKeyFunction({ plugin });\n  }\n\n  let keyExpression: ts.Expression;\n  if (plugin.config.queryKeys.enabled) {\n    const symbolQueryKey = plugin.registerSymbol({\n      exported: true,\n      name: buildName({\n        config: plugin.config.queryKeys,\n        name: operation.id,\n      }),\n    });\n    const node = queryKeyStatement({\n      operation,\n      plugin,\n      symbol: symbolQueryKey,\n    });\n    plugin.setSymbolValue(symbolQueryKey, node);\n    keyExpression = tsc.callExpression({\n      functionName: symbolQueryKey.placeholder,\n      parameters: [optionsParamName],\n    });\n  } else {\n    const symbolCreateQueryKey = plugin.referenceSymbol(\n      plugin.api.selector('createQueryKey'),\n    );\n    // Optionally include tags when configured\n    let tagsExpr: ts.Expression | undefined;\n    if (\n      plugin.config.queryKeys.tags &&\n      operation.tags &&\n      operation.tags.length > 0\n    ) {\n      tagsExpr = tsc.arrayLiteralExpression({\n        elements: operation.tags.map((t) => tsc.stringLiteral({ text: t })),\n      });\n    }\n    keyExpression = tsc.callExpression({\n      functionName: symbolCreateQueryKey.placeholder,\n      parameters: [tsc.ots.string(operation.id), optionsParamName, tagsExpr],\n    });\n  }\n\n  const typeData = useTypeData({ operation, plugin });\n  const { strippedTypeData } = getPublicTypeData({\n    plugin,\n    typeData,\n  });\n  const awaitSdkExpression = tsc.awaitExpression({\n    expression: tsc.callExpression({\n      functionName: queryFn,\n      parameters: [\n        tsc.objectExpression({\n          multiLine: true,\n          obj: [\n            { spread: optionsParamName },\n            { spread: fnOptions },\n            { key: 'throwOnError', value: true },\n          ],\n        }),\n      ],\n    }),\n  });\n\n  const statements: Array<ts.Statement> = [];\n  if (plugin.getPluginOrThrow('@hey-api/sdk').config.responseStyle === 'data') {\n    statements.push(\n      tsc.returnVariable({\n        expression: awaitSdkExpression,\n      }),\n    );\n  } else {\n    statements.push(\n      tsc.constVariable({\n        destructure: true,\n        expression: awaitSdkExpression,\n        name: 'data',\n      }),\n      tsc.returnVariable({\n        expression: 'data',\n      }),\n    );\n  }\n\n  const queryOptionsObj: Array<{ key: string; value: ts.Expression }> = [\n    {\n      key: 'key',\n      value: keyExpression,\n    },\n    {\n      key: 'query',\n      value: tsc.arrowFunction({\n        async: true,\n        multiLine: true,\n        parameters: [{ name: fnOptions }],\n        statements,\n      }),\n    },\n  ];\n\n  const meta = handleMeta(plugin, operation, 'queryOptions');\n  if (meta) {\n    queryOptionsObj.push({\n      key: 'meta',\n      value: meta,\n    });\n  }\n\n  const symbolQueryOptionsFn = plugin.registerSymbol({\n    exported: true,\n    name: buildName({\n      config: plugin.config.queryOptions,\n      name: operation.id,\n    }),\n    selector: plugin.api.selector('queryOptionsFn', operation.id),\n  });\n  const symbolDefineQueryOptions = plugin.registerSymbol({\n    external: plugin.name,\n    name: 'defineQueryOptions',\n    selector: plugin.api.selector('defineQueryOptions'),\n  });\n  const statement = tsc.constVariable({\n    comment: plugin.config.comments\n      ? createOperationComment({ operation })\n      : undefined,\n    exportConst: symbolQueryOptionsFn.exported,\n    expression: tsc.callExpression({\n      functionName: symbolDefineQueryOptions.placeholder,\n      parameters: [\n        tsc.arrowFunction({\n          parameters: [\n            {\n              isRequired: isRequiredOptions,\n              name: optionsParamName,\n              type: strippedTypeData,\n            },\n          ],\n          statements: tsc.objectExpression({ obj: queryOptionsObj }),\n        }),\n      ],\n    }),\n    name: symbolQueryOptionsFn.placeholder,\n  });\n  plugin.setSymbolValue(symbolQueryOptionsFn, statement);\n};\n","import { operationClasses } from '~/plugins/@hey-api/sdk/shared/operation';\nimport { stringCase } from '~/utils/stringCase';\n\nimport { createMutationOptions } from './mutationOptions';\nimport { createQueryOptions } from './queryOptions';\nimport type { PiniaColadaPlugin } from './types';\n\nexport const handler: PiniaColadaPlugin['Handler'] = ({ plugin }) => {\n  plugin.registerSymbol({\n    external: plugin.name,\n    meta: {\n      kind: 'type',\n    },\n    name: 'UseMutationOptions',\n    selector: plugin.api.selector('UseMutationOptions'),\n  });\n  plugin.registerSymbol({\n    external: plugin.name,\n    meta: {\n      kind: 'type',\n    },\n    name: 'UseQueryOptions',\n    selector: plugin.api.selector('UseQueryOptions'),\n  });\n  plugin.registerSymbol({\n    external: plugin.name,\n    meta: {\n      kind: 'type',\n    },\n    name: '_JSONValue',\n    selector: plugin.api.selector('_JSONValue'),\n  });\n  plugin.registerSymbol({\n    external: 'axios',\n    meta: {\n      kind: 'type',\n    },\n    name: 'AxiosError',\n    selector: plugin.api.selector('AxiosError'),\n  });\n\n  const sdkPlugin = plugin.getPluginOrThrow('@hey-api/sdk');\n\n  plugin.forEach(\n    'operation',\n    ({ operation }) => {\n      const classes = sdkPlugin.config.asClass\n        ? operationClasses({\n            context: plugin.context,\n            operation,\n            plugin: sdkPlugin,\n          })\n        : undefined;\n      const entry = classes ? classes.values().next().value : undefined;\n      const queryFn =\n        // TODO: this should use class graph to determine correct path string\n        // as it's really easy to break once we change the class casing\n        entry\n          ? [\n              plugin.referenceSymbol(\n                sdkPlugin.api.selector('class', entry.path[0]),\n              ).placeholder,\n              ...entry.path.slice(1).map((className: string) =>\n                stringCase({\n                  case: 'camelCase',\n                  value: className,\n                }),\n              ),\n              entry.methodName,\n            ]\n              .filter(Boolean)\n              .join('.')\n          : plugin.referenceSymbol(\n              sdkPlugin.api.selector('function', operation.id),\n            ).placeholder;\n\n      if (plugin.hooks.operation.isQuery(operation)) {\n        if (plugin.config.queryOptions.enabled) {\n          createQueryOptions({ operation, plugin, queryFn });\n        }\n      }\n\n      if (plugin.hooks.operation.isMutation(operation)) {\n        if (plugin.config.mutationOptions.enabled) {\n          createMutationOptions({ operation, plugin, queryFn });\n        }\n      }\n    },\n    {\n      order: 'declarations',\n    },\n  );\n};\n","import { definePluginConfig } from '~/plugins/shared/utils/config';\n\nimport { Api } from './api';\nimport { handler } from './plugin';\nimport type { PiniaColadaPlugin } from './types';\n\nexport const defaultConfig: PiniaColadaPlugin['Config'] = {\n  api: new Api({\n    name: '@pinia/colada',\n  }),\n  config: {\n    case: 'camelCase',\n    comments: true,\n    exportFromIndex: false,\n  },\n  dependencies: ['@hey-api/typescript', '@hey-api/sdk'],\n  handler: handler as PiniaColadaPlugin['Handler'],\n  name: '@pinia/colada',\n  resolveConfig: (plugin, context) => {\n    plugin.config.mutationOptions = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}Mutation',\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.mutationOptions,\n    });\n\n    plugin.config.queryKeys = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}QueryKey',\n        tags: false,\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.queryKeys,\n    });\n\n    plugin.config.queryOptions = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}Query',\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.queryOptions,\n    });\n  },\n};\n\n/**\n * Type helper for `@pinia/colada` plugin, returns {@link Plugin.Config} object\n */\nexport const defineConfig = definePluginConfig(defaultConfig);\n","import type ts from 'typescript';\n\nimport type { IR } from '~/ir/types';\nimport { tsc } from '~/tsc';\n\nimport type { PluginInstance } from './types';\n\nexport const handleMeta = (\n  plugin: PluginInstance,\n  operation: IR.OperationObject,\n  configPath: 'queryOptions' | 'infiniteQueryOptions' | 'mutationOptions',\n): ts.Expression | undefined => {\n  const metaFn = plugin.config[configPath].meta;\n  if (!metaFn) return;\n\n  const metaObject = metaFn(operation);\n  if (!Object.keys(metaObject).length) return;\n\n  return tsc.valueToExpression({ value: metaObject });\n};\n","import type { IR } from '~/ir/types';\nimport { getClientPlugin } from '~/plugins/@hey-api/client-core/utils';\nimport { operationOptionsType } from '~/plugins/@hey-api/sdk/shared/operation';\n\nimport type { PluginInstance } from './types';\n\nexport const useTypeData = ({\n  operation,\n  plugin,\n}: {\n  operation: IR.OperationObject;\n  plugin: PluginInstance;\n}): string => {\n  const pluginSdk = plugin.getPluginOrThrow('@hey-api/sdk');\n  const typeData = operationOptionsType({ operation, plugin: pluginSdk });\n  return typeData;\n};\n\nexport const useTypeError = ({\n  operation,\n  plugin,\n}: {\n  operation: IR.OperationObject;\n  plugin: PluginInstance;\n}): string => {\n  const client = getClientPlugin(plugin.context.config);\n  const pluginTypeScript = plugin.getPluginOrThrow('@hey-api/typescript');\n\n  const symbolErrorType = plugin.getSymbol(\n    pluginTypeScript.api.selector('error', operation.id),\n  );\n\n  let typeErrorName: string | undefined = symbolErrorType?.placeholder;\n  if (!typeErrorName) {\n    const symbol = plugin.referenceSymbol(plugin.api.selector('DefaultError'));\n    typeErrorName = symbol.placeholder;\n  }\n  if (client.name === '@hey-api/client-axios') {\n    const symbol = plugin.referenceSymbol(plugin.api.selector('AxiosError'));\n    typeErrorName = `${symbol.placeholder}<${typeErrorName}>`;\n  }\n  return typeErrorName;\n};\n\nexport const useTypeResponse = ({\n  operation,\n  plugin,\n}: {\n  operation: IR.OperationObject;\n  plugin: PluginInstance;\n}): string => {\n  const pluginTypeScript = plugin.getPluginOrThrow('@hey-api/typescript');\n  const symbolResponseType = plugin.getSymbol(\n    pluginTypeScript.api.selector('response', operation.id),\n  );\n  return symbolResponseType?.placeholder || 'unknown';\n};\n","import type { Symbol } from '@hey-api/codegen-core';\nimport type { Expression } from 'typescript';\n\nimport { hasOperationDataRequired } from '~/ir/operation';\nimport type { IR } from '~/ir/types';\nimport { buildName } from '~/openApi/shared/utils/name';\nimport {\n  getClientBaseUrlKey,\n  getClientPlugin,\n} from '~/plugins/@hey-api/client-core/utils';\nimport { type Property, tsc } from '~/tsc';\n\nimport type { PluginInstance } from './types';\nimport { useTypeData } from './useType';\n\nconst TOptionsType = 'TOptions';\n\nconst infiniteIdentifier = tsc.identifier({ text: 'infinite' });\nconst optionsIdentifier = tsc.identifier({ text: 'options' });\n\nexport const createQueryKeyFunction = ({\n  plugin,\n}: {\n  plugin: PluginInstance;\n}) => {\n  const symbolCreateQueryKey = plugin.registerSymbol({\n    name: buildName({\n      config: {\n        case: plugin.config.case,\n      },\n      name: 'createQueryKey',\n    }),\n    selector: plugin.api.selector('createQueryKey'),\n  });\n  const symbolQueryKeyType = plugin.referenceSymbol(\n    plugin.api.selector('QueryKey'),\n  );\n\n  const returnType = tsc.indexedAccessTypeNode({\n    indexType: tsc.literalTypeNode({\n      literal: tsc.ots.number(0),\n    }),\n    objectType: tsc.typeReferenceNode({\n      typeArguments: [tsc.typeReferenceNode({ typeName: TOptionsType })],\n      typeName: symbolQueryKeyType.placeholder,\n    }),\n  });\n\n  const baseUrlKey = getClientBaseUrlKey(plugin.context.config);\n\n  const client = getClientPlugin(plugin.context.config);\n  const symbolClient =\n    client.api && 'selector' in client.api\n      ? plugin.getSymbol(\n          // @ts-expect-error\n          client.api.selector('client'),\n        )\n      : undefined;\n\n  const sdkPlugin = plugin.getPluginOrThrow('@hey-api/sdk');\n  const symbolOptions = plugin.referenceSymbol(\n    sdkPlugin.api.selector('Options'),\n  );\n\n  const fn = tsc.constVariable({\n    expression: tsc.arrowFunction({\n      multiLine: true,\n      parameters: [\n        {\n          name: 'id',\n          type: tsc.typeReferenceNode({ typeName: 'string' }),\n        },\n        {\n          isRequired: false,\n          name: 'options',\n          type: tsc.typeReferenceNode({ typeName: TOptionsType }),\n        },\n        {\n          isRequired: false,\n          name: 'infinite',\n          type: tsc.typeReferenceNode({ typeName: 'boolean' }),\n        },\n        {\n          isRequired: false,\n          name: 'tags',\n          type: tsc.typeReferenceNode({ typeName: 'ReadonlyArray<string>' }),\n        },\n      ],\n      returnType: tsc.typeTupleNode({\n        types: [returnType],\n      }),\n      statements: [\n        tsc.constVariable({\n          assertion: returnType,\n          expression: tsc.objectExpression({\n            multiLine: false,\n            obj: [\n              {\n                key: '_id',\n                value: tsc.identifier({ text: 'id' }),\n              },\n              {\n                key: baseUrlKey,\n                value: tsc.identifier({\n                  text: `options?.${baseUrlKey} || (options?.client ?? ${symbolClient?.placeholder}).getConfig().${baseUrlKey}`,\n                }),\n              },\n            ],\n          }),\n          name: 'params',\n          typeName: returnType,\n        }),\n        tsc.ifStatement({\n          expression: infiniteIdentifier,\n          thenStatement: tsc.block({\n            statements: [\n              tsc.expressionToStatement({\n                expression: tsc.binaryExpression({\n                  left: tsc.propertyAccessExpression({\n                    expression: 'params',\n                    name: '_infinite',\n                  }),\n                  right: infiniteIdentifier,\n                }),\n              }),\n            ],\n          }),\n        }),\n        tsc.ifStatement({\n          expression: tsc.identifier({ text: 'tags' }),\n          thenStatement: tsc.block({\n            statements: [\n              tsc.expressionToStatement({\n                expression: tsc.binaryExpression({\n                  left: tsc.propertyAccessExpression({\n                    expression: 'params',\n                    name: 'tags',\n                  }),\n                  right: tsc.identifier({ text: 'tags' }),\n                }),\n              }),\n            ],\n          }),\n        }),\n        tsc.ifStatement({\n          expression: tsc.propertyAccessExpression({\n            expression: optionsIdentifier,\n            isOptional: true,\n            name: tsc.identifier({ text: 'body' }),\n          }),\n          thenStatement: tsc.block({\n            statements: [\n              tsc.expressionToStatement({\n                expression: tsc.binaryExpression({\n                  left: tsc.propertyAccessExpression({\n                    expression: 'params',\n                    name: 'body',\n                  }),\n                  right: tsc.propertyAccessExpression({\n                    expression: 'options',\n                    name: 'body',\n                  }),\n                }),\n              }),\n            ],\n          }),\n        }),\n        tsc.ifStatement({\n          expression: tsc.propertyAccessExpression({\n            expression: optionsIdentifier,\n            isOptional: true,\n            name: tsc.identifier({ text: 'headers' }),\n          }),\n          thenStatement: tsc.block({\n            statements: [\n              tsc.expressionToStatement({\n                expression: tsc.binaryExpression({\n                  left: tsc.propertyAccessExpression({\n                    expression: 'params',\n                    name: 'headers',\n                  }),\n                  right: tsc.propertyAccessExpression({\n                    expression: 'options',\n                    name: 'headers',\n                  }),\n                }),\n              }),\n            ],\n          }),\n        }),\n        tsc.ifStatement({\n          expression: tsc.propertyAccessExpression({\n            expression: optionsIdentifier,\n            isOptional: true,\n            name: tsc.identifier({ text: 'path' }),\n          }),\n          thenStatement: tsc.block({\n            statements: [\n              tsc.expressionToStatement({\n                expression: tsc.binaryExpression({\n                  left: tsc.propertyAccessExpression({\n                    expression: 'params',\n                    name: 'path',\n                  }),\n                  right: tsc.propertyAccessExpression({\n                    expression: 'options',\n                    name: 'path',\n                  }),\n                }),\n              }),\n            ],\n          }),\n        }),\n        tsc.ifStatement({\n          expression: tsc.propertyAccessExpression({\n            expression: optionsIdentifier,\n            isOptional: true,\n            name: tsc.identifier({ text: 'query' }),\n          }),\n          thenStatement: tsc.block({\n            statements: [\n              tsc.expressionToStatement({\n                expression: tsc.binaryExpression({\n                  left: tsc.propertyAccessExpression({\n                    expression: 'params',\n                    name: 'query',\n                  }),\n                  right: tsc.propertyAccessExpression({\n                    expression: 'options',\n                    name: 'query',\n                  }),\n                }),\n              }),\n            ],\n          }),\n        }),\n        tsc.returnStatement({\n          expression: tsc.arrayLiteralExpression({\n            elements: [tsc.identifier({ text: 'params' })],\n          }),\n        }),\n      ],\n      types: [\n        {\n          extends: tsc.typeReferenceNode({\n            typeName: tsc.identifier({ text: symbolOptions.placeholder }),\n          }),\n          name: TOptionsType,\n        },\n      ],\n    }),\n    name: symbolCreateQueryKey.placeholder,\n  });\n  plugin.setSymbolValue(symbolCreateQueryKey, fn);\n};\n\nconst createQueryKeyLiteral = ({\n  id,\n  isInfinite,\n  operation,\n  plugin,\n}: {\n  id: string;\n  isInfinite?: boolean;\n  operation: IR.OperationObject;\n  plugin: PluginInstance;\n}) => {\n  const config = isInfinite\n    ? plugin.config.infiniteQueryKeys\n    : plugin.config.queryKeys;\n  let tagsExpression: Expression | undefined;\n  if (config.tags && operation.tags && operation.tags.length > 0) {\n    tagsExpression = tsc.arrayLiteralExpression({\n      elements: operation.tags.map((tag) => tsc.stringLiteral({ text: tag })),\n    });\n  }\n\n  const symbolCreateQueryKey = plugin.referenceSymbol(\n    plugin.api.selector('createQueryKey'),\n  );\n  const createQueryKeyCallExpression = tsc.callExpression({\n    functionName: symbolCreateQueryKey.placeholder,\n    parameters: [\n      tsc.ots.string(id),\n      'options',\n      isInfinite || tagsExpression\n        ? tsc.ots.boolean(Boolean(isInfinite))\n        : undefined,\n      tagsExpression,\n    ],\n  });\n  return createQueryKeyCallExpression;\n};\n\nexport const createQueryKeyType = ({ plugin }: { plugin: PluginInstance }) => {\n  const properties: Array<Property> = [\n    {\n      name: '_id',\n      type: tsc.keywordTypeNode({ keyword: 'string' }),\n    },\n    {\n      isRequired: false,\n      name: '_infinite',\n      type: tsc.keywordTypeNode({ keyword: 'boolean' }),\n    },\n    {\n      isRequired: false,\n      name: 'tags',\n      type: tsc.typeReferenceNode({ typeName: 'ReadonlyArray<string>' }),\n    },\n  ];\n\n  const sdkPlugin = plugin.getPluginOrThrow('@hey-api/sdk');\n  const symbolOptions = plugin.referenceSymbol(\n    sdkPlugin.api.selector('Options'),\n  );\n  const symbolQueryKeyType = plugin.registerSymbol({\n    exported: true,\n    meta: {\n      kind: 'type',\n    },\n    name: 'QueryKey',\n    selector: plugin.api.selector('QueryKey'),\n  });\n  const queryKeyType = tsc.typeAliasDeclaration({\n    exportType: symbolQueryKeyType.exported,\n    name: symbolQueryKeyType.placeholder,\n    type: tsc.typeTupleNode({\n      types: [\n        tsc.typeIntersectionNode({\n          types: [\n            tsc.typeReferenceNode({\n              typeName: `Pick<${TOptionsType}, '${getClientBaseUrlKey(plugin.context.config)}' | 'body' | 'headers' | 'path' | 'query'>`,\n            }),\n            tsc.typeInterfaceNode({\n              properties,\n              useLegacyResolution: true,\n            }),\n          ],\n        }),\n      ],\n    }),\n    typeParameters: [\n      {\n        extends: tsc.typeReferenceNode({\n          typeName: tsc.identifier({ text: symbolOptions.placeholder }),\n        }),\n        name: TOptionsType,\n      },\n    ],\n  });\n  plugin.setSymbolValue(symbolQueryKeyType, queryKeyType);\n};\n\nexport const queryKeyStatement = ({\n  isInfinite,\n  operation,\n  plugin,\n  symbol,\n  typeQueryKey,\n}: {\n  isInfinite: boolean;\n  operation: IR.OperationObject;\n  plugin: PluginInstance;\n  symbol: Symbol;\n  typeQueryKey?: string;\n}) => {\n  const typeData = useTypeData({ operation, plugin });\n  const statement = tsc.constVariable({\n    exportConst: symbol.exported,\n    expression: tsc.arrowFunction({\n      parameters: [\n        {\n          isRequired: hasOperationDataRequired(operation),\n          name: 'options',\n          type: typeData,\n        },\n      ],\n      returnType: isInfinite ? typeQueryKey : undefined,\n      statements: createQueryKeyLiteral({\n        id: operation.id,\n        isInfinite,\n        operation,\n        plugin,\n      }),\n    }),\n    name: symbol.placeholder,\n  });\n  return statement;\n};\n","import ts from 'typescript';\n\nimport { operationPagination } from '~/ir/operation';\nimport type { IR } from '~/ir/types';\nimport { buildName } from '~/openApi/shared/utils/name';\nimport {\n  createOperationComment,\n  isOperationOptionsRequired,\n} from '~/plugins/shared/utils/operation';\nimport { tsc } from '~/tsc';\nimport { tsNodeToString } from '~/tsc/utils';\n\nimport { handleMeta } from './meta';\nimport {\n  createQueryKeyFunction,\n  createQueryKeyType,\n  queryKeyStatement,\n} from './queryKey';\nimport type { PluginInstance } from './types';\nimport { useTypeData, useTypeError, useTypeResponse } from './useType';\n\nconst createInfiniteParamsFunction = ({\n  plugin,\n}: {\n  plugin: PluginInstance;\n}) => {\n  const symbolCreateInfiniteParams = plugin.registerSymbol({\n    name: buildName({\n      config: {\n        case: plugin.config.case,\n      },\n      name: 'createInfiniteParams',\n    }),\n    selector: plugin.api.selector('createInfiniteParams'),\n  });\n\n  const fn = tsc.constVariable({\n    expression: tsc.arrowFunction({\n      multiLine: true,\n      parameters: [\n        {\n          name: 'queryKey',\n          type: tsc.typeReferenceNode({ typeName: 'QueryKey<Options>' }),\n        },\n        {\n          name: 'page',\n          type: tsc.typeReferenceNode({ typeName: 'K' }),\n        },\n      ],\n      statements: [\n        tsc.constVariable({\n          expression: tsc.objectExpression({\n            obj: [\n              {\n                spread: tsc.propertyAccessExpression({\n                  expression: 'queryKey',\n                  name: 0,\n                }),\n              },\n            ],\n          }),\n          name: 'params',\n        }),\n        tsc.ifStatement({\n          expression: tsc.propertyAccessExpression({\n            expression: tsc.identifier({\n              text: 'page',\n            }),\n            name: tsc.identifier({ text: 'body' }),\n          }),\n          thenStatement: tsc.block({\n            statements: [\n              tsc.expressionToStatement({\n                expression: tsc.binaryExpression({\n                  left: tsc.propertyAccessExpression({\n                    expression: 'params',\n                    name: 'body',\n                  }),\n                  right: tsc.objectExpression({\n                    multiLine: true,\n                    obj: [\n                      {\n                        assertion: 'any',\n                        spread: 'queryKey[0].body',\n                      },\n                      {\n                        assertion: 'any',\n                        spread: 'page.body',\n                      },\n                    ],\n                  }),\n                }),\n              }),\n            ],\n          }),\n        }),\n        tsc.ifStatement({\n          expression: tsc.propertyAccessExpression({\n            expression: tsc.identifier({\n              text: 'page',\n            }),\n            name: tsc.identifier({ text: 'headers' }),\n          }),\n          thenStatement: tsc.block({\n            statements: [\n              tsc.expressionToStatement({\n                expression: tsc.binaryExpression({\n                  left: tsc.propertyAccessExpression({\n                    expression: 'params',\n                    name: 'headers',\n                  }),\n                  right: tsc.objectExpression({\n                    multiLine: true,\n                    obj: [\n                      {\n                        spread: 'queryKey[0].headers',\n                      },\n                      {\n                        spread: 'page.headers',\n                      },\n                    ],\n                  }),\n                }),\n              }),\n            ],\n          }),\n        }),\n        tsc.ifStatement({\n          expression: tsc.propertyAccessExpression({\n            expression: tsc.identifier({\n              text: 'page',\n            }),\n            name: tsc.identifier({ text: 'path' }),\n          }),\n          thenStatement: tsc.block({\n            statements: [\n              tsc.expressionToStatement({\n                expression: tsc.binaryExpression({\n                  left: tsc.propertyAccessExpression({\n                    expression: 'params',\n                    name: 'path',\n                  }),\n                  right: tsc.objectExpression({\n                    multiLine: true,\n                    obj: [\n                      {\n                        assertion: 'any',\n                        spread: 'queryKey[0].path',\n                      },\n                      {\n                        assertion: 'any',\n                        spread: 'page.path',\n                      },\n                    ],\n                  }),\n                }),\n              }),\n            ],\n          }),\n        }),\n        tsc.ifStatement({\n          expression: tsc.propertyAccessExpression({\n            expression: tsc.identifier({\n              text: 'page',\n            }),\n            name: tsc.identifier({ text: 'query' }),\n          }),\n          thenStatement: tsc.block({\n            statements: [\n              tsc.expressionToStatement({\n                expression: tsc.binaryExpression({\n                  left: tsc.propertyAccessExpression({\n                    expression: 'params',\n                    name: 'query',\n                  }),\n                  right: tsc.objectExpression({\n                    multiLine: true,\n                    obj: [\n                      {\n                        assertion: 'any',\n                        spread: 'queryKey[0].query',\n                      },\n                      {\n                        assertion: 'any',\n                        spread: 'page.query',\n                      },\n                    ],\n                  }),\n                }),\n              }),\n            ],\n          }),\n        }),\n        tsc.returnVariable({\n          expression: tsc.asExpression({\n            expression: tsc.asExpression({\n              expression: tsc.identifier({ text: 'params' }),\n              type: tsc.keywordTypeNode({ keyword: 'unknown' }),\n            }),\n            type: ts.factory.createTypeQueryNode(\n              tsc.identifier({ text: 'page' }),\n            ),\n          }),\n        }),\n      ],\n      types: [\n        {\n          extends: tsc.typeReferenceNode({\n            typeName: tsc.identifier({\n              text: \"Pick<QueryKey<Options>[0], 'body' | 'headers' | 'path' | 'query'>\",\n            }),\n          }),\n          name: 'K',\n        },\n      ],\n    }),\n    name: symbolCreateInfiniteParams.placeholder,\n  });\n  plugin.setSymbolValue(symbolCreateInfiniteParams, fn);\n};\n\nexport const createInfiniteQueryOptions = ({\n  operation,\n  plugin,\n  queryFn,\n}: {\n  operation: IR.OperationObject;\n  plugin: PluginInstance;\n  queryFn: string;\n}): void => {\n  const pagination = operationPagination({\n    context: plugin.context,\n    operation,\n  });\n\n  if (!pagination) {\n    return;\n  }\n\n  const isRequiredOptions = isOperationOptionsRequired({\n    context: plugin.context,\n    operation,\n  });\n\n  if (!plugin.getSymbol(plugin.api.selector('createQueryKey'))) {\n    createQueryKeyType({ plugin });\n    createQueryKeyFunction({ plugin });\n  }\n\n  if (!plugin.getSymbol(plugin.api.selector('createInfiniteParams'))) {\n    createInfiniteParamsFunction({ plugin });\n  }\n\n  const symbolInfiniteQueryOptions = plugin.referenceSymbol(\n    plugin.api.selector('infiniteQueryOptions'),\n  );\n  const symbolInfiniteDataType = plugin.referenceSymbol(\n    plugin.api.selector('InfiniteData'),\n  );\n\n  const typeData = useTypeData({ operation, plugin });\n  const typeError = useTypeError({ operation, plugin });\n  const typeResponse = useTypeResponse({ operation, plugin });\n\n  const symbolQueryKeyType = plugin.referenceSymbol(\n    plugin.api.selector('QueryKey'),\n  );\n  const typeQueryKey = `${symbolQueryKeyType.placeholder}<${typeData}>`;\n  const typePageObjectParam = `Pick<${typeQueryKey}[0], 'body' | 'headers' | 'path' | 'query'>`;\n  const pluginTypeScript = plugin.getPluginOrThrow('@hey-api/typescript');\n  // TODO: parser - this is a bit clunky, need to compile type to string because\n  // `tsc.returnFunctionCall()` accepts only strings, should be cleaned up\n  const type = pluginTypeScript.api.schemaToType({\n    plugin: pluginTypeScript,\n    schema: pagination.schema,\n    state: {\n      path: {\n        value: [],\n      },\n    },\n  });\n  const typePageParam = `${tsNodeToString({\n    node: type,\n    unescape: true,\n  })} | ${typePageObjectParam}`;\n\n  const symbolInfiniteQueryKey = plugin.registerSymbol({\n    exported: true,\n    name: buildName({\n      config: plugin.config.infiniteQueryKeys,\n      name: operation.id,\n    }),\n  });\n  const node = queryKeyStatement({\n    isInfinite: true,\n    operation,\n    plugin,\n    symbol: symbolInfiniteQueryKey,\n    typeQueryKey,\n  });\n  plugin.setSymbolValue(symbolInfiniteQueryKey, node);\n\n  const awaitSdkExpression = tsc.awaitExpression({\n    expression: tsc.callExpression({\n      functionName: queryFn,\n      parameters: [\n        tsc.objectExpression({\n          multiLine: true,\n          obj: [\n            {\n              spread: 'options',\n            },\n            {\n              spread: 'params',\n            },\n            {\n              key: 'signal',\n              shorthand: true,\n              value: tsc.identifier({\n                text: 'signal',\n              }),\n            },\n            {\n              key: 'throwOnError',\n              value: true,\n            },\n          ],\n        }),\n      ],\n    }),\n  });\n\n  const symbolCreateInfiniteParams = plugin.referenceSymbol(\n    plugin.api.selector('createInfiniteParams'),\n  );\n\n  const statements: Array<ts.Statement> = [\n    tsc.constVariable({\n      comment: [\n        {\n          jsdoc: false,\n          lines: ['@ts-ignore'],\n        },\n      ],\n      expression: tsc.conditionalExpression({\n        condition: tsc.binaryExpression({\n          left: tsc.typeOfExpression({\n            text: 'pageParam',\n          }),\n          operator: '===',\n          right: tsc.ots.string('object'),\n        }),\n        whenFalse: tsc.objectExpression({\n          multiLine: true,\n          obj: [\n            {\n              key: pagination.in,\n              value: tsc.objectExpression({\n                multiLine: true,\n                obj: [\n                  {\n                    key: pagination.name,\n                    value: tsc.identifier({\n                      text: 'pageParam',\n                    }),\n                  },\n                ],\n              }),\n            },\n          ],\n        }),\n        whenTrue: tsc.identifier({\n          text: 'pageParam',\n        }),\n      }),\n      name: 'page',\n      typeName: typePageObjectParam,\n    }),\n    tsc.constVariable({\n      expression: tsc.callExpression({\n        functionName: symbolCreateInfiniteParams.placeholder,\n        parameters: ['queryKey', 'page'],\n      }),\n      name: 'params',\n    }),\n  ];\n\n  if (plugin.getPluginOrThrow('@hey-api/sdk').config.responseStyle === 'data') {\n    statements.push(\n      tsc.returnVariable({\n        expression: awaitSdkExpression,\n      }),\n    );\n  } else {\n    statements.push(\n      tsc.constVariable({\n        destructure: true,\n        expression: awaitSdkExpression,\n        name: 'data',\n      }),\n      tsc.returnVariable({\n        expression: 'data',\n      }),\n    );\n  }\n\n  const infiniteQueryOptionsObj: Array<{ key: string; value: ts.Expression }> =\n    [\n      {\n        key: 'queryFn',\n        value: tsc.arrowFunction({\n          async: true,\n          multiLine: true,\n          parameters: [\n            {\n              destructure: [\n                {\n                  name: 'pageParam',\n                },\n                {\n                  name: 'queryKey',\n                },\n                {\n                  name: 'signal',\n                },\n              ],\n            },\n          ],\n          statements,\n        }),\n      },\n      {\n        key: 'queryKey',\n        value: tsc.callExpression({\n          functionName: symbolInfiniteQueryKey.placeholder,\n          parameters: ['options'],\n        }),\n      },\n    ];\n\n  const meta = handleMeta(plugin, operation, 'infiniteQueryOptions');\n\n  if (meta) {\n    infiniteQueryOptionsObj.push({\n      key: 'meta',\n      value: meta,\n    });\n  }\n\n  const symbolInfiniteQueryOptionsFn = plugin.registerSymbol({\n    exported: true,\n    name: buildName({\n      config: plugin.config.infiniteQueryOptions,\n      name: operation.id,\n    }),\n  });\n  const statement = tsc.constVariable({\n    comment: plugin.config.comments\n      ? createOperationComment({ operation })\n      : undefined,\n    exportConst: symbolInfiniteQueryOptionsFn.exported,\n    expression: tsc.arrowFunction({\n      parameters: [\n        {\n          isRequired: isRequiredOptions,\n          name: 'options',\n          type: typeData,\n        },\n      ],\n      statements: [\n        tsc.returnFunctionCall({\n          args: [\n            tsc.objectExpression({\n              comments: [\n                {\n                  jsdoc: false,\n                  lines: ['@ts-ignore'],\n                },\n              ],\n              obj: infiniteQueryOptionsObj,\n            }),\n          ],\n          name: symbolInfiniteQueryOptions.placeholder,\n          // TODO: better types syntax\n          types: [\n            typeResponse,\n            typeError || 'unknown',\n            `${symbolInfiniteDataType.placeholder}<${typeResponse}>`,\n            typeQueryKey,\n            typePageParam,\n          ],\n        }),\n      ],\n    }),\n    name: symbolInfiniteQueryOptionsFn.placeholder,\n  });\n  plugin.setSymbolValue(symbolInfiniteQueryOptionsFn, statement);\n};\n","import type ts from 'typescript';\n\nimport type { IR } from '~/ir/types';\nimport { buildName } from '~/openApi/shared/utils/name';\nimport { createOperationComment } from '~/plugins/shared/utils/operation';\nimport { tsc } from '~/tsc';\n\nimport { handleMeta } from './meta';\nimport type { PluginInstance } from './types';\nimport { useTypeData, useTypeError, useTypeResponse } from './useType';\n\nexport const createMutationOptions = ({\n  operation,\n  plugin,\n  queryFn,\n}: {\n  operation: IR.OperationObject;\n  plugin: PluginInstance;\n  queryFn: string;\n}): void => {\n  const symbolMutationOptionsType = plugin.referenceSymbol(\n    plugin.api.selector('MutationOptions'),\n  );\n\n  const typeData = useTypeData({ operation, plugin });\n  const typeError = useTypeError({ operation, plugin });\n  const typeResponse = useTypeResponse({ operation, plugin });\n  // TODO: better types syntax\n  const mutationType = `${symbolMutationOptionsType.placeholder}<${typeResponse}, ${typeError}, ${typeData}>`;\n\n  const fnOptions = 'fnOptions';\n\n  const awaitSdkExpression = tsc.awaitExpression({\n    expression: tsc.callExpression({\n      functionName: queryFn,\n      parameters: [\n        tsc.objectExpression({\n          multiLine: true,\n          obj: [\n            {\n              spread: 'options',\n            },\n            {\n              spread: fnOptions,\n            },\n            {\n              key: 'throwOnError',\n              value: true,\n            },\n          ],\n        }),\n      ],\n    }),\n  });\n\n  const statements: Array<ts.Statement> = [];\n\n  if (plugin.getPluginOrThrow('@hey-api/sdk').config.responseStyle === 'data') {\n    statements.push(\n      tsc.returnVariable({\n        expression: awaitSdkExpression,\n      }),\n    );\n  } else {\n    statements.push(\n      tsc.constVariable({\n        destructure: true,\n        expression: awaitSdkExpression,\n        name: 'data',\n      }),\n      tsc.returnVariable({\n        expression: 'data',\n      }),\n    );\n  }\n\n  const mutationOptionsObj: Array<{ key: string; value: ts.Expression }> = [\n    {\n      key: 'mutationFn',\n      value: tsc.arrowFunction({\n        async: true,\n        multiLine: true,\n        parameters: [\n          {\n            name: fnOptions,\n          },\n        ],\n        statements,\n      }),\n    },\n  ];\n\n  const meta = handleMeta(plugin, operation, 'mutationOptions');\n\n  if (meta) {\n    mutationOptionsObj.push({\n      key: 'meta',\n      value: meta,\n    });\n  }\n\n  const mutationOptionsFn = 'mutationOptions';\n  const expression = tsc.arrowFunction({\n    parameters: [\n      {\n        isRequired: false,\n        name: 'options',\n        type: `Partial<${typeData}>`,\n      },\n    ],\n    returnType: mutationType,\n    statements: [\n      tsc.constVariable({\n        expression: tsc.objectExpression({\n          obj: mutationOptionsObj,\n        }),\n        name: mutationOptionsFn,\n        typeName: mutationType,\n      }),\n      tsc.returnVariable({\n        expression: mutationOptionsFn,\n      }),\n    ],\n  });\n  const symbolMutationOptions = plugin.registerSymbol({\n    exported: true,\n    name: buildName({\n      config: plugin.config.mutationOptions,\n      name: operation.id,\n    }),\n  });\n  const statement = tsc.constVariable({\n    comment: plugin.config.comments\n      ? createOperationComment({ operation })\n      : undefined,\n    exportConst: symbolMutationOptions.exported,\n    expression,\n    name: symbolMutationOptions.placeholder,\n  });\n  plugin.setSymbolValue(symbolMutationOptions, statement);\n};\n","import type ts from 'typescript';\n\nimport type { IR } from '~/ir/types';\nimport { buildName } from '~/openApi/shared/utils/name';\nimport {\n  createOperationComment,\n  hasOperationSse,\n  isOperationOptionsRequired,\n} from '~/plugins/shared/utils/operation';\nimport { tsc } from '~/tsc';\n\nimport { handleMeta } from './meta';\nimport {\n  createQueryKeyFunction,\n  createQueryKeyType,\n  queryKeyStatement,\n} from './queryKey';\nimport type { PluginInstance } from './types';\nimport { useTypeData } from './useType';\n\nconst optionsParamName = 'options';\n\nexport const createQueryOptions = ({\n  operation,\n  plugin,\n  queryFn,\n}: {\n  operation: IR.OperationObject;\n  plugin: PluginInstance;\n  queryFn: string;\n}): void => {\n  if (hasOperationSse({ operation })) {\n    return;\n  }\n\n  const isRequiredOptions = isOperationOptionsRequired({\n    context: plugin.context,\n    operation,\n  });\n\n  if (!plugin.getSymbol(plugin.api.selector('createQueryKey'))) {\n    createQueryKeyType({ plugin });\n    createQueryKeyFunction({ plugin });\n  }\n\n  const symbolQueryOptions = plugin.referenceSymbol(\n    plugin.api.selector('queryOptions'),\n  );\n\n  const symbolQueryKey = plugin.registerSymbol({\n    exported: true,\n    name: buildName({\n      config: plugin.config.queryKeys,\n      name: operation.id,\n    }),\n  });\n  const node = queryKeyStatement({\n    isInfinite: false,\n    operation,\n    plugin,\n    symbol: symbolQueryKey,\n  });\n  plugin.setSymbolValue(symbolQueryKey, node);\n\n  const typeData = useTypeData({ operation, plugin });\n\n  const awaitSdkExpression = tsc.awaitExpression({\n    expression: tsc.callExpression({\n      functionName: queryFn,\n      parameters: [\n        tsc.objectExpression({\n          multiLine: true,\n          obj: [\n            {\n              spread: optionsParamName,\n            },\n            {\n              spread: 'queryKey[0]',\n            },\n            {\n              key: 'signal',\n              shorthand: true,\n              value: tsc.identifier({\n                text: 'signal',\n              }),\n            },\n            {\n              key: 'throwOnError',\n              value: true,\n            },\n          ],\n        }),\n      ],\n    }),\n  });\n\n  const statements: Array<ts.Statement> = [];\n\n  if (plugin.getPluginOrThrow('@hey-api/sdk').config.responseStyle === 'data') {\n    statements.push(\n      tsc.returnVariable({\n        expression: awaitSdkExpression,\n      }),\n    );\n  } else {\n    statements.push(\n      tsc.constVariable({\n        destructure: true,\n        expression: awaitSdkExpression,\n        name: 'data',\n      }),\n      tsc.returnVariable({\n        expression: 'data',\n      }),\n    );\n  }\n\n  const queryOptionsObj: Array<{ key: string; value: ts.Expression }> = [\n    {\n      key: 'queryFn',\n      value: tsc.arrowFunction({\n        async: true,\n        multiLine: true,\n        parameters: [\n          {\n            destructure: [\n              {\n                name: 'queryKey',\n              },\n              {\n                name: 'signal',\n              },\n            ],\n          },\n        ],\n        statements,\n      }),\n    },\n    {\n      key: 'queryKey',\n      value: tsc.callExpression({\n        functionName: symbolQueryKey.placeholder,\n        parameters: [optionsParamName],\n      }),\n    },\n  ];\n\n  const meta = handleMeta(plugin, operation, 'queryOptions');\n\n  if (meta) {\n    queryOptionsObj.push({\n      key: 'meta',\n      value: meta,\n    });\n  }\n\n  const symbolQueryOptionsFn = plugin.registerSymbol({\n    exported: plugin.config.queryOptions.exported,\n    name: buildName({\n      config: plugin.config.queryOptions,\n      name: operation.id,\n    }),\n    selector: plugin.api.selector('queryOptionsFn', operation.id),\n  });\n  const statement = tsc.constVariable({\n    comment: plugin.config.comments\n      ? createOperationComment({ operation })\n      : undefined,\n    exportConst: symbolQueryOptionsFn.exported,\n    expression: tsc.arrowFunction({\n      parameters: [\n        {\n          isRequired: isRequiredOptions,\n          name: optionsParamName,\n          type: typeData,\n        },\n      ],\n      statements: [\n        tsc.returnFunctionCall({\n          args: [tsc.objectExpression({ obj: queryOptionsObj })],\n          name: symbolQueryOptions.placeholder,\n        }),\n      ],\n    }),\n    name: symbolQueryOptionsFn.placeholder,\n    // TODO: add type error\n    // TODO: AxiosError<PutSubmissionMetaError>\n  });\n  plugin.setSymbolValue(symbolQueryOptionsFn, statement);\n};\n","import type { IR } from '~/ir/types';\nimport { buildName } from '~/openApi/shared/utils/name';\nimport {\n  createOperationComment,\n  hasOperationSse,\n  isOperationOptionsRequired,\n} from '~/plugins/shared/utils/operation';\nimport { tsc } from '~/tsc';\n\nimport type { PluginInstance } from './types';\nimport { useTypeData } from './useType';\n\nconst optionsParamName = 'options';\n\nexport const createUseQuery = ({\n  operation,\n  plugin,\n}: {\n  operation: IR.OperationObject;\n  plugin: PluginInstance;\n}): void => {\n  if (hasOperationSse({ operation })) {\n    return;\n  }\n\n  if (!('useQuery' in plugin.config)) {\n    return;\n  }\n\n  const symbolUseQueryFn = plugin.registerSymbol({\n    exported: true,\n    name: buildName({\n      config: plugin.config.useQuery,\n      name: operation.id,\n    }),\n  });\n\n  const symbolUseQuery = plugin.referenceSymbol(\n    plugin.api.selector('useQuery'),\n  );\n\n  const isRequiredOptions = isOperationOptionsRequired({\n    context: plugin.context,\n    operation,\n  });\n  const typeData = useTypeData({ operation, plugin });\n\n  const symbolQueryOptionsFn = plugin.referenceSymbol(\n    plugin.api.selector('queryOptionsFn', operation.id),\n  );\n  const statement = tsc.constVariable({\n    comment: plugin.config.comments\n      ? createOperationComment({ operation })\n      : undefined,\n    exportConst: symbolUseQueryFn.exported,\n    expression: tsc.arrowFunction({\n      parameters: [\n        {\n          isRequired: isRequiredOptions,\n          name: optionsParamName,\n          type: typeData,\n        },\n      ],\n      statements: [\n        tsc.returnStatement({\n          expression: tsc.callExpression({\n            functionName: symbolUseQuery.placeholder,\n            parameters: [\n              tsc.callExpression({\n                functionName: symbolQueryOptionsFn.placeholder,\n                parameters: [optionsParamName],\n              }),\n            ],\n          }),\n        }),\n      ],\n    }),\n    name: symbolUseQueryFn.placeholder,\n  });\n  plugin.setSymbolValue(symbolUseQueryFn, statement);\n};\n","import { operationClasses } from '~/plugins/@hey-api/sdk/shared/operation';\nimport { stringCase } from '~/utils/stringCase';\n\nimport { createInfiniteQueryOptions } from './infiniteQueryOptions';\nimport { createMutationOptions } from './mutationOptions';\nimport { createQueryOptions } from './queryOptions';\nimport type { PluginHandler } from './types';\nimport { createUseQuery } from './useQuery';\n\nexport const handler: PluginHandler = ({ plugin }) => {\n  plugin.registerSymbol({\n    external: plugin.name,\n    meta: {\n      kind: 'type',\n    },\n    name: 'DefaultError',\n    selector: plugin.api.selector('DefaultError'),\n  });\n  plugin.registerSymbol({\n    external: plugin.name,\n    meta: {\n      kind: 'type',\n    },\n    name: 'InfiniteData',\n    selector: plugin.api.selector('InfiniteData'),\n  });\n  const mutationsType =\n    plugin.name === '@tanstack/angular-query-experimental' ||\n    plugin.name === '@tanstack/svelte-query' ||\n    plugin.name === '@tanstack/solid-query'\n      ? 'MutationOptions'\n      : 'UseMutationOptions';\n  plugin.registerSymbol({\n    external: plugin.name,\n    meta: {\n      kind: 'type',\n    },\n    name: mutationsType,\n    selector: plugin.api.selector('MutationOptions'),\n  });\n  plugin.registerSymbol({\n    external: plugin.name,\n    name: 'infiniteQueryOptions',\n    selector: plugin.api.selector('infiniteQueryOptions'),\n  });\n  plugin.registerSymbol({\n    external: plugin.name,\n    name: 'queryOptions',\n    selector: plugin.api.selector('queryOptions'),\n  });\n  plugin.registerSymbol({\n    external: plugin.name,\n    name: 'useQuery',\n    selector: plugin.api.selector('useQuery'),\n  });\n  plugin.registerSymbol({\n    external: 'axios',\n    meta: {\n      kind: 'type',\n    },\n    name: 'AxiosError',\n    selector: plugin.api.selector('AxiosError'),\n  });\n\n  const sdkPlugin = plugin.getPluginOrThrow('@hey-api/sdk');\n\n  plugin.forEach(\n    'operation',\n    ({ operation }) => {\n      const classes = sdkPlugin.config.asClass\n        ? operationClasses({\n            context: plugin.context,\n            operation,\n            plugin: sdkPlugin,\n          })\n        : undefined;\n      const entry = classes ? classes.values().next().value : undefined;\n      const queryFn =\n        // TODO: this should use class graph to determine correct path string\n        // as it's really easy to break once we change the class casing\n        entry\n          ? [\n              plugin.referenceSymbol(\n                sdkPlugin.api.selector('class', entry.path[0]),\n              ).placeholder,\n              ...entry.path.slice(1).map((className) =>\n                stringCase({\n                  case: 'camelCase',\n                  value: className,\n                }),\n              ),\n              entry.methodName,\n            ]\n              .filter(Boolean)\n              .join('.')\n          : plugin.referenceSymbol(\n              sdkPlugin.api.selector('function', operation.id),\n            ).placeholder;\n\n      if (plugin.hooks.operation.isQuery(operation)) {\n        if (plugin.config.queryOptions.enabled) {\n          createQueryOptions({ operation, plugin, queryFn });\n        }\n\n        if (plugin.config.infiniteQueryOptions.enabled) {\n          createInfiniteQueryOptions({ operation, plugin, queryFn });\n        }\n\n        if ('useQuery' in plugin.config && plugin.config.useQuery.enabled) {\n          createUseQuery({ operation, plugin });\n        }\n      }\n\n      if (plugin.hooks.operation.isMutation(operation)) {\n        if (plugin.config.mutationOptions.enabled) {\n          createMutationOptions({ operation, plugin, queryFn });\n        }\n      }\n    },\n    {\n      order: 'declarations',\n    },\n  );\n};\n","import ts from 'typescript';\n\nimport { clientModulePath } from '~/generate/client';\nimport { relativeModulePath } from '~/generate/utils';\nimport { createOperationKey } from '~/ir/operation';\nimport { getPaginationKeywordsRegExp } from '~/ir/pagination';\nimport type { IR } from '~/ir/types';\nimport { isOperationParameterRequired } from '~/openApi';\nimport {\n  getClientBaseUrlKey,\n  getClientPlugin,\n} from '~/plugins/@hey-api/client-core/utils';\nimport {\n  generateImport,\n  operationDataTypeName,\n  operationErrorTypeName,\n  operationOptionsLegacyParserType,\n  operationResponseTypeName,\n  serviceFunctionIdentifier,\n} from '~/plugins/@hey-api/sdk/plugin-legacy';\nimport type { TanStackAngularQueryPlugin } from '~/plugins/@tanstack/angular-query-experimental';\nimport type { TanStackReactQueryPlugin } from '~/plugins/@tanstack/react-query';\nimport type { TanStackSolidQueryPlugin } from '~/plugins/@tanstack/solid-query';\nimport type { TanStackSvelteQueryPlugin } from '~/plugins/@tanstack/svelte-query';\nimport type { TanStackVueQueryPlugin } from '~/plugins/@tanstack/vue-query';\nimport { type Property, tsc } from '~/tsc';\nimport type { ImportExportItem } from '~/tsc/module';\nimport type { ImportExportItemObject } from '~/tsc/utils';\nimport type {\n  Client,\n  Method,\n  Model,\n  Operation,\n  OperationParameter,\n} from '~/types/client';\nimport type { Config } from '~/types/config';\nimport type { Files } from '~/types/utils';\nimport { getConfig, isLegacyClient } from '~/utils/config';\nimport { transformClassName } from '~/utils/transform';\n\nconst toInfiniteQueryOptionsName = (operation: Operation) =>\n  `${serviceFunctionIdentifier({\n    config: getConfig(),\n    id: operation.name,\n    operation,\n  })}InfiniteOptions`;\n\nconst toMutationOptionsName = (operation: Operation) =>\n  `${serviceFunctionIdentifier({\n    config: getConfig(),\n    id: operation.name,\n    operation,\n  })}Mutation`;\n\nconst toQueryOptionsName = ({\n  config,\n  id,\n  operation,\n}: {\n  config: Config;\n  id: string;\n  operation: IR.OperationObject | Operation;\n}) =>\n  `${serviceFunctionIdentifier({\n    config,\n    id,\n    operation,\n  })}Options`;\n\nconst toQueryKeyName = ({\n  config,\n  id,\n  isInfinite,\n  operation,\n}: {\n  config: Config;\n  id: string;\n  isInfinite?: boolean;\n  operation: IR.OperationObject | Operation;\n}) =>\n  `${serviceFunctionIdentifier({\n    config,\n    id,\n    operation,\n  })}${isInfinite ? 'Infinite' : ''}QueryKey`;\n\nconst getPaginationIn = (parameter: OperationParameter) => {\n  switch (parameter.in) {\n    case 'formData':\n      return 'body';\n    case 'header':\n      return 'headers';\n    default:\n      return parameter.in;\n  }\n};\n\nconst createInfiniteParamsFn = 'createInfiniteParams';\nconst createQueryKeyFn = 'createQueryKey';\nconst infiniteQueryOptionsFn = 'infiniteQueryOptions';\nconst mutationOptionsFn = 'mutationOptions';\nconst queryKeyName = 'QueryKey';\nconst queryOptionsFn = 'queryOptions';\nconst TOptionsType = 'TOptions';\n\nconst createInfiniteParamsFunction = ({\n  file,\n}: {\n  file: Files[keyof Files];\n}) => {\n  const fn = tsc.constVariable({\n    expression: tsc.arrowFunction({\n      multiLine: true,\n      parameters: [\n        {\n          name: 'queryKey',\n          type: tsc.typeNode('QueryKey<OptionsLegacyParser>'),\n        },\n        {\n          name: 'page',\n          type: tsc.typeNode('K'),\n        },\n      ],\n      statements: [\n        tsc.constVariable({\n          expression: tsc.identifier({\n            text: 'queryKey[0]',\n          }),\n          name: 'params',\n        }),\n        tsc.ifStatement({\n          expression: tsc.propertyAccessExpression({\n            expression: tsc.identifier({\n              text: 'page',\n            }),\n            name: tsc.identifier({ text: 'body' }),\n          }),\n          thenStatement: tsc.block({\n            statements: [\n              tsc.expressionToStatement({\n                expression: tsc.binaryExpression({\n                  left: tsc.propertyAccessExpression({\n                    expression: 'params',\n                    name: 'body',\n                  }),\n                  right: tsc.objectExpression({\n                    multiLine: true,\n                    obj: [\n                      {\n                        assertion: 'any',\n                        spread: 'queryKey[0].body',\n                      },\n                      {\n                        assertion: 'any',\n                        spread: 'page.body',\n                      },\n                    ],\n                  }),\n                }),\n              }),\n            ],\n          }),\n        }),\n        tsc.ifStatement({\n          expression: tsc.propertyAccessExpression({\n            expression: tsc.identifier({\n              text: 'page',\n            }),\n            name: tsc.identifier({ text: 'headers' }),\n          }),\n          thenStatement: tsc.block({\n            statements: [\n              tsc.expressionToStatement({\n                expression: tsc.binaryExpression({\n                  left: tsc.propertyAccessExpression({\n                    expression: 'params',\n                    name: 'headers',\n                  }),\n                  right: tsc.objectExpression({\n                    multiLine: true,\n                    obj: [\n                      {\n                        spread: 'queryKey[0].headers',\n                      },\n                      {\n                        spread: 'page.headers',\n                      },\n                    ],\n                  }),\n                }),\n              }),\n            ],\n          }),\n        }),\n        tsc.ifStatement({\n          expression: tsc.propertyAccessExpression({\n            expression: tsc.identifier({\n              text: 'page',\n            }),\n            name: tsc.identifier({ text: 'path' }),\n          }),\n          thenStatement: tsc.block({\n            statements: [\n              tsc.expressionToStatement({\n                expression: tsc.binaryExpression({\n                  left: tsc.propertyAccessExpression({\n                    expression: 'params',\n                    name: 'path',\n                  }),\n                  right: tsc.objectExpression({\n                    multiLine: true,\n                    obj: [\n                      {\n                        spread: 'queryKey[0].path',\n                      },\n                      {\n                        spread: 'page.path',\n                      },\n                    ],\n                  }),\n                }),\n              }),\n            ],\n          }),\n        }),\n        tsc.ifStatement({\n          expression: tsc.propertyAccessExpression({\n            expression: tsc.identifier({\n              text: 'page',\n            }),\n            name: tsc.identifier({ text: 'query' }),\n          }),\n          thenStatement: tsc.block({\n            statements: [\n              tsc.expressionToStatement({\n                expression: tsc.binaryExpression({\n                  left: tsc.propertyAccessExpression({\n                    expression: 'params',\n                    name: 'query',\n                  }),\n                  right: tsc.objectExpression({\n                    multiLine: true,\n                    obj: [\n                      {\n                        spread: 'queryKey[0].query',\n                      },\n                      {\n                        spread: 'page.query',\n                      },\n                    ],\n                  }),\n                }),\n              }),\n            ],\n          }),\n        }),\n        tsc.returnVariable({\n          expression: ts.factory.createAsExpression(\n            ts.factory.createAsExpression(\n              tsc.identifier({ text: 'params' }),\n              ts.factory.createKeywordTypeNode(ts.SyntaxKind.UnknownKeyword),\n            ),\n            ts.factory.createTypeQueryNode(tsc.identifier({ text: 'page' })),\n          ),\n        }),\n      ],\n      types: [\n        {\n          extends: tsc.typeReferenceNode({\n            typeName: tsc.identifier({\n              text: \"Pick<QueryKey<OptionsLegacyParser>[0], 'body' | 'headers' | 'path' | 'query'>\",\n            }),\n          }),\n          name: 'K',\n        },\n      ],\n    }),\n    name: createInfiniteParamsFn,\n  });\n  file.add(fn);\n};\n\nconst createQueryKeyFunction = ({ file }: { file: Files[keyof Files] }) => {\n  const returnType = tsc.indexedAccessTypeNode({\n    indexType: tsc.typeNode(0),\n    objectType: tsc.typeNode(queryKeyName, [tsc.typeNode(TOptionsType)]),\n  });\n\n  const infiniteIdentifier = tsc.identifier({ text: 'infinite' });\n  const baseUrlKey = getClientBaseUrlKey(getConfig());\n\n  const fn = tsc.constVariable({\n    expression: tsc.arrowFunction({\n      multiLine: true,\n      parameters: [\n        {\n          name: 'id',\n          type: tsc.typeNode('string'),\n        },\n        {\n          isRequired: false,\n          name: 'options',\n          type: tsc.typeNode(TOptionsType),\n        },\n        {\n          isRequired: false,\n          name: 'infinite',\n          type: tsc.typeNode('boolean'),\n        },\n      ],\n      returnType,\n      statements: [\n        tsc.constVariable({\n          assertion: returnType,\n          expression: tsc.objectExpression({\n            multiLine: false,\n            obj: [\n              {\n                key: '_id',\n                value: tsc.identifier({ text: 'id' }),\n              },\n              {\n                key: baseUrlKey,\n                value: tsc.identifier({\n                  text: `options?.${baseUrlKey} || (options?.client ?? _heyApiClient).getConfig().${baseUrlKey}`,\n                }),\n              },\n            ],\n          }),\n          name: 'params',\n          typeName: returnType,\n        }),\n        tsc.ifStatement({\n          expression: infiniteIdentifier,\n          thenStatement: tsc.block({\n            statements: [\n              tsc.expressionToStatement({\n                expression: tsc.binaryExpression({\n                  left: tsc.propertyAccessExpression({\n                    expression: 'params',\n                    name: '_infinite',\n                  }),\n                  right: infiniteIdentifier,\n                }),\n              }),\n            ],\n          }),\n        }),\n        tsc.ifStatement({\n          expression: tsc.propertyAccessExpression({\n            expression: tsc.identifier({ text: 'options' }),\n            isOptional: true,\n            name: tsc.identifier({ text: 'body' }),\n          }),\n          thenStatement: tsc.block({\n            statements: [\n              tsc.expressionToStatement({\n                expression: tsc.binaryExpression({\n                  left: tsc.propertyAccessExpression({\n                    expression: 'params',\n                    name: 'body',\n                  }),\n                  right: tsc.propertyAccessExpression({\n                    expression: 'options',\n                    name: 'body',\n                  }),\n                }),\n              }),\n            ],\n          }),\n        }),\n        tsc.ifStatement({\n          expression: tsc.propertyAccessExpression({\n            expression: tsc.identifier({ text: 'options' }),\n            isOptional: true,\n            name: tsc.identifier({ text: 'headers' }),\n          }),\n          thenStatement: tsc.block({\n            statements: [\n              tsc.expressionToStatement({\n                expression: tsc.binaryExpression({\n                  left: tsc.propertyAccessExpression({\n                    expression: 'params',\n                    name: 'headers',\n                  }),\n                  right: tsc.propertyAccessExpression({\n                    expression: 'options',\n                    name: 'headers',\n                  }),\n                }),\n              }),\n            ],\n          }),\n        }),\n        tsc.ifStatement({\n          expression: tsc.propertyAccessExpression({\n            expression: tsc.identifier({ text: 'options' }),\n            isOptional: true,\n            name: tsc.identifier({ text: 'path' }),\n          }),\n          thenStatement: tsc.block({\n            statements: [\n              tsc.expressionToStatement({\n                expression: tsc.binaryExpression({\n                  left: tsc.propertyAccessExpression({\n                    expression: 'params',\n                    name: 'path',\n                  }),\n                  right: tsc.propertyAccessExpression({\n                    expression: 'options',\n                    name: 'path',\n                  }),\n                }),\n              }),\n            ],\n          }),\n        }),\n        tsc.ifStatement({\n          expression: tsc.propertyAccessExpression({\n            expression: tsc.identifier({ text: 'options' }),\n            isOptional: true,\n            name: tsc.identifier({ text: 'query' }),\n          }),\n          thenStatement: tsc.block({\n            statements: [\n              tsc.expressionToStatement({\n                expression: tsc.binaryExpression({\n                  left: tsc.propertyAccessExpression({\n                    expression: 'params',\n                    name: 'query',\n                  }),\n                  right: tsc.propertyAccessExpression({\n                    expression: 'options',\n                    name: 'query',\n                  }),\n                }),\n              }),\n            ],\n          }),\n        }),\n        tsc.returnVariable({\n          expression: 'params',\n        }),\n      ],\n      types: [\n        {\n          extends: tsc.typeReferenceNode({\n            typeName: tsc.identifier({ text: 'OptionsLegacyParser' }),\n          }),\n          name: TOptionsType,\n        },\n      ],\n    }),\n    name: createQueryKeyFn,\n  });\n  file.add(fn);\n};\n\nconst createQueryKeyType = ({ file }: { file: Files[keyof Files] }) => {\n  const properties: Property[] = [\n    {\n      name: '_id',\n      type: tsc.keywordTypeNode({\n        keyword: 'string',\n      }),\n    },\n    {\n      isRequired: false,\n      name: '_infinite',\n      type: tsc.keywordTypeNode({\n        keyword: 'boolean',\n      }),\n    },\n  ];\n\n  const queryKeyType = tsc.typeAliasDeclaration({\n    name: queryKeyName,\n    type: tsc.typeTupleNode({\n      types: [\n        tsc.typeIntersectionNode({\n          types: [\n            tsc.typeReferenceNode({\n              typeName: `Pick<${TOptionsType}, '${getClientBaseUrlKey(getConfig())}' | 'body' | 'headers' | 'path' | 'query'>`,\n            }),\n            tsc.typeInterfaceNode({\n              properties,\n              useLegacyResolution: true,\n            }),\n          ],\n        }),\n      ],\n    }),\n    typeParameters: [\n      {\n        extends: tsc.typeReferenceNode({\n          typeName: tsc.identifier({ text: 'OptionsLegacyParser' }),\n        }),\n        name: TOptionsType,\n      },\n    ],\n  });\n  file.add(queryKeyType);\n};\n\nconst createTypeData = ({\n  client,\n  file,\n  operation,\n  typesModulePath,\n}: {\n  client: Client;\n  file: Files[keyof Files];\n  operation: Operation;\n  typesModulePath: string;\n}) => {\n  const { name: nameTypeData } = generateImport({\n    client,\n    meta: operation.parameters.length\n      ? {\n          // TODO: this should be exact ref to operation for consistency,\n          // but name should work too as operation ID is unique\n          $ref: operation.name,\n          name: operation.name,\n        }\n      : undefined,\n    nameTransformer: operationDataTypeName,\n    onImport: (name) => {\n      file.import({\n        asType: true,\n        module: typesModulePath,\n        name,\n      });\n    },\n  });\n\n  const typeData = operationOptionsLegacyParserType({\n    importedType: nameTypeData,\n  });\n\n  return { typeData };\n};\n\nconst createTypeError = ({\n  client,\n  file,\n  operation,\n  pluginName,\n  typesModulePath,\n}: {\n  client: Client;\n  file: Files[keyof Files];\n  operation: Operation;\n  pluginName: string;\n  typesModulePath: string;\n}) => {\n  const config = getConfig();\n\n  const { name: nameTypeError } = generateImport({\n    client,\n    meta: {\n      // TODO: this should be exact ref to operation for consistency,\n      // but name should work too as operation ID is unique\n      $ref: operation.name,\n      name: operation.name,\n    },\n    nameTransformer: operationErrorTypeName,\n    onImport: (name) => {\n      file.import({\n        asType: true,\n        module: typesModulePath,\n        name,\n      });\n    },\n  });\n\n  let typeError: ImportExportItemObject = {\n    asType: true,\n    name: nameTypeError,\n  };\n  if (!typeError.name) {\n    typeError = file.import({\n      asType: true,\n      module: pluginName,\n      name: 'DefaultError',\n    });\n  }\n\n  const clientPlugin = getClientPlugin(config);\n  if (clientPlugin.name === '@hey-api/client-axios') {\n    const axiosError = file.import({\n      asType: true,\n      module: 'axios',\n      name: 'AxiosError',\n    });\n    typeError = {\n      ...axiosError,\n      name: `${axiosError.name}<${typeError.name}>`,\n    };\n  }\n\n  return { typeError };\n};\n\nconst createTypeResponse = ({\n  client,\n  file,\n  operation,\n  typesModulePath,\n}: {\n  client: Client;\n  file: Files[keyof Files];\n  operation: Operation;\n  typesModulePath: string;\n}) => {\n  const { name: nameTypeResponse } = generateImport({\n    client,\n    meta: {\n      // TODO: this should be exact ref to operation for consistency,\n      // but name should work too as operation ID is unique\n      $ref: operation.name,\n      name: operation.name,\n    },\n    nameTransformer: operationResponseTypeName,\n    onImport: (imported) => {\n      file.import({\n        asType: true,\n        module: typesModulePath,\n        name: imported,\n      });\n    },\n  });\n\n  const typeResponse = nameTypeResponse || 'void';\n\n  return { typeResponse };\n};\n\nconst createQueryKeyLiteral = ({\n  id,\n  isInfinite,\n}: {\n  id: string;\n  isInfinite?: boolean;\n}) => {\n  const queryKeyLiteral = tsc.arrayLiteralExpression({\n    elements: [\n      tsc.callExpression({\n        functionName: createQueryKeyFn,\n        parameters: [\n          tsc.ots.string(id),\n          'options',\n          isInfinite ? tsc.ots.boolean(true) : undefined,\n        ],\n      }),\n    ],\n    multiLine: false,\n  });\n  return queryKeyLiteral;\n};\n\nexport const handlerLegacy = ({\n  client,\n  files,\n  plugin,\n}: Parameters<\n  | TanStackAngularQueryPlugin['LegacyHandler']\n  | TanStackReactQueryPlugin['LegacyHandler']\n  | TanStackSolidQueryPlugin['LegacyHandler']\n  | TanStackSvelteQueryPlugin['LegacyHandler']\n  | TanStackVueQueryPlugin['LegacyHandler']\n>[0]) => {\n  const config = getConfig();\n\n  if (isLegacyClient(config)) {\n    throw new Error('TanStack Query plugin does not support legacy clients');\n  }\n\n  const file = files[plugin.name]!;\n\n  file.import({\n    asType: true,\n    module: clientModulePath({ config, sourceOutput: plugin.output }),\n    name: 'OptionsLegacyParser',\n  });\n\n  const typesModulePath = relativeModulePath({\n    moduleOutput: files.types!.nameWithoutExtension(),\n    sourceOutput: plugin.output,\n  });\n\n  const mutationsType =\n    plugin.name === '@tanstack/angular-query-experimental' ||\n    plugin.name === '@tanstack/svelte-query' ||\n    plugin.name === '@tanstack/solid-query'\n      ? 'MutationOptions'\n      : 'UseMutationOptions';\n\n  let typeInfiniteData!: ImportExportItem;\n  let hasCreateInfiniteParamsFunction = false;\n  let hasCreateQueryKeyParamsFunction = false;\n  let hasInfiniteQueries = false;\n  let hasMutations = false;\n  let hasQueries = false;\n\n  const processedOperations = new Map<string, boolean>();\n\n  for (const service of client.services) {\n    for (const operation of service.operations) {\n      // track processed operations to avoid creating duplicates\n      const operationKey = createOperationKey(operation);\n      if (processedOperations.has(operationKey)) {\n        continue;\n      }\n      processedOperations.set(operationKey, true);\n\n      const queryFn = [\n        config.plugins['@hey-api/sdk']?.config.asClass &&\n          transformClassName({\n            config,\n            name: service.name,\n          }),\n        serviceFunctionIdentifier({\n          config,\n          handleIllegal: !config.plugins['@hey-api/sdk']?.config.asClass,\n          id: operation.name,\n          operation,\n        }),\n      ]\n        .filter(Boolean)\n        .join('.');\n      let hasUsedQueryFn = false;\n\n      // queries\n      if (\n        plugin.config.queryOptions.enabled &&\n        (['GET', 'POST'] as ReadonlyArray<Method>).includes(operation.method)\n      ) {\n        if (!hasQueries) {\n          hasQueries = true;\n\n          if (!hasCreateQueryKeyParamsFunction) {\n            createQueryKeyType({ file });\n            createQueryKeyFunction({ file });\n            hasCreateQueryKeyParamsFunction = true;\n          }\n\n          file.import({\n            module: plugin.name,\n            name: queryOptionsFn,\n          });\n        }\n\n        hasUsedQueryFn = true;\n\n        const { typeData } = createTypeData({\n          client,\n          file,\n          operation,\n          typesModulePath,\n        });\n\n        const isRequired = isOperationParameterRequired(operation.parameters);\n\n        const queryKeyStatement = tsc.constVariable({\n          exportConst: true,\n          expression: tsc.arrowFunction({\n            parameters: [\n              {\n                isRequired,\n                name: 'options',\n                type: typeData,\n              },\n            ],\n            statements: createQueryKeyLiteral({\n              id: operation.name,\n            }),\n          }),\n          name: toQueryKeyName({\n            config,\n            id: operation.name,\n            operation,\n          }),\n        });\n        file.add(queryKeyStatement);\n\n        const statement = tsc.constVariable({\n          // TODO: describe options, same as the actual function call\n          comment: [],\n          exportConst: true,\n          expression: tsc.arrowFunction({\n            parameters: [\n              {\n                isRequired,\n                name: 'options',\n                type: typeData,\n              },\n            ],\n            statements: [\n              tsc.returnFunctionCall({\n                args: [\n                  tsc.objectExpression({\n                    obj: [\n                      {\n                        key: 'queryFn',\n                        value: tsc.arrowFunction({\n                          async: true,\n                          multiLine: true,\n                          parameters: [\n                            {\n                              destructure: [\n                                {\n                                  name: 'queryKey',\n                                },\n                                {\n                                  name: 'signal',\n                                },\n                              ],\n                            },\n                          ],\n                          statements: [\n                            tsc.constVariable({\n                              destructure: true,\n                              expression: tsc.awaitExpression({\n                                expression: tsc.callExpression({\n                                  functionName: queryFn,\n                                  parameters: [\n                                    tsc.objectExpression({\n                                      multiLine: true,\n                                      obj: [\n                                        {\n                                          spread: 'options',\n                                        },\n                                        {\n                                          spread: 'queryKey[0]',\n                                        },\n                                        {\n                                          key: 'signal',\n                                          shorthand: true,\n                                          value: tsc.identifier({\n                                            text: 'signal',\n                                          }),\n                                        },\n                                        {\n                                          key: 'throwOnError',\n                                          value: true,\n                                        },\n                                      ],\n                                    }),\n                                  ],\n                                }),\n                              }),\n                              name: 'data',\n                            }),\n                            tsc.returnVariable({\n                              expression: 'data',\n                            }),\n                          ],\n                        }),\n                      },\n                      {\n                        key: 'queryKey',\n                        value: tsc.callExpression({\n                          functionName: toQueryKeyName({\n                            config,\n                            id: operation.name,\n                            operation,\n                          }),\n                          parameters: ['options'],\n                        }),\n                      },\n                    ],\n                  }),\n                ],\n                name: queryOptionsFn,\n              }),\n            ],\n          }),\n          name: toQueryOptionsName({\n            config,\n            id: operation.name,\n            operation,\n          }),\n          // TODO: add type error\n          // TODO: AxiosError<PutSubmissionMetaError>\n        });\n        file.add(statement);\n      }\n\n      // infinite queries\n      if (\n        plugin.config.infiniteQueryOptions &&\n        (['GET', 'POST'] as ReadonlyArray<Method>).includes(operation.method)\n      ) {\n        // the actual pagination field might be nested inside parameter, e.g. body\n        let paginationField!: Model | OperationParameter;\n\n        const paginationParameter = operation.parameters.find((parameter) => {\n          const paginationRegExp = getPaginationKeywordsRegExp(\n            config.parser.pagination,\n          );\n          if (paginationRegExp.test(parameter.name)) {\n            paginationField = parameter;\n            return true;\n          }\n\n          if (parameter.in !== 'body') {\n            return;\n          }\n\n          if (parameter.export === 'reference') {\n            const ref = parameter.$refs[0];\n            const refModel = client.models.find(\n              (model) => model.meta?.$ref === ref,\n            );\n            return refModel?.properties.find((property) => {\n              const paginationRegExp = getPaginationKeywordsRegExp(\n                config.parser.pagination,\n              );\n              if (paginationRegExp.test(property.name)) {\n                paginationField = property;\n                return true;\n              }\n              return;\n            });\n          }\n\n          return parameter.properties.find((property) => {\n            const paginationRegExp = getPaginationKeywordsRegExp(\n              config.parser.pagination,\n            );\n            if (paginationRegExp.test(property.name)) {\n              paginationField = property;\n              return true;\n            }\n            return;\n          });\n        });\n\n        if (paginationParameter && paginationField) {\n          if (!hasInfiniteQueries) {\n            hasInfiniteQueries = true;\n\n            if (!hasCreateQueryKeyParamsFunction) {\n              createQueryKeyType({ file });\n              createQueryKeyFunction({ file });\n              hasCreateQueryKeyParamsFunction = true;\n            }\n\n            if (!hasCreateInfiniteParamsFunction) {\n              createInfiniteParamsFunction({ file });\n              hasCreateInfiniteParamsFunction = true;\n            }\n\n            file.import({\n              module: plugin.name,\n              name: infiniteQueryOptionsFn,\n            });\n\n            typeInfiniteData = file.import({\n              asType: true,\n              module: plugin.name,\n              name: 'InfiniteData',\n            });\n          }\n\n          hasUsedQueryFn = true;\n\n          const { typeData } = createTypeData({\n            client,\n            file,\n            operation,\n            typesModulePath,\n          });\n          const { typeError } = createTypeError({\n            client,\n            file,\n            operation,\n            pluginName: plugin.name,\n            typesModulePath,\n          });\n          const { typeResponse } = createTypeResponse({\n            client,\n            file,\n            operation,\n            typesModulePath,\n          });\n\n          const isRequired = isOperationParameterRequired(operation.parameters);\n\n          const typeQueryKey = `${queryKeyName}<${typeData}>`;\n          const typePageObjectParam = `Pick<${typeQueryKey}[0], 'body' | 'headers' | 'path' | 'query'>`;\n          const typePageParam = `${paginationField.base} | ${typePageObjectParam}`;\n\n          const queryKeyStatement = tsc.constVariable({\n            exportConst: true,\n            expression: tsc.arrowFunction({\n              parameters: [\n                {\n                  isRequired,\n                  name: 'options',\n                  type: typeData,\n                },\n              ],\n              returnType: typeQueryKey,\n              statements: createQueryKeyLiteral({\n                id: operation.name,\n                isInfinite: true,\n              }),\n            }),\n            name: toQueryKeyName({\n              config,\n              id: operation.name,\n              isInfinite: true,\n              operation,\n            }),\n          });\n          file.add(queryKeyStatement);\n\n          const statement = tsc.constVariable({\n            // TODO: describe options, same as the actual function call\n            comment: [],\n            exportConst: true,\n            expression: tsc.arrowFunction({\n              parameters: [\n                {\n                  isRequired,\n                  name: 'options',\n                  type: typeData,\n                },\n              ],\n              statements: [\n                tsc.returnFunctionCall({\n                  args: [\n                    tsc.objectExpression({\n                      comments: [\n                        {\n                          jsdoc: false,\n                          lines: ['@ts-ignore'],\n                        },\n                      ],\n                      obj: [\n                        {\n                          key: 'queryFn',\n                          value: tsc.arrowFunction({\n                            async: true,\n                            multiLine: true,\n                            parameters: [\n                              {\n                                destructure: [\n                                  {\n                                    name: 'pageParam',\n                                  },\n                                  {\n                                    name: 'queryKey',\n                                  },\n                                  {\n                                    name: 'signal',\n                                  },\n                                ],\n                              },\n                            ],\n                            statements: [\n                              tsc.constVariable({\n                                comment: [\n                                  {\n                                    jsdoc: false,\n                                    lines: ['@ts-ignore'],\n                                  },\n                                ],\n                                expression: tsc.conditionalExpression({\n                                  condition: tsc.binaryExpression({\n                                    left: tsc.typeOfExpression({\n                                      text: 'pageParam',\n                                    }),\n                                    operator: '===',\n                                    right: tsc.ots.string('object'),\n                                  }),\n                                  whenFalse: tsc.objectExpression({\n                                    multiLine: true,\n                                    obj: [\n                                      {\n                                        key: getPaginationIn(\n                                          paginationParameter,\n                                        ),\n                                        value: tsc.objectExpression({\n                                          multiLine: true,\n                                          obj: [\n                                            {\n                                              key: paginationField.name,\n                                              value: tsc.identifier({\n                                                text: 'pageParam',\n                                              }),\n                                            },\n                                          ],\n                                        }),\n                                      },\n                                    ],\n                                  }),\n                                  whenTrue: tsc.identifier({\n                                    text: 'pageParam',\n                                  }),\n                                }),\n                                name: 'page',\n                                typeName: typePageObjectParam,\n                              }),\n                              tsc.constVariable({\n                                expression: tsc.callExpression({\n                                  functionName: 'createInfiniteParams',\n                                  parameters: ['queryKey', 'page'],\n                                }),\n                                name: 'params',\n                              }),\n                              tsc.constVariable({\n                                destructure: true,\n                                expression: tsc.awaitExpression({\n                                  expression: tsc.callExpression({\n                                    functionName: queryFn,\n                                    parameters: [\n                                      tsc.objectExpression({\n                                        multiLine: true,\n                                        obj: [\n                                          {\n                                            spread: 'options',\n                                          },\n                                          {\n                                            spread: 'params',\n                                          },\n                                          {\n                                            key: 'signal',\n                                            shorthand: true,\n                                            value: tsc.identifier({\n                                              text: 'signal',\n                                            }),\n                                          },\n                                          {\n                                            key: 'throwOnError',\n                                            value: true,\n                                          },\n                                        ],\n                                      }),\n                                    ],\n                                  }),\n                                }),\n                                name: 'data',\n                              }),\n                              tsc.returnVariable({\n                                expression: 'data',\n                              }),\n                            ],\n                          }),\n                        },\n                        {\n                          key: 'queryKey',\n                          value: tsc.callExpression({\n                            functionName: toQueryKeyName({\n                              config,\n                              id: operation.name,\n                              isInfinite: true,\n                              operation,\n                            }),\n                            parameters: ['options'],\n                          }),\n                        },\n                      ],\n                    }),\n                  ],\n                  name: infiniteQueryOptionsFn,\n                  // TODO: better types syntax\n                  types: [\n                    typeResponse,\n                    typeError.name!,\n                    `${typeof typeInfiniteData === 'string' ? typeInfiniteData : typeInfiniteData.name}<${typeResponse}>`,\n                    typeQueryKey,\n                    typePageParam,\n                  ],\n                }),\n              ],\n            }),\n            name: toInfiniteQueryOptionsName(operation),\n          });\n          file.add(statement);\n        }\n      }\n\n      // mutations\n      if (\n        plugin.config.mutationOptions &&\n        (['DELETE', 'PATCH', 'POST', 'PUT'] as ReadonlyArray<Method>).includes(\n          operation.method,\n        )\n      ) {\n        if (!hasMutations) {\n          hasMutations = true;\n\n          file.import({\n            asType: true,\n            module: plugin.name,\n            name: mutationsType,\n          });\n        }\n\n        hasUsedQueryFn = true;\n\n        const { typeData } = createTypeData({\n          client,\n          file,\n          operation,\n          typesModulePath,\n        });\n        const { typeError } = createTypeError({\n          client,\n          file,\n          operation,\n          pluginName: plugin.name,\n          typesModulePath,\n        });\n        const { typeResponse } = createTypeResponse({\n          client,\n          file,\n          operation,\n          typesModulePath,\n        });\n\n        const fnOptions = 'fnOptions';\n\n        const expression = tsc.arrowFunction({\n          parameters: [\n            {\n              isRequired: false,\n              name: 'options',\n              type: `Partial<${typeData}>`,\n            },\n          ],\n          statements: [\n            tsc.constVariable({\n              expression: tsc.objectExpression({\n                obj: [\n                  {\n                    key: 'mutationFn',\n                    value: tsc.arrowFunction({\n                      async: true,\n                      multiLine: true,\n                      parameters: [\n                        {\n                          name: fnOptions,\n                        },\n                      ],\n                      statements: [\n                        tsc.constVariable({\n                          destructure: true,\n                          expression: tsc.awaitExpression({\n                            expression: tsc.callExpression({\n                              functionName: queryFn,\n                              parameters: [\n                                tsc.objectExpression({\n                                  multiLine: true,\n                                  obj: [\n                                    {\n                                      spread: 'options',\n                                    },\n                                    {\n                                      spread: fnOptions,\n                                    },\n                                    {\n                                      key: 'throwOnError',\n                                      value: true,\n                                    },\n                                  ],\n                                }),\n                              ],\n                            }),\n                          }),\n                          name: 'data',\n                        }),\n                        tsc.returnVariable({\n                          expression: 'data',\n                        }),\n                      ],\n                    }),\n                  },\n                ],\n              }),\n              name: mutationOptionsFn,\n              // TODO: better types syntax\n              typeName: `${mutationsType}<${typeResponse}, ${typeError.name}, ${typeData}>`,\n            }),\n            tsc.returnVariable({\n              expression: mutationOptionsFn,\n            }),\n          ],\n        });\n        const statement = tsc.constVariable({\n          // TODO: describe options, same as the actual function call\n          comment: [],\n          exportConst: true,\n          expression,\n          name: toMutationOptionsName(operation),\n        });\n        file.add(statement);\n      }\n\n      if (hasQueries || hasInfiniteQueries) {\n        file.import({\n          alias: '_heyApiClient',\n          module: relativeModulePath({\n            moduleOutput: files.client!.nameWithoutExtension(),\n            sourceOutput: plugin.output,\n          }),\n          name: 'client',\n        });\n      }\n\n      if (hasUsedQueryFn) {\n        file.import({\n          module: relativeModulePath({\n            moduleOutput: files.sdk!.nameWithoutExtension(),\n            sourceOutput: plugin.output,\n          }),\n          name: queryFn.split('.')[0]!,\n        });\n      }\n    }\n  }\n};\n","import type { Selector } from '@hey-api/codegen-core';\n\nimport type { Plugin } from '~/plugins';\n\ntype SelectorType =\n  | 'AxiosError'\n  | 'createInfiniteParams'\n  | 'createQueryKey'\n  | 'DefaultError'\n  | 'infiniteQueryOptions'\n  | 'InfiniteData'\n  | 'MutationOptions'\n  | 'queryOptions'\n  | 'queryOptionsFn'\n  | 'QueryKey'\n  | 'useQuery';\n\nexport type IApi = {\n  /**\n   * @param type Selector type.\n   * @param value Depends on `type`:\n   *  - `AxiosError`: never\n   *  - `createInfiniteParams`: never\n   *  - `createQueryKey`: never\n   *  - `DefaultError`: never\n   *  - `infiniteQueryOptions`: never\n   *  - `InfiniteData`: never\n   *  - `MutationOptions`: never\n   *  - `queryOptions`: never\n   *  - `queryOptionsFn`: `operation.id` string\n   *  - `QueryKey`: never\n   *  - `useQuery`: never\n   * @returns Selector array\n   */\n  selector: (type: SelectorType, value?: string) => Selector;\n};\n\nexport class Api implements IApi {\n  constructor(\n    public meta: Plugin.Name<'@tanstack/angular-query-experimental'>,\n  ) {}\n\n  selector(...args: ReadonlyArray<string | undefined>): Selector {\n    return [this.meta.name, ...(args as Selector)];\n  }\n}\n","import { handler } from '~/plugins/@tanstack/query-core/plugin';\nimport { handlerLegacy } from '~/plugins/@tanstack/query-core/plugin-legacy';\nimport { definePluginConfig } from '~/plugins/shared/utils/config';\n\nimport { Api } from './api';\nimport type { TanStackAngularQueryPlugin } from './types';\n\nexport const defaultConfig: TanStackAngularQueryPlugin['Config'] = {\n  api: new Api({\n    name: '@tanstack/angular-query-experimental',\n  }),\n  config: {\n    case: 'camelCase',\n    comments: true,\n    exportFromIndex: false,\n  },\n  dependencies: ['@hey-api/sdk', '@hey-api/typescript'],\n  handler: handler as TanStackAngularQueryPlugin['Handler'],\n  handlerLegacy: handlerLegacy as TanStackAngularQueryPlugin['LegacyHandler'],\n  name: '@tanstack/angular-query-experimental',\n  output: '@tanstack/angular-query-experimental',\n  resolveConfig: (plugin, context) => {\n    plugin.config.infiniteQueryKeys = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}InfiniteQueryKey',\n        tags: false,\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.infiniteQueryKeys,\n    });\n\n    plugin.config.infiniteQueryOptions = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}InfiniteOptions',\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.infiniteQueryOptions,\n    });\n\n    plugin.config.mutationOptions = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}Mutation',\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.mutationOptions,\n    });\n\n    plugin.config.queryKeys = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}QueryKey',\n        tags: false,\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.queryKeys,\n    });\n\n    plugin.config.queryOptions = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        exported: true,\n        name: '{{name}}Options',\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.queryOptions,\n    });\n  },\n};\n\n/**\n * Type helper for `@tanstack/angular-query-experimental` plugin, returns {@link Plugin.Config} object\n */\nexport const defineConfig = definePluginConfig(defaultConfig);\n","import type { Selector } from '@hey-api/codegen-core';\n\nimport type { Plugin } from '~/plugins';\n\ntype SelectorType =\n  | 'AxiosError'\n  | 'createInfiniteParams'\n  | 'createQueryKey'\n  | 'DefaultError'\n  | 'infiniteQueryOptions'\n  | 'InfiniteData'\n  | 'MutationOptions'\n  | 'queryOptions'\n  | 'queryOptionsFn'\n  | 'QueryKey'\n  | 'useQuery';\n\nexport type IApi = {\n  /**\n   * @param type Selector type.\n   * @param value Depends on `type`:\n   *  - `AxiosError`: never\n   *  - `createInfiniteParams`: never\n   *  - `createQueryKey`: never\n   *  - `DefaultError`: never\n   *  - `infiniteQueryOptions`: never\n   *  - `InfiniteData`: never\n   *  - `MutationOptions`: never\n   *  - `queryOptions`: never\n   *  - `queryOptionsFn`: `operation.id` string\n   *  - `QueryKey`: never\n   *  - `useQuery`: never\n   * @returns Selector array\n   */\n  selector: (type: SelectorType, value?: string) => Selector;\n};\n\nexport class Api implements IApi {\n  constructor(public meta: Plugin.Name<'@tanstack/react-query'>) {}\n\n  selector(...args: ReadonlyArray<string | undefined>): Selector {\n    return [this.meta.name, ...(args as Selector)];\n  }\n}\n","import { handler } from '~/plugins/@tanstack/query-core/plugin';\nimport { handlerLegacy } from '~/plugins/@tanstack/query-core/plugin-legacy';\nimport { definePluginConfig } from '~/plugins/shared/utils/config';\n\nimport { Api } from './api';\nimport type { TanStackReactQueryPlugin } from './types';\n\nexport const defaultConfig: TanStackReactQueryPlugin['Config'] = {\n  api: new Api({\n    name: '@tanstack/react-query',\n  }),\n  config: {\n    case: 'camelCase',\n    comments: true,\n    exportFromIndex: false,\n  },\n  dependencies: ['@hey-api/sdk', '@hey-api/typescript'],\n  handler: handler as TanStackReactQueryPlugin['Handler'],\n  handlerLegacy: handlerLegacy as TanStackReactQueryPlugin['LegacyHandler'],\n  name: '@tanstack/react-query',\n  output: '@tanstack/react-query',\n  resolveConfig: (plugin, context) => {\n    plugin.config.infiniteQueryKeys = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}InfiniteQueryKey',\n        tags: false,\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.infiniteQueryKeys,\n    });\n\n    plugin.config.infiniteQueryOptions = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}InfiniteOptions',\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.infiniteQueryOptions,\n    });\n\n    plugin.config.mutationOptions = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}Mutation',\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.mutationOptions,\n    });\n\n    plugin.config.queryKeys = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}QueryKey',\n        tags: false,\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.queryKeys,\n    });\n\n    plugin.config.queryOptions = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        exported: true,\n        name: '{{name}}Options',\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.queryOptions,\n    });\n\n    plugin.config.useQuery = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: false,\n        name: 'use{{name}}Query',\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ enabled: true, name }),\n        object: (fields) => ({ enabled: true, ...fields }),\n        string: (name) => ({ enabled: true, name }),\n      },\n      value: plugin.config.useQuery,\n    });\n\n    if (plugin.config.useQuery.enabled) {\n      // useQuery hooks consume queryOptions\n      if (!plugin.config.queryOptions.enabled) {\n        plugin.config.queryOptions.enabled = true;\n        plugin.config.queryOptions.exported = false;\n      }\n    }\n  },\n};\n\n/**\n * Type helper for `@tanstack/react-query` plugin, returns {@link Plugin.Config} object\n */\nexport const defineConfig = definePluginConfig(defaultConfig);\n","import type { Selector } from '@hey-api/codegen-core';\n\nimport type { Plugin } from '~/plugins';\n\ntype SelectorType =\n  | 'AxiosError'\n  | 'createInfiniteParams'\n  | 'createQueryKey'\n  | 'DefaultError'\n  | 'infiniteQueryOptions'\n  | 'InfiniteData'\n  | 'MutationOptions'\n  | 'queryOptions'\n  | 'queryOptionsFn'\n  | 'QueryKey'\n  | 'useQuery';\n\nexport type IApi = {\n  /**\n   * @param type Selector type.\n   * @param value Depends on `type`:\n   *  - `AxiosError`: never\n   *  - `createInfiniteParams`: never\n   *  - `createQueryKey`: never\n   *  - `DefaultError`: never\n   *  - `infiniteQueryOptions`: never\n   *  - `InfiniteData`: never\n   *  - `MutationOptions`: never\n   *  - `queryOptions`: never\n   *  - `queryOptionsFn`: `operation.id` string\n   *  - `QueryKey`: never\n   *  - `useQuery`: never\n   * @returns Selector array\n   */\n  selector: (type: SelectorType, value?: string) => Selector;\n};\n\nexport class Api implements IApi {\n  constructor(public meta: Plugin.Name<'@tanstack/solid-query'>) {}\n\n  selector(...args: ReadonlyArray<string | undefined>): Selector {\n    return [this.meta.name, ...(args as Selector)];\n  }\n}\n","import { handler } from '~/plugins/@tanstack/query-core/plugin';\nimport { handlerLegacy } from '~/plugins/@tanstack/query-core/plugin-legacy';\nimport { definePluginConfig } from '~/plugins/shared/utils/config';\n\nimport { Api } from './api';\nimport type { TanStackSolidQueryPlugin } from './types';\n\nexport const defaultConfig: TanStackSolidQueryPlugin['Config'] = {\n  api: new Api({\n    name: '@tanstack/solid-query',\n  }),\n  config: {\n    case: 'camelCase',\n    comments: true,\n    exportFromIndex: false,\n  },\n  dependencies: ['@hey-api/sdk', '@hey-api/typescript'],\n  handler: handler as TanStackSolidQueryPlugin['Handler'],\n  handlerLegacy: handlerLegacy as TanStackSolidQueryPlugin['LegacyHandler'],\n  name: '@tanstack/solid-query',\n  output: '@tanstack/solid-query',\n  resolveConfig: (plugin, context) => {\n    plugin.config.infiniteQueryKeys = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}InfiniteQueryKey',\n        tags: false,\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.infiniteQueryKeys,\n    });\n\n    plugin.config.infiniteQueryOptions = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}InfiniteOptions',\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.infiniteQueryOptions,\n    });\n\n    plugin.config.mutationOptions = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}Mutation',\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.mutationOptions,\n    });\n\n    plugin.config.queryKeys = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}QueryKey',\n        tags: false,\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.queryKeys,\n    });\n\n    plugin.config.queryOptions = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        exported: true,\n        name: '{{name}}Options',\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.queryOptions,\n    });\n  },\n};\n\n/**\n * Type helper for `@tanstack/solid-query` plugin, returns {@link Plugin.Config} object\n */\nexport const defineConfig = definePluginConfig(defaultConfig);\n","import type { Selector } from '@hey-api/codegen-core';\n\nimport type { Plugin } from '~/plugins';\n\ntype SelectorType =\n  | 'AxiosError'\n  | 'createInfiniteParams'\n  | 'createQueryKey'\n  | 'DefaultError'\n  | 'infiniteQueryOptions'\n  | 'InfiniteData'\n  | 'MutationOptions'\n  | 'queryOptions'\n  | 'queryOptionsFn'\n  | 'QueryKey'\n  | 'useQuery';\n\nexport type IApi = {\n  /**\n   * @param type Selector type.\n   * @param value Depends on `type`:\n   *  - `AxiosError`: never\n   *  - `createInfiniteParams`: never\n   *  - `createQueryKey`: never\n   *  - `DefaultError`: never\n   *  - `infiniteQueryOptions`: never\n   *  - `InfiniteData`: never\n   *  - `MutationOptions`: never\n   *  - `queryOptions`: never\n   *  - `queryOptionsFn`: `operation.id` string\n   *  - `QueryKey`: never\n   *  - `useQuery`: never\n   * @returns Selector array\n   */\n  selector: (type: SelectorType, value?: string) => Selector;\n};\n\nexport class Api implements IApi {\n  constructor(public meta: Plugin.Name<'@tanstack/svelte-query'>) {}\n\n  selector(...args: ReadonlyArray<string | undefined>): Selector {\n    return [this.meta.name, ...(args as Selector)];\n  }\n}\n","import { handler } from '~/plugins/@tanstack/query-core/plugin';\nimport { handlerLegacy } from '~/plugins/@tanstack/query-core/plugin-legacy';\nimport { definePluginConfig } from '~/plugins/shared/utils/config';\n\nimport { Api } from './api';\nimport type { TanStackSvelteQueryPlugin } from './types';\n\nexport const defaultConfig: TanStackSvelteQueryPlugin['Config'] = {\n  api: new Api({\n    name: '@tanstack/svelte-query',\n  }),\n  config: {\n    case: 'camelCase',\n    comments: true,\n    exportFromIndex: false,\n  },\n  dependencies: ['@hey-api/sdk', '@hey-api/typescript'],\n  handler: handler as TanStackSvelteQueryPlugin['Handler'],\n  handlerLegacy: handlerLegacy as TanStackSvelteQueryPlugin['LegacyHandler'],\n  name: '@tanstack/svelte-query',\n  output: '@tanstack/svelte-query',\n  resolveConfig: (plugin, context) => {\n    plugin.config.infiniteQueryKeys = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}InfiniteQueryKey',\n        tags: false,\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.infiniteQueryKeys,\n    });\n\n    plugin.config.infiniteQueryOptions = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}InfiniteOptions',\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.infiniteQueryOptions,\n    });\n\n    plugin.config.mutationOptions = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}Mutation',\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.mutationOptions,\n    });\n\n    plugin.config.queryKeys = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}QueryKey',\n        tags: false,\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.queryKeys,\n    });\n\n    plugin.config.queryOptions = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        exported: true,\n        name: '{{name}}Options',\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.queryOptions,\n    });\n  },\n};\n\n/**\n * Type helper for `@tanstack/svelte-query` plugin, returns {@link Plugin.Config} object\n */\nexport const defineConfig = definePluginConfig(defaultConfig);\n","import type { Selector } from '@hey-api/codegen-core';\n\nimport type { Plugin } from '~/plugins';\n\ntype SelectorType =\n  | 'AxiosError'\n  | 'createInfiniteParams'\n  | 'createQueryKey'\n  | 'DefaultError'\n  | 'infiniteQueryOptions'\n  | 'InfiniteData'\n  | 'MutationOptions'\n  | 'queryOptions'\n  | 'queryOptionsFn'\n  | 'QueryKey'\n  | 'useQuery';\n\nexport type IApi = {\n  /**\n   * @param type Selector type.\n   * @param value Depends on `type`:\n   *  - `AxiosError`: never\n   *  - `createInfiniteParams`: never\n   *  - `createQueryKey`: never\n   *  - `DefaultError`: never\n   *  - `infiniteQueryOptions`: never\n   *  - `InfiniteData`: never\n   *  - `MutationOptions`: never\n   *  - `queryOptions`: never\n   *  - `queryOptionsFn`: `operation.id` string\n   *  - `QueryKey`: never\n   *  - `useQuery`: never\n   * @returns Selector array\n   */\n  selector: (type: SelectorType, value?: string) => Selector;\n};\n\nexport class Api implements IApi {\n  constructor(public meta: Plugin.Name<'@tanstack/vue-query'>) {}\n\n  selector(...args: ReadonlyArray<string | undefined>): Selector {\n    return [this.meta.name, ...(args as Selector)];\n  }\n}\n","import { handler } from '~/plugins/@tanstack/query-core/plugin';\nimport { handlerLegacy } from '~/plugins/@tanstack/query-core/plugin-legacy';\nimport { definePluginConfig } from '~/plugins/shared/utils/config';\n\nimport { Api } from './api';\nimport type { TanStackVueQueryPlugin } from './types';\n\nexport const defaultConfig: TanStackVueQueryPlugin['Config'] = {\n  api: new Api({\n    name: '@tanstack/vue-query',\n  }),\n  config: {\n    case: 'camelCase',\n    comments: true,\n    exportFromIndex: false,\n  },\n  dependencies: ['@hey-api/sdk', '@hey-api/typescript'],\n  handler: handler as TanStackVueQueryPlugin['Handler'],\n  handlerLegacy: handlerLegacy as TanStackVueQueryPlugin['LegacyHandler'],\n  name: '@tanstack/vue-query',\n  output: '@tanstack/vue-query',\n  resolveConfig: (plugin, context) => {\n    plugin.config.infiniteQueryKeys = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}InfiniteQueryKey',\n        tags: false,\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.infiniteQueryKeys,\n    });\n\n    plugin.config.infiniteQueryOptions = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}InfiniteOptions',\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.infiniteQueryOptions,\n    });\n\n    plugin.config.mutationOptions = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}Mutation',\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.mutationOptions,\n    });\n\n    plugin.config.queryKeys = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}QueryKey',\n        tags: false,\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.queryKeys,\n    });\n\n    plugin.config.queryOptions = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        exported: true,\n        name: '{{name}}Options',\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.queryOptions,\n    });\n  },\n};\n\n/**\n * Type helper for `@tanstack/vue-query` plugin, returns {@link Plugin.Config} object\n */\nexport const defineConfig = definePluginConfig(defaultConfig);\n","import type ts from 'typescript';\n\nimport { tsc } from '~/tsc';\n\n// import { identifiers } from '../constants';\nimport type { ValidatorArgs } from '../shared/types';\n\nexport const createRequestValidatorV2 = ({\n  operation,\n  plugin,\n}: ValidatorArgs): ts.ArrowFunction | undefined => {\n  const symbol = plugin.getSymbol(plugin.api.selector('data', operation.id));\n  if (!symbol) return;\n\n  // const out = User({\n  //   name: \"Alan Turing\",\n  //   device: {\n  //     platform: \"enigma\",\n  //     versions: [0, \"1\", 0n]\n  //   }\n  // })\n  // if (out instanceof type.errors) {\n  //   // hover out.summary to see validation errors\n  //   console.error(out.summary)\n  // } else {\n  //   // hover out to see your validated data\n  //   console.log(`Hello, ${out.name}`)\n  // }\n  const dataParameterName = 'data';\n\n  return tsc.arrowFunction({\n    async: true,\n    parameters: [\n      {\n        name: dataParameterName,\n      },\n    ],\n    statements: [\n      tsc.returnStatement({\n        expression: tsc.awaitExpression({\n          expression: tsc.callExpression({\n            functionName: tsc.propertyAccessExpression({\n              expression: symbol.placeholder,\n              name: 'parseAsync',\n              // name: identifiers.parseAsync,\n            }),\n            parameters: [tsc.identifier({ text: dataParameterName })],\n          }),\n        }),\n      }),\n    ],\n  });\n};\n\nexport const createResponseValidatorV2 = ({\n  operation,\n  plugin,\n}: ValidatorArgs): ts.ArrowFunction | undefined => {\n  const symbol = plugin.getSymbol(\n    plugin.api.selector('responses', operation.id),\n  );\n  if (!symbol) return;\n\n  const dataParameterName = 'data';\n\n  return tsc.arrowFunction({\n    async: true,\n    parameters: [\n      {\n        name: dataParameterName,\n      },\n    ],\n    statements: [\n      tsc.returnStatement({\n        expression: tsc.awaitExpression({\n          expression: tsc.callExpression({\n            functionName: tsc.propertyAccessExpression({\n              expression: symbol.placeholder,\n              name: 'parseAsync',\n              // name: identifiers.parseAsync,\n            }),\n            parameters: [tsc.identifier({ text: dataParameterName })],\n          }),\n        }),\n      }),\n    ],\n  });\n};\n","import type { Selector } from '@hey-api/codegen-core';\nimport type ts from 'typescript';\n\nimport type { Plugin } from '~/plugins';\n\nimport type { ValidatorArgs } from './shared/types';\nimport { createRequestValidatorV2, createResponseValidatorV2 } from './v2/api';\n\ntype SelectorType =\n  | 'data'\n  | 'external'\n  | 'ref'\n  | 'responses'\n  | 'type-infer-data'\n  | 'type-infer-ref'\n  | 'type-infer-responses'\n  | 'type-infer-webhook-request'\n  | 'webhook-request';\n\nexport type IApi = {\n  createRequestValidator: (args: ValidatorArgs) => ts.ArrowFunction | undefined;\n  createResponseValidator: (\n    args: ValidatorArgs,\n  ) => ts.ArrowFunction | undefined;\n  /**\n   * @param type Selector type.\n   * @param value Depends on `type`:\n   *  - `data`: `operation.id` string\n   *  - `external`: external modules\n   *  - `ref`: `$ref` JSON pointer\n   *  - `responses`: `operation.id` string\n   *  - `type-infer-data`: `operation.id` string\n   *  - `type-infer-ref`: `$ref` JSON pointer\n   *  - `type-infer-responses`: `operation.id` string\n   *  - `type-infer-webhook-request`: `operation.id` string\n   *  - `webhook-request`: `operation.id` string\n   * @returns Selector array\n   */\n  selector: (type: SelectorType, value?: string) => Selector;\n};\n\nexport class Api implements IApi {\n  constructor(public meta: Plugin.Name<'arktype'>) {}\n\n  createRequestValidator(args: ValidatorArgs): ts.ArrowFunction | undefined {\n    return createRequestValidatorV2(args);\n  }\n\n  createResponseValidator(args: ValidatorArgs): ts.ArrowFunction | undefined {\n    return createResponseValidatorV2(args);\n  }\n\n  selector(...args: ReadonlyArray<string | undefined>): Selector {\n    return [this.meta.name, ...(args as Selector)];\n  }\n}\n","import { tsc } from '~/tsc';\n\nexport const identifiers = {\n  keywords: {\n    false: tsc.identifier({ text: 'false' }),\n    true: tsc.identifier({ text: 'true' }),\n  },\n  /**\n   * {@link https://arktype.io/docs/primitives#number Number}\n   */\n  number: {\n    Infinity: tsc.identifier({ text: 'Infinity' }),\n    NaN: tsc.identifier({ text: 'NaN' }),\n    NegativeInfinity: tsc.identifier({ text: 'NegativeInfinity' }),\n    epoch: tsc.identifier({ text: 'epoch' }),\n    integer: tsc.identifier({ text: 'integer' }),\n    safe: tsc.identifier({ text: 'safe' }),\n  },\n  /**\n   * {@link https://arktype.io/docs/primitives Primitives}\n   */\n  primitives: {\n    bigint: tsc.identifier({ text: 'bigint' }),\n    boolean: tsc.identifier({ text: 'boolean' }),\n    keywords: tsc.identifier({ text: 'keywords' }),\n    null: 'null',\n    number: tsc.identifier({ text: 'number' }),\n    string: 'string',\n    symbol: tsc.identifier({ text: 'symbol' }),\n    undefined: tsc.identifier({ text: 'undefined' }),\n    unit: tsc.identifier({ text: 'unit' }),\n  },\n  /**\n   * {@link https://arktype.io/docs/primitives#string String}\n   */\n  string: {\n    NFC: tsc.identifier({ text: 'NFC' }),\n    NFD: tsc.identifier({ text: 'NFD' }),\n    NFKC: tsc.identifier({ text: 'NFKC' }),\n    NFKD: tsc.identifier({ text: 'NFKD' }),\n    alpha: tsc.identifier({ text: 'alpha' }),\n    alphanumeric: tsc.identifier({ text: 'alphanumeric' }),\n    base64: tsc.identifier({ text: 'base64' }),\n    capitalize: tsc.identifier({ text: 'capitalize' }),\n    creditCard: tsc.identifier({ text: 'creditCard' }),\n    date: 'date',\n    digits: tsc.identifier({ text: 'digits' }),\n    email: 'email',\n    epoch: tsc.identifier({ text: 'epoch' }),\n    hex: tsc.identifier({ text: 'hex' }),\n    integer: tsc.identifier({ text: 'integer' }),\n    ip: 'ip',\n    iso: 'iso',\n    json: tsc.identifier({ text: 'json' }),\n    lower: tsc.identifier({ text: 'lower' }),\n    normalize: tsc.identifier({ text: 'normalize' }),\n    numeric: tsc.identifier({ text: 'numeric' }),\n    parse: tsc.identifier({ text: 'parse' }),\n    preformatted: tsc.identifier({ text: 'preformatted' }),\n    regex: tsc.identifier({ text: 'regex' }),\n    semver: tsc.identifier({ text: 'semver' }),\n    trim: tsc.identifier({ text: 'trim' }),\n    upper: tsc.identifier({ text: 'upper' }),\n    url: 'url',\n    uuid: 'uuid',\n    v1: 'v1',\n    v2: 'v2',\n    v3: 'v3',\n    v4: 'v4',\n    v5: 'v5',\n    v6: 'v6',\n    v7: 'v7',\n    v8: 'v8',\n  },\n  /**\n   * {@link https://arktype.io/docs/type-api Type API}\n   */\n  type: {\n    $: tsc.identifier({ text: '$' }),\n    allows: tsc.identifier({ text: 'allows' }),\n    and: tsc.identifier({ text: 'and' }),\n    array: tsc.identifier({ text: 'array' }),\n    as: tsc.identifier({ text: 'as' }),\n    assert: tsc.identifier({ text: 'assert' }),\n    brand: tsc.identifier({ text: 'brand' }),\n    configure: tsc.identifier({ text: 'configure' }),\n    default: tsc.identifier({ text: 'default' }),\n    describe: tsc.identifier({ text: 'describe' }),\n    description: tsc.identifier({ text: 'description' }),\n    equals: tsc.identifier({ text: 'equals' }),\n    exclude: tsc.identifier({ text: 'exclude' }),\n    expression: tsc.identifier({ text: 'expression' }),\n    extends: tsc.identifier({ text: 'extends' }),\n    extract: tsc.identifier({ text: 'extract' }),\n    filter: tsc.identifier({ text: 'filter' }),\n    from: tsc.identifier({ text: 'from' }),\n    ifEquals: tsc.identifier({ text: 'ifEquals' }),\n    ifExtends: tsc.identifier({ text: 'ifExtends' }),\n    infer: tsc.identifier({ text: 'infer' }),\n    inferIn: tsc.identifier({ text: 'inferIn' }),\n    intersect: tsc.identifier({ text: 'intersect' }),\n    json: tsc.identifier({ text: 'json' }),\n    meta: tsc.identifier({ text: 'meta' }),\n    narrow: tsc.identifier({ text: 'narrow' }),\n    onDeepUndeclaredKey: tsc.identifier({ text: 'onDeepUndeclaredKey' }),\n    onUndeclaredKey: tsc.identifier({ text: 'onUndeclaredKey' }),\n    optional: tsc.identifier({ text: 'optional' }),\n    or: tsc.identifier({ text: 'or' }),\n    overlaps: tsc.identifier({ text: 'overlaps' }),\n    pipe: tsc.identifier({ text: 'pipe' }),\n    select: tsc.identifier({ text: 'select' }),\n    to: tsc.identifier({ text: 'to' }),\n    toJsonSchema: tsc.identifier({ text: 'toJsonSchema' }),\n  },\n};\n","import type { Symbol } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport type { IR } from '~/ir/types';\nimport { createSchemaComment } from '~/plugins/shared/utils/schema';\nimport { tsc } from '~/tsc';\n\nimport { identifiers } from '../constants';\nimport type { ArktypePlugin } from '../types';\nimport type { Ast } from './types';\n\nexport const exportAst = ({\n  ast,\n  plugin,\n  schema,\n  symbol,\n  typeInferSymbol,\n}: {\n  ast: Ast;\n  plugin: ArktypePlugin['Instance'];\n  schema: IR.SchemaObject;\n  symbol: Symbol;\n  typeInferSymbol: Symbol | undefined;\n}): void => {\n  const type = plugin.referenceSymbol(\n    plugin.api.selector('external', 'arktype.type'),\n  );\n\n  const statement = tsc.constVariable({\n    comment: plugin.config.comments\n      ? createSchemaComment({ schema })\n      : undefined,\n    exportConst: symbol.exported,\n    expression: tsc.callExpression({\n      functionName: type.placeholder,\n      parameters: [\n        ast.def ? tsc.stringLiteral({ text: ast.def }) : ast.expression,\n      ],\n    }),\n    name: symbol.placeholder,\n    // typeName: ast.typeName\n    //   ? (tsc.propertyAccessExpression({\n    //       expression: z.placeholder,\n    //       name: ast.typeName,\n    //     }) as unknown as ts.TypeNode)\n    //   : undefined,\n  });\n  plugin.setSymbolValue(symbol, statement);\n\n  if (typeInferSymbol) {\n    const inferType = tsc.typeAliasDeclaration({\n      exportType: typeInferSymbol.exported,\n      name: typeInferSymbol.placeholder,\n      type: ts.factory.createTypeQueryNode(\n        ts.factory.createQualifiedName(\n          ts.factory.createIdentifier(symbol.placeholder),\n          identifiers.type.infer,\n        ),\n      ),\n    });\n    plugin.setSymbolValue(typeInferSymbol, inferType);\n  }\n};\n","import type { SchemaWithType } from '~/plugins/shared/types/schema';\n\nimport { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\n\nexport const nullToAst = (\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _args: IrSchemaToAstOptions & {\n    schema: SchemaWithType<'null'>;\n  },\n): Omit<Ast, 'typeName'> => {\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n  result.def = identifiers.primitives.null;\n  return result as Omit<Ast, 'typeName'>;\n};\n","import ts from 'typescript';\n\nimport type { SchemaWithType } from '~/plugins/shared/types/schema';\nimport { toRef } from '~/plugins/shared/utils/refs';\nimport { tsc } from '~/tsc';\nimport { numberRegExp } from '~/utils/regexp';\n\n// import { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\nimport { irSchemaToAst } from '../plugin';\n\nexport const objectToAst = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'object'>;\n}): Omit<Ast, 'typeName'> => {\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n\n  // TODO: parser - handle constants\n  const properties: Array<ts.PropertyAssignment | ts.GetAccessorDeclaration> =\n    [];\n\n  const required = schema.required ?? [];\n\n  for (const name in schema.properties) {\n    const property = schema.properties[name]!;\n    const isRequired = required.includes(name);\n\n    const propertyAst = irSchemaToAst({\n      optional: !isRequired,\n      plugin,\n      schema: property,\n      state: {\n        ...state,\n        path: toRef([...state.path.value, 'properties', name]),\n      },\n    });\n    if (propertyAst.hasLazyExpression) {\n      result.hasLazyExpression = true;\n    }\n\n    let propertyName:\n      | ts.ComputedPropertyName\n      | ts.StringLiteral\n      | ts.NumericLiteral\n      | string = isRequired ? name : `${name}?`;\n\n    // if (propertyAst.hasCircularReference) {\n    //   properties.push(\n    //     tsc.getAccessorDeclaration({\n    //       name: propertyName,\n    //       // @ts-expect-error\n    //       returnType: propertyAst.typeName\n    //         ? tsc.propertyAccessExpression({\n    //             expression: 'TODO',\n    //             name: propertyAst.typeName,\n    //           })\n    //         : undefined,\n    //       statements: [\n    //         tsc.returnStatement({\n    //           expression: propertyAst.expression,\n    //         }),\n    //       ],\n    //     }),\n    //   );\n    // } else {\n    //   properties.push(\n    //     tsc.propertyAssignment({\n    //       initializer: propertyAst.expression,\n    //       name: ts.factory.createComputedPropertyName(\n    //         ts.factory.createStringLiteral(`${propertyName}?`),\n    //       ),\n    //     }),\n    //   );\n    // }\n\n    if (propertyName.endsWith('?')) {\n      propertyName = ts.factory.createComputedPropertyName(\n        tsc.stringLiteral({ text: propertyName }),\n      );\n    } else {\n      // TODO: parser - abstract safe property name logic\n      if (\n        ((propertyName.match(/^[0-9]/) && propertyName.match(/\\D+/g)) ||\n          propertyName.match(/\\W/g)) &&\n        !propertyName.startsWith(\"'\") &&\n        !propertyName.endsWith(\"'\")\n      ) {\n        propertyName = `'${propertyName}'`;\n      }\n\n      numberRegExp.lastIndex = 0;\n      if (numberRegExp.test(propertyName)) {\n        // For numeric literals, we'll handle negative numbers by using a string literal\n        // instead of trying to use a PrefixUnaryExpression\n        propertyName = propertyName.startsWith('-')\n          ? tsc.stringLiteral({ text: name })\n          : ts.factory.createNumericLiteral(name);\n      } else {\n        propertyName = name;\n      }\n    }\n    properties.push(\n      tsc.propertyAssignment({\n        initializer: propertyAst.expression,\n        name: propertyName,\n      }),\n    );\n  }\n\n  if (\n    schema.additionalProperties &&\n    (!schema.properties || !Object.keys(schema.properties).length)\n  ) {\n    const additionalAst = irSchemaToAst({\n      plugin,\n      schema: schema.additionalProperties,\n      state: {\n        ...state,\n        path: toRef([...state.path.value, 'additionalProperties']),\n      },\n    });\n    result.expression = tsc.callExpression({\n      functionName: tsc.propertyAccessExpression({\n        expression: 'TODO',\n        name: 'record',\n        // name: identifiers.record,\n      }),\n      parameters: [\n        tsc.callExpression({\n          functionName: tsc.propertyAccessExpression({\n            expression: 'TODO',\n            name: 'string',\n            // name: identifiers.string,\n          }),\n          parameters: [],\n        }),\n        additionalAst.expression,\n      ],\n    });\n    if (additionalAst.hasLazyExpression) {\n      result.hasLazyExpression = true;\n    }\n\n    // Return with typeName for circular references\n    if (result.hasLazyExpression) {\n      return {\n        ...result,\n        typeName: 'TODO',\n      } as Ast;\n    }\n\n    return result as Omit<Ast, 'typeName'>;\n  }\n\n  result.expression = ts.factory.createObjectLiteralExpression(\n    properties,\n    true,\n  );\n\n  // return with typeName for circular references\n  if (result.hasLazyExpression) {\n    return {\n      ...result,\n      typeName: 'TODO',\n    } as Ast;\n  }\n\n  return result as Omit<Ast, 'typeName'>;\n};\n","import type { SchemaWithType } from '~/plugins/shared/types/schema';\n\nimport { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\n\nexport const stringToAst = ({\n  schema,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'string'>;\n}): Omit<Ast, 'typeName'> => {\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n\n  if (typeof schema.const === 'string') {\n    result.def = schema.const;\n    return result as Omit<Ast, 'typeName'>;\n  }\n\n  let def = identifiers.primitives.string;\n\n  if (schema.format) {\n    switch (schema.format) {\n      case 'date':\n      case 'date-time':\n      case 'time':\n        def = `${def}.${identifiers.string.date}.${identifiers.string.iso}`;\n        break;\n      case 'email':\n        def = `${def}.${identifiers.string.email}`;\n        break;\n      case 'ipv4':\n        def = `${def}.${identifiers.string.ip}.${identifiers.string.v4}`;\n        break;\n      case 'ipv6':\n        def = `${def}.${identifiers.string.ip}.${identifiers.string.v6}`;\n        break;\n      case 'uri':\n        def = `${def}.${identifiers.string.url}`;\n        break;\n      case 'uuid':\n        def = `${def}.${identifiers.string.uuid}`;\n        break;\n    }\n  }\n\n  if (schema.minLength === schema.maxLength && schema.minLength !== undefined) {\n    def = `${schema.minLength} <= ${def} <= ${schema.maxLength}`;\n  } else {\n    if (schema.maxLength !== undefined) {\n      def = `${def} <= ${schema.maxLength}`;\n\n      if (schema.minLength !== undefined) {\n        def = `${schema.minLength} <= ${def}`;\n      }\n    } else if (schema.minLength !== undefined) {\n      def = `${def} >= ${schema.minLength}`;\n    }\n  }\n\n  if (schema.pattern) {\n    def = `/${schema.pattern}/`;\n  }\n\n  result.def = def;\n\n  return result as Omit<Ast, 'typeName'>;\n};\n","import ts from 'typescript';\n\nimport type { SchemaWithType } from '~/plugins/shared/types/schema';\n\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\nimport { nullToAst } from './null';\nimport { objectToAst } from './object';\nimport { stringToAst } from './string';\n// import { arrayToAst } from \"./array\";\n// import { booleanToAst } from \"./boolean\";\n// import { enumToAst } from \"./enum\";\n// import { neverToAst } from \"./never\";\n// import { numberToAst } from \"./number\";\n// import { tupleToAst } from \"./tuple\";\n// import { undefinedToAst } from \"./undefined\";\n// import { unknownToAst } from \"./unknown\";\n// import { voidToAst } from \"./void\";\n\nexport const irSchemaWithTypeToAst = ({\n  schema,\n  ...args\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType;\n}): Omit<Ast, 'typeName'> => {\n  switch (schema.type) {\n    // case 'array':\n    //   return arrayToAst({\n    //     ...args,\n    //     schema: schema as SchemaWithType<'array'>,\n    //   });\n    // case 'boolean':\n    //   return booleanToAst({\n    //     ...args,\n    //     schema: schema as SchemaWithType<'boolean'>,\n    //   });\n    // case 'enum':\n    //   return enumToAst({\n    //     ...args,\n    //     schema: schema as SchemaWithType<'enum'>,\n    //   });\n    // case 'integer':\n    // case 'number':\n    //   return numberToAst({\n    //     ...args,\n    //     schema: schema as SchemaWithType<'integer' | 'number'>,\n    //   });\n    // case 'never':\n    //   return neverToAst({\n    //     ...args,\n    //     schema: schema as SchemaWithType<'never'>,\n    //   });\n    case 'null':\n      return nullToAst({\n        ...args,\n        schema: schema as SchemaWithType<'null'>,\n      });\n    case 'object':\n      return objectToAst({\n        ...args,\n        schema: schema as SchemaWithType<'object'>,\n      });\n    case 'string':\n      return stringToAst({\n        ...args,\n        schema: schema as SchemaWithType<'string'>,\n      });\n    // case 'tuple':\n    //   return tupleToAst({\n    //     ...args,\n    //     schema: schema as SchemaWithType<'tuple'>,\n    //   });\n    // case 'undefined':\n    //   return undefinedToAst({\n    //     ...args,\n    //     schema: schema as SchemaWithType<'undefined'>,\n    //   });\n    // case 'unknown':\n    //   return unknownToAst({\n    //     ...args,\n    //     schema: schema as SchemaWithType<'unknown'>,\n    //   });\n    // case 'void':\n    //   return voidToAst({\n    //     ...args,\n    //     schema: schema as SchemaWithType<'void'>,\n    //   });\n  }\n\n  const type = args.plugin.referenceSymbol(\n    args.plugin.api.selector('external', 'arktype.type'),\n  );\n\n  const expression = ts.factory.createCallExpression(\n    ts.factory.createIdentifier(type.placeholder),\n    undefined,\n    [\n      ts.factory.createObjectLiteralExpression(\n        [\n          ts.factory.createPropertyAssignment(\n            'name',\n            ts.factory.createStringLiteral('string'),\n          ),\n          ts.factory.createPropertyAssignment(\n            'platform',\n            ts.factory.createStringLiteral(\"'android' | 'ios'\"),\n          ),\n          ts.factory.createPropertyAssignment(\n            ts.factory.createComputedPropertyName(\n              ts.factory.createStringLiteral('versions?'),\n            ),\n            ts.factory.createStringLiteral('(number | string)[]'),\n          ),\n        ],\n        true,\n      ),\n    ],\n  );\n\n  return {\n    def: '',\n    expression,\n    hasLazyExpression: false,\n  };\n};\n","import { deduplicateSchema } from '~/ir/schema';\nimport type { IR } from '~/ir/types';\nimport { buildName } from '~/openApi/shared/utils/name';\nimport type { SchemaWithType } from '~/plugins/shared/types/schema';\nimport { toRefs } from '~/plugins/shared/utils/refs';\nimport { tsc } from '~/tsc';\nimport { pathToJsonPointer, refToName } from '~/utils/ref';\n\nimport { exportAst } from '../shared/export';\nimport type { Ast, IrSchemaToAstOptions, PluginState } from '../shared/types';\nimport type { ArktypePlugin } from '../types';\nimport { irSchemaWithTypeToAst } from './toAst';\n\nexport const irSchemaToAst = ({\n  // optional,\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  /**\n   * Accept `optional` to handle optional object properties. We can't handle\n   * this inside the object function because `.optional()` must come before\n   * `.default()` which is handled in this function.\n   */\n  optional?: boolean;\n  schema: IR.SchemaObject;\n}): Ast => {\n  let ast: Partial<Ast> = {};\n\n  // const z = plugin.referenceSymbol(plugin.api.selector('external', 'zod.z'));\n\n  if (schema.$ref) {\n    const selector = plugin.api.selector('ref', schema.$ref);\n    const refSymbol = plugin.referenceSymbol(selector);\n    if (plugin.isSymbolRegistered(selector)) {\n      const ref = tsc.identifier({ text: refSymbol.placeholder });\n      ast.expression = ref;\n    } else {\n      const lazyExpression = tsc.callExpression({\n        functionName: tsc.propertyAccessExpression({\n          // expression: z.placeholder,\n          expression: 'TODO',\n          name: 'TODO',\n          // name: identifiers.lazy,\n        }),\n        parameters: [\n          tsc.arrowFunction({\n            returnType: tsc.keywordTypeNode({ keyword: 'any' }),\n            statements: [\n              tsc.returnStatement({\n                expression: tsc.identifier({ text: refSymbol.placeholder }),\n              }),\n            ],\n          }),\n        ],\n      });\n      ast.expression = lazyExpression;\n      ast.hasLazyExpression = true;\n      state.hasLazyExpression.value = true;\n    }\n  } else if (schema.type) {\n    const typeAst = irSchemaWithTypeToAst({\n      plugin,\n      schema: schema as SchemaWithType,\n      state,\n    });\n    ast.def = typeAst.def;\n    ast.expression = typeAst.expression;\n    ast.hasLazyExpression = typeAst.hasLazyExpression;\n\n    if (plugin.config.metadata && schema.description) {\n      // TODO: add description\n      // ast.expression = tsc.callExpression({\n      //   functionName: tsc.propertyAccessExpression({\n      //     expression: ast.expression,\n      //     name: identifiers.register,\n      //   }),\n      //   parameters: [\n      //     tsc.propertyAccessExpression({\n      //       expression: z.placeholder,\n      //       name: identifiers.globalRegistry,\n      //     }),\n      //     tsc.objectExpression({\n      //       obj: [\n      //         {\n      //           key: 'description',\n      //           value: tsc.stringLiteral({ text: schema.description }),\n      //         },\n      //       ],\n      //     }),\n      //   ],\n      // });\n    }\n  } else if (schema.items) {\n    schema = deduplicateSchema({ schema });\n\n    if (schema.items) {\n      //     const itemSchemas = schema.items.map((item, index) =>\n      //       irSchemaToAst({\n      //         plugin,\n      //         schema: item,\n      //         state: {\n      //           ...state,\n      //           _path: [...state._path, 'items', index],\n      //         },\n      //       }),\n      //     );\n      //     if (schema.logicalOperator === 'and') {\n      //       const firstSchema = schema.items[0]!;\n      //       // we want to add an intersection, but not every schema can use the same API.\n      //       // if the first item contains another array or not an object, we cannot use\n      //       // `.merge()` as that does not exist on `.union()` and non-object schemas.\n      //       if (\n      //         firstSchema.logicalOperator === 'or' ||\n      //         (firstSchema.type && firstSchema.type !== 'object')\n      //       ) {\n      //         ast.expression = tsc.callExpression({\n      //           functionName: tsc.propertyAccessExpression({\n      //             expression: z.placeholder,\n      //             name: identifiers.intersection,\n      //           }),\n      //           parameters: itemSchemas.map((schema) => schema.expression),\n      //         });\n      //       } else {\n      //         ast.expression = itemSchemas[0]!.expression;\n      //         itemSchemas.slice(1).forEach((schema) => {\n      //           ast.expression = tsc.callExpression({\n      //             functionName: tsc.propertyAccessExpression({\n      //               expression: ast.expression!,\n      //               name: identifiers.and,\n      //             }),\n      //             parameters: [\n      //               schema.hasCircularReference\n      //                 ? tsc.callExpression({\n      //                     functionName: tsc.propertyAccessExpression({\n      //                       expression: z.placeholder,\n      //                       name: identifiers.lazy,\n      //                     }),\n      //                     parameters: [\n      //                       tsc.arrowFunction({\n      //                         statements: [\n      //                           tsc.returnStatement({\n      //                             expression: schema.expression,\n      //                           }),\n      //                         ],\n      //                       }),\n      //                     ],\n      //                   })\n      //                 : schema.expression,\n      //             ],\n      //           });\n      //         });\n      //       }\n      //     } else {\n      //       ast.expression = tsc.callExpression({\n      //         functionName: tsc.propertyAccessExpression({\n      //           expression: z.placeholder,\n      //           name: identifiers.union,\n      //         }),\n      //         parameters: [\n      //           tsc.arrayLiteralExpression({\n      //             elements: itemSchemas.map((schema) => schema.expression),\n      //           }),\n      //         ],\n      //       });\n      //     }\n    } else {\n      ast = irSchemaToAst({ plugin, schema, state });\n    }\n  } else {\n    // catch-all fallback for failed schemas\n    const typeAst = irSchemaWithTypeToAst({\n      plugin,\n      schema: {\n        type: 'unknown',\n      },\n      state,\n    });\n    ast.def = typeAst.def;\n    ast.expression = typeAst.expression;\n  }\n\n  // TODO: remove later\n  if (!ast.expression) {\n    const typeAst = irSchemaWithTypeToAst({\n      plugin,\n      schema: {\n        type: 'unknown',\n      },\n      state,\n    });\n    ast.expression = typeAst.expression;\n  }\n  // END TODO: remove later\n\n  // if (ast.expression) {\n  //   if (schema.accessScope === 'read') {\n  //     ast.expression = tsc.callExpression({\n  //       functionName: tsc.propertyAccessExpression({\n  //         expression: ast.expression,\n  //         name: identifiers.readonly,\n  //       }),\n  //     });\n  //   }\n\n  //   if (optional) {\n  //     ast.expression = tsc.callExpression({\n  //       functionName: tsc.propertyAccessExpression({\n  //         expression: z.placeholder,\n  //         name: identifiers.optional,\n  //       }),\n  //       parameters: [ast.expression],\n  //     });\n  //     ast.typeName = identifiers.ZodOptional;\n  //   }\n\n  //   if (schema.default !== undefined) {\n  //     const isBigInt = schema.type === 'integer' && schema.format === 'int64';\n  //     const callParameter = numberParameter({\n  //       isBigInt,\n  //       value: schema.default,\n  //     });\n  //     if (callParameter) {\n  //       ast.expression = tsc.callExpression({\n  //         functionName: tsc.propertyAccessExpression({\n  //           expression: ast.expression,\n  //           name: identifiers.default,\n  //         }),\n  //         parameters: [callParameter],\n  //       });\n  //     }\n  //   }\n  // }\n\n  return ast as Ast;\n};\n\nconst handleComponent = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: IR.SchemaObject;\n}): void => {\n  const $ref = pathToJsonPointer(state.path.value);\n  const ast = irSchemaToAst({ plugin, schema, state });\n  const baseName = refToName($ref);\n  const symbol = plugin.registerSymbol({\n    exported: true,\n    meta: {\n      path: state.path.value,\n    },\n    name: buildName({\n      config: plugin.config.definitions,\n      name: baseName,\n    }),\n    selector: plugin.api.selector('ref', $ref),\n  });\n  const typeInferSymbol = plugin.config.definitions.types.infer.enabled\n    ? plugin.registerSymbol({\n        exported: true,\n        meta: {\n          kind: 'type',\n          path: state.path.value,\n        },\n        name: buildName({\n          config: plugin.config.definitions.types.infer,\n          name: baseName,\n        }),\n        selector: plugin.api.selector('type-infer-ref', $ref),\n      })\n    : undefined;\n  exportAst({\n    ast,\n    plugin,\n    schema,\n    symbol,\n    typeInferSymbol,\n  });\n};\n\nexport const handlerV2: ArktypePlugin['Handler'] = ({ plugin }) => {\n  plugin.registerSymbol({\n    external: 'arktype',\n    name: 'type',\n    selector: plugin.api.selector('external', 'arktype.type'),\n  });\n\n  plugin.forEach(\n    'operation',\n    'parameter',\n    'requestBody',\n    'schema',\n    'webhook',\n    (event) => {\n      const state = toRefs<PluginState>({\n        hasLazyExpression: false,\n        path: event._path,\n        tags: event.tags,\n      });\n      switch (event.type) {\n        //   case 'operation':\n        //     operationToZodSchema({\n        //       getZodSchema: (schema) => {\n        //         const state: State = {\n        //           circularReferenceTracker: [],\n        //           currentReferenceTracker: [],\n        //           hasCircularReference: false,\n        //         };\n        //         return schemaToZodSchema({ plugin, schema, state });\n        //       },\n        //       operation: event.operation,\n        //       plugin,\n        //     });\n        //     break;\n        case 'parameter':\n          handleComponent({\n            plugin,\n            schema: event.parameter.schema,\n            state,\n          });\n          break;\n        case 'requestBody':\n          handleComponent({\n            plugin,\n            schema: event.requestBody.schema,\n            state,\n          });\n          break;\n        case 'schema':\n          handleComponent({\n            plugin,\n            schema: event.schema,\n            state,\n          });\n          break;\n        //   case 'webhook':\n        //     webhookToZodSchema({\n        //       getZodSchema: (schema) => {\n        //         const state: State = {\n        //           circularReferenceTracker: [],\n        //           currentReferenceTracker: [],\n        //           hasCircularReference: false,\n        //         };\n        //         return schemaToZodSchema({ plugin, schema, state });\n        //       },\n        //       operation: event.operation,\n        //       plugin,\n        //     });\n        //     break;\n      }\n    },\n  );\n};\n","import type { ArktypePlugin } from './types';\nimport { handlerV2 } from './v2/plugin';\n\nexport const handler: ArktypePlugin['Handler'] = (args) => handlerV2(args);\n","import { definePluginConfig, mappers } from '~/plugins/shared/utils/config';\n\nimport { Api } from './api';\nimport { handler } from './plugin';\nimport type { ArktypePlugin } from './types';\n\nexport const defaultConfig: ArktypePlugin['Config'] = {\n  api: new Api({\n    name: 'arktype',\n  }),\n  config: {\n    case: 'PascalCase',\n    comments: true,\n    exportFromIndex: false,\n    metadata: false,\n  },\n  handler,\n  name: 'arktype',\n  resolveConfig: (plugin, context) => {\n    plugin.config.types = context.valueToObject({\n      defaultValue: {\n        infer: {\n          case: 'PascalCase',\n          enabled: false,\n        },\n      },\n      mappers: {\n        object: (fields, defaultValue) => ({\n          ...fields,\n          infer: context.valueToObject({\n            defaultValue: {\n              ...(defaultValue.infer as Extract<\n                typeof defaultValue.infer,\n                Record<string, unknown>\n              >),\n              enabled:\n                fields.infer !== undefined\n                  ? Boolean(fields.infer)\n                  : (\n                      defaultValue.infer as Extract<\n                        typeof defaultValue.infer,\n                        Record<string, unknown>\n                      >\n                    ).enabled,\n            },\n            mappers,\n            value: fields.infer,\n          }),\n        }),\n      },\n      value: plugin.config.types,\n    });\n\n    plugin.config.definitions = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'PascalCase',\n        enabled: true,\n        name: '{{name}}',\n        types: {\n          ...plugin.config.types,\n          infer: {\n            ...(plugin.config.types.infer as Extract<\n              typeof plugin.config.types.infer,\n              Record<string, unknown>\n            >),\n            name: '{{name}}',\n          },\n        },\n      },\n      mappers: {\n        ...mappers,\n        object: (fields, defaultValue) => ({\n          ...fields,\n          types: context.valueToObject({\n            defaultValue: defaultValue.types!,\n            mappers: {\n              object: (fields, defaultValue) => ({\n                ...fields,\n                infer: context.valueToObject({\n                  defaultValue: {\n                    ...(defaultValue.infer as Extract<\n                      typeof defaultValue.infer,\n                      Record<string, unknown>\n                    >),\n                    enabled:\n                      fields.infer !== undefined\n                        ? Boolean(fields.infer)\n                        : (\n                            defaultValue.infer as Extract<\n                              typeof defaultValue.infer,\n                              Record<string, unknown>\n                            >\n                          ).enabled,\n                  },\n                  mappers,\n                  value: fields.infer,\n                }),\n              }),\n            },\n            value: fields.types,\n          }),\n        }),\n      },\n      value: plugin.config.definitions,\n    });\n\n    plugin.config.requests = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'PascalCase',\n        enabled: true,\n        name: '{{name}}Data',\n        types: {\n          ...plugin.config.types,\n          infer: {\n            ...(plugin.config.types.infer as Extract<\n              typeof plugin.config.types.infer,\n              Record<string, unknown>\n            >),\n            name: '{{name}}Data',\n          },\n        },\n      },\n      mappers: {\n        ...mappers,\n        object: (fields, defaultValue) => ({\n          ...fields,\n          types: context.valueToObject({\n            defaultValue: defaultValue.types!,\n            mappers: {\n              object: (fields, defaultValue) => ({\n                ...fields,\n                infer: context.valueToObject({\n                  defaultValue: {\n                    ...(defaultValue.infer as Extract<\n                      typeof defaultValue.infer,\n                      Record<string, unknown>\n                    >),\n                    enabled:\n                      fields.infer !== undefined\n                        ? Boolean(fields.infer)\n                        : (\n                            defaultValue.infer as Extract<\n                              typeof defaultValue.infer,\n                              Record<string, unknown>\n                            >\n                          ).enabled,\n                  },\n                  mappers,\n                  value: fields.infer,\n                }),\n              }),\n            },\n            value: fields.types,\n          }),\n        }),\n      },\n      value: plugin.config.requests,\n    });\n\n    plugin.config.responses = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'PascalCase',\n        enabled: true,\n        name: '{{name}}Response',\n        types: {\n          ...plugin.config.types,\n          infer: {\n            ...(plugin.config.types.infer as Extract<\n              typeof plugin.config.types.infer,\n              Record<string, unknown>\n            >),\n            name: '{{name}}Response',\n          },\n        },\n      },\n      mappers: {\n        ...mappers,\n        object: (fields, defaultValue) => ({\n          ...fields,\n          types: context.valueToObject({\n            defaultValue: defaultValue.types!,\n            mappers: {\n              object: (fields, defaultValue) => ({\n                ...fields,\n                infer: context.valueToObject({\n                  defaultValue: {\n                    ...(defaultValue.infer as Extract<\n                      typeof defaultValue.infer,\n                      Record<string, unknown>\n                    >),\n                    enabled:\n                      fields.infer !== undefined\n                        ? Boolean(fields.infer)\n                        : (\n                            defaultValue.infer as Extract<\n                              typeof defaultValue.infer,\n                              Record<string, unknown>\n                            >\n                          ).enabled,\n                  },\n                  mappers,\n                  value: fields.infer,\n                }),\n              }),\n            },\n            value: fields.types,\n          }),\n        }),\n      },\n      value: plugin.config.responses,\n    });\n\n    plugin.config.webhooks = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'PascalCase',\n        enabled: true,\n        name: '{{name}}WebhookRequest',\n        types: {\n          ...plugin.config.types,\n          infer: {\n            ...(plugin.config.types.infer as Extract<\n              typeof plugin.config.types.infer,\n              Record<string, unknown>\n            >),\n            name: '{{name}}WebhookRequest',\n          },\n        },\n      },\n      mappers: {\n        ...mappers,\n        object: (fields, defaultValue) => ({\n          ...fields,\n          types: context.valueToObject({\n            defaultValue: defaultValue.types!,\n            mappers: {\n              object: (fields, defaultValue) => ({\n                ...fields,\n                infer: context.valueToObject({\n                  defaultValue: {\n                    ...(defaultValue.infer as Extract<\n                      typeof defaultValue.infer,\n                      Record<string, unknown>\n                    >),\n                    enabled:\n                      fields.infer !== undefined\n                        ? Boolean(fields.infer)\n                        : (\n                            defaultValue.infer as Extract<\n                              typeof defaultValue.infer,\n                              Record<string, unknown>\n                            >\n                          ).enabled,\n                  },\n                  mappers,\n                  value: fields.infer,\n                }),\n              }),\n            },\n            value: fields.types,\n          }),\n        }),\n      },\n      value: plugin.config.webhooks,\n    });\n  },\n  tags: ['validator'],\n};\n\n/**\n * Type helper for Arktype plugin, returns {@link Plugin.Config} object\n */\nexport const defineConfig = definePluginConfig(defaultConfig);\n","import type { Selector } from '@hey-api/codegen-core';\n\nimport type { Plugin } from '~/plugins';\n\ntype SelectorType = 'RouteHandler';\n\nexport type IApi = {\n  /**\n   * @param type Selector type.\n   * @param value Depends on `type`:\n   *  - `RouteHandler`: never\n   * @returns Selector array\n   */\n  selector: (type: SelectorType, value?: string) => Selector;\n};\n\nexport class Api implements IApi {\n  constructor(public meta: Plugin.Name<'fastify'>) {}\n\n  selector(...args: ReadonlyArray<string | undefined>): Selector {\n    return [this.meta.name, ...(args as Selector)];\n  }\n}\n","import type ts from 'typescript';\n\nimport { operationResponsesMap } from '~/ir/operation';\nimport { hasParameterGroupObjectRequired } from '~/ir/parameter';\nimport type { IR } from '~/ir/types';\nimport { type Property, tsc } from '~/tsc';\n\nimport type { FastifyPlugin } from './types';\n\nconst operationToRouteHandler = ({\n  operation,\n  plugin,\n}: {\n  operation: IR.OperationObject;\n  plugin: FastifyPlugin['Instance'];\n}): Property | undefined => {\n  const properties: Array<Property> = [];\n\n  const pluginTypeScript = plugin.getPluginOrThrow('@hey-api/typescript');\n  const symbolDataType = plugin.getSymbol(\n    pluginTypeScript.api.selector('data', operation.id),\n  );\n  if (symbolDataType) {\n    if (operation.body) {\n      properties.push({\n        isRequired: operation.body.required,\n        name: 'Body',\n        type: `${symbolDataType.placeholder}['body']`,\n      });\n    }\n\n    if (operation.parameters) {\n      if (operation.parameters.header) {\n        properties.push({\n          isRequired: hasParameterGroupObjectRequired(\n            operation.parameters.header,\n          ),\n          name: 'Headers',\n          type: `${symbolDataType.placeholder}['headers']`,\n        });\n      }\n\n      if (operation.parameters.path) {\n        properties.push({\n          isRequired: hasParameterGroupObjectRequired(\n            operation.parameters.path,\n          ),\n          name: 'Params',\n          type: `${symbolDataType.placeholder}['path']`,\n        });\n      }\n\n      if (operation.parameters.query) {\n        properties.push({\n          isRequired: hasParameterGroupObjectRequired(\n            operation.parameters.query,\n          ),\n          name: 'Querystring',\n          type: `${symbolDataType.placeholder}['query']`,\n        });\n      }\n    }\n  }\n\n  const { errors, responses } = operationResponsesMap(operation);\n\n  let errorsTypeReference: ts.TypeReferenceNode | undefined = undefined;\n  const symbolErrorType = plugin.getSymbol(\n    pluginTypeScript.api.selector('errors', operation.id),\n  );\n  if (symbolErrorType && errors && errors.properties) {\n    const keys = Object.keys(errors.properties);\n    if (keys.length) {\n      const hasDefaultResponse = keys.includes('default');\n      if (!hasDefaultResponse) {\n        errorsTypeReference = tsc.typeReferenceNode({\n          typeName: symbolErrorType.placeholder,\n        });\n      } else if (keys.length > 1) {\n        const errorsType = tsc.typeReferenceNode({\n          typeName: symbolErrorType.placeholder,\n        });\n        const defaultType = tsc.literalTypeNode({\n          literal: tsc.stringLiteral({ text: 'default' }),\n        });\n        errorsTypeReference = tsc.typeReferenceNode({\n          typeArguments: [errorsType, defaultType],\n          typeName: 'Omit',\n        });\n      }\n    }\n  }\n\n  let responsesTypeReference: ts.TypeReferenceNode | undefined = undefined;\n  const symbolResponseType = plugin.getSymbol(\n    pluginTypeScript.api.selector('responses', operation.id),\n  );\n  if (symbolResponseType && responses && responses.properties) {\n    const keys = Object.keys(responses.properties);\n    if (keys.length) {\n      const hasDefaultResponse = keys.includes('default');\n      if (!hasDefaultResponse) {\n        responsesTypeReference = tsc.typeReferenceNode({\n          typeName: symbolResponseType.placeholder,\n        });\n      } else if (keys.length > 1) {\n        const responsesType = tsc.typeReferenceNode({\n          typeName: symbolResponseType.placeholder,\n        });\n        const defaultType = tsc.literalTypeNode({\n          literal: tsc.stringLiteral({ text: 'default' }),\n        });\n        responsesTypeReference = tsc.typeReferenceNode({\n          typeArguments: [responsesType, defaultType],\n          typeName: 'Omit',\n        });\n      }\n    }\n  }\n\n  const replyTypes = [errorsTypeReference, responsesTypeReference].filter(\n    Boolean,\n  );\n  if (replyTypes.length) {\n    properties.push({\n      name: 'Reply',\n      type: tsc.typeIntersectionNode({\n        types: replyTypes,\n      }),\n    });\n  }\n\n  if (!properties.length) {\n    return;\n  }\n\n  const symbolRouteHandler = plugin.referenceSymbol(\n    plugin.api.selector('RouteHandler'),\n  );\n  const routeHandler: Property = {\n    name: operation.id,\n    type: tsc.typeReferenceNode({\n      typeArguments: [\n        tsc.typeInterfaceNode({\n          properties,\n          useLegacyResolution: false,\n        }),\n      ],\n      typeName: symbolRouteHandler.placeholder,\n    }),\n  };\n  return routeHandler;\n};\n\nexport const handler: FastifyPlugin['Handler'] = ({ plugin }) => {\n  plugin.registerSymbol({\n    external: 'fastify',\n    meta: {\n      kind: 'type',\n    },\n    name: 'RouteHandler',\n    selector: plugin.api.selector('RouteHandler'),\n  });\n\n  const symbolRouteHandlers = plugin.registerSymbol({\n    exported: true,\n    meta: {\n      kind: 'type',\n    },\n    name: 'RouteHandlers',\n  });\n\n  const routeHandlers: Array<Property> = [];\n\n  plugin.forEach(\n    'operation',\n    ({ operation }) => {\n      const routeHandler = operationToRouteHandler({ operation, plugin });\n      if (routeHandler) {\n        routeHandlers.push(routeHandler);\n      }\n    },\n    {\n      order: 'declarations',\n    },\n  );\n\n  const node = tsc.typeAliasDeclaration({\n    exportType: symbolRouteHandlers.exported,\n    name: symbolRouteHandlers.placeholder,\n    type: tsc.typeInterfaceNode({\n      properties: routeHandlers,\n      useLegacyResolution: false,\n    }),\n  });\n  plugin.setSymbolValue(symbolRouteHandlers, node);\n};\n","import { definePluginConfig } from '~/plugins/shared/utils/config';\n\nimport { Api } from './api';\nimport { handler } from './plugin';\nimport type { FastifyPlugin } from './types';\n\nexport const defaultConfig: FastifyPlugin['Config'] = {\n  api: new Api({\n    name: 'fastify',\n  }),\n  config: {\n    exportFromIndex: false,\n  },\n  dependencies: ['@hey-api/typescript'],\n  handler,\n  name: 'fastify',\n};\n\n/**\n * Type helper for `fastify` plugin, returns {@link Plugin.Config} object\n */\nexport const defineConfig = definePluginConfig(defaultConfig);\n","import { tsc } from '~/tsc';\n\nexport const identifiers = {\n  /**\n   * {@link https://valibot.dev/api/#actions Actions}\n   */\n  actions: {\n    args: tsc.identifier({ text: 'args' }),\n    base64: tsc.identifier({ text: 'base64' }),\n    bic: tsc.identifier({ text: 'bic' }),\n    brand: tsc.identifier({ text: 'brand' }),\n    bytes: tsc.identifier({ text: 'bytes' }),\n    check: tsc.identifier({ text: 'check' }),\n    checkItems: tsc.identifier({ text: 'checkItems' }),\n    creditCard: tsc.identifier({ text: 'creditCard' }),\n    cuid2: tsc.identifier({ text: 'cuid2' }),\n    decimal: tsc.identifier({ text: 'decimal' }),\n    description: tsc.identifier({ text: 'description' }),\n    digits: tsc.identifier({ text: 'digits' }),\n    email: tsc.identifier({ text: 'email' }),\n    emoji: tsc.identifier({ text: 'emoji' }),\n    empty: tsc.identifier({ text: 'empty' }),\n    endsWith: tsc.identifier({ text: 'endsWith' }),\n    entries: tsc.identifier({ text: 'entries' }),\n    everyItem: tsc.identifier({ text: 'everyItem' }),\n    excludes: tsc.identifier({ text: 'excludes' }),\n    filterItems: tsc.identifier({ text: 'filterItems' }),\n    findItem: tsc.identifier({ text: 'findItem' }),\n    finite: tsc.identifier({ text: 'finite' }),\n    flavor: tsc.identifier({ text: 'flavor' }),\n    graphemes: tsc.identifier({ text: 'graphemes' }),\n    gtValue: tsc.identifier({ text: 'gtValue' }),\n    hash: tsc.identifier({ text: 'hash' }),\n    hexColor: tsc.identifier({ text: 'hexColor' }),\n    hexadecimal: tsc.identifier({ text: 'hexadecimal' }),\n    imei: tsc.identifier({ text: 'imei' }),\n    includes: tsc.identifier({ text: 'includes' }),\n    integer: tsc.identifier({ text: 'integer' }),\n    ip: tsc.identifier({ text: 'ip' }),\n    ipv4: tsc.identifier({ text: 'ipv4' }),\n    ipv6: tsc.identifier({ text: 'ipv6' }),\n    isoDate: tsc.identifier({ text: 'isoDate' }),\n    isoDateTime: tsc.identifier({ text: 'isoDateTime' }),\n    isoTime: tsc.identifier({ text: 'isoTime' }),\n    isoTimeSecond: tsc.identifier({ text: 'isoTimeSecond' }),\n    isoTimestamp: tsc.identifier({ text: 'isoTimestamp' }),\n    isoWeek: tsc.identifier({ text: 'isoWeek' }),\n    length: tsc.identifier({ text: 'length' }),\n    ltValue: tsc.identifier({ text: 'ltValue' }),\n    mac: tsc.identifier({ text: 'mac' }),\n    mac48: tsc.identifier({ text: 'mac48' }),\n    mac64: tsc.identifier({ text: 'mac64' }),\n    mapItems: tsc.identifier({ text: 'mapItems' }),\n    maxBytes: tsc.identifier({ text: 'maxBytes' }),\n    maxEntries: tsc.identifier({ text: 'maxEntries' }),\n    maxGraphemes: tsc.identifier({ text: 'maxGraphemes' }),\n    maxLength: tsc.identifier({ text: 'maxLength' }),\n    maxSize: tsc.identifier({ text: 'maxSize' }),\n    maxValue: tsc.identifier({ text: 'maxValue' }),\n    maxWords: tsc.identifier({ text: 'maxWords' }),\n    metadata: tsc.identifier({ text: 'metadata' }),\n    mimeType: tsc.identifier({ text: 'mimeType' }),\n    minBytes: tsc.identifier({ text: 'minBytes' }),\n    minEntries: tsc.identifier({ text: 'minEntries' }),\n    minGraphemes: tsc.identifier({ text: 'minGraphemes' }),\n    minLength: tsc.identifier({ text: 'minLength' }),\n    minSize: tsc.identifier({ text: 'minSize' }),\n    minValue: tsc.identifier({ text: 'minValue' }),\n    minWords: tsc.identifier({ text: 'minWords' }),\n    multipleOf: tsc.identifier({ text: 'multipleOf' }),\n    nanoid: tsc.identifier({ text: 'nanoid' }),\n    nonEmpty: tsc.identifier({ text: 'nonEmpty' }),\n    normalize: tsc.identifier({ text: 'normalize' }),\n    notBytes: tsc.identifier({ text: 'notBytes' }),\n    notEntries: tsc.identifier({ text: 'notEntries' }),\n    notGraphemes: tsc.identifier({ text: 'notGraphemes' }),\n    notLength: tsc.identifier({ text: 'notLength' }),\n    notSize: tsc.identifier({ text: 'notSize' }),\n    notValue: tsc.identifier({ text: 'notValue' }),\n    notValues: tsc.identifier({ text: 'notValues' }),\n    notWords: tsc.identifier({ text: 'notWords' }),\n    octal: tsc.identifier({ text: 'octal' }),\n    parseJson: tsc.identifier({ text: 'parseJson' }),\n    partialCheck: tsc.identifier({ text: 'partialCheck' }),\n    rawCheck: tsc.identifier({ text: 'rawCheck' }),\n    rawTransform: tsc.identifier({ text: 'rawTransform' }),\n    readonly: tsc.identifier({ text: 'readonly' }),\n    reduceItems: tsc.identifier({ text: 'reduceItems' }),\n    regex: tsc.identifier({ text: 'regex' }),\n    returns: tsc.identifier({ text: 'returns' }),\n    rfcEmail: tsc.identifier({ text: 'rfcEmail' }),\n    safeInteger: tsc.identifier({ text: 'safeInteger' }),\n    size: tsc.identifier({ text: 'size' }),\n    slug: tsc.identifier({ text: 'slug' }),\n    someItem: tsc.identifier({ text: 'someItem' }),\n    sortItems: tsc.identifier({ text: 'sortItems' }),\n    startsWith: tsc.identifier({ text: 'startsWith' }),\n    stringifyJson: tsc.identifier({ text: 'stringifyJson' }),\n    title: tsc.identifier({ text: 'title' }),\n    toLowerCase: tsc.identifier({ text: 'toLowerCase' }),\n    toMaxValue: tsc.identifier({ text: 'toMaxValue' }),\n    toMinValue: tsc.identifier({ text: 'toMinValue' }),\n    toUpperCase: tsc.identifier({ text: 'toUpperCase' }),\n    transform: tsc.identifier({ text: 'transform' }),\n    trim: tsc.identifier({ text: 'trim' }),\n    trimEnd: tsc.identifier({ text: 'trimEnd' }),\n    trimStart: tsc.identifier({ text: 'trimStart' }),\n    ulid: tsc.identifier({ text: 'ulid' }),\n    url: tsc.identifier({ text: 'url' }),\n    uuid: tsc.identifier({ text: 'uuid' }),\n    value: tsc.identifier({ text: 'value' }),\n    values: tsc.identifier({ text: 'values' }),\n    words: tsc.identifier({ text: 'words' }),\n  },\n  /**\n   * {@link https://valibot.dev/api/#async Async}\n   */\n  async: {\n    argsAsync: tsc.identifier({ text: 'argsAsync' }),\n    arrayAsync: tsc.identifier({ text: 'arrayAsync' }),\n    awaitAsync: tsc.identifier({ text: 'awaitAsync' }),\n    checkAsync: tsc.identifier({ text: 'checkAsync' }),\n    checkItemsAsync: tsc.identifier({ text: 'checkItemsAsync' }),\n    customAsync: tsc.identifier({ text: 'customAsync' }),\n    exactOptionalAsync: tsc.identifier({ text: 'exactOptionalAsync' }),\n    fallbackAsync: tsc.identifier({ text: 'fallbackAsync' }),\n    forwardAsync: tsc.identifier({ text: 'forwardAsync' }),\n    getDefaultsAsync: tsc.identifier({ text: 'getDefaultsAsync' }),\n    getFallbacksAsync: tsc.identifier({ text: 'getFallbacksAsync' }),\n    intersectAsync: tsc.identifier({ text: 'intersectAsync' }),\n    lazyAsync: tsc.identifier({ text: 'lazyAsync' }),\n    looseObjectAsync: tsc.identifier({ text: 'looseObjectAsync' }),\n    looseTupleAsync: tsc.identifier({ text: 'looseTupleAsync' }),\n    mapAsync: tsc.identifier({ text: 'mapAsync' }),\n    nonNullableAsync: tsc.identifier({ text: 'nonNullableAsync' }),\n    nonNullishAsync: tsc.identifier({ text: 'nonNullishAsync' }),\n    nonOptionalAsync: tsc.identifier({ text: 'nonOptionalAsync' }),\n    nullableAsync: tsc.identifier({ text: 'nullableAsync' }),\n    nullishAsync: tsc.identifier({ text: 'nullishAsync' }),\n    objectAsync: tsc.identifier({ text: 'objectAsync' }),\n    objectWithRestAsync: tsc.identifier({ text: 'objectWithRestAsync' }),\n    optionalAsync: tsc.identifier({ text: 'optionalAsync' }),\n    parseAsync: tsc.identifier({ text: 'parseAsync' }),\n    parserAsync: tsc.identifier({ text: 'parserAsync' }),\n    partialAsync: tsc.identifier({ text: 'partialAsync' }),\n    partialCheckAsync: tsc.identifier({ text: 'partialCheckAsync' }),\n    pipeAsync: tsc.identifier({ text: 'pipeAsync' }),\n    rawCheckAsync: tsc.identifier({ text: 'rawCheckAsync' }),\n    rawTransformAsync: tsc.identifier({ text: 'rawTransformAsync' }),\n    recordAsync: tsc.identifier({ text: 'recordAsync' }),\n    requiredAsync: tsc.identifier({ text: 'requiredAsync' }),\n    returnsAsync: tsc.identifier({ text: 'returnsAsync' }),\n    safeParseAsync: tsc.identifier({ text: 'safeParseAsync' }),\n    safeParserAsync: tsc.identifier({ text: 'safeParserAsync' }),\n    setAsync: tsc.identifier({ text: 'setAsync' }),\n    strictObjectAsync: tsc.identifier({ text: 'strictObjectAsync' }),\n    strictTupleAsync: tsc.identifier({ text: 'strictTupleAsync' }),\n    transformAsync: tsc.identifier({ text: 'transformAsync' }),\n    tupleAsync: tsc.identifier({ text: 'tupleAsync' }),\n    tupleWithRestAsync: tsc.identifier({ text: 'tupleWithRestAsync' }),\n    undefinedableAsync: tsc.identifier({ text: 'undefinedableAsync' }),\n    unionAsync: tsc.identifier({ text: 'unionAsync' }),\n    variantAsync: tsc.identifier({ text: 'variantAsync' }),\n  },\n  /**\n   * {@link https://valibot.dev/api/#methods Methods}\n   */\n  methods: {\n    assert: tsc.identifier({ text: 'assert' }),\n    config: tsc.identifier({ text: 'config' }),\n    fallback: tsc.identifier({ text: 'fallback' }),\n    flatten: tsc.identifier({ text: 'flatten' }),\n    forward: tsc.identifier({ text: 'forward' }),\n    getDefault: tsc.identifier({ text: 'getDefault' }),\n    getDefaults: tsc.identifier({ text: 'getDefaults' }),\n    getDescription: tsc.identifier({ text: 'getDescription' }),\n    getFallback: tsc.identifier({ text: 'getFallback' }),\n    getFallbacks: tsc.identifier({ text: 'getFallbacks' }),\n    getMetadata: tsc.identifier({ text: 'getMetadata' }),\n    getTitle: tsc.identifier({ text: 'getTitle' }),\n    is: tsc.identifier({ text: 'is' }),\n    keyof: tsc.identifier({ text: 'keyof' }),\n    message: tsc.identifier({ text: 'message' }),\n    omit: tsc.identifier({ text: 'omit' }),\n    parse: tsc.identifier({ text: 'parse' }),\n    parser: tsc.identifier({ text: 'parser' }),\n    partial: tsc.identifier({ text: 'partial' }),\n    pick: tsc.identifier({ text: 'pick' }),\n    pipe: tsc.identifier({ text: 'pipe' }),\n    required: tsc.identifier({ text: 'required' }),\n    safeParse: tsc.identifier({ text: 'safeParse' }),\n    safeParser: tsc.identifier({ text: 'safeParser' }),\n    summarize: tsc.identifier({ text: 'summarize' }),\n    unwrap: tsc.identifier({ text: 'unwrap' }),\n  },\n  /**\n   * {@link https://valibot.dev/api/#schemas Schemas}\n   */\n  schemas: {\n    any: tsc.identifier({ text: 'any' }),\n    array: tsc.identifier({ text: 'array' }),\n    bigInt: tsc.identifier({ text: 'bigint' }),\n    blob: tsc.identifier({ text: 'blob' }),\n    boolean: tsc.identifier({ text: 'boolean' }),\n    custom: tsc.identifier({ text: 'custom' }),\n    date: tsc.identifier({ text: 'date' }),\n    enum: tsc.identifier({ text: 'enum' }),\n    exactOptional: tsc.identifier({ text: 'exactOptional' }),\n    file: tsc.identifier({ text: 'file' }),\n    function: tsc.identifier({ text: 'function' }),\n    instance: tsc.identifier({ text: 'instance' }),\n    intersect: tsc.identifier({ text: 'intersect' }),\n    lazy: tsc.identifier({ text: 'lazy' }),\n    literal: tsc.identifier({ text: 'literal' }),\n    looseObject: tsc.identifier({ text: 'looseObject' }),\n    looseTuple: tsc.identifier({ text: 'looseTuple' }),\n    map: tsc.identifier({ text: 'map' }),\n    nan: tsc.identifier({ text: 'nan' }),\n    never: tsc.identifier({ text: 'never' }),\n    nonNullable: tsc.identifier({ text: 'nonNullable' }),\n    nonNullish: tsc.identifier({ text: 'nonNullish' }),\n    nonOptional: tsc.identifier({ text: 'nonOptional' }),\n    null: tsc.identifier({ text: 'null' }),\n    nullable: tsc.identifier({ text: 'nullable' }),\n    nullish: tsc.identifier({ text: 'nullish' }),\n    number: tsc.identifier({ text: 'number' }),\n    object: tsc.identifier({ text: 'object' }),\n    objectWithRest: tsc.identifier({ text: 'objectWithRest' }),\n    optional: tsc.identifier({ text: 'optional' }),\n    picklist: tsc.identifier({ text: 'picklist' }),\n    promise: tsc.identifier({ text: 'promise' }),\n    record: tsc.identifier({ text: 'record' }),\n    set: tsc.identifier({ text: 'set' }),\n    strictObject: tsc.identifier({ text: 'strictObject' }),\n    strictTuple: tsc.identifier({ text: 'strictTuple' }),\n    string: tsc.identifier({ text: 'string' }),\n    symbol: tsc.identifier({ text: 'symbol' }),\n    tuple: tsc.identifier({ text: 'tuple' }),\n    tupleWithRest: tsc.identifier({ text: 'tupleWithRest' }),\n    undefined: tsc.identifier({ text: 'undefined' }),\n    undefinedable: tsc.identifier({ text: 'undefinedable' }),\n    union: tsc.identifier({ text: 'union' }),\n    unknown: tsc.identifier({ text: 'unknown' }),\n    variant: tsc.identifier({ text: 'variant' }),\n    void: tsc.identifier({ text: 'void' }),\n  },\n  /**\n   * {@link https://valibot.dev/api/#storages Storages}\n   */\n  storages: {\n    // TODO: implement if necessary\n  },\n  /**\n   * {@link https://valibot.dev/api/#types Types}\n   */\n  types: {\n    // TODO: implement if necessary\n    GenericSchema: tsc.identifier({ text: 'GenericSchema' }),\n  },\n  /**\n   * {@link https://valibot.dev/api/#utils Utils}\n   */\n  utils: {\n    // TODO: implement if necessary\n  },\n};\n","import type ts from 'typescript';\n\nimport { tsc } from '~/tsc';\n\nimport type { ValidatorArgs } from '../shared/types';\nimport { identifiers } from './constants';\n\nexport const createRequestValidatorV1 = ({\n  operation,\n  plugin,\n}: ValidatorArgs): ts.ArrowFunction | undefined => {\n  const symbol = plugin.getSymbol(plugin.api.selector('data', operation.id));\n  if (!symbol) return;\n\n  const v = plugin.referenceSymbol(\n    plugin.api.selector('external', 'valibot.v'),\n  );\n\n  const dataParameterName = 'data';\n\n  return tsc.arrowFunction({\n    async: true,\n    parameters: [\n      {\n        name: dataParameterName,\n      },\n    ],\n    statements: [\n      tsc.returnStatement({\n        expression: tsc.awaitExpression({\n          expression: tsc.callExpression({\n            functionName: tsc.propertyAccessExpression({\n              expression: v.placeholder,\n              name: identifiers.async.parseAsync,\n            }),\n            parameters: [\n              tsc.identifier({ text: symbol.placeholder }),\n              tsc.identifier({ text: dataParameterName }),\n            ],\n          }),\n        }),\n      }),\n    ],\n  });\n};\n\nexport const createResponseValidatorV1 = ({\n  operation,\n  plugin,\n}: ValidatorArgs): ts.ArrowFunction | undefined => {\n  const symbol = plugin.getSymbol(\n    plugin.api.selector('responses', operation.id),\n  );\n  if (!symbol) return;\n\n  const v = plugin.referenceSymbol(\n    plugin.api.selector('external', 'valibot.v'),\n  );\n\n  const dataParameterName = 'data';\n\n  return tsc.arrowFunction({\n    async: true,\n    parameters: [\n      {\n        name: dataParameterName,\n      },\n    ],\n    statements: [\n      tsc.returnStatement({\n        expression: tsc.awaitExpression({\n          expression: tsc.callExpression({\n            functionName: tsc.propertyAccessExpression({\n              expression: v.placeholder,\n              name: identifiers.async.parseAsync,\n            }),\n            parameters: [\n              tsc.identifier({ text: symbol.placeholder }),\n              tsc.identifier({ text: dataParameterName }),\n            ],\n          }),\n        }),\n      }),\n    ],\n  });\n};\n","import type { Selector } from '@hey-api/codegen-core';\nimport type ts from 'typescript';\n\nimport type { Plugin } from '~/plugins';\n\nimport type { ValidatorArgs } from './shared/types';\nimport { createRequestValidatorV1, createResponseValidatorV1 } from './v1/api';\n\ntype SelectorType =\n  | 'data'\n  | 'external'\n  | 'ref'\n  | 'responses'\n  | 'webhook-request';\n\nexport type IApi = {\n  createRequestValidator: (args: ValidatorArgs) => ts.ArrowFunction | undefined;\n  createResponseValidator: (\n    args: ValidatorArgs,\n  ) => ts.ArrowFunction | undefined;\n  /**\n   * @param type Selector type.\n   * @param value Depends on `type`:\n   *  - `data`: `operation.id` string\n   *  - `external`: external modules\n   *  - `ref`: `$ref` JSON pointer\n   *  - `responses`: `operation.id` string\n   *  - `webhook-request`: `operation.id` string\n   * @returns Selector array\n   */\n  selector: (type: SelectorType, value?: string) => Selector;\n};\n\nexport class Api implements IApi {\n  constructor(public meta: Plugin.Name<'valibot'>) {}\n\n  createRequestValidator(args: ValidatorArgs): ts.ArrowFunction | undefined {\n    return createRequestValidatorV1(args);\n  }\n\n  createResponseValidator(args: ValidatorArgs): ts.ArrowFunction | undefined {\n    return createResponseValidatorV1(args);\n  }\n\n  selector(...args: ReadonlyArray<string | undefined>): Selector {\n    return [this.meta.name, ...(args as Selector)];\n  }\n}\n","import type ts from 'typescript';\n\nimport { tsc } from '~/tsc';\n\nimport type { ValibotPlugin } from '../types';\nimport { identifiers } from '../v1/constants';\n\nexport const pipesToAst = ({\n  pipes,\n  plugin,\n}: {\n  pipes: Array<ts.Expression>;\n  plugin: ValibotPlugin['Instance'];\n}): ts.Expression => {\n  if (pipes.length === 1) {\n    return pipes[0]!;\n  }\n\n  const v = plugin.referenceSymbol(\n    plugin.api.selector('external', 'valibot.v'),\n  );\n  const expression = tsc.callExpression({\n    functionName: tsc.propertyAccessExpression({\n      expression: v.placeholder,\n      name: identifiers.methods.pipe,\n    }),\n    parameters: pipes,\n  });\n  return expression;\n};\n","import type { Symbol } from '@hey-api/codegen-core';\nimport type ts from 'typescript';\n\nimport type { IR } from '~/ir/types';\nimport { createSchemaComment } from '~/plugins/shared/utils/schema';\nimport { tsc } from '~/tsc';\n\nimport { identifiers } from '../v1/constants';\nimport { pipesToAst } from './pipesToAst';\nimport type { Ast, IrSchemaToAstOptions } from './types';\n\nexport const exportAst = ({\n  ast,\n  plugin,\n  schema,\n  state,\n  symbol,\n}: IrSchemaToAstOptions & {\n  ast: Ast;\n  schema: IR.SchemaObject;\n  symbol: Symbol;\n}): void => {\n  const v = plugin.referenceSymbol(\n    plugin.api.selector('external', 'valibot.v'),\n  );\n\n  const statement = tsc.constVariable({\n    comment: plugin.config.comments\n      ? createSchemaComment({ schema })\n      : undefined,\n    exportConst: symbol.exported,\n    expression: pipesToAst({ pipes: ast.pipes, plugin }),\n    name: symbol.placeholder,\n    typeName: state.hasLazyExpression.value\n      ? (tsc.propertyAccessExpression({\n          expression: v.placeholder,\n          name: ast.typeName || identifiers.types.GenericSchema.text,\n        }) as unknown as ts.TypeNode)\n      : undefined,\n  });\n  plugin.setSymbolValue(symbol, statement);\n};\n","import { tsc } from '~/tsc';\n\nexport const INTEGER_FORMATS = {\n  int16: {\n    max: 32767,\n    maxError: 'Invalid value: Expected int16 to be <= 2^15-1',\n    min: -32768,\n    minError: 'Invalid value: Expected int16 to be >= -2^15',\n    needsBigInt: false,\n  },\n  int32: {\n    max: 2147483647,\n    maxError: 'Invalid value: Expected int32 to be <= 2^31-1',\n    min: -2147483648,\n    minError: 'Invalid value: Expected int32 to be >= -2^31',\n    needsBigInt: false,\n  },\n  int64: {\n    max: '9223372036854775807',\n    maxError: 'Invalid value: Expected int64 to be <= 2^63-1',\n    min: '-9223372036854775808',\n    minError: 'Invalid value: Expected int64 to be >= -2^63',\n    needsBigInt: true,\n  },\n  int8: {\n    max: 127,\n    maxError: 'Invalid value: Expected int8 to be <= 2^7-1',\n    min: -128,\n    minError: 'Invalid value: Expected int8 to be >= -2^7',\n    needsBigInt: false,\n  },\n  uint16: {\n    max: 65535,\n    maxError: 'Invalid value: Expected uint16 to be <= 2^16-1',\n    min: 0,\n    minError: 'Invalid value: Expected uint16 to be >= 0',\n    needsBigInt: false,\n  },\n  uint32: {\n    max: 4294967295,\n    maxError: 'Invalid value: Expected uint32 to be <= 2^32-1',\n    min: 0,\n    minError: 'Invalid value: Expected uint32 to be >= 0',\n    needsBigInt: false,\n  },\n  uint64: {\n    max: '18446744073709551615',\n    maxError: 'Invalid value: Expected uint64 to be <= 2^64-1',\n    min: '0',\n    minError: 'Invalid value: Expected uint64 to be >= 0',\n    needsBigInt: true,\n  },\n  uint8: {\n    max: 255,\n    maxError: 'Invalid value: Expected uint8 to be <= 2^8-1',\n    min: 0,\n    minError: 'Invalid value: Expected uint8 to be >= 0',\n    needsBigInt: false,\n  },\n} as const;\n\nexport type IntegerFormat = keyof typeof INTEGER_FORMATS;\n\nexport const isIntegerFormat = (\n  format: string | undefined,\n): format is IntegerFormat => format !== undefined && format in INTEGER_FORMATS;\n\nexport const needsBigIntForFormat = (format: string | undefined): boolean =>\n  isIntegerFormat(format) && INTEGER_FORMATS[format].needsBigInt;\n\nexport const numberParameter = ({\n  isBigInt,\n  value,\n}: {\n  isBigInt: boolean;\n  value: unknown;\n}) => {\n  const expression = tsc.valueToExpression({ value });\n\n  if (\n    isBigInt &&\n    (typeof value === 'bigint' ||\n      typeof value === 'number' ||\n      typeof value === 'string' ||\n      typeof value === 'boolean')\n  ) {\n    return tsc.callExpression({\n      functionName: 'BigInt',\n      parameters: [expression],\n    });\n  }\n\n  return expression;\n};\n","import { operationResponsesMap } from '~/ir/operation';\nimport type { IR } from '~/ir/types';\nimport { buildName } from '~/openApi/shared/utils/name';\n\nimport { exportAst } from './export';\nimport type { Ast, IrSchemaToAstOptions } from './types';\n\nexport const irOperationToAst = ({\n  getAst,\n  operation,\n  plugin,\n  state,\n}: IrSchemaToAstOptions & {\n  getAst: (\n    schema: IR.SchemaObject,\n    path: ReadonlyArray<string | number>,\n  ) => Ast;\n  operation: IR.OperationObject;\n}) => {\n  if (plugin.config.requests.enabled) {\n    const requiredProperties = new Set<string>();\n\n    const schemaData: IR.SchemaObject = {\n      properties: {\n        body: {\n          type: 'never',\n        },\n        path: {\n          type: 'never',\n        },\n        query: {\n          type: 'never',\n        },\n      },\n      type: 'object',\n    };\n\n    if (operation.parameters) {\n      // TODO: add support for cookies\n\n      if (operation.parameters.header) {\n        const properties: Record<string, IR.SchemaObject> = {};\n        const required: Array<string> = [];\n\n        for (const key in operation.parameters.header) {\n          const parameter = operation.parameters.header[key]!;\n          properties[parameter.name] = parameter.schema;\n          if (parameter.required) {\n            required.push(parameter.name);\n            requiredProperties.add('headers');\n          }\n        }\n\n        if (Object.keys(properties).length) {\n          schemaData.properties!.headers = {\n            properties,\n            required,\n            type: 'object',\n          };\n        }\n      }\n\n      if (operation.parameters.path) {\n        const properties: Record<string, IR.SchemaObject> = {};\n        const required: Array<string> = [];\n\n        for (const key in operation.parameters.path) {\n          const parameter = operation.parameters.path[key]!;\n          properties[parameter.name] = parameter.schema;\n          if (parameter.required) {\n            required.push(parameter.name);\n            requiredProperties.add('path');\n          }\n        }\n\n        if (Object.keys(properties).length) {\n          schemaData.properties!.path = {\n            properties,\n            required,\n            type: 'object',\n          };\n        }\n      }\n\n      if (operation.parameters.query) {\n        const properties: Record<string, IR.SchemaObject> = {};\n        const required: Array<string> = [];\n\n        for (const key in operation.parameters.query) {\n          const parameter = operation.parameters.query[key]!;\n          properties[parameter.name] = parameter.schema;\n          if (parameter.required) {\n            required.push(parameter.name);\n            requiredProperties.add('query');\n          }\n        }\n\n        if (Object.keys(properties).length) {\n          schemaData.properties!.query = {\n            properties,\n            required,\n            type: 'object',\n          };\n        }\n      }\n    }\n\n    if (operation.body) {\n      schemaData.properties!.body = operation.body.schema;\n\n      if (operation.body.required) {\n        requiredProperties.add('body');\n      }\n    }\n\n    schemaData.required = [...requiredProperties];\n\n    const ast = getAst(schemaData, state.path.value);\n    const symbol = plugin.registerSymbol({\n      exported: true,\n      meta: {\n        path: state.path.value,\n        tags: state.tags?.value,\n      },\n      name: buildName({\n        config: plugin.config.requests,\n        name: operation.id,\n      }),\n      selector: plugin.api.selector('data', operation.id),\n    });\n    exportAst({\n      ast,\n      plugin,\n      schema: schemaData,\n      state,\n      symbol,\n    });\n  }\n\n  if (plugin.config.responses.enabled) {\n    if (operation.responses) {\n      const { response } = operationResponsesMap(operation);\n\n      if (response) {\n        const path = [...state.path.value, 'responses'];\n        const ast = getAst(response, path);\n        const symbol = plugin.registerSymbol({\n          exported: true,\n          meta: {\n            path,\n            tags: state.tags?.value,\n          },\n          name: buildName({\n            config: plugin.config.responses,\n            name: operation.id,\n          }),\n          selector: plugin.api.selector('responses', operation.id),\n        });\n        exportAst({\n          ast,\n          plugin,\n          schema: response,\n          state,\n          symbol,\n        });\n      }\n    }\n  }\n};\n","import type { IR } from '~/ir/types';\nimport { buildName } from '~/openApi/shared/utils/name';\n\nimport { exportAst } from './export';\nimport type { Ast, IrSchemaToAstOptions } from './types';\n\nexport const irWebhookToAst = ({\n  getAst,\n  operation,\n  plugin,\n  state,\n}: IrSchemaToAstOptions & {\n  getAst: (\n    schema: IR.SchemaObject,\n    path: ReadonlyArray<string | number>,\n  ) => Ast;\n  operation: IR.OperationObject;\n}) => {\n  if (plugin.config.webhooks.enabled) {\n    const requiredProperties = new Set<string>();\n\n    const schemaData: IR.SchemaObject = {\n      properties: {\n        body: {\n          type: 'never',\n        },\n        path: {\n          type: 'never',\n        },\n        query: {\n          type: 'never',\n        },\n      },\n      type: 'object',\n    };\n\n    if (operation.parameters) {\n      // TODO: add support for cookies\n\n      if (operation.parameters.header) {\n        const properties: Record<string, IR.SchemaObject> = {};\n        const required: Array<string> = [];\n\n        for (const key in operation.parameters.header) {\n          const parameter = operation.parameters.header[key]!;\n          properties[parameter.name] = parameter.schema;\n          if (parameter.required) {\n            required.push(parameter.name);\n            requiredProperties.add('headers');\n          }\n        }\n\n        if (Object.keys(properties).length) {\n          schemaData.properties!.headers = {\n            properties,\n            required,\n            type: 'object',\n          };\n        }\n      }\n\n      if (operation.parameters.path) {\n        const properties: Record<string, IR.SchemaObject> = {};\n        const required: Array<string> = [];\n\n        for (const key in operation.parameters.path) {\n          const parameter = operation.parameters.path[key]!;\n          properties[parameter.name] = parameter.schema;\n          if (parameter.required) {\n            required.push(parameter.name);\n            requiredProperties.add('path');\n          }\n        }\n\n        if (Object.keys(properties).length) {\n          schemaData.properties!.path = {\n            properties,\n            required,\n            type: 'object',\n          };\n        }\n      }\n\n      if (operation.parameters.query) {\n        const properties: Record<string, IR.SchemaObject> = {};\n        const required: Array<string> = [];\n\n        for (const key in operation.parameters.query) {\n          const parameter = operation.parameters.query[key]!;\n          properties[parameter.name] = parameter.schema;\n          if (parameter.required) {\n            required.push(parameter.name);\n            requiredProperties.add('query');\n          }\n        }\n\n        if (Object.keys(properties).length) {\n          schemaData.properties!.query = {\n            properties,\n            required,\n            type: 'object',\n          };\n        }\n      }\n    }\n\n    if (operation.body) {\n      schemaData.properties!.body = operation.body.schema;\n\n      if (operation.body.required) {\n        requiredProperties.add('body');\n      }\n    }\n\n    schemaData.required = [...requiredProperties];\n\n    const ast = getAst(schemaData, state.path.value);\n    const symbol = plugin.registerSymbol({\n      exported: true,\n      meta: {\n        path: state.path.value,\n        tags: state.tags?.value,\n      },\n      name: buildName({\n        config: plugin.config.webhooks,\n        name: operation.id,\n      }),\n      selector: plugin.api.selector('webhook-request', operation.id),\n    });\n    exportAst({\n      ast,\n      plugin,\n      schema: schemaData,\n      state,\n      symbol,\n    });\n  }\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { tsc } from '~/tsc';\n\nimport type { IrSchemaToAstOptions } from '../../shared/types';\nimport { identifiers } from '../constants';\n\nexport const unknownToAst = ({\n  plugin,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'unknown'>;\n}) => {\n  const v = plugin.referenceSymbol(\n    plugin.api.selector('external', 'valibot.v'),\n  );\n\n  const expression = tsc.callExpression({\n    functionName: tsc.propertyAccessExpression({\n      expression: v.placeholder,\n      name: identifiers.schemas.unknown,\n    }),\n  });\n  return expression;\n};\n","import { deduplicateSchema } from '~/ir/schema';\nimport type { SchemaWithType } from '~/plugins';\nimport { toRef } from '~/plugins/shared/utils/refs';\nimport { tsc } from '~/tsc';\n\nimport { pipesToAst } from '../../shared/pipesToAst';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\nimport { identifiers } from '../constants';\nimport { irSchemaToAst } from '../plugin';\nimport { unknownToAst } from './unknown';\n\nexport const arrayToAst = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'array'>;\n}): Omit<Ast, 'typeName'> => {\n  const result: Omit<Ast, 'typeName'> = {\n    pipes: [],\n  };\n\n  const v = plugin.referenceSymbol(\n    plugin.api.selector('external', 'valibot.v'),\n  );\n  const functionName = tsc.propertyAccessExpression({\n    expression: v.placeholder,\n    name: identifiers.schemas.array,\n  });\n\n  if (!schema.items) {\n    const expression = tsc.callExpression({\n      functionName,\n      parameters: [\n        unknownToAst({\n          plugin,\n          schema: {\n            type: 'unknown',\n          },\n          state,\n        }),\n      ],\n    });\n    result.pipes.push(expression);\n  } else {\n    schema = deduplicateSchema({ schema });\n\n    // at least one item is guaranteed\n    const itemExpressions = schema.items!.map((item, index) => {\n      const itemAst = irSchemaToAst({\n        plugin,\n        schema: item,\n        state: {\n          ...state,\n          path: toRef([...state.path.value, 'items', index]),\n        },\n      });\n      if (itemAst.hasLazyExpression) {\n        result.hasLazyExpression = true;\n      }\n      return pipesToAst({ pipes: itemAst.pipes, plugin });\n    });\n\n    if (itemExpressions.length === 1) {\n      const expression = tsc.callExpression({\n        functionName,\n        parameters: itemExpressions,\n      });\n      result.pipes.push(expression);\n    } else {\n      if (schema.logicalOperator === 'and') {\n        // TODO: parser - handle intersection\n        // return tsc.typeArrayNode(\n        //   tsc.typeIntersectionNode({ types: itemExpressions }),\n        // );\n      }\n\n      // TODO: parser - handle union\n      // return tsc.typeArrayNode(tsc.typeUnionNode({ types: itemExpressions }));\n\n      const expression = tsc.callExpression({\n        functionName,\n        parameters: [\n          unknownToAst({\n            plugin,\n            schema: {\n              type: 'unknown',\n            },\n            state,\n          }),\n        ],\n      });\n      result.pipes.push(expression);\n    }\n  }\n\n  if (schema.minItems === schema.maxItems && schema.minItems !== undefined) {\n    const expression = tsc.callExpression({\n      functionName: tsc.propertyAccessExpression({\n        expression: v.placeholder,\n        name: identifiers.actions.length,\n      }),\n      parameters: [tsc.valueToExpression({ value: schema.minItems })],\n    });\n    result.pipes.push(expression);\n  } else {\n    if (schema.minItems !== undefined) {\n      const expression = tsc.callExpression({\n        functionName: tsc.propertyAccessExpression({\n          expression: v.placeholder,\n          name: identifiers.actions.minLength,\n        }),\n        parameters: [tsc.valueToExpression({ value: schema.minItems })],\n      });\n      result.pipes.push(expression);\n    }\n\n    if (schema.maxItems !== undefined) {\n      const expression = tsc.callExpression({\n        functionName: tsc.propertyAccessExpression({\n          expression: v.placeholder,\n          name: identifiers.actions.maxLength,\n        }),\n        parameters: [tsc.valueToExpression({ value: schema.maxItems })],\n      });\n      result.pipes.push(expression);\n    }\n  }\n\n  return result as Omit<Ast, 'typeName'>;\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { tsc } from '~/tsc';\n\nimport type { IrSchemaToAstOptions } from '../../shared/types';\nimport { identifiers } from '../constants';\n\nexport const booleanToAst = ({\n  plugin,\n  schema,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'boolean'>;\n}) => {\n  const v = plugin.referenceSymbol(\n    plugin.api.selector('external', 'valibot.v'),\n  );\n\n  if (typeof schema.const === 'boolean') {\n    const expression = tsc.callExpression({\n      functionName: tsc.propertyAccessExpression({\n        expression: v.placeholder,\n        name: identifiers.schemas.literal,\n      }),\n      parameters: [tsc.ots.boolean(schema.const)],\n    });\n    return expression;\n  }\n\n  const expression = tsc.callExpression({\n    functionName: tsc.propertyAccessExpression({\n      expression: v.placeholder,\n      name: identifiers.schemas.boolean,\n    }),\n  });\n  return expression;\n};\n","import type ts from 'typescript';\n\nimport type { SchemaWithType } from '~/plugins';\nimport { tsc } from '~/tsc';\n\nimport type { IrSchemaToAstOptions } from '../../shared/types';\nimport { identifiers } from '../constants';\nimport { unknownToAst } from './unknown';\n\nexport const enumToAst = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'enum'>;\n}): ts.CallExpression => {\n  const enumMembers: Array<ts.LiteralExpression> = [];\n\n  let isNullable = false;\n\n  for (const item of schema.items ?? []) {\n    // Zod supports only string enums\n    if (item.type === 'string' && typeof item.const === 'string') {\n      enumMembers.push(\n        tsc.stringLiteral({\n          text: item.const,\n        }),\n      );\n    } else if (item.type === 'null' || item.const === null) {\n      isNullable = true;\n    }\n  }\n\n  if (!enumMembers.length) {\n    return unknownToAst({\n      plugin,\n      schema: {\n        type: 'unknown',\n      },\n      state,\n    });\n  }\n\n  const v = plugin.referenceSymbol(\n    plugin.api.selector('external', 'valibot.v'),\n  );\n\n  let resultExpression = tsc.callExpression({\n    functionName: tsc.propertyAccessExpression({\n      expression: v.placeholder,\n      name: identifiers.schemas.picklist,\n    }),\n    parameters: [\n      tsc.arrayLiteralExpression({\n        elements: enumMembers,\n        multiLine: false,\n      }),\n    ],\n  });\n\n  if (isNullable) {\n    resultExpression = tsc.callExpression({\n      functionName: tsc.propertyAccessExpression({\n        expression: v.placeholder,\n        name: identifiers.schemas.nullable,\n      }),\n      parameters: [resultExpression],\n    });\n  }\n\n  return resultExpression;\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { tsc } from '~/tsc';\n\nimport type { IrSchemaToAstOptions } from '../../shared/types';\nimport { identifiers } from '../constants';\n\nexport const neverToAst = ({\n  plugin,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'never'>;\n}) => {\n  const v = plugin.referenceSymbol(\n    plugin.api.selector('external', 'valibot.v'),\n  );\n  const expression = tsc.callExpression({\n    functionName: tsc.propertyAccessExpression({\n      expression: v.placeholder,\n      name: identifiers.schemas.never,\n    }),\n  });\n  return expression;\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { tsc } from '~/tsc';\n\nimport type { IrSchemaToAstOptions } from '../../shared/types';\nimport { identifiers } from '../constants';\n\nexport const nullToAst = ({\n  plugin,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'null'>;\n}) => {\n  const v = plugin.referenceSymbol(\n    plugin.api.selector('external', 'valibot.v'),\n  );\n  const expression = tsc.callExpression({\n    functionName: tsc.propertyAccessExpression({\n      expression: v.placeholder,\n      name: identifiers.schemas.null,\n    }),\n  });\n  return expression;\n};\n","import type ts from 'typescript';\n\nimport type { SchemaWithType } from '~/plugins';\nimport { tsc } from '~/tsc';\n\nimport {\n  INTEGER_FORMATS,\n  isIntegerFormat,\n  needsBigIntForFormat,\n  numberParameter,\n} from '../../shared/numbers';\nimport { pipesToAst } from '../../shared/pipesToAst';\nimport type { IrSchemaToAstOptions } from '../../shared/types';\nimport { identifiers } from '../constants';\n\nexport const numberToAst = ({\n  plugin,\n  schema,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'integer' | 'number'>;\n}) => {\n  const format = schema.format;\n  const isInteger = schema.type === 'integer';\n  const isBigInt = needsBigIntForFormat(format);\n  const formatInfo = isIntegerFormat(format) ? INTEGER_FORMATS[format] : null;\n\n  const v = plugin.referenceSymbol(\n    plugin.api.selector('external', 'valibot.v'),\n  );\n\n  // Return early if const is defined since we can create a literal type directly without additional validation\n  if (schema.const !== undefined && schema.const !== null) {\n    const constValue = schema.const;\n    let literalValue;\n\n    // Case 1: Number with no format -> generate literal with the number\n    if (typeof constValue === 'number' && !format) {\n      literalValue = tsc.ots.number(constValue);\n    }\n    // Case 2: Number with format -> check if format needs BigInt, generate appropriate literal\n    else if (typeof constValue === 'number' && format) {\n      if (isBigInt) {\n        // Format requires BigInt, convert number to BigInt\n        literalValue = tsc.callExpression({\n          functionName: 'BigInt',\n          parameters: [tsc.ots.string(constValue.toString())],\n        });\n      } else {\n        // Regular format, use number as-is\n        literalValue = tsc.ots.number(constValue);\n      }\n    }\n    // Case 3: Format that allows string -> generate BigInt literal (for int64/uint64 formats)\n    else if (typeof constValue === 'string' && isBigInt) {\n      // Remove 'n' suffix if present in string\n      const cleanString = constValue.endsWith('n')\n        ? constValue.slice(0, -1)\n        : constValue;\n      literalValue = tsc.callExpression({\n        functionName: 'BigInt',\n        parameters: [tsc.ots.string(cleanString)],\n      });\n    }\n    // Case 4: Const is typeof bigint (literal) -> transform from literal to BigInt()\n    else if (typeof constValue === 'bigint') {\n      // Convert BigInt to string and remove 'n' suffix that toString() adds\n      const bigintString = constValue.toString();\n      const cleanString = bigintString.endsWith('n')\n        ? bigintString.slice(0, -1)\n        : bigintString;\n      literalValue = tsc.callExpression({\n        functionName: 'BigInt',\n        parameters: [tsc.ots.string(cleanString)],\n      });\n    }\n    // Default case: use value as-is for other types\n    else {\n      literalValue = tsc.valueToExpression({ value: constValue });\n    }\n\n    return tsc.callExpression({\n      functionName: tsc.propertyAccessExpression({\n        expression: v.placeholder,\n        name: identifiers.schemas.literal,\n      }),\n      parameters: [literalValue],\n    });\n  }\n\n  const pipes: Array<ts.CallExpression> = [];\n\n  // For bigint formats (int64, uint64), create union of number, string, and bigint with transform\n  if (isBigInt) {\n    const unionExpression = tsc.callExpression({\n      functionName: tsc.propertyAccessExpression({\n        expression: v.placeholder,\n        name: identifiers.schemas.union,\n      }),\n      parameters: [\n        tsc.arrayLiteralExpression({\n          elements: [\n            tsc.callExpression({\n              functionName: tsc.propertyAccessExpression({\n                expression: v.placeholder,\n                name: identifiers.schemas.number,\n              }),\n            }),\n            tsc.callExpression({\n              functionName: tsc.propertyAccessExpression({\n                expression: v.placeholder,\n                name: identifiers.schemas.string,\n              }),\n            }),\n            tsc.callExpression({\n              functionName: tsc.propertyAccessExpression({\n                expression: v.placeholder,\n                name: identifiers.schemas.bigInt,\n              }),\n            }),\n          ],\n          multiLine: false,\n        }),\n      ],\n    });\n    pipes.push(unionExpression);\n\n    // Add transform to convert to BigInt\n    const transformExpression = tsc.callExpression({\n      functionName: tsc.propertyAccessExpression({\n        expression: v.placeholder,\n        name: identifiers.actions.transform,\n      }),\n      parameters: [\n        tsc.arrowFunction({\n          parameters: [{ name: 'x' }],\n          statements: tsc.callExpression({\n            functionName: 'BigInt',\n            parameters: [tsc.identifier({ text: 'x' })],\n          }),\n        }),\n      ],\n    });\n    pipes.push(transformExpression);\n  } else {\n    // For regular number formats, use number schema\n    const expression = tsc.callExpression({\n      functionName: tsc.propertyAccessExpression({\n        expression: v.placeholder,\n        name: identifiers.schemas.number,\n      }),\n    });\n    pipes.push(expression);\n  }\n\n  // Add integer validation for integer types (except when using bigint union)\n  if (!isBigInt && isInteger) {\n    const expression = tsc.callExpression({\n      functionName: tsc.propertyAccessExpression({\n        expression: v.placeholder,\n        name: identifiers.actions.integer,\n      }),\n    });\n    pipes.push(expression);\n  }\n\n  // Add format-specific range validations\n  if (formatInfo) {\n    const minValue = formatInfo.min;\n    const maxValue = formatInfo.max;\n    const minErrorMessage = formatInfo.minError;\n    const maxErrorMessage = formatInfo.maxError;\n\n    // Add minimum value validation\n    const minExpression = tsc.callExpression({\n      functionName: tsc.propertyAccessExpression({\n        expression: v.placeholder,\n        name: identifiers.actions.minValue,\n      }),\n      parameters: [\n        isBigInt\n          ? tsc.callExpression({\n              functionName: 'BigInt',\n              parameters: [tsc.ots.string(minValue.toString())],\n            })\n          : tsc.ots.number(minValue as number),\n        tsc.ots.string(minErrorMessage),\n      ],\n    });\n    pipes.push(minExpression);\n\n    // Add maximum value validation\n    const maxExpression = tsc.callExpression({\n      functionName: tsc.propertyAccessExpression({\n        expression: v.placeholder,\n        name: identifiers.actions.maxValue,\n      }),\n      parameters: [\n        isBigInt\n          ? tsc.callExpression({\n              functionName: 'BigInt',\n              parameters: [tsc.ots.string(maxValue.toString())],\n            })\n          : tsc.ots.number(maxValue as number),\n        tsc.ots.string(maxErrorMessage),\n      ],\n    });\n    pipes.push(maxExpression);\n  }\n\n  if (schema.exclusiveMinimum !== undefined) {\n    const expression = tsc.callExpression({\n      functionName: tsc.propertyAccessExpression({\n        expression: v.placeholder,\n        name: identifiers.actions.gtValue,\n      }),\n      parameters: [\n        numberParameter({ isBigInt, value: schema.exclusiveMinimum }),\n      ],\n    });\n    pipes.push(expression);\n  } else if (schema.minimum !== undefined) {\n    const expression = tsc.callExpression({\n      functionName: tsc.propertyAccessExpression({\n        expression: v.placeholder,\n        name: identifiers.actions.minValue,\n      }),\n      parameters: [numberParameter({ isBigInt, value: schema.minimum })],\n    });\n    pipes.push(expression);\n  }\n\n  if (schema.exclusiveMaximum !== undefined) {\n    const expression = tsc.callExpression({\n      functionName: tsc.propertyAccessExpression({\n        expression: v.placeholder,\n        name: identifiers.actions.ltValue,\n      }),\n      parameters: [\n        numberParameter({ isBigInt, value: schema.exclusiveMaximum }),\n      ],\n    });\n    pipes.push(expression);\n  } else if (schema.maximum !== undefined) {\n    const expression = tsc.callExpression({\n      functionName: tsc.propertyAccessExpression({\n        expression: v.placeholder,\n        name: identifiers.actions.maxValue,\n      }),\n      parameters: [numberParameter({ isBigInt, value: schema.maximum })],\n    });\n    pipes.push(expression);\n  }\n\n  return pipesToAst({ pipes, plugin });\n};\n","import ts from 'typescript';\n\nimport type { SchemaWithType } from '~/plugins';\nimport { toRef } from '~/plugins/shared/utils/refs';\nimport { tsc } from '~/tsc';\nimport { numberRegExp } from '~/utils/regexp';\n\nimport { pipesToAst } from '../../shared/pipesToAst';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\nimport { identifiers } from '../constants';\nimport { irSchemaToAst } from '../plugin';\n\nexport const objectToAst = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'object'>;\n}): Omit<Ast, 'typeName'> => {\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n\n  // TODO: parser - handle constants\n  const properties: Array<ts.PropertyAssignment> = [];\n\n  const required = schema.required ?? [];\n\n  for (const name in schema.properties) {\n    const property = schema.properties[name]!;\n    const isRequired = required.includes(name);\n\n    const propertyAst = irSchemaToAst({\n      optional: !isRequired,\n      plugin,\n      schema: property,\n      state: {\n        ...state,\n        path: toRef([...state.path.value, 'properties', name]),\n      },\n    });\n    if (propertyAst.hasLazyExpression) {\n      result.hasLazyExpression = true;\n    }\n\n    numberRegExp.lastIndex = 0;\n    let propertyName;\n    if (numberRegExp.test(name)) {\n      // For numeric literals, we'll handle negative numbers by using a string literal\n      // instead of trying to use a PrefixUnaryExpression\n      propertyName = name.startsWith('-')\n        ? ts.factory.createStringLiteral(name)\n        : ts.factory.createNumericLiteral(name);\n    } else {\n      propertyName = name;\n    }\n    // TODO: parser - abstract safe property name logic\n    if (\n      ((name.match(/^[0-9]/) && name.match(/\\D+/g)) || name.match(/\\W/g)) &&\n      !name.startsWith(\"'\") &&\n      !name.endsWith(\"'\")\n    ) {\n      propertyName = `'${name}'`;\n    }\n    properties.push(\n      tsc.propertyAssignment({\n        initializer: pipesToAst({ pipes: propertyAst.pipes, plugin }),\n        name: propertyName,\n      }),\n    );\n  }\n\n  const v = plugin.referenceSymbol(\n    plugin.api.selector('external', 'valibot.v'),\n  );\n\n  // Handle additionalProperties with a schema (not just true/false)\n  // This supports objects with dynamic keys (e.g., Record<string, T>)\n  if (\n    schema.additionalProperties &&\n    typeof schema.additionalProperties === 'object' &&\n    schema.additionalProperties.type !== undefined\n  ) {\n    const additionalAst = irSchemaToAst({\n      plugin,\n      schema: schema.additionalProperties,\n      state: {\n        ...state,\n        path: toRef([...state.path.value, 'additionalProperties']),\n      },\n    });\n    if (additionalAst.hasLazyExpression) {\n      result.hasLazyExpression = true;\n    }\n\n    // If there are no named properties, use v.record() directly\n    if (!Object.keys(properties).length) {\n      result.pipes = [\n        tsc.callExpression({\n          functionName: tsc.propertyAccessExpression({\n            expression: v.placeholder,\n            name: identifiers.schemas.record,\n          }),\n          parameters: [\n            tsc.callExpression({\n              functionName: tsc.propertyAccessExpression({\n                expression: v.placeholder,\n                name: identifiers.schemas.string,\n              }),\n              parameters: [],\n            }),\n            pipesToAst({ pipes: additionalAst.pipes, plugin }),\n          ],\n        }),\n      ];\n      return result as Omit<Ast, 'typeName'>;\n    }\n\n    // If there are named properties, use v.objectWithRest() to validate both\n    // The rest parameter is the schema for each additional property value\n    result.pipes = [\n      tsc.callExpression({\n        functionName: tsc.propertyAccessExpression({\n          expression: v.placeholder,\n          name: identifiers.schemas.objectWithRest,\n        }),\n        parameters: [\n          ts.factory.createObjectLiteralExpression(properties, true),\n          pipesToAst({ pipes: additionalAst.pipes, plugin }),\n        ],\n      }),\n    ];\n    return result as Omit<Ast, 'typeName'>;\n  }\n\n  result.pipes = [\n    tsc.callExpression({\n      functionName: tsc.propertyAccessExpression({\n        expression: v.placeholder,\n        name: identifiers.schemas.object,\n      }),\n      parameters: [ts.factory.createObjectLiteralExpression(properties, true)],\n    }),\n  ];\n  return result as Omit<Ast, 'typeName'>;\n};\n","import type ts from 'typescript';\n\nimport type { SchemaWithType } from '~/plugins';\nimport { tsc } from '~/tsc';\n\nimport { pipesToAst } from '../../shared/pipesToAst';\nimport type { IrSchemaToAstOptions } from '../../shared/types';\nimport { identifiers } from '../constants';\n\nexport const stringToAst = ({\n  plugin,\n  schema,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'string'>;\n}) => {\n  const v = plugin.referenceSymbol(\n    plugin.api.selector('external', 'valibot.v'),\n  );\n\n  if (typeof schema.const === 'string') {\n    const expression = tsc.callExpression({\n      functionName: tsc.propertyAccessExpression({\n        expression: v.placeholder,\n        name: identifiers.schemas.literal,\n      }),\n      parameters: [tsc.ots.string(schema.const)],\n    });\n    return expression;\n  }\n\n  const pipes: Array<ts.CallExpression> = [];\n\n  const expression = tsc.callExpression({\n    functionName: tsc.propertyAccessExpression({\n      expression: v.placeholder,\n      name: identifiers.schemas.string,\n    }),\n  });\n  pipes.push(expression);\n\n  if (schema.format) {\n    switch (schema.format) {\n      case 'date':\n        pipes.push(\n          tsc.callExpression({\n            functionName: tsc.propertyAccessExpression({\n              expression: v.placeholder,\n              name: identifiers.actions.isoDate,\n            }),\n          }),\n        );\n        break;\n      case 'date-time':\n        pipes.push(\n          tsc.callExpression({\n            functionName: tsc.propertyAccessExpression({\n              expression: v.placeholder,\n              name: identifiers.actions.isoTimestamp,\n            }),\n          }),\n        );\n        break;\n      case 'ipv4':\n      case 'ipv6':\n        pipes.push(\n          tsc.callExpression({\n            functionName: tsc.propertyAccessExpression({\n              expression: v.placeholder,\n              name: identifiers.actions.ip,\n            }),\n          }),\n        );\n        break;\n      case 'uri':\n        pipes.push(\n          tsc.callExpression({\n            functionName: tsc.propertyAccessExpression({\n              expression: v.placeholder,\n              name: identifiers.actions.url,\n            }),\n          }),\n        );\n        break;\n      case 'email':\n      case 'time':\n      case 'uuid':\n        pipes.push(\n          tsc.callExpression({\n            functionName: tsc.propertyAccessExpression({\n              expression: v.placeholder,\n              name: tsc.identifier({ text: schema.format }),\n            }),\n          }),\n        );\n        break;\n    }\n  }\n\n  if (schema.minLength === schema.maxLength && schema.minLength !== undefined) {\n    const expression = tsc.callExpression({\n      functionName: tsc.propertyAccessExpression({\n        expression: v.placeholder,\n        name: identifiers.actions.length,\n      }),\n      parameters: [tsc.valueToExpression({ value: schema.minLength })],\n    });\n    pipes.push(expression);\n  } else {\n    if (schema.minLength !== undefined) {\n      const expression = tsc.callExpression({\n        functionName: tsc.propertyAccessExpression({\n          expression: v.placeholder,\n          name: identifiers.actions.minLength,\n        }),\n        parameters: [tsc.valueToExpression({ value: schema.minLength })],\n      });\n      pipes.push(expression);\n    }\n\n    if (schema.maxLength !== undefined) {\n      const expression = tsc.callExpression({\n        functionName: tsc.propertyAccessExpression({\n          expression: v.placeholder,\n          name: identifiers.actions.maxLength,\n        }),\n        parameters: [tsc.valueToExpression({ value: schema.maxLength })],\n      });\n      pipes.push(expression);\n    }\n  }\n\n  if (schema.pattern) {\n    const expression = tsc.callExpression({\n      functionName: tsc.propertyAccessExpression({\n        expression: v.placeholder,\n        name: identifiers.actions.regex,\n      }),\n      parameters: [tsc.regularExpressionLiteral({ text: schema.pattern })],\n    });\n    pipes.push(expression);\n  }\n\n  return pipesToAst({ pipes, plugin });\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { toRef } from '~/plugins/shared/utils/refs';\nimport { tsc } from '~/tsc';\n\nimport { pipesToAst } from '../../shared/pipesToAst';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\nimport { identifiers } from '../constants';\nimport { irSchemaToAst } from '../plugin';\nimport { unknownToAst } from './unknown';\n\nexport const tupleToAst = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'tuple'>;\n}): Omit<Ast, 'typeName'> => {\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n\n  const v = plugin.referenceSymbol(\n    plugin.api.selector('external', 'valibot.v'),\n  );\n\n  if (schema.const && Array.isArray(schema.const)) {\n    const tupleElements = schema.const.map((value) =>\n      tsc.callExpression({\n        functionName: tsc.propertyAccessExpression({\n          expression: v.placeholder,\n          name: identifiers.schemas.literal,\n        }),\n        parameters: [tsc.valueToExpression({ value })],\n      }),\n    );\n    result.pipes = [\n      tsc.callExpression({\n        functionName: tsc.propertyAccessExpression({\n          expression: v.placeholder,\n          name: identifiers.schemas.tuple,\n        }),\n        parameters: [\n          tsc.arrayLiteralExpression({\n            elements: tupleElements,\n          }),\n        ],\n      }),\n    ];\n    return result as Omit<Ast, 'typeName'>;\n  }\n\n  if (schema.items) {\n    const tupleElements = schema.items.map((item, index) => {\n      const schemaPipes = irSchemaToAst({\n        plugin,\n        schema: item,\n        state: {\n          ...state,\n          path: toRef([...state.path.value, 'items', index]),\n        },\n      });\n      if (schemaPipes.hasLazyExpression) {\n        result.hasLazyExpression = true;\n      }\n      return pipesToAst({ pipes: schemaPipes.pipes, plugin });\n    });\n    result.pipes = [\n      tsc.callExpression({\n        functionName: tsc.propertyAccessExpression({\n          expression: v.placeholder,\n          name: identifiers.schemas.tuple,\n        }),\n        parameters: [\n          tsc.arrayLiteralExpression({\n            elements: tupleElements,\n          }),\n        ],\n      }),\n    ];\n    return result as Omit<Ast, 'typeName'>;\n  }\n\n  return {\n    pipes: [\n      unknownToAst({\n        plugin,\n        schema: {\n          type: 'unknown',\n        },\n        state,\n      }),\n    ],\n  };\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { tsc } from '~/tsc';\n\nimport type { IrSchemaToAstOptions } from '../../shared/types';\nimport { identifiers } from '../constants';\n\nexport const undefinedToAst = ({\n  plugin,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'undefined'>;\n}) => {\n  const v = plugin.referenceSymbol(\n    plugin.api.selector('external', 'valibot.v'),\n  );\n\n  const expression = tsc.callExpression({\n    functionName: tsc.propertyAccessExpression({\n      expression: v.placeholder,\n      name: identifiers.schemas.undefined,\n    }),\n  });\n  return expression;\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { tsc } from '~/tsc';\n\nimport type { IrSchemaToAstOptions } from '../../shared/types';\nimport { identifiers } from '../constants';\n\nexport const voidToAst = ({\n  plugin,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'void'>;\n}) => {\n  const v = plugin.referenceSymbol(\n    plugin.api.selector('external', 'valibot.v'),\n  );\n\n  const expression = tsc.callExpression({\n    functionName: tsc.propertyAccessExpression({\n      expression: v.placeholder,\n      name: identifiers.schemas.void,\n    }),\n  });\n  return expression;\n};\n","import type ts from 'typescript';\n\nimport type { SchemaWithType } from '~/plugins';\n\nimport { pipesToAst } from '../../shared/pipesToAst';\nimport type { IrSchemaToAstOptions } from '../../shared/types';\nimport { arrayToAst } from './array';\nimport { booleanToAst } from './boolean';\nimport { enumToAst } from './enum';\nimport { neverToAst } from './never';\nimport { nullToAst } from './null';\nimport { numberToAst } from './number';\nimport { objectToAst } from './object';\nimport { stringToAst } from './string';\nimport { tupleToAst } from './tuple';\nimport { undefinedToAst } from './undefined';\nimport { unknownToAst } from './unknown';\nimport { voidToAst } from './void';\n\nexport const irSchemaWithTypeToAst = ({\n  schema,\n  ...args\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType;\n}): {\n  anyType?: string;\n  expression: ts.Expression;\n} => {\n  switch (schema.type) {\n    case 'array':\n      return {\n        expression: pipesToAst({\n          pipes: arrayToAst({\n            ...args,\n            schema: schema as SchemaWithType<'array'>,\n          }).pipes,\n          plugin: args.plugin,\n        }),\n      };\n    case 'boolean':\n      return {\n        expression: booleanToAst({\n          ...args,\n          schema: schema as SchemaWithType<'boolean'>,\n        }),\n      };\n    case 'enum':\n      return {\n        expression: enumToAst({\n          ...args,\n          schema: schema as SchemaWithType<'enum'>,\n        }),\n      };\n    case 'integer':\n    case 'number':\n      return {\n        expression: numberToAst({\n          ...args,\n          schema: schema as SchemaWithType<'integer' | 'number'>,\n        }),\n      };\n    case 'never':\n      return {\n        expression: neverToAst({\n          ...args,\n          schema: schema as SchemaWithType<'never'>,\n        }),\n      };\n    case 'null':\n      return {\n        expression: nullToAst({\n          ...args,\n          schema: schema as SchemaWithType<'null'>,\n        }),\n      };\n    case 'object':\n      return {\n        expression: pipesToAst({\n          pipes: objectToAst({\n            ...args,\n            schema: schema as SchemaWithType<'object'>,\n          }).pipes,\n          plugin: args.plugin,\n        }),\n      };\n    case 'string':\n      // For string schemas with int64/uint64 formats, use number handler to generate union with transform\n      if (schema.format === 'int64' || schema.format === 'uint64') {\n        return {\n          expression: numberToAst({\n            ...args,\n            schema: schema as SchemaWithType<'integer' | 'number'>,\n          }),\n        };\n      }\n      return {\n        expression: stringToAst({\n          ...args,\n          schema: schema as SchemaWithType<'string'>,\n        }),\n      };\n    case 'tuple':\n      return {\n        expression: pipesToAst({\n          pipes: tupleToAst({\n            ...args,\n            schema: schema as SchemaWithType<'tuple'>,\n          }).pipes,\n          plugin: args.plugin,\n        }),\n      };\n    case 'undefined':\n      return {\n        expression: undefinedToAst({\n          ...args,\n          schema: schema as SchemaWithType<'undefined'>,\n        }),\n      };\n    case 'unknown':\n      return {\n        expression: unknownToAst({\n          ...args,\n          schema: schema as SchemaWithType<'unknown'>,\n        }),\n      };\n    case 'void':\n      return {\n        expression: voidToAst({\n          ...args,\n          schema: schema as SchemaWithType<'void'>,\n        }),\n      };\n  }\n};\n","import type ts from 'typescript';\n\nimport { deduplicateSchema } from '~/ir/schema';\nimport type { IR } from '~/ir/types';\nimport { buildName } from '~/openApi/shared/utils/name';\nimport type { SchemaWithType } from '~/plugins';\nimport { toRef, toRefs } from '~/plugins/shared/utils/refs';\nimport { tsc } from '~/tsc';\nimport { pathToJsonPointer, refToName } from '~/utils/ref';\n\nimport { exportAst } from '../shared/export';\nimport { numberParameter } from '../shared/numbers';\nimport { irOperationToAst } from '../shared/operation';\nimport { pipesToAst } from '../shared/pipesToAst';\nimport type { Ast, IrSchemaToAstOptions, PluginState } from '../shared/types';\nimport { irWebhookToAst } from '../shared/webhook';\nimport type { ValibotPlugin } from '../types';\nimport { identifiers } from './constants';\nimport { irSchemaWithTypeToAst } from './toAst';\n\nexport const irSchemaToAst = ({\n  optional,\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  /**\n   * Accept `optional` to handle optional object properties. We can't handle\n   * this inside the object function because `.optional()` must come before\n   * `.default()` which is handled in this function.\n   */\n  optional?: boolean;\n  schema: IR.SchemaObject;\n}): Ast => {\n  const ast: Ast = {\n    pipes: [],\n  };\n\n  const v = plugin.referenceSymbol(\n    plugin.api.selector('external', 'valibot.v'),\n  );\n\n  if (schema.$ref) {\n    const selector = plugin.api.selector('ref', schema.$ref);\n    const refSymbol = plugin.referenceSymbol(selector);\n    if (plugin.isSymbolRegistered(selector)) {\n      const ref = tsc.identifier({ text: refSymbol.placeholder });\n      ast.pipes.push(ref);\n    } else {\n      const lazyExpression = tsc.callExpression({\n        functionName: tsc.propertyAccessExpression({\n          expression: v.placeholder,\n          name: identifiers.schemas.lazy,\n        }),\n        parameters: [\n          tsc.arrowFunction({\n            statements: [\n              tsc.returnStatement({\n                expression: tsc.identifier({ text: refSymbol.placeholder }),\n              }),\n            ],\n          }),\n        ],\n      });\n      ast.pipes.push(lazyExpression);\n      state.hasLazyExpression.value = true;\n    }\n  } else if (schema.type) {\n    const typeAst = irSchemaWithTypeToAst({\n      plugin,\n      schema: schema as SchemaWithType,\n      state,\n    });\n    ast.typeName = typeAst.anyType;\n    ast.pipes.push(typeAst.expression);\n\n    if (plugin.config.metadata && schema.description) {\n      const expression = tsc.callExpression({\n        functionName: tsc.propertyAccessExpression({\n          expression: v.placeholder,\n          name: identifiers.actions.metadata,\n        }),\n        parameters: [\n          tsc.objectExpression({\n            obj: [\n              {\n                key: 'description',\n                value: tsc.stringLiteral({ text: schema.description }),\n              },\n            ],\n          }),\n        ],\n      });\n      ast.pipes.push(expression);\n    }\n  } else if (schema.items) {\n    schema = deduplicateSchema({ schema });\n\n    if (schema.items) {\n      const itemsAst = schema.items.map((item, index) => {\n        const itemAst = irSchemaToAst({\n          plugin,\n          schema: item,\n          state: {\n            ...state,\n            path: toRef([...state.path.value, 'items', index]),\n          },\n        });\n        return pipesToAst({ pipes: itemAst.pipes, plugin });\n      });\n\n      if (schema.logicalOperator === 'and') {\n        const intersectExpression = tsc.callExpression({\n          functionName: tsc.propertyAccessExpression({\n            expression: v.placeholder,\n            name: identifiers.schemas.intersect,\n          }),\n          parameters: [\n            tsc.arrayLiteralExpression({\n              elements: itemsAst,\n            }),\n          ],\n        });\n        ast.pipes.push(intersectExpression);\n      } else {\n        const unionExpression = tsc.callExpression({\n          functionName: tsc.propertyAccessExpression({\n            expression: v.placeholder,\n            name: identifiers.schemas.union,\n          }),\n          parameters: [\n            tsc.arrayLiteralExpression({\n              elements: itemsAst,\n            }),\n          ],\n        });\n        ast.pipes.push(unionExpression);\n      }\n    } else {\n      const schemaPipes = irSchemaToAst({ plugin, schema, state });\n      ast.pipes.push(...schemaPipes.pipes);\n    }\n  } else {\n    // catch-all fallback for failed schemas\n    const typeAst = irSchemaWithTypeToAst({\n      plugin,\n      schema: {\n        type: 'unknown',\n      },\n      state,\n    });\n    ast.typeName = typeAst.anyType;\n    ast.pipes.push(typeAst.expression);\n  }\n\n  if (ast.pipes.length) {\n    if (schema.accessScope === 'read') {\n      const readonlyExpression = tsc.callExpression({\n        functionName: tsc.propertyAccessExpression({\n          expression: v.placeholder,\n          name: identifiers.actions.readonly,\n        }),\n      });\n      ast.pipes.push(readonlyExpression);\n    }\n\n    let callParameter: ts.Expression | undefined;\n\n    if (schema.default !== undefined) {\n      const isBigInt = schema.type === 'integer' && schema.format === 'int64';\n      callParameter = numberParameter({ isBigInt, value: schema.default });\n      if (callParameter) {\n        ast.pipes = [\n          tsc.callExpression({\n            functionName: tsc.propertyAccessExpression({\n              expression: v.placeholder,\n              name: identifiers.schemas.optional,\n            }),\n            parameters: [\n              pipesToAst({ pipes: ast.pipes, plugin }),\n              callParameter,\n            ],\n          }),\n        ];\n      }\n    }\n\n    if (optional && !callParameter) {\n      ast.pipes = [\n        tsc.callExpression({\n          functionName: tsc.propertyAccessExpression({\n            expression: v.placeholder,\n            name: identifiers.schemas.optional,\n          }),\n          parameters: [pipesToAst({ pipes: ast.pipes, plugin })],\n        }),\n      ];\n    }\n  }\n\n  return ast as Ast;\n};\n\nconst handleComponent = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: IR.SchemaObject;\n}): void => {\n  const $ref = pathToJsonPointer(state.path.value);\n  const ast = irSchemaToAst({ plugin, schema, state });\n  const baseName = refToName($ref);\n  const symbol = plugin.registerSymbol({\n    exported: true,\n    meta: {\n      path: state.path.value,\n      tags: state.tags?.value,\n    },\n    name: buildName({\n      config: plugin.config.definitions,\n      name: baseName,\n    }),\n    selector: plugin.api.selector('ref', $ref),\n  });\n  exportAst({\n    ast,\n    plugin,\n    schema,\n    state,\n    symbol,\n  });\n};\n\nexport const handlerV1: ValibotPlugin['Handler'] = ({ plugin }) => {\n  plugin.registerSymbol({\n    external: 'valibot',\n    meta: { importKind: 'namespace' },\n    name: 'v',\n    selector: plugin.api.selector('external', 'valibot.v'),\n  });\n\n  plugin.forEach(\n    'operation',\n    'parameter',\n    'requestBody',\n    'schema',\n    'webhook',\n    (event) => {\n      const state = toRefs<PluginState>({\n        hasLazyExpression: false,\n        path: event._path,\n        tags: event.tags,\n      });\n      switch (event.type) {\n        case 'operation':\n          irOperationToAst({\n            getAst: (schema, path) => {\n              const state = toRefs<PluginState>({\n                hasLazyExpression: false,\n                path,\n                tags: event.tags,\n              });\n              return irSchemaToAst({ plugin, schema, state });\n            },\n            operation: event.operation,\n            plugin,\n            state,\n          });\n          break;\n        case 'parameter':\n          handleComponent({\n            plugin,\n            schema: event.parameter.schema,\n            state,\n          });\n          break;\n        case 'requestBody':\n          handleComponent({\n            plugin,\n            schema: event.requestBody.schema,\n            state,\n          });\n          break;\n        case 'schema':\n          handleComponent({\n            plugin,\n            schema: event.schema,\n            state,\n          });\n          break;\n        case 'webhook':\n          irWebhookToAst({\n            getAst: (schema, path) => {\n              const state = toRefs<PluginState>({\n                hasLazyExpression: false,\n                path,\n                tags: event.tags,\n              });\n              return irSchemaToAst({ plugin, schema, state });\n            },\n            operation: event.operation,\n            plugin,\n            state,\n          });\n          break;\n      }\n    },\n  );\n};\n","import type { ValibotPlugin } from './types';\nimport { handlerV1 } from './v1/plugin';\n\nexport const handler: ValibotPlugin['Handler'] = (args) => handlerV1(args);\n","import { definePluginConfig } from '~/plugins/shared/utils/config';\n\nimport { Api } from './api';\nimport { handler } from './plugin';\nimport type { ValibotPlugin } from './types';\n\nexport const defaultConfig: ValibotPlugin['Config'] = {\n  api: new Api({\n    name: 'valibot',\n  }),\n  config: {\n    case: 'camelCase',\n    comments: true,\n    exportFromIndex: false,\n    metadata: false,\n  },\n  handler,\n  name: 'valibot',\n  resolveConfig: (plugin, context) => {\n    plugin.config.definitions = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: 'v{{name}}',\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.definitions,\n    });\n\n    plugin.config.requests = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: 'v{{name}}Data',\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.requests,\n    });\n\n    plugin.config.responses = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: 'v{{name}}Response',\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.responses,\n    });\n\n    plugin.config.webhooks = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: 'v{{name}}WebhookRequest',\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.webhooks,\n    });\n  },\n  tags: ['validator'],\n};\n\n/**\n * Type helper for Valibot plugin, returns {@link Plugin.Config} object\n */\nexport const defineConfig = definePluginConfig(defaultConfig);\n","import { tsc } from '~/tsc';\n\n// TODO: this is inaccurate, it combines identifiers for all supported versions\nexport const identifiers = {\n  ZodMiniOptional: tsc.identifier({ text: 'ZodMiniOptional' }),\n  ZodOptional: tsc.identifier({ text: 'ZodOptional' }),\n  _default: tsc.identifier({ text: '_default' }),\n  and: tsc.identifier({ text: 'and' }),\n  array: tsc.identifier({ text: 'array' }),\n  bigint: tsc.identifier({ text: 'bigint' }),\n  boolean: tsc.identifier({ text: 'boolean' }),\n  check: tsc.identifier({ text: 'check' }),\n  coerce: tsc.identifier({ text: 'coerce' }),\n  date: tsc.identifier({ text: 'date' }),\n  datetime: tsc.identifier({ text: 'datetime' }),\n  default: tsc.identifier({ text: 'default' }),\n  describe: tsc.identifier({ text: 'describe' }),\n  email: tsc.identifier({ text: 'email' }),\n  enum: tsc.identifier({ text: 'enum' }),\n  globalRegistry: tsc.identifier({ text: 'globalRegistry' }),\n  gt: tsc.identifier({ text: 'gt' }),\n  gte: tsc.identifier({ text: 'gte' }),\n  infer: tsc.identifier({ text: 'infer' }),\n  int: tsc.identifier({ text: 'int' }),\n  intersection: tsc.identifier({ text: 'intersection' }),\n  ip: tsc.identifier({ text: 'ip' }),\n  ipv4: tsc.identifier({ text: 'ipv4' }),\n  ipv6: tsc.identifier({ text: 'ipv6' }),\n  iso: tsc.identifier({ text: 'iso' }),\n  lazy: tsc.identifier({ text: 'lazy' }),\n  length: tsc.identifier({ text: 'length' }),\n  literal: tsc.identifier({ text: 'literal' }),\n  lt: tsc.identifier({ text: 'lt' }),\n  lte: tsc.identifier({ text: 'lte' }),\n  max: tsc.identifier({ text: 'max' }),\n  maxLength: tsc.identifier({ text: 'maxLength' }),\n  min: tsc.identifier({ text: 'min' }),\n  minLength: tsc.identifier({ text: 'minLength' }),\n  never: tsc.identifier({ text: 'never' }),\n  null: tsc.identifier({ text: 'null' }),\n  nullable: tsc.identifier({ text: 'nullable' }),\n  number: tsc.identifier({ text: 'number' }),\n  object: tsc.identifier({ text: 'object' }),\n  optional: tsc.identifier({ text: 'optional' }),\n  parseAsync: tsc.identifier({ text: 'parseAsync' }),\n  readonly: tsc.identifier({ text: 'readonly' }),\n  record: tsc.identifier({ text: 'record' }),\n  regex: tsc.identifier({ text: 'regex' }),\n  register: tsc.identifier({ text: 'register' }),\n  string: tsc.identifier({ text: 'string' }),\n  time: tsc.identifier({ text: 'time' }),\n  tuple: tsc.identifier({ text: 'tuple' }),\n  undefined: tsc.identifier({ text: 'undefined' }),\n  union: tsc.identifier({ text: 'union' }),\n  unknown: tsc.identifier({ text: 'unknown' }),\n  url: tsc.identifier({ text: 'url' }),\n  uuid: tsc.identifier({ text: 'uuid' }),\n  void: tsc.identifier({ text: 'void' }),\n};\n","import type ts from 'typescript';\n\nimport { tsc } from '~/tsc';\n\nimport { identifiers } from '../constants';\nimport type { ValidatorArgs } from '../shared/types';\n\nexport const createRequestValidatorMini = ({\n  operation,\n  plugin,\n}: ValidatorArgs): ts.ArrowFunction | undefined => {\n  const symbol = plugin.getSymbol(plugin.api.selector('data', operation.id));\n  if (!symbol) return;\n\n  const dataParameterName = 'data';\n\n  return tsc.arrowFunction({\n    async: true,\n    parameters: [\n      {\n        name: dataParameterName,\n      },\n    ],\n    statements: [\n      tsc.returnStatement({\n        expression: tsc.awaitExpression({\n          expression: tsc.callExpression({\n            functionName: tsc.propertyAccessExpression({\n              expression: symbol.placeholder,\n              name: identifiers.parseAsync,\n            }),\n            parameters: [tsc.identifier({ text: dataParameterName })],\n          }),\n        }),\n      }),\n    ],\n  });\n};\n\nexport const createResponseValidatorMini = ({\n  operation,\n  plugin,\n}: ValidatorArgs): ts.ArrowFunction | undefined => {\n  const symbol = plugin.getSymbol(\n    plugin.api.selector('responses', operation.id),\n  );\n  if (!symbol) return;\n\n  const dataParameterName = 'data';\n\n  return tsc.arrowFunction({\n    async: true,\n    parameters: [\n      {\n        name: dataParameterName,\n      },\n    ],\n    statements: [\n      tsc.returnStatement({\n        expression: tsc.awaitExpression({\n          expression: tsc.callExpression({\n            functionName: tsc.propertyAccessExpression({\n              expression: symbol.placeholder,\n              name: identifiers.parseAsync,\n            }),\n            parameters: [tsc.identifier({ text: dataParameterName })],\n          }),\n        }),\n      }),\n    ],\n  });\n};\n","import type ts from 'typescript';\n\nimport { tsc } from '~/tsc';\n\nimport { identifiers } from '../constants';\nimport type { ValidatorArgs } from '../shared/types';\n\nexport const createRequestValidatorV3 = ({\n  operation,\n  plugin,\n}: ValidatorArgs): ts.ArrowFunction | undefined => {\n  const symbol = plugin.getSymbol(plugin.api.selector('data', operation.id));\n  if (!symbol) return;\n\n  const dataParameterName = 'data';\n\n  return tsc.arrowFunction({\n    async: true,\n    parameters: [\n      {\n        name: dataParameterName,\n      },\n    ],\n    statements: [\n      tsc.returnStatement({\n        expression: tsc.awaitExpression({\n          expression: tsc.callExpression({\n            functionName: tsc.propertyAccessExpression({\n              expression: symbol.placeholder,\n              name: identifiers.parseAsync,\n            }),\n            parameters: [tsc.identifier({ text: dataParameterName })],\n          }),\n        }),\n      }),\n    ],\n  });\n};\n\nexport const createResponseValidatorV3 = ({\n  operation,\n  plugin,\n}: ValidatorArgs): ts.ArrowFunction | undefined => {\n  const symbol = plugin.getSymbol(\n    plugin.api.selector('responses', operation.id),\n  );\n  if (!symbol) return;\n\n  const dataParameterName = 'data';\n\n  return tsc.arrowFunction({\n    async: true,\n    parameters: [\n      {\n        name: dataParameterName,\n      },\n    ],\n    statements: [\n      tsc.returnStatement({\n        expression: tsc.awaitExpression({\n          expression: tsc.callExpression({\n            functionName: tsc.propertyAccessExpression({\n              expression: symbol.placeholder,\n              name: identifiers.parseAsync,\n            }),\n            parameters: [tsc.identifier({ text: dataParameterName })],\n          }),\n        }),\n      }),\n    ],\n  });\n};\n","import type ts from 'typescript';\n\nimport { tsc } from '~/tsc';\n\nimport { identifiers } from '../constants';\nimport type { ValidatorArgs } from '../shared/types';\n\nexport const createRequestValidatorV4 = ({\n  operation,\n  plugin,\n}: ValidatorArgs): ts.ArrowFunction | undefined => {\n  const symbol = plugin.getSymbol(plugin.api.selector('data', operation.id));\n  if (!symbol) return;\n\n  const dataParameterName = 'data';\n\n  return tsc.arrowFunction({\n    async: true,\n    parameters: [\n      {\n        name: dataParameterName,\n      },\n    ],\n    statements: [\n      tsc.returnStatement({\n        expression: tsc.awaitExpression({\n          expression: tsc.callExpression({\n            functionName: tsc.propertyAccessExpression({\n              expression: symbol.placeholder,\n              name: identifiers.parseAsync,\n            }),\n            parameters: [tsc.identifier({ text: dataParameterName })],\n          }),\n        }),\n      }),\n    ],\n  });\n};\n\nexport const createResponseValidatorV4 = ({\n  operation,\n  plugin,\n}: ValidatorArgs): ts.ArrowFunction | undefined => {\n  const symbol = plugin.getSymbol(\n    plugin.api.selector('responses', operation.id),\n  );\n  if (!symbol) return;\n\n  const dataParameterName = 'data';\n\n  return tsc.arrowFunction({\n    async: true,\n    parameters: [\n      {\n        name: dataParameterName,\n      },\n    ],\n    statements: [\n      tsc.returnStatement({\n        expression: tsc.awaitExpression({\n          expression: tsc.callExpression({\n            functionName: tsc.propertyAccessExpression({\n              expression: symbol.placeholder,\n              name: identifiers.parseAsync,\n            }),\n            parameters: [tsc.identifier({ text: dataParameterName })],\n          }),\n        }),\n      }),\n    ],\n  });\n};\n","import type { Selector } from '@hey-api/codegen-core';\nimport type ts from 'typescript';\n\nimport type { Plugin } from '~/plugins';\n\nimport {\n  createRequestValidatorMini,\n  createResponseValidatorMini,\n} from './mini/api';\nimport type { ValidatorArgs } from './shared/types';\nimport { createRequestValidatorV3, createResponseValidatorV3 } from './v3/api';\nimport { createRequestValidatorV4, createResponseValidatorV4 } from './v4/api';\n\ntype SelectorType =\n  | 'data'\n  | 'external'\n  | 'ref'\n  | 'responses'\n  | 'type-infer-data'\n  | 'type-infer-ref'\n  | 'type-infer-responses'\n  | 'type-infer-webhook-request'\n  | 'webhook-request';\n\nexport type IApi = {\n  createRequestValidator: (args: ValidatorArgs) => ts.ArrowFunction | undefined;\n  createResponseValidator: (\n    args: ValidatorArgs,\n  ) => ts.ArrowFunction | undefined;\n  /**\n   * @param type Selector type.\n   * @param value Depends on `type`:\n   *  - `data`: `operation.id` string\n   *  - `external`: external modules\n   *  - `ref`: `$ref` JSON pointer\n   *  - `responses`: `operation.id` string\n   *  - `type-infer-data`: `operation.id` string\n   *  - `type-infer-ref`: `$ref` JSON pointer\n   *  - `type-infer-responses`: `operation.id` string\n   *  - `type-infer-webhook-request`: `operation.id` string\n   *  - `webhook-request`: `operation.id` string\n   * @returns Selector array\n   */\n  selector: (type: SelectorType, value?: string) => Selector;\n};\n\nexport class Api implements IApi {\n  constructor(public meta: Plugin.Name<'zod'>) {}\n\n  createRequestValidator(args: ValidatorArgs): ts.ArrowFunction | undefined {\n    const { plugin } = args;\n    switch (plugin.config.compatibilityVersion) {\n      case 3:\n        return createRequestValidatorV3(args);\n      case 'mini':\n        return createRequestValidatorMini(args);\n      case 4:\n      default:\n        return createRequestValidatorV4(args);\n    }\n  }\n\n  createResponseValidator(args: ValidatorArgs): ts.ArrowFunction | undefined {\n    const { plugin } = args;\n    switch (plugin.config.compatibilityVersion) {\n      case 3:\n        return createResponseValidatorV3(args);\n      case 'mini':\n        return createResponseValidatorMini(args);\n      case 4:\n      default:\n        return createResponseValidatorV4(args);\n    }\n  }\n\n  selector(...args: ReadonlyArray<string | undefined>): Selector {\n    return [this.meta.name, ...(args as Selector)];\n  }\n}\n","import type { Symbol } from '@hey-api/codegen-core';\nimport type ts from 'typescript';\n\nimport type { IR } from '~/ir/types';\nimport { createSchemaComment } from '~/plugins/shared/utils/schema';\nimport { tsc } from '~/tsc';\n\nimport { identifiers } from '../constants';\nimport type { ZodPlugin } from '../types';\nimport type { Ast } from './types';\n\nexport const exportAst = ({\n  ast,\n  plugin,\n  schema,\n  symbol,\n  typeInferSymbol,\n}: {\n  ast: Ast;\n  plugin: ZodPlugin['Instance'];\n  schema: IR.SchemaObject;\n  symbol: Symbol;\n  typeInferSymbol: Symbol | undefined;\n}): void => {\n  const z = plugin.referenceSymbol(plugin.api.selector('external', 'zod.z'));\n\n  const statement = tsc.constVariable({\n    comment: plugin.config.comments\n      ? createSchemaComment({ schema })\n      : undefined,\n    exportConst: symbol.exported,\n    expression: ast.expression,\n    name: symbol.placeholder,\n    typeName: ast.typeName\n      ? (tsc.propertyAccessExpression({\n          expression: z.placeholder,\n          name: ast.typeName,\n        }) as unknown as ts.TypeNode)\n      : undefined,\n  });\n  plugin.setSymbolValue(symbol, statement);\n\n  if (typeInferSymbol) {\n    const inferType = tsc.typeAliasDeclaration({\n      exportType: typeInferSymbol.exported,\n      name: typeInferSymbol.placeholder,\n      type: tsc.typeReferenceNode({\n        typeArguments: [\n          tsc.typeOfExpression({\n            text: symbol.placeholder,\n          }) as unknown as ts.TypeNode,\n        ],\n        typeName: tsc.propertyAccessExpression({\n          expression: z.placeholder,\n          name: identifiers.infer,\n        }) as unknown as string,\n      }),\n    });\n    plugin.setSymbolValue(typeInferSymbol, inferType);\n  }\n};\n","import type { ZodPlugin } from '../types';\n\nexport const getZodModule = ({\n  plugin,\n}: {\n  plugin: ZodPlugin['Instance'];\n}): string => {\n  const version = plugin.package.getVersion('zod');\n\n  if (version) {\n    if (plugin.package.satisfies(version, '<4.0.0')) {\n      switch (plugin.config.compatibilityVersion) {\n        case 3:\n        default:\n          return 'zod';\n        case 4:\n          return 'zod/v4';\n        case 'mini':\n          return 'zod/v4-mini';\n      }\n    }\n  }\n\n  switch (plugin.config.compatibilityVersion) {\n    case 3:\n      return 'zod/v3';\n    case 4:\n    default:\n      return 'zod';\n    case 'mini':\n      return 'zod/mini';\n  }\n};\n","import type ts from 'typescript';\n\nimport { tsc } from '~/tsc';\n\nexport const numberParameter = ({\n  isBigInt,\n  value,\n}: {\n  isBigInt: boolean;\n  value: unknown;\n}): ts.Expression | undefined => {\n  const expression = tsc.valueToExpression({ value });\n\n  if (\n    isBigInt &&\n    (typeof value === 'bigint' ||\n      typeof value === 'number' ||\n      typeof value === 'string' ||\n      typeof value === 'boolean')\n  ) {\n    return tsc.callExpression({\n      functionName: 'BigInt',\n      parameters: [expression],\n    });\n  }\n\n  return expression;\n};\n","import { operationResponsesMap } from '~/ir/operation';\nimport type { IR } from '~/ir/types';\nimport { buildName } from '~/openApi/shared/utils/name';\n\nimport { exportAst } from './export';\nimport type { Ast, IrSchemaToAstOptions } from './types';\n\nexport const irOperationToAst = ({\n  getAst,\n  operation,\n  plugin,\n  state,\n}: IrSchemaToAstOptions & {\n  getAst: (\n    schema: IR.SchemaObject,\n    path: ReadonlyArray<string | number>,\n  ) => Ast;\n  operation: IR.OperationObject;\n}): void => {\n  if (plugin.config.requests.enabled) {\n    const requiredProperties = new Set<string>();\n\n    const schemaData: IR.SchemaObject = {\n      properties: {\n        body: {\n          type: 'never',\n        },\n        path: {\n          type: 'never',\n        },\n        query: {\n          type: 'never',\n        },\n      },\n      type: 'object',\n    };\n\n    if (operation.parameters) {\n      // TODO: add support for cookies\n\n      if (operation.parameters.header) {\n        const properties: Record<string, IR.SchemaObject> = {};\n        const required: Array<string> = [];\n\n        for (const key in operation.parameters.header) {\n          const parameter = operation.parameters.header[key]!;\n          properties[parameter.name] = parameter.schema;\n          if (parameter.required) {\n            required.push(parameter.name);\n            requiredProperties.add('headers');\n          }\n        }\n\n        if (Object.keys(properties).length) {\n          schemaData.properties!.headers = {\n            properties,\n            required,\n            type: 'object',\n          };\n        }\n      }\n\n      if (operation.parameters.path) {\n        const properties: Record<string, IR.SchemaObject> = {};\n        const required: Array<string> = [];\n\n        for (const key in operation.parameters.path) {\n          const parameter = operation.parameters.path[key]!;\n          properties[parameter.name] = parameter.schema;\n          if (parameter.required) {\n            required.push(parameter.name);\n            requiredProperties.add('path');\n          }\n        }\n\n        if (Object.keys(properties).length) {\n          schemaData.properties!.path = {\n            properties,\n            required,\n            type: 'object',\n          };\n        }\n      }\n\n      if (operation.parameters.query) {\n        const properties: Record<string, IR.SchemaObject> = {};\n        const required: Array<string> = [];\n\n        for (const key in operation.parameters.query) {\n          const parameter = operation.parameters.query[key]!;\n          properties[parameter.name] = parameter.schema;\n          if (parameter.required) {\n            required.push(parameter.name);\n            requiredProperties.add('query');\n          }\n        }\n\n        if (Object.keys(properties).length) {\n          schemaData.properties!.query = {\n            properties,\n            required,\n            type: 'object',\n          };\n        }\n      }\n    }\n\n    if (operation.body) {\n      schemaData.properties!.body = operation.body.schema;\n\n      if (operation.body.required) {\n        requiredProperties.add('body');\n      }\n    }\n\n    schemaData.required = [...requiredProperties];\n\n    const ast = getAst(schemaData, state.path.value);\n    const symbol = plugin.registerSymbol({\n      exported: true,\n      meta: {\n        path: state.path.value,\n        tags: state.tags?.value,\n      },\n      name: buildName({\n        config: plugin.config.requests,\n        name: operation.id,\n      }),\n      selector: plugin.api.selector('data', operation.id),\n    });\n    const typeInferSymbol = plugin.config.requests.types.infer.enabled\n      ? plugin.registerSymbol({\n          exported: true,\n          meta: {\n            kind: 'type',\n            path: state.path.value,\n            tags: state.tags?.value,\n          },\n          name: buildName({\n            config: plugin.config.requests.types.infer,\n            name: operation.id,\n          }),\n          selector: plugin.api.selector('type-infer-data', operation.id),\n        })\n      : undefined;\n    exportAst({\n      ast,\n      plugin,\n      schema: schemaData,\n      symbol,\n      typeInferSymbol,\n    });\n  }\n\n  if (plugin.config.responses.enabled) {\n    if (operation.responses) {\n      const { response } = operationResponsesMap(operation);\n\n      if (response) {\n        const path = [...state.path.value, 'responses'];\n        const ast = getAst(response, path);\n        const symbol = plugin.registerSymbol({\n          exported: true,\n          meta: {\n            path,\n            tags: state.tags?.value,\n          },\n          name: buildName({\n            config: plugin.config.responses,\n            name: operation.id,\n          }),\n          selector: plugin.api.selector('responses', operation.id),\n        });\n        const typeInferSymbol = plugin.config.responses.types.infer.enabled\n          ? plugin.registerSymbol({\n              exported: true,\n              meta: {\n                kind: 'type',\n                path,\n                tags: state.tags?.value,\n              },\n              name: buildName({\n                config: plugin.config.responses.types.infer,\n                name: operation.id,\n              }),\n              selector: plugin.api.selector(\n                'type-infer-responses',\n                operation.id,\n              ),\n            })\n          : undefined;\n        exportAst({\n          ast,\n          plugin,\n          schema: response,\n          symbol,\n          typeInferSymbol,\n        });\n      }\n    }\n  }\n};\n","import type { IR } from '~/ir/types';\nimport { buildName } from '~/openApi/shared/utils/name';\n\nimport { exportAst } from './export';\nimport type { Ast, IrSchemaToAstOptions } from './types';\n\nexport const irWebhookToAst = ({\n  getAst,\n  operation,\n  plugin,\n  state,\n}: IrSchemaToAstOptions & {\n  getAst: (\n    schema: IR.SchemaObject,\n    path: ReadonlyArray<string | number>,\n  ) => Ast;\n  operation: IR.OperationObject;\n}) => {\n  if (plugin.config.webhooks.enabled) {\n    const requiredProperties = new Set<string>();\n\n    const schemaData: IR.SchemaObject = {\n      properties: {\n        body: {\n          type: 'never',\n        },\n        path: {\n          type: 'never',\n        },\n        query: {\n          type: 'never',\n        },\n      },\n      type: 'object',\n    };\n\n    if (operation.parameters) {\n      // TODO: add support for cookies\n\n      if (operation.parameters.header) {\n        const properties: Record<string, IR.SchemaObject> = {};\n        const required: Array<string> = [];\n\n        for (const key in operation.parameters.header) {\n          const parameter = operation.parameters.header[key]!;\n          properties[parameter.name] = parameter.schema;\n          if (parameter.required) {\n            required.push(parameter.name);\n            requiredProperties.add('headers');\n          }\n        }\n\n        if (Object.keys(properties).length) {\n          schemaData.properties!.headers = {\n            properties,\n            required,\n            type: 'object',\n          };\n        }\n      }\n\n      if (operation.parameters.path) {\n        const properties: Record<string, IR.SchemaObject> = {};\n        const required: Array<string> = [];\n\n        for (const key in operation.parameters.path) {\n          const parameter = operation.parameters.path[key]!;\n          properties[parameter.name] = parameter.schema;\n          if (parameter.required) {\n            required.push(parameter.name);\n            requiredProperties.add('path');\n          }\n        }\n\n        if (Object.keys(properties).length) {\n          schemaData.properties!.path = {\n            properties,\n            required,\n            type: 'object',\n          };\n        }\n      }\n\n      if (operation.parameters.query) {\n        const properties: Record<string, IR.SchemaObject> = {};\n        const required: Array<string> = [];\n\n        for (const key in operation.parameters.query) {\n          const parameter = operation.parameters.query[key]!;\n          properties[parameter.name] = parameter.schema;\n          if (parameter.required) {\n            required.push(parameter.name);\n            requiredProperties.add('query');\n          }\n        }\n\n        if (Object.keys(properties).length) {\n          schemaData.properties!.query = {\n            properties,\n            required,\n            type: 'object',\n          };\n        }\n      }\n    }\n\n    if (operation.body) {\n      schemaData.properties!.body = operation.body.schema;\n\n      if (operation.body.required) {\n        requiredProperties.add('body');\n      }\n    }\n\n    schemaData.required = [...requiredProperties];\n\n    const ast = getAst(schemaData, state.path.value);\n    const symbol = plugin.registerSymbol({\n      exported: true,\n      meta: {\n        path: state.path.value,\n        tags: state.tags?.value,\n      },\n      name: buildName({\n        config: plugin.config.webhooks,\n        name: operation.id,\n      }),\n      selector: plugin.api.selector('webhook-request', operation.id),\n    });\n    const typeInferSymbol = plugin.config.webhooks.types.infer.enabled\n      ? plugin.registerSymbol({\n          exported: true,\n          meta: {\n            kind: 'type',\n            path: state.path.value,\n            tags: state.tags?.value,\n          },\n          name: buildName({\n            config: plugin.config.webhooks.types.infer,\n            name: operation.id,\n          }),\n          selector: plugin.api.selector(\n            'type-infer-webhook-request',\n            operation.id,\n          ),\n        })\n      : undefined;\n    exportAst({\n      ast,\n      plugin,\n      schema: schemaData,\n      symbol,\n      typeInferSymbol,\n    });\n  }\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { tsc } from '~/tsc';\n\nimport { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\n\nexport const unknownToAst = ({\n  plugin,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'unknown'>;\n}): Omit<Ast, 'typeName'> => {\n  const z = plugin.referenceSymbol(plugin.api.selector('external', 'zod.z'));\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n  result.expression = tsc.callExpression({\n    functionName: tsc.propertyAccessExpression({\n      expression: z.placeholder,\n      name: identifiers.unknown,\n    }),\n  });\n  return result as Omit<Ast, 'typeName'>;\n};\n","import type ts from 'typescript';\n\nimport { deduplicateSchema } from '~/ir/schema';\nimport type { SchemaWithType } from '~/plugins';\nimport { toRef } from '~/plugins/shared/utils/refs';\nimport { tsc } from '~/tsc';\n\nimport { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\nimport { irSchemaToAst } from '../plugin';\nimport { unknownToAst } from './unknown';\n\nexport const arrayToAst = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'array'>;\n}): Omit<Ast, 'typeName'> => {\n  const z = plugin.referenceSymbol(plugin.api.selector('external', 'zod.z'));\n\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n\n  const functionName = tsc.propertyAccessExpression({\n    expression: z.placeholder,\n    name: identifiers.array,\n  });\n\n  if (!schema.items) {\n    result.expression = tsc.callExpression({\n      functionName,\n      parameters: [\n        unknownToAst({\n          plugin,\n          schema: {\n            type: 'unknown',\n          },\n          state,\n        }).expression,\n      ],\n    });\n  } else {\n    schema = deduplicateSchema({ schema });\n\n    // at least one item is guaranteed\n    const itemExpressions = schema.items!.map((item, index) => {\n      const itemAst = irSchemaToAst({\n        plugin,\n        schema: item,\n        state: {\n          ...state,\n          path: toRef([...state.path.value, 'items', index]),\n        },\n      });\n      if (itemAst.hasLazyExpression) {\n        result.hasLazyExpression = true;\n      }\n      return itemAst.expression;\n    });\n\n    if (itemExpressions.length === 1) {\n      result.expression = tsc.callExpression({\n        functionName,\n        parameters: itemExpressions,\n      });\n    } else {\n      if (schema.logicalOperator === 'and') {\n        const firstSchema = schema.items![0]!;\n        // we want to add an intersection, but not every schema can use the same API.\n        // if the first item contains another array or not an object, we cannot use\n        // `.intersection()` as that does not exist on `.union()` and non-object schemas.\n        let intersectionExpression: ts.Expression;\n        if (\n          firstSchema.logicalOperator === 'or' ||\n          (firstSchema.type && firstSchema.type !== 'object')\n        ) {\n          intersectionExpression = tsc.callExpression({\n            functionName: tsc.propertyAccessExpression({\n              expression: z.placeholder,\n              name: identifiers.intersection,\n            }),\n            parameters: itemExpressions,\n          });\n        } else {\n          intersectionExpression = itemExpressions[0]!;\n          for (let i = 1; i < itemExpressions.length; i++) {\n            intersectionExpression = tsc.callExpression({\n              functionName: tsc.propertyAccessExpression({\n                expression: z.placeholder,\n                name: identifiers.intersection,\n              }),\n              parameters: [intersectionExpression, itemExpressions[i]!],\n            });\n          }\n        }\n\n        result.expression = tsc.callExpression({\n          functionName,\n          parameters: [intersectionExpression],\n        });\n      } else {\n        result.expression = tsc.callExpression({\n          functionName: tsc.propertyAccessExpression({\n            expression: z.placeholder,\n            name: identifiers.array,\n          }),\n          parameters: [\n            tsc.callExpression({\n              functionName: tsc.propertyAccessExpression({\n                expression: z.placeholder,\n                name: identifiers.union,\n              }),\n              parameters: [\n                tsc.arrayLiteralExpression({\n                  elements: itemExpressions,\n                }),\n              ],\n            }),\n          ],\n        });\n      }\n    }\n  }\n\n  const checks: Array<ts.Expression> = [];\n\n  if (schema.minItems === schema.maxItems && schema.minItems !== undefined) {\n    checks.push(\n      tsc.callExpression({\n        functionName: tsc.propertyAccessExpression({\n          expression: z.placeholder,\n          name: identifiers.length,\n        }),\n        parameters: [tsc.valueToExpression({ value: schema.minItems })],\n      }),\n    );\n  } else {\n    if (schema.minItems !== undefined) {\n      checks.push(\n        tsc.callExpression({\n          functionName: tsc.propertyAccessExpression({\n            expression: z.placeholder,\n            name: identifiers.minLength,\n          }),\n          parameters: [tsc.valueToExpression({ value: schema.minItems })],\n        }),\n      );\n    }\n\n    if (schema.maxItems !== undefined) {\n      checks.push(\n        tsc.callExpression({\n          functionName: tsc.propertyAccessExpression({\n            expression: z.placeholder,\n            name: identifiers.maxLength,\n          }),\n          parameters: [tsc.valueToExpression({ value: schema.maxItems })],\n        }),\n      );\n    }\n  }\n\n  if (checks.length) {\n    result.expression = tsc.callExpression({\n      functionName: tsc.propertyAccessExpression({\n        expression: result.expression,\n        name: identifiers.check,\n      }),\n      parameters: checks,\n    });\n  }\n\n  return result as Omit<Ast, 'typeName'>;\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { tsc } from '~/tsc';\n\nimport { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\n\nexport const booleanToAst = ({\n  plugin,\n  schema,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'boolean'>;\n}): Omit<Ast, 'typeName'> => {\n  const z = plugin.referenceSymbol(plugin.api.selector('external', 'zod.z'));\n\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n\n  if (typeof schema.const === 'boolean') {\n    result.expression = tsc.callExpression({\n      functionName: tsc.propertyAccessExpression({\n        expression: z.placeholder,\n        name: identifiers.literal,\n      }),\n      parameters: [tsc.ots.boolean(schema.const)],\n    });\n    return result as Omit<Ast, 'typeName'>;\n  }\n\n  result.expression = tsc.callExpression({\n    functionName: tsc.propertyAccessExpression({\n      expression: z.placeholder,\n      name: identifiers.boolean,\n    }),\n  });\n  return result as Omit<Ast, 'typeName'>;\n};\n","import type ts from 'typescript';\n\nimport type { SchemaWithType } from '~/plugins';\nimport { tsc } from '~/tsc';\n\nimport { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\nimport { unknownToAst } from './unknown';\n\nexport const enumToAst = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'enum'>;\n}): Omit<Ast, 'typeName'> => {\n  const z = plugin.referenceSymbol(plugin.api.selector('external', 'zod.z'));\n\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n\n  const enumMembers: Array<ts.LiteralExpression> = [];\n  const literalMembers: Array<ts.CallExpression> = [];\n\n  let isNullable = false;\n  let allStrings = true;\n\n  for (const item of schema.items ?? []) {\n    // Zod supports string, number, and boolean enums\n    if (item.type === 'string' && typeof item.const === 'string') {\n      const stringLiteral = tsc.stringLiteral({\n        text: item.const,\n      });\n      enumMembers.push(stringLiteral);\n      literalMembers.push(\n        tsc.callExpression({\n          functionName: tsc.propertyAccessExpression({\n            expression: z.placeholder,\n            name: identifiers.literal,\n          }),\n          parameters: [stringLiteral],\n        }),\n      );\n    } else if (\n      (item.type === 'number' || item.type === 'integer') &&\n      typeof item.const === 'number'\n    ) {\n      allStrings = false;\n      const numberLiteral = tsc.ots.number(item.const);\n      literalMembers.push(\n        tsc.callExpression({\n          functionName: tsc.propertyAccessExpression({\n            expression: z.placeholder,\n            name: identifiers.literal,\n          }),\n          parameters: [numberLiteral],\n        }),\n      );\n    } else if (item.type === 'boolean' && typeof item.const === 'boolean') {\n      allStrings = false;\n      const booleanLiteral = tsc.ots.boolean(item.const);\n      literalMembers.push(\n        tsc.callExpression({\n          functionName: tsc.propertyAccessExpression({\n            expression: z.placeholder,\n            name: identifiers.literal,\n          }),\n          parameters: [booleanLiteral],\n        }),\n      );\n    } else if (item.type === 'null' || item.const === null) {\n      isNullable = true;\n    }\n  }\n\n  if (!literalMembers.length) {\n    return unknownToAst({\n      plugin,\n      schema: {\n        type: 'unknown',\n      },\n      state,\n    });\n  }\n\n  // Use z.enum() for pure string enums, z.union() for mixed or non-string types\n  if (allStrings && enumMembers.length > 0) {\n    result.expression = tsc.callExpression({\n      functionName: tsc.propertyAccessExpression({\n        expression: z.placeholder,\n        name: identifiers.enum,\n      }),\n      parameters: [\n        tsc.arrayLiteralExpression({\n          elements: enumMembers,\n          multiLine: false,\n        }),\n      ],\n    });\n  } else if (literalMembers.length === 1) {\n    // For single-member unions, use the member directly instead of wrapping in z.union()\n    result.expression = literalMembers[0];\n  } else {\n    result.expression = tsc.callExpression({\n      functionName: tsc.propertyAccessExpression({\n        expression: z.placeholder,\n        name: identifiers.union,\n      }),\n      parameters: [\n        tsc.arrayLiteralExpression({\n          elements: literalMembers,\n          multiLine: literalMembers.length > 3,\n        }),\n      ],\n    });\n  }\n\n  if (isNullable) {\n    result.expression = tsc.callExpression({\n      functionName: tsc.propertyAccessExpression({\n        expression: z.placeholder,\n        name: identifiers.nullable,\n      }),\n      parameters: [result.expression],\n    });\n  }\n\n  return result as Omit<Ast, 'typeName'>;\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { tsc } from '~/tsc';\n\nimport { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\n\nexport const neverToAst = ({\n  plugin,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'never'>;\n}): Omit<Ast, 'typeName'> => {\n  const z = plugin.referenceSymbol(plugin.api.selector('external', 'zod.z'));\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n  result.expression = tsc.callExpression({\n    functionName: tsc.propertyAccessExpression({\n      expression: z.placeholder,\n      name: identifiers.never,\n    }),\n  });\n  return result as Omit<Ast, 'typeName'>;\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { tsc } from '~/tsc';\n\nimport { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\n\nexport const nullToAst = ({\n  plugin,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'null'>;\n}): Omit<Ast, 'typeName'> => {\n  const z = plugin.referenceSymbol(plugin.api.selector('external', 'zod.z'));\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n  result.expression = tsc.callExpression({\n    functionName: tsc.propertyAccessExpression({\n      expression: z.placeholder,\n      name: identifiers.null,\n    }),\n  });\n  return result as Omit<Ast, 'typeName'>;\n};\n","import type ts from 'typescript';\n\nimport type { SchemaWithType } from '~/plugins';\nimport { tsc } from '~/tsc';\n\nimport { identifiers } from '../../constants';\nimport { numberParameter } from '../../shared/numbers';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\n\nexport const numberToAst = ({\n  plugin,\n  schema,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'integer' | 'number'>;\n}): Omit<Ast, 'typeName'> => {\n  const z = plugin.referenceSymbol(plugin.api.selector('external', 'zod.z'));\n\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n\n  const isBigInt = schema.type === 'integer' && schema.format === 'int64';\n\n  if (typeof schema.const === 'number') {\n    // TODO: parser - handle bigint constants\n    result.expression = tsc.callExpression({\n      functionName: tsc.propertyAccessExpression({\n        expression: z.placeholder,\n        name: identifiers.literal,\n      }),\n      parameters: [tsc.ots.number(schema.const)],\n    });\n    return result as Omit<Ast, 'typeName'>;\n  }\n\n  result.expression = tsc.callExpression({\n    functionName: isBigInt\n      ? tsc.propertyAccessExpression({\n          expression: tsc.propertyAccessExpression({\n            expression: z.placeholder,\n            name: identifiers.coerce,\n          }),\n          name: identifiers.bigint,\n        })\n      : tsc.propertyAccessExpression({\n          expression: z.placeholder,\n          name: identifiers.number,\n        }),\n  });\n\n  if (!isBigInt && schema.type === 'integer') {\n    result.expression = tsc.callExpression({\n      functionName: tsc.propertyAccessExpression({\n        expression: z.placeholder,\n        name: identifiers.int,\n      }),\n    });\n  }\n\n  const checks: Array<ts.Expression> = [];\n\n  if (schema.exclusiveMinimum !== undefined) {\n    checks.push(\n      tsc.callExpression({\n        functionName: tsc.propertyAccessExpression({\n          expression: z.placeholder,\n          name: identifiers.gt,\n        }),\n        parameters: [\n          numberParameter({ isBigInt, value: schema.exclusiveMinimum }),\n        ],\n      }),\n    );\n  } else if (schema.minimum !== undefined) {\n    checks.push(\n      tsc.callExpression({\n        functionName: tsc.propertyAccessExpression({\n          expression: z.placeholder,\n          name: identifiers.gte,\n        }),\n        parameters: [numberParameter({ isBigInt, value: schema.minimum })],\n      }),\n    );\n  }\n\n  if (schema.exclusiveMaximum !== undefined) {\n    checks.push(\n      tsc.callExpression({\n        functionName: tsc.propertyAccessExpression({\n          expression: z.placeholder,\n          name: identifiers.lt,\n        }),\n        parameters: [\n          numberParameter({ isBigInt, value: schema.exclusiveMaximum }),\n        ],\n      }),\n    );\n  } else if (schema.maximum !== undefined) {\n    checks.push(\n      tsc.callExpression({\n        functionName: tsc.propertyAccessExpression({\n          expression: z.placeholder,\n          name: identifiers.lte,\n        }),\n        parameters: [numberParameter({ isBigInt, value: schema.maximum })],\n      }),\n    );\n  }\n\n  if (checks.length) {\n    result.expression = tsc.callExpression({\n      functionName: tsc.propertyAccessExpression({\n        expression: result.expression,\n        name: identifiers.check,\n      }),\n      parameters: checks,\n    });\n  }\n\n  return result as Omit<Ast, 'typeName'>;\n};\n","import ts from 'typescript';\n\nimport type { SchemaWithType } from '~/plugins';\nimport { toRef } from '~/plugins/shared/utils/refs';\nimport { tsc } from '~/tsc';\nimport { numberRegExp } from '~/utils/regexp';\n\nimport { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\nimport { irSchemaToAst } from '../plugin';\n\nexport const objectToAst = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'object'>;\n}): Omit<Ast, 'typeName'> => {\n  const z = plugin.referenceSymbol(plugin.api.selector('external', 'zod.z'));\n\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n\n  // TODO: parser - handle constants\n  const properties: Array<ts.PropertyAssignment | ts.GetAccessorDeclaration> =\n    [];\n\n  const required = schema.required ?? [];\n\n  for (const name in schema.properties) {\n    const property = schema.properties[name]!;\n    const isRequired = required.includes(name);\n\n    const propertyAst = irSchemaToAst({\n      optional: !isRequired,\n      plugin,\n      schema: property,\n      state: {\n        ...state,\n        path: toRef([...state.path.value, 'properties', name]),\n      },\n    });\n    if (propertyAst.hasLazyExpression) {\n      result.hasLazyExpression = true;\n    }\n\n    numberRegExp.lastIndex = 0;\n    let propertyName;\n    if (numberRegExp.test(name)) {\n      // For numeric literals, we'll handle negative numbers by using a string literal\n      // instead of trying to use a PrefixUnaryExpression\n      propertyName = name.startsWith('-')\n        ? ts.factory.createStringLiteral(name)\n        : ts.factory.createNumericLiteral(name);\n    } else {\n      propertyName = name;\n    }\n    // TODO: parser - abstract safe property name logic\n    if (\n      ((name.match(/^[0-9]/) && name.match(/\\D+/g)) || name.match(/\\W/g)) &&\n      !name.startsWith(\"'\") &&\n      !name.endsWith(\"'\")\n    ) {\n      propertyName = `'${name}'`;\n    }\n\n    if (propertyAst.hasLazyExpression) {\n      properties.push(\n        tsc.getAccessorDeclaration({\n          name: propertyName,\n          statements: [\n            tsc.returnStatement({\n              expression: propertyAst.expression,\n            }),\n          ],\n        }),\n      );\n    } else {\n      properties.push(\n        tsc.propertyAssignment({\n          initializer: propertyAst.expression,\n          name: propertyName,\n        }),\n      );\n    }\n  }\n\n  if (\n    schema.additionalProperties &&\n    (!schema.properties || !Object.keys(schema.properties).length)\n  ) {\n    const additionalAst = irSchemaToAst({\n      plugin,\n      schema: schema.additionalProperties,\n      state: {\n        ...state,\n        path: toRef([...state.path.value, 'additionalProperties']),\n      },\n    });\n    result.expression = tsc.callExpression({\n      functionName: tsc.propertyAccessExpression({\n        expression: z.placeholder,\n        name: identifiers.record,\n      }),\n      parameters: [\n        tsc.callExpression({\n          functionName: tsc.propertyAccessExpression({\n            expression: z.placeholder,\n            name: identifiers.string,\n          }),\n          parameters: [],\n        }),\n        additionalAst.expression,\n      ],\n    });\n    if (additionalAst.hasLazyExpression) {\n      result.hasLazyExpression = true;\n    }\n    return result as Omit<Ast, 'typeName'>;\n  }\n\n  result.expression = tsc.callExpression({\n    functionName: tsc.propertyAccessExpression({\n      expression: z.placeholder,\n      name: identifiers.object,\n    }),\n    parameters: [ts.factory.createObjectLiteralExpression(properties, true)],\n  });\n\n  return result as Omit<Ast, 'typeName'>;\n};\n","import type ts from 'typescript';\n\nimport type { SchemaWithType } from '~/plugins';\nimport { tsc } from '~/tsc';\n\nimport { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\n\nexport const stringToAst = ({\n  plugin,\n  schema,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'string'>;\n}): Omit<Ast, 'typeName'> => {\n  const z = plugin.referenceSymbol(plugin.api.selector('external', 'zod.z'));\n\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n\n  if (typeof schema.const === 'string') {\n    result.expression = tsc.callExpression({\n      functionName: tsc.propertyAccessExpression({\n        expression: z.placeholder,\n        name: identifiers.literal,\n      }),\n      parameters: [tsc.ots.string(schema.const)],\n    });\n    return result as Omit<Ast, 'typeName'>;\n  }\n\n  result.expression = tsc.callExpression({\n    functionName: tsc.propertyAccessExpression({\n      expression: z.placeholder,\n      name: identifiers.string,\n    }),\n  });\n\n  const dateTimeOptions: { key: string; value: boolean }[] = [];\n\n  if (plugin.config.dates.offset) {\n    dateTimeOptions.push({ key: 'offset', value: true });\n  }\n  if (plugin.config.dates.local) {\n    dateTimeOptions.push({ key: 'local', value: true });\n  }\n\n  if (schema.format) {\n    switch (schema.format) {\n      case 'date':\n        result.expression = tsc.callExpression({\n          functionName: tsc.propertyAccessExpression({\n            expression: tsc.propertyAccessExpression({\n              expression: z.placeholder,\n              name: identifiers.iso,\n            }),\n            name: identifiers.date,\n          }),\n        });\n        break;\n      case 'date-time':\n        result.expression = tsc.callExpression({\n          functionName: tsc.propertyAccessExpression({\n            expression: tsc.propertyAccessExpression({\n              expression: z.placeholder,\n              name: identifiers.iso,\n            }),\n            name: identifiers.datetime,\n          }),\n          parameters:\n            dateTimeOptions.length > 0\n              ? [\n                  tsc.objectExpression({\n                    obj: dateTimeOptions,\n                  }),\n                ]\n              : [],\n        });\n        break;\n      case 'email':\n        result.expression = tsc.callExpression({\n          functionName: tsc.propertyAccessExpression({\n            expression: z.placeholder,\n            name: identifiers.email,\n          }),\n        });\n        break;\n      case 'ipv4':\n        result.expression = tsc.callExpression({\n          functionName: tsc.propertyAccessExpression({\n            expression: z.placeholder,\n            name: identifiers.ipv4,\n          }),\n        });\n        break;\n      case 'ipv6':\n        result.expression = tsc.callExpression({\n          functionName: tsc.propertyAccessExpression({\n            expression: z.placeholder,\n            name: identifiers.ipv6,\n          }),\n        });\n        break;\n      case 'time':\n        result.expression = tsc.callExpression({\n          functionName: tsc.propertyAccessExpression({\n            expression: tsc.propertyAccessExpression({\n              expression: z.placeholder,\n              name: identifiers.iso,\n            }),\n            name: identifiers.time,\n          }),\n        });\n        break;\n      case 'uri':\n        result.expression = tsc.callExpression({\n          functionName: tsc.propertyAccessExpression({\n            expression: z.placeholder,\n            name: identifiers.url,\n          }),\n        });\n        break;\n      case 'uuid':\n        result.expression = tsc.callExpression({\n          functionName: tsc.propertyAccessExpression({\n            expression: z.placeholder,\n            name: identifiers.uuid,\n          }),\n        });\n        break;\n    }\n  }\n\n  const checks: Array<ts.Expression> = [];\n\n  if (schema.minLength === schema.maxLength && schema.minLength !== undefined) {\n    checks.push(\n      tsc.callExpression({\n        functionName: tsc.propertyAccessExpression({\n          expression: z.placeholder,\n          name: identifiers.length,\n        }),\n        parameters: [tsc.valueToExpression({ value: schema.minLength })],\n      }),\n    );\n  } else {\n    if (schema.minLength !== undefined) {\n      checks.push(\n        tsc.callExpression({\n          functionName: tsc.propertyAccessExpression({\n            expression: z.placeholder,\n            name: identifiers.minLength,\n          }),\n          parameters: [tsc.valueToExpression({ value: schema.minLength })],\n        }),\n      );\n    }\n\n    if (schema.maxLength !== undefined) {\n      checks.push(\n        tsc.callExpression({\n          functionName: tsc.propertyAccessExpression({\n            expression: z.placeholder,\n            name: identifiers.maxLength,\n          }),\n          parameters: [tsc.valueToExpression({ value: schema.maxLength })],\n        }),\n      );\n    }\n  }\n\n  if (schema.pattern) {\n    checks.push(\n      tsc.callExpression({\n        functionName: tsc.propertyAccessExpression({\n          expression: z.placeholder,\n          name: identifiers.regex,\n        }),\n        parameters: [tsc.regularExpressionLiteral({ text: schema.pattern })],\n      }),\n    );\n  }\n\n  if (checks.length) {\n    result.expression = tsc.callExpression({\n      functionName: tsc.propertyAccessExpression({\n        expression: result.expression,\n        name: identifiers.check,\n      }),\n      parameters: checks,\n    });\n  }\n\n  return result as Omit<Ast, 'typeName'>;\n};\n","import type ts from 'typescript';\n\nimport type { SchemaWithType } from '~/plugins';\nimport { toRef } from '~/plugins/shared/utils/refs';\nimport { tsc } from '~/tsc';\n\nimport { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\nimport { irSchemaToAst } from '../plugin';\n\nexport const tupleToAst = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'tuple'>;\n}): Omit<Ast, 'typeName'> => {\n  const z = plugin.referenceSymbol(plugin.api.selector('external', 'zod.z'));\n\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n\n  if (schema.const && Array.isArray(schema.const)) {\n    const tupleElements = schema.const.map((value) =>\n      tsc.callExpression({\n        functionName: tsc.propertyAccessExpression({\n          expression: z.placeholder,\n          name: identifiers.literal,\n        }),\n        parameters: [tsc.valueToExpression({ value })],\n      }),\n    );\n    result.expression = tsc.callExpression({\n      functionName: tsc.propertyAccessExpression({\n        expression: z.placeholder,\n        name: identifiers.tuple,\n      }),\n      parameters: [\n        tsc.arrayLiteralExpression({\n          elements: tupleElements,\n        }),\n      ],\n    });\n    return result as Omit<Ast, 'typeName'>;\n  }\n\n  const tupleElements: Array<ts.Expression> = [];\n\n  if (schema.items) {\n    schema.items.forEach((item, index) => {\n      const itemSchema = irSchemaToAst({\n        plugin,\n        schema: item,\n        state: {\n          ...state,\n          path: toRef([...state.path.value, 'items', index]),\n        },\n      });\n      tupleElements.push(itemSchema.expression);\n      if (itemSchema.hasLazyExpression) {\n        result.hasLazyExpression = true;\n      }\n    });\n  }\n\n  result.expression = tsc.callExpression({\n    functionName: tsc.propertyAccessExpression({\n      expression: z.placeholder,\n      name: identifiers.tuple,\n    }),\n    parameters: [\n      tsc.arrayLiteralExpression({\n        elements: tupleElements,\n      }),\n    ],\n  });\n\n  return result as Omit<Ast, 'typeName'>;\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { tsc } from '~/tsc';\n\nimport { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\n\nexport const undefinedToAst = ({\n  plugin,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'undefined'>;\n}): Omit<Ast, 'typeName'> => {\n  const z = plugin.referenceSymbol(plugin.api.selector('external', 'zod.z'));\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n  result.expression = tsc.callExpression({\n    functionName: tsc.propertyAccessExpression({\n      expression: z.placeholder,\n      name: identifiers.undefined,\n    }),\n  });\n  return result as Omit<Ast, 'typeName'>;\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { tsc } from '~/tsc';\n\nimport { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\n\nexport const voidToAst = ({\n  plugin,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'void'>;\n}): Omit<Ast, 'typeName'> => {\n  const z = plugin.referenceSymbol(plugin.api.selector('external', 'zod.z'));\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n  result.expression = tsc.callExpression({\n    functionName: tsc.propertyAccessExpression({\n      expression: z.placeholder,\n      name: identifiers.void,\n    }),\n  });\n  return result as Omit<Ast, 'typeName'>;\n};\n","import type { SchemaWithType } from '~/plugins';\n\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\nimport { arrayToAst } from './array';\nimport { booleanToAst } from './boolean';\nimport { enumToAst } from './enum';\nimport { neverToAst } from './never';\nimport { nullToAst } from './null';\nimport { numberToAst } from './number';\nimport { objectToAst } from './object';\nimport { stringToAst } from './string';\nimport { tupleToAst } from './tuple';\nimport { undefinedToAst } from './undefined';\nimport { unknownToAst } from './unknown';\nimport { voidToAst } from './void';\n\nexport const irSchemaWithTypeToAst = ({\n  schema,\n  ...args\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType;\n}): Omit<Ast, 'typeName'> => {\n  switch (schema.type) {\n    case 'array':\n      return arrayToAst({\n        ...args,\n        schema: schema as SchemaWithType<'array'>,\n      });\n    case 'boolean':\n      return booleanToAst({\n        ...args,\n        schema: schema as SchemaWithType<'boolean'>,\n      });\n    case 'enum':\n      return enumToAst({\n        ...args,\n        schema: schema as SchemaWithType<'enum'>,\n      });\n    case 'integer':\n    case 'number':\n      return numberToAst({\n        ...args,\n        schema: schema as SchemaWithType<'integer' | 'number'>,\n      });\n    case 'never':\n      return neverToAst({\n        ...args,\n        schema: schema as SchemaWithType<'never'>,\n      });\n    case 'null':\n      return nullToAst({\n        ...args,\n        schema: schema as SchemaWithType<'null'>,\n      });\n    case 'object':\n      return objectToAst({\n        ...args,\n        schema: schema as SchemaWithType<'object'>,\n      });\n    case 'string':\n      return stringToAst({\n        ...args,\n        schema: schema as SchemaWithType<'string'>,\n      });\n    case 'tuple':\n      return tupleToAst({\n        ...args,\n        schema: schema as SchemaWithType<'tuple'>,\n      });\n    case 'undefined':\n      return undefinedToAst({\n        ...args,\n        schema: schema as SchemaWithType<'undefined'>,\n      });\n    case 'unknown':\n      return unknownToAst({\n        ...args,\n        schema: schema as SchemaWithType<'unknown'>,\n      });\n    case 'void':\n      return voidToAst({\n        ...args,\n        schema: schema as SchemaWithType<'void'>,\n      });\n  }\n};\n","import { deduplicateSchema } from '~/ir/schema';\nimport type { IR } from '~/ir/types';\nimport { buildName } from '~/openApi/shared/utils/name';\nimport type { SchemaWithType } from '~/plugins';\nimport { toRef, toRefs } from '~/plugins/shared/utils/refs';\nimport { tsc } from '~/tsc';\nimport { pathToJsonPointer, refToName } from '~/utils/ref';\n\nimport { identifiers } from '../constants';\nimport { exportAst } from '../shared/export';\nimport { getZodModule } from '../shared/module';\nimport { numberParameter } from '../shared/numbers';\nimport { irOperationToAst } from '../shared/operation';\nimport type { Ast, IrSchemaToAstOptions, PluginState } from '../shared/types';\nimport { irWebhookToAst } from '../shared/webhook';\nimport type { ZodPlugin } from '../types';\nimport { irSchemaWithTypeToAst } from './toAst';\n\nexport const irSchemaToAst = ({\n  optional,\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  /**\n   * Accept `optional` to handle optional object properties. We can't handle\n   * this inside the object function because `.optional()` must come before\n   * `.default()` which is handled in this function.\n   */\n  optional?: boolean;\n  schema: IR.SchemaObject;\n}): Ast => {\n  let ast: Partial<Ast> = {};\n\n  const z = plugin.referenceSymbol(plugin.api.selector('external', 'zod.z'));\n\n  if (schema.$ref) {\n    const selector = plugin.api.selector('ref', schema.$ref);\n    const refSymbol = plugin.referenceSymbol(selector);\n    if (plugin.isSymbolRegistered(selector)) {\n      const ref = tsc.identifier({ text: refSymbol.placeholder });\n      ast.expression = ref;\n    } else {\n      const lazyExpression = tsc.callExpression({\n        functionName: tsc.propertyAccessExpression({\n          expression: z.placeholder,\n          name: identifiers.lazy,\n        }),\n        parameters: [\n          tsc.arrowFunction({\n            returnType: tsc.keywordTypeNode({ keyword: 'any' }),\n            statements: [\n              tsc.returnStatement({\n                expression: tsc.identifier({ text: refSymbol.placeholder }),\n              }),\n            ],\n          }),\n        ],\n      });\n      ast.expression = lazyExpression;\n      ast.hasLazyExpression = true;\n      state.hasLazyExpression.value = true;\n    }\n  } else if (schema.type) {\n    const typeAst = irSchemaWithTypeToAst({\n      plugin,\n      schema: schema as SchemaWithType,\n      state,\n    });\n    ast.expression = typeAst.expression;\n    ast.hasLazyExpression = typeAst.hasLazyExpression;\n\n    if (plugin.config.metadata && schema.description) {\n      ast.expression = tsc.callExpression({\n        functionName: tsc.propertyAccessExpression({\n          expression: ast.expression,\n          name: identifiers.register,\n        }),\n        parameters: [\n          tsc.propertyAccessExpression({\n            expression: z.placeholder,\n            name: identifiers.globalRegistry,\n          }),\n          tsc.objectExpression({\n            obj: [\n              {\n                key: 'description',\n                value: tsc.stringLiteral({ text: schema.description }),\n              },\n            ],\n          }),\n        ],\n      });\n    }\n  } else if (schema.items) {\n    schema = deduplicateSchema({ schema });\n\n    if (schema.items) {\n      const itemSchemas = schema.items.map((item, index) =>\n        irSchemaToAst({\n          plugin,\n          schema: item,\n          state: {\n            ...state,\n            path: toRef([...state.path.value, 'items', index]),\n          },\n        }),\n      );\n\n      if (schema.logicalOperator === 'and') {\n        const firstSchema = schema.items[0]!;\n        // we want to add an intersection, but not every schema can use the same API.\n        // if the first item contains another array or not an object, we cannot use\n        // `.merge()` as that does not exist on `.union()` and non-object schemas.\n        if (\n          firstSchema.logicalOperator === 'or' ||\n          (firstSchema.type && firstSchema.type !== 'object')\n        ) {\n          ast.expression = tsc.callExpression({\n            functionName: tsc.propertyAccessExpression({\n              expression: z.placeholder,\n              name: identifiers.intersection,\n            }),\n            parameters: itemSchemas.map((schema) => schema.expression),\n          });\n        } else {\n          ast.expression = itemSchemas[0]!.expression;\n          itemSchemas.slice(1).forEach((schema) => {\n            ast.expression = tsc.callExpression({\n              functionName: tsc.propertyAccessExpression({\n                expression: z.placeholder,\n                name: identifiers.intersection,\n              }),\n              parameters: [\n                ast.expression,\n                schema.hasLazyExpression\n                  ? tsc.callExpression({\n                      functionName: tsc.propertyAccessExpression({\n                        expression: z.placeholder,\n                        name: identifiers.lazy,\n                      }),\n                      parameters: [\n                        tsc.arrowFunction({\n                          statements: [\n                            tsc.returnStatement({\n                              expression: schema.expression,\n                            }),\n                          ],\n                        }),\n                      ],\n                    })\n                  : schema.expression,\n              ],\n            });\n          });\n        }\n      } else {\n        ast.expression = tsc.callExpression({\n          functionName: tsc.propertyAccessExpression({\n            expression: z.placeholder,\n            name: identifiers.union,\n          }),\n          parameters: [\n            tsc.arrayLiteralExpression({\n              elements: itemSchemas.map((schema) => schema.expression),\n            }),\n          ],\n        });\n      }\n    } else {\n      ast = irSchemaToAst({ plugin, schema, state });\n    }\n  } else {\n    // catch-all fallback for failed schemas\n    const typeAst = irSchemaWithTypeToAst({\n      plugin,\n      schema: {\n        type: 'unknown',\n      },\n      state,\n    });\n    ast.expression = typeAst.expression;\n  }\n\n  if (ast.expression) {\n    if (schema.accessScope === 'read') {\n      ast.expression = tsc.callExpression({\n        functionName: tsc.propertyAccessExpression({\n          expression: z.placeholder,\n          name: identifiers.readonly,\n        }),\n        parameters: [ast.expression],\n      });\n    }\n\n    if (optional) {\n      ast.expression = tsc.callExpression({\n        functionName: tsc.propertyAccessExpression({\n          expression: z.placeholder,\n          name: identifiers.optional,\n        }),\n        parameters: [ast.expression],\n      });\n      ast.typeName = identifiers.ZodMiniOptional;\n    }\n\n    if (schema.default !== undefined) {\n      const isBigInt = schema.type === 'integer' && schema.format === 'int64';\n      const callParameter = numberParameter({\n        isBigInt,\n        value: schema.default,\n      });\n      if (callParameter) {\n        ast.expression = tsc.callExpression({\n          functionName: tsc.propertyAccessExpression({\n            expression: z.placeholder,\n            name: identifiers._default,\n          }),\n          parameters: [ast.expression, callParameter],\n        });\n      }\n    }\n  }\n\n  return ast as Ast;\n};\n\nconst handleComponent = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: IR.SchemaObject;\n}): void => {\n  const $ref = pathToJsonPointer(state.path.value);\n  const ast = irSchemaToAst({ plugin, schema, state });\n  const baseName = refToName($ref);\n  const symbol = plugin.registerSymbol({\n    exported: true,\n    meta: {\n      path: state.path.value,\n      tags: state.tags?.value,\n    },\n    name: buildName({\n      config: plugin.config.definitions,\n      name: baseName,\n    }),\n    selector: plugin.api.selector('ref', $ref),\n  });\n  const typeInferSymbol = plugin.config.definitions.types.infer.enabled\n    ? plugin.registerSymbol({\n        exported: true,\n        meta: {\n          kind: 'type',\n          path: state.path.value,\n          tags: state.tags?.value,\n        },\n        name: buildName({\n          config: plugin.config.definitions.types.infer,\n          name: baseName,\n        }),\n        selector: plugin.api.selector('type-infer-ref', $ref),\n      })\n    : undefined;\n  exportAst({\n    ast,\n    plugin,\n    schema,\n    symbol,\n    typeInferSymbol,\n  });\n};\n\nexport const handlerMini: ZodPlugin['Handler'] = ({ plugin }) => {\n  plugin.registerSymbol({\n    external: getZodModule({ plugin }),\n    meta: { importKind: 'namespace' },\n    name: 'z',\n    selector: plugin.api.selector('external', 'zod.z'),\n  });\n\n  plugin.forEach(\n    'operation',\n    'parameter',\n    'requestBody',\n    'schema',\n    'webhook',\n    (event) => {\n      const state = toRefs<PluginState>({\n        hasLazyExpression: false,\n        path: event._path,\n        tags: event.tags,\n      });\n      switch (event.type) {\n        case 'operation':\n          irOperationToAst({\n            getAst: (schema, path) => {\n              const state = toRefs<PluginState>({\n                hasLazyExpression: false,\n                path,\n                tags: event.tags,\n              });\n              return irSchemaToAst({ plugin, schema, state });\n            },\n            operation: event.operation,\n            plugin,\n            state,\n          });\n          break;\n        case 'parameter':\n          handleComponent({\n            plugin,\n            schema: event.parameter.schema,\n            state,\n          });\n          break;\n        case 'requestBody':\n          handleComponent({\n            plugin,\n            schema: event.requestBody.schema,\n            state,\n          });\n          break;\n        case 'schema':\n          handleComponent({\n            plugin,\n            schema: event.schema,\n            state,\n          });\n          break;\n        case 'webhook':\n          irWebhookToAst({\n            getAst: (schema, path) => {\n              const state = toRefs<PluginState>({\n                hasLazyExpression: false,\n                path,\n                tags: event.tags,\n              });\n              return irSchemaToAst({ plugin, schema, state });\n            },\n            operation: event.operation,\n            plugin,\n            state,\n          });\n          break;\n      }\n    },\n  );\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { tsc } from '~/tsc';\n\nimport { identifiers } from '../../constants';\nimport type { IrSchemaToAstOptions } from '../../shared/types';\n\nexport const unknownToAst = ({\n  plugin,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'unknown'>;\n}) => {\n  const z = plugin.referenceSymbol(plugin.api.selector('external', 'zod.z'));\n  const expression = tsc.callExpression({\n    functionName: tsc.propertyAccessExpression({\n      expression: z.placeholder,\n      name: identifiers.unknown,\n    }),\n  });\n  return expression;\n};\n","import type ts from 'typescript';\n\nimport { deduplicateSchema } from '~/ir/schema';\nimport type { SchemaWithType } from '~/plugins';\nimport { toRef } from '~/plugins/shared/utils/refs';\nimport { tsc } from '~/tsc';\n\nimport { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\nimport { irSchemaToAst } from '../plugin';\nimport { unknownToAst } from './unknown';\n\nexport const arrayToAst = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'array'>;\n}): Omit<Ast, 'typeName'> & {\n  anyType?: string;\n} => {\n  const z = plugin.referenceSymbol(plugin.api.selector('external', 'zod.z'));\n\n  const functionName = tsc.propertyAccessExpression({\n    expression: z.placeholder,\n    name: identifiers.array,\n  });\n\n  let arrayExpression: ts.CallExpression | undefined;\n  let hasLazyExpression = false;\n\n  if (!schema.items) {\n    arrayExpression = tsc.callExpression({\n      functionName,\n      parameters: [\n        unknownToAst({\n          plugin,\n          schema: {\n            type: 'unknown',\n          },\n          state,\n        }),\n      ],\n    });\n  } else {\n    schema = deduplicateSchema({ schema });\n\n    // at least one item is guaranteed\n    const itemExpressions = schema.items!.map((item, index) => {\n      const itemAst = irSchemaToAst({\n        plugin,\n        schema: item,\n        state: {\n          ...state,\n          path: toRef([...state.path.value, 'items', index]),\n        },\n      });\n      if (itemAst.hasLazyExpression) {\n        hasLazyExpression = true;\n      }\n      return itemAst.expression;\n    });\n\n    if (itemExpressions.length === 1) {\n      arrayExpression = tsc.callExpression({\n        functionName,\n        parameters: itemExpressions,\n      });\n    } else {\n      if (schema.logicalOperator === 'and') {\n        const firstSchema = schema.items![0]!;\n        // we want to add an intersection, but not every schema can use the same API.\n        // if the first item contains another array or not an object, we cannot use\n        // `.and()` as that does not exist on `.union()` and non-object schemas.\n        let intersectionExpression: ts.Expression;\n        if (\n          firstSchema.logicalOperator === 'or' ||\n          (firstSchema.type && firstSchema.type !== 'object')\n        ) {\n          intersectionExpression = tsc.callExpression({\n            functionName: tsc.propertyAccessExpression({\n              expression: z.placeholder,\n              name: identifiers.intersection,\n            }),\n            parameters: itemExpressions,\n          });\n        } else {\n          intersectionExpression = itemExpressions[0]!;\n          for (let i = 1; i < itemExpressions.length; i++) {\n            intersectionExpression = tsc.callExpression({\n              functionName: tsc.propertyAccessExpression({\n                expression: intersectionExpression,\n                name: identifiers.and,\n              }),\n              parameters: [itemExpressions[i]!],\n            });\n          }\n        }\n\n        arrayExpression = tsc.callExpression({\n          functionName,\n          parameters: [intersectionExpression],\n        });\n      } else {\n        arrayExpression = tsc.callExpression({\n          functionName: tsc.propertyAccessExpression({\n            expression: z.placeholder,\n            name: identifiers.array,\n          }),\n          parameters: [\n            tsc.callExpression({\n              functionName: tsc.propertyAccessExpression({\n                expression: z.placeholder,\n                name: identifiers.union,\n              }),\n              parameters: [\n                tsc.arrayLiteralExpression({\n                  elements: itemExpressions,\n                }),\n              ],\n            }),\n          ],\n        });\n      }\n    }\n  }\n\n  if (schema.minItems === schema.maxItems && schema.minItems !== undefined) {\n    arrayExpression = tsc.callExpression({\n      functionName: tsc.propertyAccessExpression({\n        expression: arrayExpression,\n        name: identifiers.length,\n      }),\n      parameters: [tsc.valueToExpression({ value: schema.minItems })],\n    });\n  } else {\n    if (schema.minItems !== undefined) {\n      arrayExpression = tsc.callExpression({\n        functionName: tsc.propertyAccessExpression({\n          expression: arrayExpression,\n          name: identifiers.min,\n        }),\n        parameters: [tsc.valueToExpression({ value: schema.minItems })],\n      });\n    }\n\n    if (schema.maxItems !== undefined) {\n      arrayExpression = tsc.callExpression({\n        functionName: tsc.propertyAccessExpression({\n          expression: arrayExpression,\n          name: identifiers.max,\n        }),\n        parameters: [tsc.valueToExpression({ value: schema.maxItems })],\n      });\n    }\n  }\n\n  return {\n    expression: arrayExpression,\n    hasLazyExpression,\n  };\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { tsc } from '~/tsc';\n\nimport { identifiers } from '../../constants';\nimport type { IrSchemaToAstOptions } from '../../shared/types';\n\nexport const booleanToAst = ({\n  plugin,\n  schema,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'boolean'>;\n}) => {\n  const z = plugin.referenceSymbol(plugin.api.selector('external', 'zod.z'));\n\n  if (typeof schema.const === 'boolean') {\n    const expression = tsc.callExpression({\n      functionName: tsc.propertyAccessExpression({\n        expression: z.placeholder,\n        name: identifiers.literal,\n      }),\n      parameters: [tsc.ots.boolean(schema.const)],\n    });\n    return expression;\n  }\n\n  const expression = tsc.callExpression({\n    functionName: tsc.propertyAccessExpression({\n      expression: z.placeholder,\n      name: identifiers.boolean,\n    }),\n  });\n  return expression;\n};\n","import type ts from 'typescript';\n\nimport type { SchemaWithType } from '~/plugins';\nimport { tsc } from '~/tsc';\n\nimport { identifiers } from '../../constants';\nimport type { IrSchemaToAstOptions } from '../../shared/types';\nimport { unknownToAst } from './unknown';\n\nexport const enumToAst = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'enum'>;\n}): ts.CallExpression => {\n  const z = plugin.referenceSymbol(plugin.api.selector('external', 'zod.z'));\n\n  const enumMembers: Array<ts.LiteralExpression> = [];\n  const literalMembers: Array<ts.CallExpression> = [];\n\n  let isNullable = false;\n  let allStrings = true;\n\n  for (const item of schema.items ?? []) {\n    // Zod supports string, number, and boolean enums\n    if (item.type === 'string' && typeof item.const === 'string') {\n      const stringLiteral = tsc.stringLiteral({\n        text: item.const,\n      });\n      enumMembers.push(stringLiteral);\n      literalMembers.push(\n        tsc.callExpression({\n          functionName: tsc.propertyAccessExpression({\n            expression: z.placeholder,\n            name: identifiers.literal,\n          }),\n          parameters: [stringLiteral],\n        }),\n      );\n    } else if (\n      (item.type === 'number' || item.type === 'integer') &&\n      typeof item.const === 'number'\n    ) {\n      allStrings = false;\n      const numberLiteral = tsc.ots.number(item.const);\n      literalMembers.push(\n        tsc.callExpression({\n          functionName: tsc.propertyAccessExpression({\n            expression: z.placeholder,\n            name: identifiers.literal,\n          }),\n          parameters: [numberLiteral],\n        }),\n      );\n    } else if (item.type === 'boolean' && typeof item.const === 'boolean') {\n      allStrings = false;\n      const booleanLiteral = tsc.ots.boolean(item.const);\n      literalMembers.push(\n        tsc.callExpression({\n          functionName: tsc.propertyAccessExpression({\n            expression: z.placeholder,\n            name: identifiers.literal,\n          }),\n          parameters: [booleanLiteral],\n        }),\n      );\n    } else if (item.type === 'null' || item.const === null) {\n      isNullable = true;\n    }\n  }\n\n  if (!literalMembers.length) {\n    return unknownToAst({\n      plugin,\n      schema: {\n        type: 'unknown',\n      },\n      state,\n    });\n  }\n\n  // Use z.enum() for pure string enums, z.union() for mixed or non-string types\n  let enumExpression: ts.CallExpression;\n  if (allStrings && enumMembers.length > 0) {\n    enumExpression = tsc.callExpression({\n      functionName: tsc.propertyAccessExpression({\n        expression: z.placeholder,\n        name: identifiers.enum,\n      }),\n      parameters: [\n        tsc.arrayLiteralExpression({\n          elements: enumMembers,\n          multiLine: false,\n        }),\n      ],\n    });\n  } else if (literalMembers.length === 1) {\n    // For single-member unions, use the member directly instead of wrapping in z.union()\n    enumExpression = literalMembers[0]!;\n  } else {\n    enumExpression = tsc.callExpression({\n      functionName: tsc.propertyAccessExpression({\n        expression: z.placeholder,\n        name: identifiers.union,\n      }),\n      parameters: [\n        tsc.arrayLiteralExpression({\n          elements: literalMembers,\n          multiLine: literalMembers.length > 3,\n        }),\n      ],\n    });\n  }\n\n  if (isNullable) {\n    enumExpression = tsc.callExpression({\n      functionName: tsc.propertyAccessExpression({\n        expression: enumExpression,\n        name: identifiers.nullable,\n      }),\n    });\n  }\n\n  return enumExpression;\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { tsc } from '~/tsc';\n\nimport { identifiers } from '../../constants';\nimport type { IrSchemaToAstOptions } from '../../shared/types';\n\nexport const neverToAst = ({\n  plugin,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'never'>;\n}) => {\n  const z = plugin.referenceSymbol(plugin.api.selector('external', 'zod.z'));\n  const expression = tsc.callExpression({\n    functionName: tsc.propertyAccessExpression({\n      expression: z.placeholder,\n      name: identifiers.never,\n    }),\n  });\n  return expression;\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { tsc } from '~/tsc';\n\nimport { identifiers } from '../../constants';\nimport type { IrSchemaToAstOptions } from '../../shared/types';\n\nexport const nullToAst = ({\n  plugin,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'null'>;\n}) => {\n  const z = plugin.referenceSymbol(plugin.api.selector('external', 'zod.z'));\n  const expression = tsc.callExpression({\n    functionName: tsc.propertyAccessExpression({\n      expression: z.placeholder,\n      name: identifiers.null,\n    }),\n  });\n  return expression;\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { tsc } from '~/tsc';\n\nimport { identifiers } from '../../constants';\nimport { numberParameter } from '../../shared/numbers';\nimport type { IrSchemaToAstOptions } from '../../shared/types';\n\nexport const numberToAst = ({\n  plugin,\n  schema,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'integer' | 'number'>;\n}) => {\n  const z = plugin.referenceSymbol(plugin.api.selector('external', 'zod.z'));\n\n  const isBigInt = schema.type === 'integer' && schema.format === 'int64';\n\n  if (typeof schema.const === 'number') {\n    // TODO: parser - handle bigint constants\n    const expression = tsc.callExpression({\n      functionName: tsc.propertyAccessExpression({\n        expression: z.placeholder,\n        name: identifiers.literal,\n      }),\n      parameters: [tsc.ots.number(schema.const)],\n    });\n    return expression;\n  }\n\n  let numberExpression = tsc.callExpression({\n    functionName: isBigInt\n      ? tsc.propertyAccessExpression({\n          expression: tsc.propertyAccessExpression({\n            expression: z.placeholder,\n            name: identifiers.coerce,\n          }),\n          name: identifiers.bigint,\n        })\n      : tsc.propertyAccessExpression({\n          expression: z.placeholder,\n          name: identifiers.number,\n        }),\n  });\n\n  if (!isBigInt && schema.type === 'integer') {\n    numberExpression = tsc.callExpression({\n      functionName: tsc.propertyAccessExpression({\n        expression: numberExpression,\n        name: identifiers.int,\n      }),\n    });\n  }\n\n  if (schema.exclusiveMinimum !== undefined) {\n    numberExpression = tsc.callExpression({\n      functionName: tsc.propertyAccessExpression({\n        expression: numberExpression,\n        name: identifiers.gt,\n      }),\n      parameters: [\n        numberParameter({ isBigInt, value: schema.exclusiveMinimum }),\n      ],\n    });\n  } else if (schema.minimum !== undefined) {\n    numberExpression = tsc.callExpression({\n      functionName: tsc.propertyAccessExpression({\n        expression: numberExpression,\n        name: identifiers.gte,\n      }),\n      parameters: [numberParameter({ isBigInt, value: schema.minimum })],\n    });\n  }\n\n  if (schema.exclusiveMaximum !== undefined) {\n    numberExpression = tsc.callExpression({\n      functionName: tsc.propertyAccessExpression({\n        expression: numberExpression,\n        name: identifiers.lt,\n      }),\n      parameters: [\n        numberParameter({ isBigInt, value: schema.exclusiveMaximum }),\n      ],\n    });\n  } else if (schema.maximum !== undefined) {\n    numberExpression = tsc.callExpression({\n      functionName: tsc.propertyAccessExpression({\n        expression: numberExpression,\n        name: identifiers.lte,\n      }),\n      parameters: [numberParameter({ isBigInt, value: schema.maximum })],\n    });\n  }\n\n  return numberExpression;\n};\n","import ts from 'typescript';\n\nimport type { SchemaWithType } from '~/plugins';\nimport { toRef } from '~/plugins/shared/utils/refs';\nimport { tsc } from '~/tsc';\nimport { numberRegExp } from '~/utils/regexp';\n\nimport { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\nimport { irSchemaToAst } from '../plugin';\n\nexport const objectToAst = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'object'>;\n}): Omit<Ast, 'typeName'> & {\n  anyType?: string;\n} => {\n  const z = plugin.referenceSymbol(plugin.api.selector('external', 'zod.z'));\n\n  let hasLazyExpression = false;\n\n  // TODO: parser - handle constants\n  const properties: Array<ts.PropertyAssignment> = [];\n\n  const required = schema.required ?? [];\n\n  for (const name in schema.properties) {\n    const property = schema.properties[name]!;\n    const isRequired = required.includes(name);\n\n    const propertyExpression = irSchemaToAst({\n      optional: !isRequired,\n      plugin,\n      schema: property,\n      state: {\n        ...state,\n        path: toRef([...state.path.value, 'properties', name]),\n      },\n    });\n\n    if (propertyExpression.hasLazyExpression) {\n      hasLazyExpression = true;\n    }\n\n    numberRegExp.lastIndex = 0;\n    let propertyName;\n    if (numberRegExp.test(name)) {\n      // For numeric literals, we'll handle negative numbers by using a string literal\n      // instead of trying to use a PrefixUnaryExpression\n      propertyName = name.startsWith('-')\n        ? ts.factory.createStringLiteral(name)\n        : ts.factory.createNumericLiteral(name);\n    } else {\n      propertyName = name;\n    }\n    // TODO: parser - abstract safe property name logic\n    if (\n      ((name.match(/^[0-9]/) && name.match(/\\D+/g)) || name.match(/\\W/g)) &&\n      !name.startsWith(\"'\") &&\n      !name.endsWith(\"'\")\n    ) {\n      propertyName = `'${name}'`;\n    }\n    properties.push(\n      tsc.propertyAssignment({\n        initializer: propertyExpression.expression,\n        name: propertyName,\n      }),\n    );\n  }\n\n  if (\n    schema.additionalProperties &&\n    (!schema.properties || !Object.keys(schema.properties).length)\n  ) {\n    const additionalAst = irSchemaToAst({\n      plugin,\n      schema: schema.additionalProperties,\n      state: {\n        ...state,\n        path: toRef([...state.path.value, 'additionalProperties']),\n      },\n    });\n    const expression = tsc.callExpression({\n      functionName: tsc.propertyAccessExpression({\n        expression: z.placeholder,\n        name: identifiers.record,\n      }),\n      parameters: [additionalAst.expression],\n    });\n    return {\n      anyType: 'AnyZodObject',\n      expression,\n      hasLazyExpression: additionalAst.hasLazyExpression,\n    };\n  }\n\n  const expression = tsc.callExpression({\n    functionName: tsc.propertyAccessExpression({\n      expression: z.placeholder,\n      name: identifiers.object,\n    }),\n    parameters: [ts.factory.createObjectLiteralExpression(properties, true)],\n  });\n  return {\n    anyType: 'AnyZodObject',\n    expression,\n    hasLazyExpression,\n  };\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { tsc } from '~/tsc';\n\nimport { identifiers } from '../../constants';\nimport type { IrSchemaToAstOptions } from '../../shared/types';\n\nexport const stringToAst = ({\n  plugin,\n  schema,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'string'>;\n}) => {\n  const z = plugin.referenceSymbol(plugin.api.selector('external', 'zod.z'));\n\n  if (typeof schema.const === 'string') {\n    const expression = tsc.callExpression({\n      functionName: tsc.propertyAccessExpression({\n        expression: z.placeholder,\n        name: identifiers.literal,\n      }),\n      parameters: [tsc.ots.string(schema.const)],\n    });\n    return expression;\n  }\n\n  let stringExpression = tsc.callExpression({\n    functionName: tsc.propertyAccessExpression({\n      expression: z.placeholder,\n      name: identifiers.string,\n    }),\n  });\n\n  const dateTimeOptions: { key: string; value: boolean }[] = [];\n\n  if (plugin.config.dates.offset) {\n    dateTimeOptions.push({ key: 'offset', value: true });\n  }\n  if (plugin.config.dates.local) {\n    dateTimeOptions.push({ key: 'local', value: true });\n  }\n\n  if (schema.format) {\n    switch (schema.format) {\n      case 'date':\n        stringExpression = tsc.callExpression({\n          functionName: tsc.propertyAccessExpression({\n            expression: stringExpression,\n            name: identifiers.date,\n          }),\n        });\n        break;\n      case 'date-time':\n        stringExpression = tsc.callExpression({\n          functionName: tsc.propertyAccessExpression({\n            expression: stringExpression,\n            name: identifiers.datetime,\n          }),\n          parameters:\n            dateTimeOptions.length > 0\n              ? [\n                  tsc.objectExpression({\n                    obj: dateTimeOptions,\n                  }),\n                ]\n              : [],\n        });\n        break;\n      case 'email':\n        stringExpression = tsc.callExpression({\n          functionName: tsc.propertyAccessExpression({\n            expression: stringExpression,\n            name: identifiers.email,\n          }),\n        });\n        break;\n      case 'ipv4':\n      case 'ipv6':\n        stringExpression = tsc.callExpression({\n          functionName: tsc.propertyAccessExpression({\n            expression: stringExpression,\n            name: identifiers.ip,\n          }),\n        });\n        break;\n      case 'time':\n        stringExpression = tsc.callExpression({\n          functionName: tsc.propertyAccessExpression({\n            expression: stringExpression,\n            name: identifiers.time,\n          }),\n        });\n        break;\n      case 'uri':\n        stringExpression = tsc.callExpression({\n          functionName: tsc.propertyAccessExpression({\n            expression: stringExpression,\n            name: identifiers.url,\n          }),\n        });\n        break;\n      case 'uuid':\n        stringExpression = tsc.callExpression({\n          functionName: tsc.propertyAccessExpression({\n            expression: stringExpression,\n            name: identifiers.uuid,\n          }),\n        });\n        break;\n    }\n  }\n\n  if (schema.minLength === schema.maxLength && schema.minLength !== undefined) {\n    stringExpression = tsc.callExpression({\n      functionName: tsc.propertyAccessExpression({\n        expression: stringExpression,\n        name: identifiers.length,\n      }),\n      parameters: [tsc.valueToExpression({ value: schema.minLength })],\n    });\n  } else {\n    if (schema.minLength !== undefined) {\n      stringExpression = tsc.callExpression({\n        functionName: tsc.propertyAccessExpression({\n          expression: stringExpression,\n          name: identifiers.min,\n        }),\n        parameters: [tsc.valueToExpression({ value: schema.minLength })],\n      });\n    }\n\n    if (schema.maxLength !== undefined) {\n      stringExpression = tsc.callExpression({\n        functionName: tsc.propertyAccessExpression({\n          expression: stringExpression,\n          name: identifiers.max,\n        }),\n        parameters: [tsc.valueToExpression({ value: schema.maxLength })],\n      });\n    }\n  }\n\n  if (schema.pattern) {\n    stringExpression = tsc.callExpression({\n      functionName: tsc.propertyAccessExpression({\n        expression: stringExpression,\n        name: identifiers.regex,\n      }),\n      parameters: [tsc.regularExpressionLiteral({ text: schema.pattern })],\n    });\n  }\n\n  return stringExpression;\n};\n","import type ts from 'typescript';\n\nimport type { SchemaWithType } from '~/plugins';\nimport { toRef } from '~/plugins/shared/utils/refs';\nimport { tsc } from '~/tsc';\n\nimport { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\nimport { irSchemaToAst } from '../plugin';\n\nexport const tupleToAst = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'tuple'>;\n}): Omit<Ast, 'typeName'> & {\n  anyType?: string;\n} => {\n  const z = plugin.referenceSymbol(plugin.api.selector('external', 'zod.z'));\n\n  let hasLazyExpression = false;\n\n  if (schema.const && Array.isArray(schema.const)) {\n    const tupleElements = schema.const.map((value) =>\n      tsc.callExpression({\n        functionName: tsc.propertyAccessExpression({\n          expression: z.placeholder,\n          name: identifiers.literal,\n        }),\n        parameters: [tsc.valueToExpression({ value })],\n      }),\n    );\n    const expression = tsc.callExpression({\n      functionName: tsc.propertyAccessExpression({\n        expression: z.placeholder,\n        name: identifiers.tuple,\n      }),\n      parameters: [\n        tsc.arrayLiteralExpression({\n          elements: tupleElements,\n        }),\n      ],\n    });\n    return {\n      expression,\n      hasLazyExpression,\n    };\n  }\n\n  const tupleElements: Array<ts.Expression> = [];\n\n  if (schema.items) {\n    schema.items.forEach((item, index) => {\n      const itemSchema = irSchemaToAst({\n        plugin,\n        schema: item,\n        state: {\n          ...state,\n          path: toRef([...state.path.value, 'items', index]),\n        },\n      });\n      tupleElements.push(itemSchema.expression);\n      if (itemSchema.hasLazyExpression) {\n        hasLazyExpression = true;\n      }\n    });\n  }\n\n  const expression = tsc.callExpression({\n    functionName: tsc.propertyAccessExpression({\n      expression: z.placeholder,\n      name: identifiers.tuple,\n    }),\n    parameters: [\n      tsc.arrayLiteralExpression({\n        elements: tupleElements,\n      }),\n    ],\n  });\n  return {\n    expression,\n    hasLazyExpression,\n  };\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { tsc } from '~/tsc';\n\nimport { identifiers } from '../../constants';\nimport type { IrSchemaToAstOptions } from '../../shared/types';\n\nexport const undefinedToAst = ({\n  plugin,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'undefined'>;\n}) => {\n  const z = plugin.referenceSymbol(plugin.api.selector('external', 'zod.z'));\n  const expression = tsc.callExpression({\n    functionName: tsc.propertyAccessExpression({\n      expression: z.placeholder,\n      name: identifiers.undefined,\n    }),\n  });\n  return expression;\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { tsc } from '~/tsc';\n\nimport { identifiers } from '../../constants';\nimport type { IrSchemaToAstOptions } from '../../shared/types';\n\nexport const voidToAst = ({\n  plugin,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'void'>;\n}) => {\n  const z = plugin.referenceSymbol(plugin.api.selector('external', 'zod.z'));\n  const expression = tsc.callExpression({\n    functionName: tsc.propertyAccessExpression({\n      expression: z.placeholder,\n      name: identifiers.void,\n    }),\n  });\n  return expression;\n};\n","import type { SchemaWithType } from '~/plugins';\n\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\nimport { arrayToAst } from './array';\nimport { booleanToAst } from './boolean';\nimport { enumToAst } from './enum';\nimport { neverToAst } from './never';\nimport { nullToAst } from './null';\nimport { numberToAst } from './number';\nimport { objectToAst } from './object';\nimport { stringToAst } from './string';\nimport { tupleToAst } from './tuple';\nimport { undefinedToAst } from './undefined';\nimport { unknownToAst } from './unknown';\nimport { voidToAst } from './void';\n\nexport const irSchemaWithTypeToAst = ({\n  schema,\n  ...args\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType;\n}): Omit<Ast, 'typeName'> & {\n  anyType?: string;\n} => {\n  switch (schema.type) {\n    case 'array':\n      return arrayToAst({\n        ...args,\n        schema: schema as SchemaWithType<'array'>,\n      });\n    case 'boolean':\n      return {\n        expression: booleanToAst({\n          ...args,\n          schema: schema as SchemaWithType<'boolean'>,\n        }),\n      };\n    case 'enum':\n      return {\n        expression: enumToAst({\n          ...args,\n          schema: schema as SchemaWithType<'enum'>,\n        }),\n      };\n    case 'integer':\n    case 'number':\n      return {\n        expression: numberToAst({\n          ...args,\n          schema: schema as SchemaWithType<'integer' | 'number'>,\n        }),\n      };\n    case 'never':\n      return {\n        expression: neverToAst({\n          ...args,\n          schema: schema as SchemaWithType<'never'>,\n        }),\n      };\n    case 'null':\n      return {\n        expression: nullToAst({\n          ...args,\n          schema: schema as SchemaWithType<'null'>,\n        }),\n      };\n    case 'object':\n      return objectToAst({\n        ...args,\n        schema: schema as SchemaWithType<'object'>,\n      });\n    case 'string':\n      return {\n        expression: stringToAst({\n          ...args,\n          schema: schema as SchemaWithType<'string'>,\n        }),\n      };\n    case 'tuple':\n      return tupleToAst({\n        ...args,\n        schema: schema as SchemaWithType<'tuple'>,\n      });\n    case 'undefined':\n      return {\n        expression: undefinedToAst({\n          ...args,\n          schema: schema as SchemaWithType<'undefined'>,\n        }),\n      };\n    case 'unknown':\n      return {\n        expression: unknownToAst({\n          ...args,\n          schema: schema as SchemaWithType<'unknown'>,\n        }),\n      };\n    case 'void':\n      return {\n        expression: voidToAst({\n          ...args,\n          schema: schema as SchemaWithType<'void'>,\n        }),\n      };\n  }\n};\n","import { deduplicateSchema } from '~/ir/schema';\nimport type { IR } from '~/ir/types';\nimport { buildName } from '~/openApi/shared/utils/name';\nimport type { SchemaWithType } from '~/plugins';\nimport { toRef, toRefs } from '~/plugins/shared/utils/refs';\nimport { tsc } from '~/tsc';\nimport { pathToJsonPointer, refToName } from '~/utils/ref';\n\nimport { identifiers } from '../constants';\nimport { exportAst } from '../shared/export';\nimport { getZodModule } from '../shared/module';\nimport { numberParameter } from '../shared/numbers';\nimport { irOperationToAst } from '../shared/operation';\nimport type { Ast, IrSchemaToAstOptions, PluginState } from '../shared/types';\nimport { irWebhookToAst } from '../shared/webhook';\nimport type { ZodPlugin } from '../types';\nimport { irSchemaWithTypeToAst } from './toAst';\n\nexport const irSchemaToAst = ({\n  optional,\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  /**\n   * Accept `optional` to handle optional object properties. We can't handle\n   * this inside the object function because `.optional()` must come before\n   * `.default()` which is handled in this function.\n   */\n  optional?: boolean;\n  schema: IR.SchemaObject;\n}): Ast => {\n  let ast: Partial<Ast> = {};\n\n  const z = plugin.referenceSymbol(plugin.api.selector('external', 'zod.z'));\n\n  if (schema.$ref) {\n    const selector = plugin.api.selector('ref', schema.$ref);\n    const refSymbol = plugin.referenceSymbol(selector);\n    if (plugin.isSymbolRegistered(selector)) {\n      const ref = tsc.identifier({ text: refSymbol.placeholder });\n      ast.expression = ref;\n    } else {\n      const lazyExpression = tsc.callExpression({\n        functionName: tsc.propertyAccessExpression({\n          expression: z.placeholder,\n          name: identifiers.lazy,\n        }),\n        parameters: [\n          tsc.arrowFunction({\n            statements: [\n              tsc.returnStatement({\n                expression: tsc.identifier({ text: refSymbol.placeholder }),\n              }),\n            ],\n          }),\n        ],\n      });\n      ast.expression = lazyExpression;\n      ast.hasLazyExpression = true;\n      state.hasLazyExpression.value = true;\n    }\n  } else if (schema.type) {\n    const typeAst = irSchemaWithTypeToAst({\n      plugin,\n      schema: schema as SchemaWithType,\n      state,\n    });\n    ast.expression = typeAst.expression;\n    ast.typeName = typeAst.anyType;\n\n    if (plugin.config.metadata && schema.description) {\n      ast.expression = tsc.callExpression({\n        functionName: tsc.propertyAccessExpression({\n          expression: ast.expression,\n          name: identifiers.describe,\n        }),\n        parameters: [tsc.stringLiteral({ text: schema.description })],\n      });\n    }\n  } else if (schema.items) {\n    schema = deduplicateSchema({ schema });\n\n    if (schema.items) {\n      const itemTypes = schema.items.map((item, index) => {\n        const typeAst = irSchemaToAst({\n          plugin,\n          schema: item,\n          state: {\n            ...state,\n            path: toRef([...state.path.value, 'items', index]),\n          },\n        });\n        return typeAst.expression;\n      });\n\n      if (schema.logicalOperator === 'and') {\n        const firstSchema = schema.items[0]!;\n        // we want to add an intersection, but not every schema can use the same API.\n        // if the first item contains another array or not an object, we cannot use\n        // `.merge()` as that does not exist on `.union()` and non-object schemas.\n        if (\n          firstSchema.logicalOperator === 'or' ||\n          (firstSchema.type && firstSchema.type !== 'object')\n        ) {\n          ast.expression = tsc.callExpression({\n            functionName: tsc.propertyAccessExpression({\n              expression: z.placeholder,\n              name: identifiers.intersection,\n            }),\n            parameters: itemTypes,\n          });\n        } else {\n          ast.expression = itemTypes[0];\n          itemTypes.slice(1).forEach((item) => {\n            ast.expression = tsc.callExpression({\n              functionName: tsc.propertyAccessExpression({\n                expression: ast.expression!,\n                name: identifiers.and,\n              }),\n              parameters: [item],\n            });\n          });\n        }\n      } else {\n        ast.expression = tsc.callExpression({\n          functionName: tsc.propertyAccessExpression({\n            expression: z.placeholder,\n            name: identifiers.union,\n          }),\n          parameters: [\n            tsc.arrayLiteralExpression({\n              elements: itemTypes,\n            }),\n          ],\n        });\n      }\n    } else {\n      ast = irSchemaToAst({ plugin, schema, state });\n    }\n  } else {\n    // catch-all fallback for failed schemas\n    const typeAst = irSchemaWithTypeToAst({\n      plugin,\n      schema: {\n        type: 'unknown',\n      },\n      state,\n    });\n    ast.expression = typeAst.expression;\n    ast.typeName = typeAst.anyType;\n  }\n\n  if (ast.expression) {\n    if (schema.accessScope === 'read') {\n      ast.expression = tsc.callExpression({\n        functionName: tsc.propertyAccessExpression({\n          expression: ast.expression,\n          name: identifiers.readonly,\n        }),\n      });\n    }\n\n    if (optional) {\n      ast.expression = tsc.callExpression({\n        functionName: tsc.propertyAccessExpression({\n          expression: ast.expression,\n          name: identifiers.optional,\n        }),\n      });\n    }\n\n    if (schema.default !== undefined) {\n      const isBigInt = schema.type === 'integer' && schema.format === 'int64';\n      const callParameter = numberParameter({\n        isBigInt,\n        value: schema.default,\n      });\n      if (callParameter) {\n        ast.expression = tsc.callExpression({\n          functionName: tsc.propertyAccessExpression({\n            expression: ast.expression,\n            name: identifiers.default,\n          }),\n          parameters: [callParameter],\n        });\n      }\n    }\n  }\n\n  if (state.hasLazyExpression.value) {\n    if (!ast.typeName) {\n      ast.typeName = 'ZodTypeAny';\n    }\n  } else if (ast.typeName) {\n    ast.typeName = undefined;\n  }\n\n  return ast as Ast;\n};\n\nconst handleComponent = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: IR.SchemaObject;\n}): void => {\n  const $ref = pathToJsonPointer(state.path.value);\n  const ast = irSchemaToAst({ plugin, schema, state });\n  const baseName = refToName($ref);\n  const symbol = plugin.registerSymbol({\n    exported: true,\n    meta: {\n      path: state.path.value,\n      tags: state.tags?.value,\n    },\n    name: buildName({\n      config: plugin.config.definitions,\n      name: baseName,\n    }),\n    selector: plugin.api.selector('ref', $ref),\n  });\n  const typeInferSymbol = plugin.config.definitions.types.infer.enabled\n    ? plugin.registerSymbol({\n        exported: true,\n        meta: {\n          kind: 'type',\n          path: state.path.value,\n          tags: state.tags?.value,\n        },\n        name: buildName({\n          config: plugin.config.definitions.types.infer,\n          name: baseName,\n        }),\n        selector: plugin.api.selector('type-infer-ref', $ref),\n      })\n    : undefined;\n  exportAst({\n    ast,\n    plugin,\n    schema,\n    symbol,\n    typeInferSymbol,\n  });\n};\n\nexport const handlerV3: ZodPlugin['Handler'] = ({ plugin }) => {\n  plugin.registerSymbol({\n    external: getZodModule({ plugin }),\n    name: 'z',\n    selector: plugin.api.selector('external', 'zod.z'),\n  });\n\n  plugin.forEach(\n    'operation',\n    'parameter',\n    'requestBody',\n    'schema',\n    'webhook',\n    (event) => {\n      const state = toRefs<PluginState>({\n        hasLazyExpression: false,\n        path: event._path,\n        tags: event.tags,\n      });\n      switch (event.type) {\n        case 'operation':\n          irOperationToAst({\n            getAst: (schema, path) => {\n              const state = toRefs<PluginState>({\n                hasLazyExpression: false,\n                path,\n                tags: event.tags,\n              });\n              return irSchemaToAst({ plugin, schema, state });\n            },\n            operation: event.operation,\n            plugin,\n            state,\n          });\n          break;\n        case 'parameter':\n          handleComponent({\n            plugin,\n            schema: event.parameter.schema,\n            state,\n          });\n          break;\n        case 'requestBody':\n          handleComponent({\n            plugin,\n            schema: event.requestBody.schema,\n            state,\n          });\n          break;\n        case 'schema':\n          handleComponent({\n            plugin,\n            schema: event.schema,\n            state,\n          });\n          break;\n        case 'webhook':\n          irWebhookToAst({\n            getAst: (schema, path) => {\n              const state = toRefs<PluginState>({\n                hasLazyExpression: false,\n                path,\n                tags: event.tags,\n              });\n              return irSchemaToAst({ plugin, schema, state });\n            },\n            operation: event.operation,\n            plugin,\n            state,\n          });\n          break;\n      }\n    },\n  );\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { tsc } from '~/tsc';\n\nimport { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\n\nexport const unknownToAst = ({\n  plugin,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'unknown'>;\n}): Omit<Ast, 'typeName'> => {\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n  const z = plugin.referenceSymbol(plugin.api.selector('external', 'zod.z'));\n  result.expression = tsc.callExpression({\n    functionName: tsc.propertyAccessExpression({\n      expression: z.placeholder,\n      name: identifiers.unknown,\n    }),\n  });\n  return result as Omit<Ast, 'typeName'>;\n};\n","import type ts from 'typescript';\n\nimport { deduplicateSchema } from '~/ir/schema';\nimport type { SchemaWithType } from '~/plugins';\nimport { toRef } from '~/plugins/shared/utils/refs';\nimport { tsc } from '~/tsc';\n\nimport { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\nimport { irSchemaToAst } from '../plugin';\nimport { unknownToAst } from './unknown';\n\nexport const arrayToAst = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'array'>;\n}): Omit<Ast, 'typeName'> => {\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n\n  const z = plugin.referenceSymbol(plugin.api.selector('external', 'zod.z'));\n\n  const functionName = tsc.propertyAccessExpression({\n    expression: z.placeholder,\n    name: identifiers.array,\n  });\n\n  if (!schema.items) {\n    result.expression = tsc.callExpression({\n      functionName,\n      parameters: [\n        unknownToAst({\n          plugin,\n          schema: {\n            type: 'unknown',\n          },\n          state,\n        }).expression,\n      ],\n    });\n  } else {\n    schema = deduplicateSchema({ schema });\n\n    // at least one item is guaranteed\n    const itemExpressions = schema.items!.map((item, index) => {\n      const itemAst = irSchemaToAst({\n        plugin,\n        schema: item,\n        state: {\n          ...state,\n          path: toRef([...state.path.value, 'items', index]),\n        },\n      });\n      if (itemAst.hasLazyExpression) {\n        result.hasLazyExpression = true;\n      }\n      return itemAst.expression;\n    });\n\n    if (itemExpressions.length === 1) {\n      result.expression = tsc.callExpression({\n        functionName,\n        parameters: itemExpressions,\n      });\n    } else {\n      if (schema.logicalOperator === 'and') {\n        const firstSchema = schema.items![0]!;\n        // we want to add an intersection, but not every schema can use the same API.\n        // if the first item contains another array or not an object, we cannot use\n        // `.and()` as that does not exist on `.union()` and non-object schemas.\n        let intersectionExpression: ts.Expression;\n        if (\n          firstSchema.logicalOperator === 'or' ||\n          (firstSchema.type && firstSchema.type !== 'object')\n        ) {\n          intersectionExpression = tsc.callExpression({\n            functionName: tsc.propertyAccessExpression({\n              expression: z.placeholder,\n              name: identifiers.intersection,\n            }),\n            parameters: itemExpressions,\n          });\n        } else {\n          intersectionExpression = itemExpressions[0]!;\n          for (let i = 1; i < itemExpressions.length; i++) {\n            intersectionExpression = tsc.callExpression({\n              functionName: tsc.propertyAccessExpression({\n                expression: intersectionExpression,\n                name: identifiers.and,\n              }),\n              parameters: [itemExpressions[i]!],\n            });\n          }\n        }\n\n        result.expression = tsc.callExpression({\n          functionName,\n          parameters: [intersectionExpression],\n        });\n      } else {\n        result.expression = tsc.callExpression({\n          functionName: tsc.propertyAccessExpression({\n            expression: z.placeholder,\n            name: identifiers.array,\n          }),\n          parameters: [\n            tsc.callExpression({\n              functionName: tsc.propertyAccessExpression({\n                expression: z.placeholder,\n                name: identifiers.union,\n              }),\n              parameters: [\n                tsc.arrayLiteralExpression({\n                  elements: itemExpressions,\n                }),\n              ],\n            }),\n          ],\n        });\n      }\n    }\n  }\n\n  if (schema.minItems === schema.maxItems && schema.minItems !== undefined) {\n    result.expression = tsc.callExpression({\n      functionName: tsc.propertyAccessExpression({\n        expression: result.expression,\n        name: identifiers.length,\n      }),\n      parameters: [tsc.valueToExpression({ value: schema.minItems })],\n    });\n  } else {\n    if (schema.minItems !== undefined) {\n      result.expression = tsc.callExpression({\n        functionName: tsc.propertyAccessExpression({\n          expression: result.expression,\n          name: identifiers.min,\n        }),\n        parameters: [tsc.valueToExpression({ value: schema.minItems })],\n      });\n    }\n\n    if (schema.maxItems !== undefined) {\n      result.expression = tsc.callExpression({\n        functionName: tsc.propertyAccessExpression({\n          expression: result.expression,\n          name: identifiers.max,\n        }),\n        parameters: [tsc.valueToExpression({ value: schema.maxItems })],\n      });\n    }\n  }\n\n  return result as Omit<Ast, 'typeName'>;\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { tsc } from '~/tsc';\n\nimport { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\n\nexport const booleanToAst = ({\n  plugin,\n  schema,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'boolean'>;\n}): Omit<Ast, 'typeName'> => {\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n\n  const z = plugin.referenceSymbol(plugin.api.selector('external', 'zod.z'));\n\n  if (typeof schema.const === 'boolean') {\n    result.expression = tsc.callExpression({\n      functionName: tsc.propertyAccessExpression({\n        expression: z.placeholder,\n        name: identifiers.literal,\n      }),\n      parameters: [tsc.ots.boolean(schema.const)],\n    });\n    return result as Omit<Ast, 'typeName'>;\n  }\n\n  result.expression = tsc.callExpression({\n    functionName: tsc.propertyAccessExpression({\n      expression: z.placeholder,\n      name: identifiers.boolean,\n    }),\n  });\n  return result as Omit<Ast, 'typeName'>;\n};\n","import type ts from 'typescript';\n\nimport type { SchemaWithType } from '~/plugins';\nimport { tsc } from '~/tsc';\n\nimport { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\nimport { unknownToAst } from './unknown';\n\nexport const enumToAst = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'enum'>;\n}): Omit<Ast, 'typeName'> => {\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n\n  const z = plugin.referenceSymbol(plugin.api.selector('external', 'zod.z'));\n\n  const enumMembers: Array<ts.LiteralExpression> = [];\n  const literalMembers: Array<ts.CallExpression> = [];\n\n  let isNullable = false;\n  let allStrings = true;\n\n  for (const item of schema.items ?? []) {\n    // Zod supports string, number, and boolean enums\n    if (item.type === 'string' && typeof item.const === 'string') {\n      const stringLiteral = tsc.stringLiteral({\n        text: item.const,\n      });\n      enumMembers.push(stringLiteral);\n      literalMembers.push(\n        tsc.callExpression({\n          functionName: tsc.propertyAccessExpression({\n            expression: z.placeholder,\n            name: identifiers.literal,\n          }),\n          parameters: [stringLiteral],\n        }),\n      );\n    } else if (\n      (item.type === 'number' || item.type === 'integer') &&\n      typeof item.const === 'number'\n    ) {\n      allStrings = false;\n      const numberLiteral = tsc.ots.number(item.const);\n      literalMembers.push(\n        tsc.callExpression({\n          functionName: tsc.propertyAccessExpression({\n            expression: z.placeholder,\n            name: identifiers.literal,\n          }),\n          parameters: [numberLiteral],\n        }),\n      );\n    } else if (item.type === 'boolean' && typeof item.const === 'boolean') {\n      allStrings = false;\n      const booleanLiteral = tsc.ots.boolean(item.const);\n      literalMembers.push(\n        tsc.callExpression({\n          functionName: tsc.propertyAccessExpression({\n            expression: z.placeholder,\n            name: identifiers.literal,\n          }),\n          parameters: [booleanLiteral],\n        }),\n      );\n    } else if (item.type === 'null' || item.const === null) {\n      isNullable = true;\n    }\n  }\n\n  if (!literalMembers.length) {\n    return unknownToAst({\n      plugin,\n      schema: {\n        type: 'unknown',\n      },\n      state,\n    });\n  }\n\n  // Use z.enum() for pure string enums, z.union() for mixed or non-string types\n  if (allStrings && enumMembers.length > 0) {\n    result.expression = tsc.callExpression({\n      functionName: tsc.propertyAccessExpression({\n        expression: z.placeholder,\n        name: identifiers.enum,\n      }),\n      parameters: [\n        tsc.arrayLiteralExpression({\n          elements: enumMembers,\n          multiLine: false,\n        }),\n      ],\n    });\n  } else if (literalMembers.length === 1) {\n    // For single-member unions, use the member directly instead of wrapping in z.union()\n    result.expression = literalMembers[0];\n  } else {\n    result.expression = tsc.callExpression({\n      functionName: tsc.propertyAccessExpression({\n        expression: z.placeholder,\n        name: identifiers.union,\n      }),\n      parameters: [\n        tsc.arrayLiteralExpression({\n          elements: literalMembers,\n          multiLine: literalMembers.length > 3,\n        }),\n      ],\n    });\n  }\n\n  if (isNullable) {\n    result.expression = tsc.callExpression({\n      functionName: tsc.propertyAccessExpression({\n        expression: z.placeholder,\n        name: identifiers.nullable,\n      }),\n      parameters: [result.expression],\n    });\n  }\n\n  return result as Omit<Ast, 'typeName'>;\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { tsc } from '~/tsc';\n\nimport { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\n\nexport const neverToAst = ({\n  plugin,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'never'>;\n}): Omit<Ast, 'typeName'> => {\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n  const z = plugin.referenceSymbol(plugin.api.selector('external', 'zod.z'));\n  result.expression = tsc.callExpression({\n    functionName: tsc.propertyAccessExpression({\n      expression: z.placeholder,\n      name: identifiers.never,\n    }),\n  });\n  return result as Omit<Ast, 'typeName'>;\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { tsc } from '~/tsc';\n\nimport { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\n\nexport const nullToAst = ({\n  plugin,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'null'>;\n}): Omit<Ast, 'typeName'> => {\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n  const z = plugin.referenceSymbol(plugin.api.selector('external', 'zod.z'));\n  result.expression = tsc.callExpression({\n    functionName: tsc.propertyAccessExpression({\n      expression: z.placeholder,\n      name: identifiers.null,\n    }),\n  });\n  return result as Omit<Ast, 'typeName'>;\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { tsc } from '~/tsc';\n\nimport { identifiers } from '../../constants';\nimport { numberParameter } from '../../shared/numbers';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\n\nexport const numberToAst = ({\n  plugin,\n  schema,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'integer' | 'number'>;\n}): Omit<Ast, 'typeName'> => {\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n\n  const isBigInt = schema.type === 'integer' && schema.format === 'int64';\n\n  const z = plugin.referenceSymbol(plugin.api.selector('external', 'zod.z'));\n\n  if (typeof schema.const === 'number') {\n    // TODO: parser - handle bigint constants\n    result.expression = tsc.callExpression({\n      functionName: tsc.propertyAccessExpression({\n        expression: z.placeholder,\n        name: identifiers.literal,\n      }),\n      parameters: [tsc.ots.number(schema.const)],\n    });\n    return result as Omit<Ast, 'typeName'>;\n  }\n\n  result.expression = tsc.callExpression({\n    functionName: isBigInt\n      ? tsc.propertyAccessExpression({\n          expression: tsc.propertyAccessExpression({\n            expression: z.placeholder,\n            name: identifiers.coerce,\n          }),\n          name: identifiers.bigint,\n        })\n      : tsc.propertyAccessExpression({\n          expression: z.placeholder,\n          name: identifiers.number,\n        }),\n  });\n\n  if (!isBigInt && schema.type === 'integer') {\n    result.expression = tsc.callExpression({\n      functionName: tsc.propertyAccessExpression({\n        expression: z.placeholder,\n        name: identifiers.int,\n      }),\n    });\n  }\n\n  if (schema.exclusiveMinimum !== undefined) {\n    result.expression = tsc.callExpression({\n      functionName: tsc.propertyAccessExpression({\n        expression: result.expression,\n        name: identifiers.gt,\n      }),\n      parameters: [\n        numberParameter({ isBigInt, value: schema.exclusiveMinimum }),\n      ],\n    });\n  } else if (schema.minimum !== undefined) {\n    result.expression = tsc.callExpression({\n      functionName: tsc.propertyAccessExpression({\n        expression: result.expression,\n        name: identifiers.gte,\n      }),\n      parameters: [numberParameter({ isBigInt, value: schema.minimum })],\n    });\n  }\n\n  if (schema.exclusiveMaximum !== undefined) {\n    result.expression = tsc.callExpression({\n      functionName: tsc.propertyAccessExpression({\n        expression: result.expression,\n        name: identifiers.lt,\n      }),\n      parameters: [\n        numberParameter({ isBigInt, value: schema.exclusiveMaximum }),\n      ],\n    });\n  } else if (schema.maximum !== undefined) {\n    result.expression = tsc.callExpression({\n      functionName: tsc.propertyAccessExpression({\n        expression: result.expression,\n        name: identifiers.lte,\n      }),\n      parameters: [numberParameter({ isBigInt, value: schema.maximum })],\n    });\n  }\n\n  return result as Omit<Ast, 'typeName'>;\n};\n","import ts from 'typescript';\n\nimport type { SchemaWithType } from '~/plugins';\nimport { toRef } from '~/plugins/shared/utils/refs';\nimport { tsc } from '~/tsc';\nimport { numberRegExp } from '~/utils/regexp';\n\nimport { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\nimport { irSchemaToAst } from '../plugin';\n\nexport const objectToAst = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'object'>;\n}): Omit<Ast, 'typeName'> => {\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n\n  // TODO: parser - handle constants\n  const properties: Array<ts.PropertyAssignment | ts.GetAccessorDeclaration> =\n    [];\n\n  const required = schema.required ?? [];\n\n  const z = plugin.referenceSymbol(plugin.api.selector('external', 'zod.z'));\n\n  for (const name in schema.properties) {\n    const property = schema.properties[name]!;\n    const isRequired = required.includes(name);\n\n    const propertyAst = irSchemaToAst({\n      optional: !isRequired,\n      plugin,\n      schema: property,\n      state: {\n        ...state,\n        path: toRef([...state.path.value, 'properties', name]),\n      },\n    });\n    if (propertyAst.hasLazyExpression) {\n      result.hasLazyExpression = true;\n    }\n\n    numberRegExp.lastIndex = 0;\n    let propertyName;\n    if (numberRegExp.test(name)) {\n      // For numeric literals, we'll handle negative numbers by using a string literal\n      // instead of trying to use a PrefixUnaryExpression\n      propertyName = name.startsWith('-')\n        ? ts.factory.createStringLiteral(name)\n        : ts.factory.createNumericLiteral(name);\n    } else {\n      propertyName = name;\n    }\n    // TODO: parser - abstract safe property name logic\n    if (\n      ((name.match(/^[0-9]/) && name.match(/\\D+/g)) || name.match(/\\W/g)) &&\n      !name.startsWith(\"'\") &&\n      !name.endsWith(\"'\")\n    ) {\n      propertyName = `'${name}'`;\n    }\n\n    if (propertyAst.hasLazyExpression) {\n      properties.push(\n        tsc.getAccessorDeclaration({\n          name: propertyName,\n          statements: [\n            tsc.returnStatement({\n              expression: propertyAst.expression,\n            }),\n          ],\n        }),\n      );\n    } else {\n      properties.push(\n        tsc.propertyAssignment({\n          initializer: propertyAst.expression,\n          name: propertyName,\n        }),\n      );\n    }\n  }\n\n  if (\n    schema.additionalProperties &&\n    (!schema.properties || !Object.keys(schema.properties).length)\n  ) {\n    const additionalAst = irSchemaToAst({\n      plugin,\n      schema: schema.additionalProperties,\n      state: {\n        ...state,\n        path: toRef([...state.path.value, 'additionalProperties']),\n      },\n    });\n    result.expression = tsc.callExpression({\n      functionName: tsc.propertyAccessExpression({\n        expression: z.placeholder,\n        name: identifiers.record,\n      }),\n      parameters: [\n        tsc.callExpression({\n          functionName: tsc.propertyAccessExpression({\n            expression: z.placeholder,\n            name: identifiers.string,\n          }),\n          parameters: [],\n        }),\n        additionalAst.expression,\n      ],\n    });\n    if (additionalAst.hasLazyExpression) {\n      result.hasLazyExpression = true;\n    }\n\n    // Return with typeName for circular references\n    if (result.hasLazyExpression) {\n      return {\n        ...result,\n        typeName: 'ZodType',\n      } as Ast;\n    }\n\n    return result as Omit<Ast, 'typeName'>;\n  }\n\n  result.expression = tsc.callExpression({\n    functionName: tsc.propertyAccessExpression({\n      expression: z.placeholder,\n      name: identifiers.object,\n    }),\n    parameters: [ts.factory.createObjectLiteralExpression(properties, true)],\n  });\n\n  // Return with typeName for circular references (AnyZodObject doesn't exist in Zod v4, use ZodType)\n  if (result.hasLazyExpression) {\n    return {\n      ...result,\n      typeName: 'ZodType',\n    } as Ast;\n  }\n\n  return result as Omit<Ast, 'typeName'>;\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { tsc } from '~/tsc';\n\nimport { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\n\nexport const stringToAst = ({\n  plugin,\n  schema,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'string'>;\n}): Omit<Ast, 'typeName'> => {\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n\n  const z = plugin.referenceSymbol(plugin.api.selector('external', 'zod.z'));\n\n  if (typeof schema.const === 'string') {\n    result.expression = tsc.callExpression({\n      functionName: tsc.propertyAccessExpression({\n        expression: z.placeholder,\n        name: identifiers.literal,\n      }),\n      parameters: [tsc.ots.string(schema.const)],\n    });\n    return result as Omit<Ast, 'typeName'>;\n  }\n\n  result.expression = tsc.callExpression({\n    functionName: tsc.propertyAccessExpression({\n      expression: z.placeholder,\n      name: identifiers.string,\n    }),\n  });\n\n  const dateTimeOptions: { key: string; value: boolean }[] = [];\n\n  if (plugin.config.dates.offset) {\n    dateTimeOptions.push({ key: 'offset', value: true });\n  }\n  if (plugin.config.dates.local) {\n    dateTimeOptions.push({ key: 'local', value: true });\n  }\n\n  if (schema.format) {\n    switch (schema.format) {\n      case 'date':\n        result.expression = tsc.callExpression({\n          functionName: tsc.propertyAccessExpression({\n            expression: tsc.propertyAccessExpression({\n              expression: z.placeholder,\n              name: identifiers.iso,\n            }),\n            name: identifiers.date,\n          }),\n        });\n        break;\n      case 'date-time':\n        result.expression = tsc.callExpression({\n          functionName: tsc.propertyAccessExpression({\n            expression: tsc.propertyAccessExpression({\n              expression: z.placeholder,\n              name: identifiers.iso,\n            }),\n            name: identifiers.datetime,\n          }),\n          parameters:\n            dateTimeOptions.length > 0\n              ? [\n                  tsc.objectExpression({\n                    obj: dateTimeOptions,\n                  }),\n                ]\n              : [],\n        });\n        break;\n      case 'email':\n        result.expression = tsc.callExpression({\n          functionName: tsc.propertyAccessExpression({\n            expression: z.placeholder,\n            name: identifiers.email,\n          }),\n        });\n        break;\n      case 'ipv4':\n        result.expression = tsc.callExpression({\n          functionName: tsc.propertyAccessExpression({\n            expression: z.placeholder,\n            name: identifiers.ipv4,\n          }),\n        });\n        break;\n      case 'ipv6':\n        result.expression = tsc.callExpression({\n          functionName: tsc.propertyAccessExpression({\n            expression: z.placeholder,\n            name: identifiers.ipv6,\n          }),\n        });\n        break;\n      case 'time':\n        result.expression = tsc.callExpression({\n          functionName: tsc.propertyAccessExpression({\n            expression: tsc.propertyAccessExpression({\n              expression: z.placeholder,\n              name: identifiers.iso,\n            }),\n            name: identifiers.time,\n          }),\n        });\n        break;\n      case 'uri':\n        result.expression = tsc.callExpression({\n          functionName: tsc.propertyAccessExpression({\n            expression: z.placeholder,\n            name: identifiers.url,\n          }),\n        });\n        break;\n      case 'uuid':\n        result.expression = tsc.callExpression({\n          functionName: tsc.propertyAccessExpression({\n            expression: z.placeholder,\n            name: identifiers.uuid,\n          }),\n        });\n        break;\n    }\n  }\n\n  if (schema.minLength === schema.maxLength && schema.minLength !== undefined) {\n    result.expression = tsc.callExpression({\n      functionName: tsc.propertyAccessExpression({\n        expression: result.expression,\n        name: identifiers.length,\n      }),\n      parameters: [tsc.valueToExpression({ value: schema.minLength })],\n    });\n  } else {\n    if (schema.minLength !== undefined) {\n      result.expression = tsc.callExpression({\n        functionName: tsc.propertyAccessExpression({\n          expression: result.expression,\n          name: identifiers.min,\n        }),\n        parameters: [tsc.valueToExpression({ value: schema.minLength })],\n      });\n    }\n\n    if (schema.maxLength !== undefined) {\n      result.expression = tsc.callExpression({\n        functionName: tsc.propertyAccessExpression({\n          expression: result.expression,\n          name: identifiers.max,\n        }),\n        parameters: [tsc.valueToExpression({ value: schema.maxLength })],\n      });\n    }\n  }\n\n  if (schema.pattern) {\n    result.expression = tsc.callExpression({\n      functionName: tsc.propertyAccessExpression({\n        expression: result.expression,\n        name: identifiers.regex,\n      }),\n      parameters: [tsc.regularExpressionLiteral({ text: schema.pattern })],\n    });\n  }\n\n  return result as Omit<Ast, 'typeName'>;\n};\n","import type ts from 'typescript';\n\nimport type { SchemaWithType } from '~/plugins';\nimport { toRef } from '~/plugins/shared/utils/refs';\nimport { tsc } from '~/tsc';\n\nimport { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\nimport { irSchemaToAst } from '../plugin';\n\nexport const tupleToAst = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'tuple'>;\n}): Omit<Ast, 'typeName'> => {\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n\n  const z = plugin.referenceSymbol(plugin.api.selector('external', 'zod.z'));\n\n  if (schema.const && Array.isArray(schema.const)) {\n    const tupleElements = schema.const.map((value) =>\n      tsc.callExpression({\n        functionName: tsc.propertyAccessExpression({\n          expression: z.placeholder,\n          name: identifiers.literal,\n        }),\n        parameters: [tsc.valueToExpression({ value })],\n      }),\n    );\n    result.expression = tsc.callExpression({\n      functionName: tsc.propertyAccessExpression({\n        expression: z.placeholder,\n        name: identifiers.tuple,\n      }),\n      parameters: [\n        tsc.arrayLiteralExpression({\n          elements: tupleElements,\n        }),\n      ],\n    });\n    return result as Omit<Ast, 'typeName'>;\n  }\n\n  const tupleElements: Array<ts.Expression> = [];\n\n  if (schema.items) {\n    schema.items.forEach((item, index) => {\n      const itemSchema = irSchemaToAst({\n        plugin,\n        schema: item,\n        state: {\n          ...state,\n          path: toRef([...state.path.value, 'items', index]),\n        },\n      });\n      tupleElements.push(itemSchema.expression);\n      if (itemSchema.hasLazyExpression) {\n        result.hasLazyExpression = true;\n      }\n    });\n  }\n\n  result.expression = tsc.callExpression({\n    functionName: tsc.propertyAccessExpression({\n      expression: z.placeholder,\n      name: identifiers.tuple,\n    }),\n    parameters: [\n      tsc.arrayLiteralExpression({\n        elements: tupleElements,\n      }),\n    ],\n  });\n\n  return result as Omit<Ast, 'typeName'>;\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { tsc } from '~/tsc';\n\nimport { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\n\nexport const undefinedToAst = ({\n  plugin,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'undefined'>;\n}): Omit<Ast, 'typeName'> => {\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n  const z = plugin.referenceSymbol(plugin.api.selector('external', 'zod.z'));\n  result.expression = tsc.callExpression({\n    functionName: tsc.propertyAccessExpression({\n      expression: z.placeholder,\n      name: identifiers.undefined,\n    }),\n  });\n  return result as Omit<Ast, 'typeName'>;\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { tsc } from '~/tsc';\n\nimport { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\n\nexport const voidToAst = ({\n  plugin,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'void'>;\n}): Omit<Ast, 'typeName'> => {\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n  const z = plugin.referenceSymbol(plugin.api.selector('external', 'zod.z'));\n  result.expression = tsc.callExpression({\n    functionName: tsc.propertyAccessExpression({\n      expression: z.placeholder,\n      name: identifiers.void,\n    }),\n  });\n  return result as Omit<Ast, 'typeName'>;\n};\n","import type { SchemaWithType } from '~/plugins';\n\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\nimport { arrayToAst } from './array';\nimport { booleanToAst } from './boolean';\nimport { enumToAst } from './enum';\nimport { neverToAst } from './never';\nimport { nullToAst } from './null';\nimport { numberToAst } from './number';\nimport { objectToAst } from './object';\nimport { stringToAst } from './string';\nimport { tupleToAst } from './tuple';\nimport { undefinedToAst } from './undefined';\nimport { unknownToAst } from './unknown';\nimport { voidToAst } from './void';\n\nexport const irSchemaWithTypeToAst = ({\n  schema,\n  ...args\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType;\n}): Omit<Ast, 'typeName'> => {\n  switch (schema.type) {\n    case 'array':\n      return arrayToAst({\n        ...args,\n        schema: schema as SchemaWithType<'array'>,\n      });\n    case 'boolean':\n      return booleanToAst({\n        ...args,\n        schema: schema as SchemaWithType<'boolean'>,\n      });\n    case 'enum':\n      return enumToAst({\n        ...args,\n        schema: schema as SchemaWithType<'enum'>,\n      });\n    case 'integer':\n    case 'number':\n      return numberToAst({\n        ...args,\n        schema: schema as SchemaWithType<'integer' | 'number'>,\n      });\n    case 'never':\n      return neverToAst({\n        ...args,\n        schema: schema as SchemaWithType<'never'>,\n      });\n    case 'null':\n      return nullToAst({\n        ...args,\n        schema: schema as SchemaWithType<'null'>,\n      });\n    case 'object':\n      return objectToAst({\n        ...args,\n        schema: schema as SchemaWithType<'object'>,\n      });\n    case 'string':\n      return stringToAst({\n        ...args,\n        schema: schema as SchemaWithType<'string'>,\n      });\n    case 'tuple':\n      return tupleToAst({\n        ...args,\n        schema: schema as SchemaWithType<'tuple'>,\n      });\n    case 'undefined':\n      return undefinedToAst({\n        ...args,\n        schema: schema as SchemaWithType<'undefined'>,\n      });\n    case 'unknown':\n      return unknownToAst({\n        ...args,\n        schema: schema as SchemaWithType<'unknown'>,\n      });\n    case 'void':\n      return voidToAst({\n        ...args,\n        schema: schema as SchemaWithType<'void'>,\n      });\n  }\n};\n","import { deduplicateSchema } from '~/ir/schema';\nimport type { IR } from '~/ir/types';\nimport { buildName } from '~/openApi/shared/utils/name';\nimport type { SchemaWithType } from '~/plugins';\nimport { toRef, toRefs } from '~/plugins/shared/utils/refs';\nimport { tsc } from '~/tsc';\nimport { pathToJsonPointer, refToName } from '~/utils/ref';\n\nimport { identifiers } from '../constants';\nimport { exportAst } from '../shared/export';\nimport { getZodModule } from '../shared/module';\nimport { numberParameter } from '../shared/numbers';\nimport { irOperationToAst } from '../shared/operation';\nimport type { Ast, IrSchemaToAstOptions, PluginState } from '../shared/types';\nimport { irWebhookToAst } from '../shared/webhook';\nimport type { ZodPlugin } from '../types';\nimport { irSchemaWithTypeToAst } from './toAst';\n\nexport const irSchemaToAst = ({\n  optional,\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  /**\n   * Accept `optional` to handle optional object properties. We can't handle\n   * this inside the object function because `.optional()` must come before\n   * `.default()` which is handled in this function.\n   */\n  optional?: boolean;\n  schema: IR.SchemaObject;\n}): Ast => {\n  let ast: Partial<Ast> = {};\n\n  const z = plugin.referenceSymbol(plugin.api.selector('external', 'zod.z'));\n\n  if (schema.$ref) {\n    const selector = plugin.api.selector('ref', schema.$ref);\n    const refSymbol = plugin.referenceSymbol(selector);\n    if (plugin.isSymbolRegistered(selector)) {\n      const ref = tsc.identifier({ text: refSymbol.placeholder });\n      ast.expression = ref;\n    } else {\n      const lazyExpression = tsc.callExpression({\n        functionName: tsc.propertyAccessExpression({\n          expression: z.placeholder,\n          name: identifiers.lazy,\n        }),\n        parameters: [\n          tsc.arrowFunction({\n            returnType: tsc.keywordTypeNode({ keyword: 'any' }),\n            statements: [\n              tsc.returnStatement({\n                expression: tsc.identifier({ text: refSymbol.placeholder }),\n              }),\n            ],\n          }),\n        ],\n      });\n      ast.expression = lazyExpression;\n      ast.hasLazyExpression = true;\n      state.hasLazyExpression.value = true;\n    }\n  } else if (schema.type) {\n    const typeAst = irSchemaWithTypeToAst({\n      plugin,\n      schema: schema as SchemaWithType,\n      state,\n    });\n    ast.expression = typeAst.expression;\n    ast.hasLazyExpression = typeAst.hasLazyExpression;\n\n    if (plugin.config.metadata && schema.description) {\n      ast.expression = tsc.callExpression({\n        functionName: tsc.propertyAccessExpression({\n          expression: ast.expression,\n          name: identifiers.register,\n        }),\n        parameters: [\n          tsc.propertyAccessExpression({\n            expression: z.placeholder,\n            name: identifiers.globalRegistry,\n          }),\n          tsc.objectExpression({\n            obj: [\n              {\n                key: 'description',\n                value: tsc.stringLiteral({ text: schema.description }),\n              },\n            ],\n          }),\n        ],\n      });\n    }\n  } else if (schema.items) {\n    schema = deduplicateSchema({ schema });\n\n    if (schema.items) {\n      const itemSchemas = schema.items.map((item, index) =>\n        irSchemaToAst({\n          plugin,\n          schema: item,\n          state: {\n            ...state,\n            path: toRef([...state.path.value, 'items', index]),\n          },\n        }),\n      );\n\n      if (schema.logicalOperator === 'and') {\n        const firstSchema = schema.items[0]!;\n        // we want to add an intersection, but not every schema can use the same API.\n        // if the first item contains another array or not an object, we cannot use\n        // `.merge()` as that does not exist on `.union()` and non-object schemas.\n        if (\n          firstSchema.logicalOperator === 'or' ||\n          (firstSchema.type && firstSchema.type !== 'object')\n        ) {\n          ast.expression = tsc.callExpression({\n            functionName: tsc.propertyAccessExpression({\n              expression: z.placeholder,\n              name: identifiers.intersection,\n            }),\n            parameters: itemSchemas.map((schema) => schema.expression),\n          });\n        } else {\n          ast.expression = itemSchemas[0]!.expression;\n          itemSchemas.slice(1).forEach((schema) => {\n            ast.expression = tsc.callExpression({\n              functionName: tsc.propertyAccessExpression({\n                expression: ast.expression!,\n                name: identifiers.and,\n              }),\n              parameters: [\n                schema.hasLazyExpression\n                  ? tsc.callExpression({\n                      functionName: tsc.propertyAccessExpression({\n                        expression: z.placeholder,\n                        name: identifiers.lazy,\n                      }),\n                      parameters: [\n                        tsc.arrowFunction({\n                          statements: [\n                            tsc.returnStatement({\n                              expression: schema.expression,\n                            }),\n                          ],\n                        }),\n                      ],\n                    })\n                  : schema.expression,\n              ],\n            });\n          });\n        }\n      } else {\n        ast.expression = tsc.callExpression({\n          functionName: tsc.propertyAccessExpression({\n            expression: z.placeholder,\n            name: identifiers.union,\n          }),\n          parameters: [\n            tsc.arrayLiteralExpression({\n              elements: itemSchemas.map((schema) => schema.expression),\n            }),\n          ],\n        });\n      }\n    } else {\n      ast = irSchemaToAst({\n        plugin,\n        schema,\n        state,\n      });\n    }\n  } else {\n    // catch-all fallback for failed schemas\n    const typeAst = irSchemaWithTypeToAst({\n      plugin,\n      schema: {\n        type: 'unknown',\n      },\n      state,\n    });\n    ast.expression = typeAst.expression;\n  }\n\n  if (ast.expression) {\n    if (schema.accessScope === 'read') {\n      ast.expression = tsc.callExpression({\n        functionName: tsc.propertyAccessExpression({\n          expression: ast.expression,\n          name: identifiers.readonly,\n        }),\n      });\n    }\n\n    if (optional) {\n      ast.expression = tsc.callExpression({\n        functionName: tsc.propertyAccessExpression({\n          expression: z.placeholder,\n          name: identifiers.optional,\n        }),\n        parameters: [ast.expression],\n      });\n      ast.typeName = identifiers.ZodOptional;\n    }\n\n    if (schema.default !== undefined) {\n      const isBigInt = schema.type === 'integer' && schema.format === 'int64';\n      const callParameter = numberParameter({\n        isBigInt,\n        value: schema.default,\n      });\n      if (callParameter) {\n        ast.expression = tsc.callExpression({\n          functionName: tsc.propertyAccessExpression({\n            expression: ast.expression,\n            name: identifiers.default,\n          }),\n          parameters: [callParameter],\n        });\n      }\n    }\n  }\n\n  return ast as Ast;\n};\n\nconst handleComponent = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: IR.SchemaObject;\n}): void => {\n  const $ref = pathToJsonPointer(state.path.value);\n  const ast = irSchemaToAst({ plugin, schema, state });\n  const baseName = refToName($ref);\n  const symbol = plugin.registerSymbol({\n    exported: true,\n    meta: {\n      path: state.path.value,\n      tags: state.tags?.value,\n    },\n    name: buildName({\n      config: plugin.config.definitions,\n      name: baseName,\n    }),\n    selector: plugin.api.selector('ref', $ref),\n  });\n  const typeInferSymbol = plugin.config.definitions.types.infer.enabled\n    ? plugin.registerSymbol({\n        exported: true,\n        meta: {\n          kind: 'type',\n          path: state.path.value,\n          tags: state.tags?.value,\n        },\n        name: buildName({\n          config: plugin.config.definitions.types.infer,\n          name: baseName,\n        }),\n        selector: plugin.api.selector('type-infer-ref', $ref),\n      })\n    : undefined;\n  exportAst({\n    ast,\n    plugin,\n    schema,\n    symbol,\n    typeInferSymbol,\n  });\n};\n\nexport const handlerV4: ZodPlugin['Handler'] = ({ plugin }) => {\n  plugin.registerSymbol({\n    external: getZodModule({ plugin }),\n    name: 'z',\n    selector: plugin.api.selector('external', 'zod.z'),\n  });\n\n  plugin.forEach(\n    'operation',\n    'parameter',\n    'requestBody',\n    'schema',\n    'webhook',\n    (event) => {\n      const state = toRefs<PluginState>({\n        hasLazyExpression: false,\n        path: event._path,\n        tags: event.tags,\n      });\n      switch (event.type) {\n        case 'operation':\n          irOperationToAst({\n            getAst: (schema, path) => {\n              const state = toRefs<PluginState>({\n                hasLazyExpression: false,\n                path,\n                tags: event.tags,\n              });\n              return irSchemaToAst({ plugin, schema, state });\n            },\n            operation: event.operation,\n            plugin,\n            state,\n          });\n          break;\n        case 'parameter':\n          handleComponent({\n            plugin,\n            schema: event.parameter.schema,\n            state,\n          });\n          break;\n        case 'requestBody':\n          handleComponent({\n            plugin,\n            schema: event.requestBody.schema,\n            state,\n          });\n          break;\n        case 'schema':\n          handleComponent({\n            plugin,\n            schema: event.schema,\n            state,\n          });\n          break;\n        case 'webhook':\n          irWebhookToAst({\n            getAst: (schema, path) => {\n              const state = toRefs<PluginState>({\n                hasLazyExpression: false,\n                path,\n                tags: event.tags,\n              });\n              return irSchemaToAst({ plugin, schema, state });\n            },\n            operation: event.operation,\n            plugin,\n            state,\n          });\n          break;\n      }\n    },\n  );\n};\n","import { handlerMini } from './mini/plugin';\nimport type { ZodPlugin } from './types';\nimport { handlerV3 } from './v3/plugin';\nimport { handlerV4 } from './v4/plugin';\n\nexport const handler: ZodPlugin['Handler'] = (args) => {\n  const { plugin } = args;\n  switch (plugin.config.compatibilityVersion) {\n    case 3:\n      return handlerV3(args);\n    case 'mini':\n      return handlerMini(args);\n    case 4:\n    default:\n      return handlerV4(args);\n  }\n};\n","import colors from 'ansi-colors';\n\nimport { definePluginConfig, mappers } from '~/plugins/shared/utils/config';\n\nimport { Api } from './api';\nimport { handler } from './plugin';\nimport type { ZodPlugin } from './types';\n\ntype CompatibilityVersion = NonNullable<\n  ZodPlugin['Config']['config']['compatibilityVersion']\n>;\n\nexport const defaultConfig: ZodPlugin['Config'] = {\n  api: new Api({\n    name: 'zod',\n  }),\n  config: {\n    case: 'camelCase',\n    comments: true,\n    exportFromIndex: false,\n    metadata: false,\n  },\n  handler,\n  name: 'zod',\n  resolveConfig: (plugin, context) => {\n    const packageName = 'zod';\n    const version = context.package.getVersion(packageName);\n\n    const inferCompatibleVersion = (): CompatibilityVersion => {\n      if (version && (version.major === 4 || version.major === 3)) {\n        return version.major;\n      }\n\n      // default compatibility version\n      return 4;\n    };\n\n    const ensureCompatibleVersion = (\n      compatibilityVersion: CompatibilityVersion | undefined,\n    ): CompatibilityVersion => {\n      if (!compatibilityVersion) {\n        return inferCompatibleVersion();\n      }\n\n      if (!version) {\n        return compatibilityVersion;\n      }\n\n      if (\n        compatibilityVersion === 4 ||\n        compatibilityVersion === 3 ||\n        compatibilityVersion === 'mini'\n      ) {\n        if (!context.package.satisfies(version, '>=3.25.0 <5.0.0')) {\n          const compatibleVersion = inferCompatibleVersion();\n          console.warn(\n            ` ${colors.yellow('Warning:')} Installed ${colors.cyan(packageName)} ${colors.cyan(`v${version.version}`)} does not support compatibility version ${colors.yellow(String(compatibilityVersion))}, using ${colors.yellow(String(compatibleVersion))}.`,\n          );\n          return compatibleVersion;\n        }\n      }\n\n      return compatibilityVersion;\n    };\n\n    plugin.config.compatibilityVersion = ensureCompatibleVersion(\n      plugin.config.compatibilityVersion,\n    );\n\n    plugin.config.dates = context.valueToObject({\n      defaultValue: {\n        local: false,\n        offset: false,\n      },\n      value: plugin.config.dates,\n    });\n\n    plugin.config.types = context.valueToObject({\n      defaultValue: {\n        infer: {\n          case: 'PascalCase',\n          enabled: false,\n        },\n      },\n      mappers: {\n        object: (fields, defaultValue) => ({\n          ...fields,\n          infer: context.valueToObject({\n            defaultValue: {\n              ...(defaultValue.infer as Extract<\n                typeof defaultValue.infer,\n                Record<string, unknown>\n              >),\n              enabled:\n                fields.infer !== undefined\n                  ? Boolean(fields.infer)\n                  : (\n                      defaultValue.infer as Extract<\n                        typeof defaultValue.infer,\n                        Record<string, unknown>\n                      >\n                    ).enabled,\n            },\n            mappers,\n            value: fields.infer,\n          }),\n        }),\n      },\n      value: plugin.config.types,\n    });\n\n    plugin.config.definitions = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: 'z{{name}}',\n        types: {\n          ...plugin.config.types,\n          infer: {\n            ...(plugin.config.types.infer as Extract<\n              typeof plugin.config.types.infer,\n              Record<string, unknown>\n            >),\n            name: '{{name}}ZodType',\n          },\n        },\n      },\n      mappers: {\n        ...mappers,\n        object: (fields, defaultValue) => ({\n          ...fields,\n          types: context.valueToObject({\n            defaultValue: defaultValue.types!,\n            mappers: {\n              object: (fields, defaultValue) => ({\n                ...fields,\n                infer: context.valueToObject({\n                  defaultValue: {\n                    ...(defaultValue.infer as Extract<\n                      typeof defaultValue.infer,\n                      Record<string, unknown>\n                    >),\n                    enabled:\n                      fields.infer !== undefined\n                        ? Boolean(fields.infer)\n                        : (\n                            defaultValue.infer as Extract<\n                              typeof defaultValue.infer,\n                              Record<string, unknown>\n                            >\n                          ).enabled,\n                  },\n                  mappers,\n                  value: fields.infer,\n                }),\n              }),\n            },\n            value: fields.types,\n          }),\n        }),\n      },\n      value: plugin.config.definitions,\n    });\n\n    plugin.config.requests = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: 'z{{name}}Data',\n        types: {\n          ...plugin.config.types,\n          infer: {\n            ...(plugin.config.types.infer as Extract<\n              typeof plugin.config.types.infer,\n              Record<string, unknown>\n            >),\n            name: '{{name}}DataZodType',\n          },\n        },\n      },\n      mappers: {\n        ...mappers,\n        object: (fields, defaultValue) => ({\n          ...fields,\n          types: context.valueToObject({\n            defaultValue: defaultValue.types!,\n            mappers: {\n              object: (fields, defaultValue) => ({\n                ...fields,\n                infer: context.valueToObject({\n                  defaultValue: {\n                    ...(defaultValue.infer as Extract<\n                      typeof defaultValue.infer,\n                      Record<string, unknown>\n                    >),\n                    enabled:\n                      fields.infer !== undefined\n                        ? Boolean(fields.infer)\n                        : (\n                            defaultValue.infer as Extract<\n                              typeof defaultValue.infer,\n                              Record<string, unknown>\n                            >\n                          ).enabled,\n                  },\n                  mappers,\n                  value: fields.infer,\n                }),\n              }),\n            },\n            value: fields.types,\n          }),\n        }),\n      },\n      value: plugin.config.requests,\n    });\n\n    plugin.config.responses = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: 'z{{name}}Response',\n        types: {\n          ...plugin.config.types,\n          infer: {\n            ...(plugin.config.types.infer as Extract<\n              typeof plugin.config.types.infer,\n              Record<string, unknown>\n            >),\n            name: '{{name}}ResponseZodType',\n          },\n        },\n      },\n      mappers: {\n        ...mappers,\n        object: (fields, defaultValue) => ({\n          ...fields,\n          types: context.valueToObject({\n            defaultValue: defaultValue.types!,\n            mappers: {\n              object: (fields, defaultValue) => ({\n                ...fields,\n                infer: context.valueToObject({\n                  defaultValue: {\n                    ...(defaultValue.infer as Extract<\n                      typeof defaultValue.infer,\n                      Record<string, unknown>\n                    >),\n                    enabled:\n                      fields.infer !== undefined\n                        ? Boolean(fields.infer)\n                        : (\n                            defaultValue.infer as Extract<\n                              typeof defaultValue.infer,\n                              Record<string, unknown>\n                            >\n                          ).enabled,\n                  },\n                  mappers,\n                  value: fields.infer,\n                }),\n              }),\n            },\n            value: fields.types,\n          }),\n        }),\n      },\n      value: plugin.config.responses,\n    });\n\n    plugin.config.webhooks = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: 'z{{name}}WebhookRequest',\n        types: {\n          ...plugin.config.types,\n          infer: {\n            ...(plugin.config.types.infer as Extract<\n              typeof plugin.config.types.infer,\n              Record<string, unknown>\n            >),\n            name: '{{name}}WebhookRequestZodType',\n          },\n        },\n      },\n      mappers: {\n        ...mappers,\n        object: (fields, defaultValue) => ({\n          ...fields,\n          types: context.valueToObject({\n            defaultValue: defaultValue.types!,\n            mappers: {\n              object: (fields, defaultValue) => ({\n                ...fields,\n                infer: context.valueToObject({\n                  defaultValue: {\n                    ...(defaultValue.infer as Extract<\n                      typeof defaultValue.infer,\n                      Record<string, unknown>\n                    >),\n                    enabled:\n                      fields.infer !== undefined\n                        ? Boolean(fields.infer)\n                        : (\n                            defaultValue.infer as Extract<\n                              typeof defaultValue.infer,\n                              Record<string, unknown>\n                            >\n                          ).enabled,\n                  },\n                  mappers,\n                  value: fields.infer,\n                }),\n              }),\n            },\n            value: fields.types,\n          }),\n        }),\n      },\n      value: plugin.config.webhooks,\n    });\n  },\n  tags: ['validator'],\n};\n\n/**\n * Type helper for Zod plugin, returns {@link Plugin.Config} object\n */\nexport const defineConfig = definePluginConfig(defaultConfig);\n","import type { Plugin } from '~/plugins';\nimport type { AngularCommonPlugin } from '~/plugins/@angular/common';\nimport { defaultConfig as angularCommon } from '~/plugins/@angular/common';\nimport type { HeyApiClientAngularPlugin } from '~/plugins/@hey-api/client-angular';\nimport { defaultConfig as heyApiClientAngular } from '~/plugins/@hey-api/client-angular';\nimport type { HeyApiClientAxiosPlugin } from '~/plugins/@hey-api/client-axios';\nimport { defaultConfig as heyApiClientAxios } from '~/plugins/@hey-api/client-axios';\nimport type { HeyApiClientFetchPlugin } from '~/plugins/@hey-api/client-fetch';\nimport { defaultConfig as heyApiClientFetch } from '~/plugins/@hey-api/client-fetch';\nimport type { HeyApiClientNextPlugin } from '~/plugins/@hey-api/client-next';\nimport { defaultConfig as heyApiClientNext } from '~/plugins/@hey-api/client-next';\nimport type { HeyApiClientNuxtPlugin } from '~/plugins/@hey-api/client-nuxt';\nimport { defaultConfig as heyApiClientNuxt } from '~/plugins/@hey-api/client-nuxt';\nimport type { HeyApiClientOfetchPlugin } from '~/plugins/@hey-api/client-ofetch';\nimport { defaultConfig as heyApiClientOfetch } from '~/plugins/@hey-api/client-ofetch';\nimport type { HeyApiClientLegacyAngularPlugin } from '~/plugins/@hey-api/legacy-angular';\nimport { defaultConfig as heyApiLegacyAngular } from '~/plugins/@hey-api/legacy-angular';\nimport type { HeyApiClientLegacyAxiosPlugin } from '~/plugins/@hey-api/legacy-axios';\nimport { defaultConfig as heyApiLegacyAxios } from '~/plugins/@hey-api/legacy-axios';\nimport type { HeyApiClientLegacyFetchPlugin } from '~/plugins/@hey-api/legacy-fetch';\nimport { defaultConfig as heyApiLegacyFetch } from '~/plugins/@hey-api/legacy-fetch';\nimport type { HeyApiClientLegacyNodePlugin } from '~/plugins/@hey-api/legacy-node';\nimport { defaultConfig as heyApiLegacyNode } from '~/plugins/@hey-api/legacy-node';\nimport type { HeyApiClientLegacyXhrPlugin } from '~/plugins/@hey-api/legacy-xhr';\nimport { defaultConfig as heyApiLegacyXhr } from '~/plugins/@hey-api/legacy-xhr';\nimport type { HeyApiSchemasPlugin } from '~/plugins/@hey-api/schemas';\nimport { defaultConfig as heyApiSchemas } from '~/plugins/@hey-api/schemas';\nimport type { HeyApiSdkPlugin } from '~/plugins/@hey-api/sdk';\nimport { defaultConfig as heyApiSdk } from '~/plugins/@hey-api/sdk';\nimport type { HeyApiTransformersPlugin } from '~/plugins/@hey-api/transformers';\nimport { defaultConfig as heyApiTransformers } from '~/plugins/@hey-api/transformers';\nimport type { HeyApiTypeScriptPlugin } from '~/plugins/@hey-api/typescript';\nimport { defaultConfig as heyApiTypeScript } from '~/plugins/@hey-api/typescript';\nimport type { PiniaColadaPlugin } from '~/plugins/@pinia/colada';\nimport { defaultConfig as piniaColada } from '~/plugins/@pinia/colada';\nimport type { TanStackAngularQueryPlugin } from '~/plugins/@tanstack/angular-query-experimental';\nimport { defaultConfig as tanStackAngularQuery } from '~/plugins/@tanstack/angular-query-experimental';\nimport type { TanStackReactQueryPlugin } from '~/plugins/@tanstack/react-query';\nimport { defaultConfig as tanStackReactQuery } from '~/plugins/@tanstack/react-query';\nimport type { TanStackSolidQueryPlugin } from '~/plugins/@tanstack/solid-query';\nimport { defaultConfig as tanStackSolidQuery } from '~/plugins/@tanstack/solid-query';\nimport type { TanStackSvelteQueryPlugin } from '~/plugins/@tanstack/svelte-query';\nimport { defaultConfig as tanStackSvelteQuery } from '~/plugins/@tanstack/svelte-query';\nimport type { TanStackVueQueryPlugin } from '~/plugins/@tanstack/vue-query';\nimport { defaultConfig as tanStackVueQuery } from '~/plugins/@tanstack/vue-query';\nimport type { ArktypePlugin } from '~/plugins/arktype';\nimport { defaultConfig as arktype } from '~/plugins/arktype';\nimport type { FastifyPlugin } from '~/plugins/fastify';\nimport { defaultConfig as fastify } from '~/plugins/fastify';\nimport type { PluginNames } from '~/plugins/types';\nimport type { ValibotPlugin } from '~/plugins/valibot';\nimport { defaultConfig as valibot } from '~/plugins/valibot';\nimport type { ZodPlugin } from '~/plugins/zod';\nimport { defaultConfig as zod } from '~/plugins/zod';\n\nexport interface PluginConfigMap {\n  '@angular/common': AngularCommonPlugin['Types'];\n  '@hey-api/client-angular': HeyApiClientAngularPlugin['Types'];\n  '@hey-api/client-axios': HeyApiClientAxiosPlugin['Types'];\n  '@hey-api/client-fetch': HeyApiClientFetchPlugin['Types'];\n  '@hey-api/client-next': HeyApiClientNextPlugin['Types'];\n  '@hey-api/client-nuxt': HeyApiClientNuxtPlugin['Types'];\n  '@hey-api/client-ofetch': HeyApiClientOfetchPlugin['Types'];\n  '@hey-api/schemas': HeyApiSchemasPlugin['Types'];\n  '@hey-api/sdk': HeyApiSdkPlugin['Types'];\n  '@hey-api/transformers': HeyApiTransformersPlugin['Types'];\n  '@hey-api/typescript': HeyApiTypeScriptPlugin['Types'];\n  '@pinia/colada': PiniaColadaPlugin['Types'];\n  '@tanstack/angular-query-experimental': TanStackAngularQueryPlugin['Types'];\n  '@tanstack/react-query': TanStackReactQueryPlugin['Types'];\n  '@tanstack/solid-query': TanStackSolidQueryPlugin['Types'];\n  '@tanstack/svelte-query': TanStackSvelteQueryPlugin['Types'];\n  '@tanstack/vue-query': TanStackVueQueryPlugin['Types'];\n  arktype: ArktypePlugin['Types'];\n  fastify: FastifyPlugin['Types'];\n  'legacy/angular': HeyApiClientLegacyAngularPlugin['Types'];\n  'legacy/axios': HeyApiClientLegacyAxiosPlugin['Types'];\n  'legacy/fetch': HeyApiClientLegacyFetchPlugin['Types'];\n  'legacy/node': HeyApiClientLegacyNodePlugin['Types'];\n  'legacy/xhr': HeyApiClientLegacyXhrPlugin['Types'];\n  valibot: ValibotPlugin['Types'];\n  zod: ZodPlugin['Types'];\n}\n\nexport const defaultPluginConfigs: {\n  [K in PluginNames]: Plugin.Config<PluginConfigMap[K]>;\n} = {\n  '@angular/common': angularCommon,\n  '@hey-api/client-angular': heyApiClientAngular,\n  '@hey-api/client-axios': heyApiClientAxios,\n  '@hey-api/client-fetch': heyApiClientFetch,\n  '@hey-api/client-next': heyApiClientNext,\n  '@hey-api/client-nuxt': heyApiClientNuxt,\n  '@hey-api/client-ofetch': heyApiClientOfetch,\n  '@hey-api/schemas': heyApiSchemas,\n  '@hey-api/sdk': heyApiSdk,\n  '@hey-api/transformers': heyApiTransformers,\n  '@hey-api/typescript': heyApiTypeScript,\n  '@pinia/colada': piniaColada,\n  '@tanstack/angular-query-experimental': tanStackAngularQuery,\n  '@tanstack/react-query': tanStackReactQuery,\n  '@tanstack/solid-query': tanStackSolidQuery,\n  '@tanstack/svelte-query': tanStackSvelteQuery,\n  '@tanstack/vue-query': tanStackVueQuery,\n  arktype,\n  fastify,\n  'legacy/angular': heyApiLegacyAngular,\n  'legacy/axios': heyApiLegacyAxios,\n  'legacy/fetch': heyApiLegacyFetch,\n  'legacy/node': heyApiLegacyNode,\n  'legacy/xhr': heyApiLegacyXhr,\n  valibot,\n  zod,\n};\n","import { defaultPluginConfigs } from '~/plugins/config';\nimport type {\n  AnyPluginName,\n  PluginContext,\n  PluginNames,\n} from '~/plugins/types';\nimport type { Config, UserConfig } from '~/types/config';\n\nimport { valueToObject } from './utils/config';\nimport { packageFactory } from './utils/package';\n\n/**\n * Default plugins used to generate artifacts if plugins aren't specified.\n */\nexport const defaultPlugins = [\n  '@hey-api/typescript',\n  '@hey-api/sdk',\n] as const satisfies ReadonlyArray<PluginNames>;\n\nconst getPluginsConfig = ({\n  dependencies,\n  userPlugins,\n  userPluginsConfig,\n}: {\n  dependencies: Record<string, string>;\n  userPlugins: ReadonlyArray<AnyPluginName>;\n  userPluginsConfig: Config['plugins'];\n}): Pick<Config, 'plugins' | 'pluginOrder'> => {\n  const circularReferenceTracker = new Set<AnyPluginName>();\n  const pluginOrder = new Set<AnyPluginName>();\n  const plugins: Config['plugins'] = {};\n\n  const dfs = (name: AnyPluginName) => {\n    if (circularReferenceTracker.has(name)) {\n      throw new Error(`Circular reference detected at '${name}'`);\n    }\n\n    if (pluginOrder.has(name)) {\n      return;\n    }\n\n    circularReferenceTracker.add(name);\n\n    const defaultPlugin = defaultPluginConfigs[name as PluginNames];\n    const userPlugin = userPluginsConfig[name as PluginNames];\n\n    if (!defaultPlugin && !userPlugin) {\n      throw new Error(\n        `unknown plugin dependency \"${name}\" - do you need to register a custom plugin with this name?`,\n      );\n    }\n\n    const plugin = {\n      ...defaultPlugin,\n      ...userPlugin,\n      config: {\n        ...defaultPlugin?.config,\n        ...userPlugin?.config,\n      },\n      dependencies: new Set([\n        ...(defaultPlugin?.dependencies || []),\n        ...(userPlugin?.dependencies || []),\n      ]),\n    };\n\n    if (plugin.resolveConfig) {\n      const context: PluginContext = {\n        package: packageFactory(dependencies),\n        pluginByTag: (tag, props = {}) => {\n          const { defaultPlugin, errorMessage } = props;\n\n          for (const userPlugin of userPlugins) {\n            const defaultConfig =\n              defaultPluginConfigs[userPlugin as PluginNames] ||\n              userPluginsConfig[userPlugin as PluginNames];\n            if (\n              defaultConfig &&\n              defaultConfig.tags?.includes(tag) &&\n              userPlugin !== name\n            ) {\n              return userPlugin as any;\n            }\n          }\n\n          if (defaultPlugin) {\n            const defaultConfig =\n              defaultPluginConfigs[defaultPlugin as PluginNames] ||\n              userPluginsConfig[defaultPlugin as PluginNames];\n            if (\n              defaultConfig &&\n              defaultConfig.tags?.includes(tag) &&\n              defaultPlugin !== name\n            ) {\n              return defaultPlugin;\n            }\n          }\n\n          throw new Error(\n            errorMessage ||\n              `missing plugin - no plugin with tag \"${tag}\" found`,\n          );\n        },\n        valueToObject,\n      };\n      // @ts-expect-error\n      plugin.resolveConfig(plugin, context);\n    }\n\n    for (const dependency of plugin.dependencies) {\n      dfs(dependency);\n    }\n\n    circularReferenceTracker.delete(name);\n    pluginOrder.add(name);\n\n    // @ts-expect-error\n    plugins[name] = plugin;\n  };\n\n  for (const name of userPlugins) {\n    dfs(name);\n  }\n\n  return {\n    pluginOrder: Array.from(pluginOrder) as ReadonlyArray<PluginNames>,\n    plugins,\n  };\n};\n\nconst isPluginClient = (plugin: Required<UserConfig>['plugins'][number]) => {\n  if (typeof plugin === 'string') {\n    return plugin.startsWith('@hey-api/client') || plugin.startsWith('legacy/');\n  }\n\n  return (\n    plugin.name.startsWith('@hey-api/client') ||\n    plugin.name.startsWith('legacy/') ||\n    // @ts-expect-error\n    (plugin.tags && plugin.tags.includes('client'))\n  );\n};\n\nexport const getPlugins = ({\n  dependencies,\n  userConfig,\n}: {\n  dependencies: Record<string, string>;\n  userConfig: UserConfig;\n}): Pick<Config, 'plugins' | 'pluginOrder'> => {\n  const userPluginsConfig: Config['plugins'] = {};\n\n  let definedPlugins: UserConfig['plugins'] = defaultPlugins;\n\n  if (userConfig.plugins) {\n    userConfig.plugins = userConfig.plugins.filter(\n      (plugin) =>\n        (typeof plugin === 'string' && plugin) ||\n        (typeof plugin !== 'string' && plugin.name),\n    );\n    if (\n      userConfig.plugins.length === 1 &&\n      isPluginClient(userConfig.plugins[0]!)\n    ) {\n      definedPlugins = [...defaultPlugins, ...userConfig.plugins];\n    } else {\n      definedPlugins = userConfig.plugins;\n    }\n  }\n\n  const userPlugins = definedPlugins\n    .map((plugin) => {\n      if (typeof plugin === 'string') {\n        return plugin;\n      }\n\n      const pluginName = plugin.name;\n\n      if (pluginName) {\n        // @ts-expect-error\n        if (plugin.handler) {\n          // @ts-expect-error\n          userPluginsConfig[pluginName] = plugin;\n        } else {\n          // @ts-expect-error\n          userPluginsConfig[pluginName] = {\n            config: { ...plugin },\n          };\n          // @ts-expect-error\n          delete userPluginsConfig[pluginName]!.config.name;\n        }\n      }\n\n      return pluginName;\n    })\n    .filter(Boolean);\n\n  return getPluginsConfig({ dependencies, userPlugins, userPluginsConfig });\n};\n","import path from 'node:path';\n\nimport colors from 'ansi-colors';\n\nimport { ConfigError } from '~/error';\nimport type { Config, UserConfig } from '~/types/config';\nimport type { ArrayOnly } from '~/types/utils';\nimport { isLegacyClient, setConfig } from '~/utils/config';\nimport type { Logger } from '~/utils/logger';\n\nimport { getInput } from './input';\nimport { getLogs } from './logs';\nimport { mergeConfigs } from './merge';\nimport { getOutput } from './output';\nimport { getProjectDependencies } from './packages';\nimport { getParser } from './parser';\nimport { getPlugins } from './plugins';\n\ntype ConfigResult = {\n  config: Config;\n  errors: ReadonlyArray<Error>;\n  jobIndex: number;\n};\n\nexport type Configs = {\n  dependencies: Record<string, string>;\n  results: ReadonlyArray<ConfigResult>;\n};\n\n/**\n * Detect if the current session is interactive based on TTY status and environment variables.\n * This is used as a fallback when the user doesn't explicitly set the interactive option.\n * @internal\n */\nexport const detectInteractiveSession = (): boolean =>\n  Boolean(\n    process.stdin.isTTY &&\n      process.stdout.isTTY &&\n      !process.env.CI &&\n      !process.env.NO_INTERACTIVE &&\n      !process.env.NO_INTERACTION,\n  );\n\n/**\n * @internal\n */\nexport const initConfigs = async ({\n  logger,\n  userConfigs,\n}: {\n  logger: Logger;\n  userConfigs: ReadonlyArray<UserConfig>;\n}): Promise<Configs> => {\n  const configs: Array<UserConfig> = [];\n  let dependencies: Record<string, string> = {};\n\n  const eventLoad = logger.timeEvent('load');\n  for (const userConfig of userConfigs) {\n    let configurationFile: string | undefined = undefined;\n    if (userConfig?.configFile) {\n      const parts = userConfig.configFile.split('.');\n      configurationFile = parts.slice(0, parts.length - 1).join('.');\n    }\n\n    const eventC12 = logger.timeEvent('c12');\n    // c12 is ESM-only since v3\n    const { loadConfig } = await import('c12');\n    const { config: configFromFile, configFile: loadedConfigFile } =\n      await loadConfig<UserConfig>({\n        configFile: configurationFile,\n        name: 'openapi-ts',\n      });\n    eventC12.timeEnd();\n\n    if (!Object.keys(dependencies).length) {\n      // TODO: handle dependencies for multiple configs properly?\n      dependencies = getProjectDependencies(\n        Object.keys(configFromFile).length ? loadedConfigFile : undefined,\n      );\n    }\n\n    const mergedConfigs =\n      configFromFile instanceof Array\n        ? configFromFile.map((config) => mergeConfigs(config, userConfig))\n        : [mergeConfigs(configFromFile, userConfig)];\n\n    for (const mergedConfig of mergedConfigs) {\n      const input = getInput(mergedConfig);\n\n      if (mergedConfig.output instanceof Array) {\n        const countInputs = input.length;\n        const countOutputs = mergedConfig.output.length;\n        if (countOutputs > 1) {\n          if (countInputs !== countOutputs) {\n            console.warn(\n              ` ${colors.yellow('Warning:')} You provided ${colors.cyan(String(countInputs))} ${colors.cyan(countInputs === 1 ? 'input' : 'inputs')} and ${colors.yellow(String(countOutputs))} ${colors.yellow('outputs')}. This is probably not what you want as it will produce identical output in multiple locations. You most likely want to provide a single output or the same number of outputs as inputs.`,\n            );\n            for (const output of mergedConfig.output) {\n              configs.push({ ...mergedConfig, input, output });\n            }\n          } else {\n            mergedConfig.output.forEach((output, index) => {\n              configs.push({ ...mergedConfig, input: input[index]!, output });\n            });\n          }\n        } else {\n          configs.push({\n            ...mergedConfig,\n            input,\n            output: mergedConfig.output[0] ?? '',\n          });\n        }\n      } else {\n        configs.push({ ...mergedConfig, input });\n      }\n    }\n  }\n  eventLoad.timeEnd();\n\n  const results: Array<ArrayOnly<ConfigResult>> = [];\n\n  const eventBuild = logger.timeEvent('build');\n  for (const userConfig of configs) {\n    const {\n      base,\n      configFile = '',\n      dryRun = false,\n      experimentalParser = true,\n      exportCore = true,\n      name,\n      request,\n      useOptions = true,\n    } = userConfig;\n\n    const interactive =\n      userConfig.interactive !== undefined\n        ? userConfig.interactive\n        : detectInteractiveSession();\n\n    const logs = getLogs(userConfig);\n\n    const input = getInput(userConfig);\n    const output = getOutput(userConfig);\n    const parser = getParser(userConfig);\n\n    const errors: Array<Error> = [];\n\n    if (!input.length) {\n      errors.push(\n        new ConfigError(\n          'missing input - which OpenAPI specification should we use to generate your output?',\n        ),\n      );\n    }\n\n    if (!output.path) {\n      errors.push(\n        new ConfigError(\n          'missing output - where should we generate your output?',\n        ),\n      );\n    }\n\n    if (!useOptions && logs.level !== 'silent') {\n      console.warn(\n        ' Deprecation warning: useOptions set to false. This setting will be removed in future versions. Please migrate useOptions to true https://heyapi.dev/openapi-ts/migrating.html#v0-27-38',\n      );\n    }\n\n    output.path = path.resolve(process.cwd(), output.path);\n\n    let plugins: Pick<Config, 'plugins' | 'pluginOrder'>;\n\n    try {\n      plugins = getPlugins({ dependencies, userConfig });\n    } catch (error) {\n      errors.push(error);\n      plugins = {\n        pluginOrder: [],\n        plugins: {},\n      };\n    }\n\n    const config = setConfig({\n      ...plugins,\n      base,\n      configFile,\n      dryRun,\n      experimentalParser,\n      exportCore: false,\n      input,\n      interactive,\n      logs,\n      name,\n      output,\n      parser,\n      request,\n      useOptions,\n    });\n    config.exportCore = isLegacyClient(config) ? exportCore : false;\n\n    const jobIndex = results.length;\n\n    if (logs.level === 'debug') {\n      const jobPrefix = colors.gray(`[Job ${jobIndex + 1}] `);\n      console.warn(`${jobPrefix}${colors.cyan('config:')}`, config);\n    }\n\n    results.push({ config, errors, jobIndex });\n  }\n  eventBuild.timeEnd();\n\n  return { dependencies, results };\n};\n","type Slot = 'body' | 'headers' | 'path' | 'query';\n\nexport type Field =\n  | {\n      in: Exclude<Slot, 'body'>;\n      /**\n       * Field name. This is the name we want the user to see and use.\n       */\n      key: string;\n      /**\n       * Field mapped name. This is the name we want to use in the request.\n       * If omitted, we use the same value as `key`.\n       */\n      map?: string;\n    }\n  | {\n      in: Extract<Slot, 'body'>;\n      /**\n       * Key isn't required for bodies.\n       */\n      key?: string;\n      map?: string;\n    };\n\nexport interface Fields {\n  allowExtra?: Partial<Record<Slot, boolean>>;\n  args?: ReadonlyArray<Field>;\n}\n\nexport type FieldsConfig = ReadonlyArray<Field | Fields>;\n\nconst extraPrefixesMap: Record<string, Slot> = {\n  $body_: 'body',\n  $headers_: 'headers',\n  $path_: 'path',\n  $query_: 'query',\n};\nconst extraPrefixes = Object.entries(extraPrefixesMap);\n\ntype KeyMap = Map<\n  string,\n  {\n    in: Slot;\n    map?: string;\n  }\n>;\n\nconst buildKeyMap = (fields: FieldsConfig, map?: KeyMap): KeyMap => {\n  if (!map) {\n    map = new Map();\n  }\n\n  for (const config of fields) {\n    if ('in' in config) {\n      if (config.key) {\n        map.set(config.key, {\n          in: config.in,\n          map: config.map,\n        });\n      }\n    } else if (config.args) {\n      buildKeyMap(config.args, map);\n    }\n  }\n\n  return map;\n};\n\ninterface Params {\n  body: unknown;\n  headers: Record<string, unknown>;\n  path: Record<string, unknown>;\n  query: Record<string, unknown>;\n}\n\nconst stripEmptySlots = (params: Params) => {\n  for (const [slot, value] of Object.entries(params)) {\n    if (value && typeof value === 'object' && !Object.keys(value).length) {\n      delete params[slot as Slot];\n    }\n  }\n};\n\nexport const buildClientParams = (\n  args: ReadonlyArray<unknown>,\n  fields: FieldsConfig,\n) => {\n  const params: Params = {\n    body: {},\n    headers: {},\n    path: {},\n    query: {},\n  };\n\n  const map = buildKeyMap(fields);\n\n  let config: FieldsConfig[number] | undefined;\n\n  for (const [index, arg] of args.entries()) {\n    if (fields[index]) {\n      config = fields[index];\n    }\n\n    if (!config) {\n      continue;\n    }\n\n    if ('in' in config) {\n      if (config.key) {\n        const field = map.get(config.key)!;\n        const name = field.map || config.key;\n        (params[field.in] as Record<string, unknown>)[name] = arg;\n      } else {\n        params.body = arg;\n      }\n    } else {\n      for (const [key, value] of Object.entries(arg ?? {})) {\n        const field = map.get(key);\n\n        if (field) {\n          const name = field.map || key;\n          (params[field.in] as Record<string, unknown>)[name] = value;\n        } else {\n          const extra = extraPrefixes.find(([prefix]) =>\n            key.startsWith(prefix),\n          );\n\n          if (extra) {\n            const [prefix, slot] = extra;\n            (params[slot] as Record<string, unknown>)[\n              key.slice(prefix.length)\n            ] = value;\n          } else {\n            for (const [slot, allowed] of Object.entries(\n              config.allowExtra ?? {},\n            )) {\n              if (allowed) {\n                (params[slot as Slot] as Record<string, unknown>)[key] = value;\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  stripEmptySlots(params);\n\n  return params;\n};\n","interface SerializeOptions<T>\n  extends SerializePrimitiveOptions,\n    SerializerOptions<T> {}\n\ninterface SerializePrimitiveOptions {\n  allowReserved?: boolean;\n  name: string;\n}\n\nexport interface SerializerOptions<T> {\n  /**\n   * @default true\n   */\n  explode: boolean;\n  style: T;\n}\n\nexport type ArrayStyle = 'form' | 'spaceDelimited' | 'pipeDelimited';\nexport type ArraySeparatorStyle = ArrayStyle | MatrixStyle;\ntype MatrixStyle = 'label' | 'matrix' | 'simple';\nexport type ObjectStyle = 'form' | 'deepObject';\ntype ObjectSeparatorStyle = ObjectStyle | MatrixStyle;\n\ninterface SerializePrimitiveParam extends SerializePrimitiveOptions {\n  value: string;\n}\n\nexport const separatorArrayExplode = (style: ArraySeparatorStyle) => {\n  switch (style) {\n    case 'label':\n      return '.';\n    case 'matrix':\n      return ';';\n    case 'simple':\n      return ',';\n    default:\n      return '&';\n  }\n};\n\nexport const separatorArrayNoExplode = (style: ArraySeparatorStyle) => {\n  switch (style) {\n    case 'form':\n      return ',';\n    case 'pipeDelimited':\n      return '|';\n    case 'spaceDelimited':\n      return '%20';\n    default:\n      return ',';\n  }\n};\n\nexport const separatorObjectExplode = (style: ObjectSeparatorStyle) => {\n  switch (style) {\n    case 'label':\n      return '.';\n    case 'matrix':\n      return ';';\n    case 'simple':\n      return ',';\n    default:\n      return '&';\n  }\n};\n\nexport const serializeArrayParam = ({\n  allowReserved,\n  explode,\n  name,\n  style,\n  value,\n}: SerializeOptions<ArraySeparatorStyle> & {\n  value: unknown[];\n}) => {\n  if (!explode) {\n    const joinedValues = (\n      allowReserved ? value : value.map((v) => encodeURIComponent(v as string))\n    ).join(separatorArrayNoExplode(style));\n    switch (style) {\n      case 'label':\n        return `.${joinedValues}`;\n      case 'matrix':\n        return `;${name}=${joinedValues}`;\n      case 'simple':\n        return joinedValues;\n      default:\n        return `${name}=${joinedValues}`;\n    }\n  }\n\n  const separator = separatorArrayExplode(style);\n  const joinedValues = value\n    .map((v) => {\n      if (style === 'label' || style === 'simple') {\n        return allowReserved ? v : encodeURIComponent(v as string);\n      }\n\n      return serializePrimitiveParam({\n        allowReserved,\n        name,\n        value: v as string,\n      });\n    })\n    .join(separator);\n  return style === 'label' || style === 'matrix'\n    ? separator + joinedValues\n    : joinedValues;\n};\n\nexport const serializePrimitiveParam = ({\n  allowReserved,\n  name,\n  value,\n}: SerializePrimitiveParam) => {\n  if (value === undefined || value === null) {\n    return '';\n  }\n\n  if (typeof value === 'object') {\n    throw new Error(\n      'Deeply-nested arrays/objects arent supported. Provide your own `querySerializer()` to handle these.',\n    );\n  }\n\n  return `${name}=${allowReserved ? value : encodeURIComponent(value)}`;\n};\n\nexport const serializeObjectParam = ({\n  allowReserved,\n  explode,\n  name,\n  style,\n  value,\n  valueOnly,\n}: SerializeOptions<ObjectSeparatorStyle> & {\n  value: Record<string, unknown> | Date;\n  valueOnly?: boolean;\n}) => {\n  if (value instanceof Date) {\n    return valueOnly ? value.toISOString() : `${name}=${value.toISOString()}`;\n  }\n\n  if (style !== 'deepObject' && !explode) {\n    let values: string[] = [];\n    Object.entries(value).forEach(([key, v]) => {\n      values = [\n        ...values,\n        key,\n        allowReserved ? (v as string) : encodeURIComponent(v as string),\n      ];\n    });\n    const joinedValues = values.join(',');\n    switch (style) {\n      case 'form':\n        return `${name}=${joinedValues}`;\n      case 'label':\n        return `.${joinedValues}`;\n      case 'matrix':\n        return `;${name}=${joinedValues}`;\n      default:\n        return joinedValues;\n    }\n  }\n\n  const separator = separatorObjectExplode(style);\n  const joinedValues = Object.entries(value)\n    .map(([key, v]) =>\n      serializePrimitiveParam({\n        allowReserved,\n        name: style === 'deepObject' ? `${name}[${key}]` : key,\n        value: v as string,\n      }),\n    )\n    .join(separator);\n  return style === 'label' || style === 'matrix'\n    ? separator + joinedValues\n    : joinedValues;\n};\n","import { getAuthToken } from '../../client-core/bundle/auth';\nimport type { QuerySerializerOptions } from '../../client-core/bundle/bodySerializer';\nimport { jsonBodySerializer } from '../../client-core/bundle/bodySerializer';\nimport {\n  serializeArrayParam,\n  serializeObjectParam,\n  serializePrimitiveParam,\n} from '../../client-core/bundle/pathSerializer';\nimport { getUrl } from '../../client-core/bundle/utils';\nimport type { Client, ClientOptions, Config, RequestOptions } from './types';\n\nexport const createQuerySerializer = <T = unknown>({\n  parameters = {},\n  ...args\n}: QuerySerializerOptions = {}) => {\n  const querySerializer = (queryParams: T) => {\n    const search: string[] = [];\n    if (queryParams && typeof queryParams === 'object') {\n      for (const name in queryParams) {\n        const value = queryParams[name];\n\n        if (value === undefined || value === null) {\n          continue;\n        }\n\n        const options = parameters[name] || args;\n\n        if (Array.isArray(value)) {\n          const serializedArray = serializeArrayParam({\n            allowReserved: options.allowReserved,\n            explode: true,\n            name,\n            style: 'form',\n            value,\n            ...options.array,\n          });\n          if (serializedArray) search.push(serializedArray);\n        } else if (typeof value === 'object') {\n          const serializedObject = serializeObjectParam({\n            allowReserved: options.allowReserved,\n            explode: true,\n            name,\n            style: 'deepObject',\n            value: value as Record<string, unknown>,\n            ...options.object,\n          });\n          if (serializedObject) search.push(serializedObject);\n        } else {\n          const serializedPrimitive = serializePrimitiveParam({\n            allowReserved: options.allowReserved,\n            name,\n            value: value as string,\n          });\n          if (serializedPrimitive) search.push(serializedPrimitive);\n        }\n      }\n    }\n    return search.join('&');\n  };\n  return querySerializer;\n};\n\n/**\n * Infers parseAs value from provided Content-Type header.\n */\nexport const getParseAs = (\n  contentType: string | null,\n): Exclude<Config['parseAs'], 'auto'> => {\n  if (!contentType) {\n    // If no Content-Type header is provided, the best we can do is return the raw response body,\n    // which is effectively the same as the 'stream' option.\n    return 'stream';\n  }\n\n  const cleanContent = contentType.split(';')[0]?.trim();\n\n  if (!cleanContent) {\n    return;\n  }\n\n  if (\n    cleanContent.startsWith('application/json') ||\n    cleanContent.endsWith('+json')\n  ) {\n    return 'json';\n  }\n\n  if (cleanContent === 'multipart/form-data') {\n    return 'formData';\n  }\n\n  if (\n    ['application/', 'audio/', 'image/', 'video/'].some((type) =>\n      cleanContent.startsWith(type),\n    )\n  ) {\n    return 'blob';\n  }\n\n  if (cleanContent.startsWith('text/')) {\n    return 'text';\n  }\n\n  return;\n};\n\nconst checkForExistence = (\n  options: Pick<RequestOptions, 'auth' | 'query'> & {\n    headers: Headers;\n  },\n  name?: string,\n): boolean => {\n  if (!name) {\n    return false;\n  }\n  if (\n    options.headers.has(name) ||\n    options.query?.[name] ||\n    options.headers.get('Cookie')?.includes(`${name}=`)\n  ) {\n    return true;\n  }\n  return false;\n};\n\nexport const setAuthParams = async ({\n  security,\n  ...options\n}: Pick<Required<RequestOptions>, 'security'> &\n  Pick<RequestOptions, 'auth' | 'query'> & {\n    headers: Headers;\n  }) => {\n  for (const auth of security) {\n    if (checkForExistence(options, auth.name)) {\n      continue;\n    }\n\n    const token = await getAuthToken(auth, options.auth);\n\n    if (!token) {\n      continue;\n    }\n\n    const name = auth.name ?? 'Authorization';\n\n    switch (auth.in) {\n      case 'query':\n        if (!options.query) {\n          options.query = {};\n        }\n        options.query[name] = token;\n        break;\n      case 'cookie':\n        options.headers.append('Cookie', `${name}=${token}`);\n        break;\n      case 'header':\n      default:\n        options.headers.set(name, token);\n        break;\n    }\n  }\n};\n\nexport const buildUrl: Client['buildUrl'] = (options) =>\n  getUrl({\n    baseUrl: options.baseUrl as string,\n    path: options.path,\n    query: options.query,\n    querySerializer:\n      typeof options.querySerializer === 'function'\n        ? options.querySerializer\n        : createQuerySerializer(options.querySerializer),\n    url: options.url,\n  });\n\nexport const mergeConfigs = (a: Config, b: Config): Config => {\n  const config = { ...a, ...b };\n  if (config.baseUrl?.endsWith('/')) {\n    config.baseUrl = config.baseUrl.substring(0, config.baseUrl.length - 1);\n  }\n  config.headers = mergeHeaders(a.headers, b.headers);\n  return config;\n};\n\nconst headersEntries = (headers: Headers): Array<[string, string]> => {\n  const entries: Array<[string, string]> = [];\n  headers.forEach((value, key) => {\n    entries.push([key, value]);\n  });\n  return entries;\n};\n\nexport const mergeHeaders = (\n  ...headers: Array<Required<Config>['headers'] | undefined>\n): Headers => {\n  const mergedHeaders = new Headers();\n  for (const header of headers) {\n    if (!header) {\n      continue;\n    }\n\n    const iterator =\n      header instanceof Headers\n        ? headersEntries(header)\n        : Object.entries(header);\n\n    for (const [key, value] of iterator) {\n      if (value === null) {\n        mergedHeaders.delete(key);\n      } else if (Array.isArray(value)) {\n        for (const v of value) {\n          mergedHeaders.append(key, v as string);\n        }\n      } else if (value !== undefined) {\n        // assume object headers are meant to be JSON stringified, i.e. their\n        // content value in OpenAPI specification is 'application/json'\n        mergedHeaders.set(\n          key,\n          typeof value === 'object' ? JSON.stringify(value) : (value as string),\n        );\n      }\n    }\n  }\n  return mergedHeaders;\n};\n\ntype ErrInterceptor<Err, Res, Req, Options> = (\n  error: Err,\n  response: Res,\n  request: Req,\n  options: Options,\n) => Err | Promise<Err>;\n\ntype ReqInterceptor<Req, Options> = (\n  request: Req,\n  options: Options,\n) => Req | Promise<Req>;\n\ntype ResInterceptor<Res, Req, Options> = (\n  response: Res,\n  request: Req,\n  options: Options,\n) => Res | Promise<Res>;\n\nclass Interceptors<Interceptor> {\n  fns: Array<Interceptor | null> = [];\n\n  clear(): void {\n    this.fns = [];\n  }\n\n  eject(id: number | Interceptor): void {\n    const index = this.getInterceptorIndex(id);\n    if (this.fns[index]) {\n      this.fns[index] = null;\n    }\n  }\n\n  exists(id: number | Interceptor): boolean {\n    const index = this.getInterceptorIndex(id);\n    return Boolean(this.fns[index]);\n  }\n\n  getInterceptorIndex(id: number | Interceptor): number {\n    if (typeof id === 'number') {\n      return this.fns[id] ? id : -1;\n    }\n    return this.fns.indexOf(id);\n  }\n\n  update(\n    id: number | Interceptor,\n    fn: Interceptor,\n  ): number | Interceptor | false {\n    const index = this.getInterceptorIndex(id);\n    if (this.fns[index]) {\n      this.fns[index] = fn;\n      return id;\n    }\n    return false;\n  }\n\n  use(fn: Interceptor): number {\n    this.fns.push(fn);\n    return this.fns.length - 1;\n  }\n}\n\nexport interface Middleware<Req, Res, Err, Options> {\n  error: Interceptors<ErrInterceptor<Err, Res, Req, Options>>;\n  request: Interceptors<ReqInterceptor<Req, Options>>;\n  response: Interceptors<ResInterceptor<Res, Req, Options>>;\n}\n\nexport const createInterceptors = <Req, Res, Err, Options>(): Middleware<\n  Req,\n  Res,\n  Err,\n  Options\n> => ({\n  error: new Interceptors<ErrInterceptor<Err, Res, Req, Options>>(),\n  request: new Interceptors<ReqInterceptor<Req, Options>>(),\n  response: new Interceptors<ResInterceptor<Res, Req, Options>>(),\n});\n\nconst defaultQuerySerializer = createQuerySerializer({\n  allowReserved: false,\n  array: {\n    explode: true,\n    style: 'form',\n  },\n  object: {\n    explode: true,\n    style: 'deepObject',\n  },\n});\n\nconst defaultHeaders = {\n  'Content-Type': 'application/json',\n};\n\nexport const createConfig = <T extends ClientOptions = ClientOptions>(\n  override: Config<Omit<ClientOptions, keyof T> & T> = {},\n): Config<Omit<ClientOptions, keyof T> & T> => ({\n  ...jsonBodySerializer,\n  headers: defaultHeaders,\n  parseAs: 'auto',\n  querySerializer: defaultQuerySerializer,\n  ...override,\n});\n","import { getResolvedInput, sendRequest } from '@hey-api/json-schema-ref-parser';\n\nimport { mergeHeaders } from '~/plugins/@hey-api/client-fetch/bundle';\nimport type { Input } from '~/types/input';\nimport type { WatchValues } from '~/types/types';\n\ntype SpecResponse = {\n  arrayBuffer: ArrayBuffer | undefined;\n  error?: never;\n  resolvedInput: ReturnType<typeof getResolvedInput>;\n  response?: never;\n};\n\ntype SpecError = {\n  arrayBuffer?: never;\n  error: 'not-modified' | 'not-ok';\n  resolvedInput?: never;\n  response: Response;\n};\n\n/**\n * @internal\n */\nexport const getSpec = async ({\n  fetchOptions,\n  inputPath,\n  timeout,\n  watch,\n}: {\n  fetchOptions?: RequestInit;\n  inputPath: Input['path'];\n  timeout: number | undefined;\n  watch: WatchValues;\n}): Promise<SpecResponse | SpecError> => {\n  const resolvedInput = getResolvedInput({ pathOrUrlOrSchema: inputPath });\n\n  let arrayBuffer: ArrayBuffer | undefined;\n  // boolean signals whether the file has **definitely** changed\n  let hasChanged: boolean | undefined;\n  let response: Response | undefined;\n\n  if (resolvedInput.type === 'url') {\n    // do NOT send HEAD request on first run or if unsupported\n    if (watch.lastValue && watch.isHeadMethodSupported !== false) {\n      try {\n        const request = await sendRequest({\n          fetchOptions: {\n            method: 'HEAD',\n            ...fetchOptions,\n            headers: mergeHeaders(fetchOptions?.headers, watch.headers),\n          },\n          timeout,\n          url: resolvedInput.path,\n        });\n\n        if (request.response.status >= 300) {\n          return {\n            error: 'not-ok',\n            response: request.response,\n          };\n        }\n\n        response = request.response;\n      } catch (error) {\n        return {\n          error: 'not-ok',\n          response: new Response(error.message),\n        };\n      }\n\n      if (!response.ok && watch.isHeadMethodSupported) {\n        // assume the server is no longer running\n        // do nothing, it might be restarted later\n        return {\n          error: 'not-ok',\n          response,\n        };\n      }\n\n      if (watch.isHeadMethodSupported === undefined) {\n        watch.isHeadMethodSupported = response.ok;\n      }\n\n      if (response.status === 304) {\n        return {\n          error: 'not-modified',\n          response,\n        };\n      }\n\n      if (hasChanged === undefined) {\n        const eTag = response.headers.get('ETag');\n        if (eTag) {\n          hasChanged = eTag !== watch.headers.get('If-None-Match');\n\n          if (hasChanged) {\n            watch.headers.set('If-None-Match', eTag);\n          }\n        }\n      }\n\n      if (hasChanged === undefined) {\n        const lastModified = response.headers.get('Last-Modified');\n        if (lastModified) {\n          hasChanged = lastModified !== watch.headers.get('If-Modified-Since');\n\n          if (hasChanged) {\n            watch.headers.set('If-Modified-Since', lastModified);\n          }\n        }\n      }\n\n      // we definitely know the input has not changed\n      if (hasChanged === false) {\n        return {\n          error: 'not-modified',\n          response,\n        };\n      }\n    }\n\n    try {\n      const request = await sendRequest({\n        fetchOptions: {\n          method: 'GET',\n          ...fetchOptions,\n        },\n        timeout,\n        url: resolvedInput.path,\n      });\n\n      if (request.response.status >= 300) {\n        return {\n          error: 'not-ok',\n          response: request.response,\n        };\n      }\n\n      response = request.response;\n    } catch (error) {\n      return {\n        error: 'not-ok',\n        response: new Response(error.message),\n      };\n    }\n\n    if (!response.ok) {\n      // assume the server is no longer running\n      // do nothing, it might be restarted later\n      return {\n        error: 'not-ok',\n        response,\n      };\n    }\n\n    arrayBuffer = response.body\n      ? await response.arrayBuffer()\n      : new ArrayBuffer(0);\n\n    if (hasChanged === undefined) {\n      const content = new TextDecoder().decode(arrayBuffer);\n      hasChanged = content !== watch.lastValue;\n      watch.lastValue = content;\n    }\n  } else {\n    // we do not support watch mode for files or raw spec data\n    if (!watch.lastValue) {\n      watch.lastValue = resolvedInput.type;\n    } else {\n      hasChanged = false;\n    }\n  }\n\n  if (hasChanged === false) {\n    return {\n      error: 'not-modified',\n      response: response!,\n    };\n  }\n\n  return {\n    arrayBuffer,\n    resolvedInput,\n  };\n};\n"],"mappings":"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"}