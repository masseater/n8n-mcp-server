var e=Object.create,t=Object.defineProperty,n=Object.getOwnPropertyDescriptor,r=Object.getOwnPropertyNames,i=Object.getPrototypeOf,a=Object.prototype.hasOwnProperty,o=(e,i,o,s)=>{if(i&&typeof i==`object`||typeof i==`function`)for(var c=r(i),l=0,u=c.length,d;l<u;l++)d=c[l],!a.call(e,d)&&d!==o&&t(e,d,{get:(e=>i[e]).bind(null,d),enumerable:!(s=n(i,d))||s.enumerable});return e},s=(n,r,a)=>(a=n==null?{}:e(i(n)),o(r||!n||!n.__esModule?t(a,`default`,{value:n,enumerable:!0}):a,n));let c=require(`node:path`);c=s(c);const l=({file:e,modulePath:t,symbol:n,symbolFile:r})=>{let i=[],a=[],o={aliases:{},from:t};if(n.meta?.importKind&&(n.meta.importKind===`default`?(o.defaultBinding=n.placeholder,n.meta.kind===`type`&&(o.typeDefaultBinding=!0)):n.meta.importKind===`namespace`&&(o.namespaceBinding=n.placeholder,n.meta.kind===`type`&&(o.typeNamespaceBinding=!0))),n.meta?.importKind===`named`||!i.length&&!o.defaultBinding&&!o.namespaceBinding){let t=n.placeholder,s=e.resolvedNames.get(n.id);if(s){let e=r.resolvedNames.get(n.id);e?e!==s&&(t=e,o.aliases[t]=s):n.name&&s!==n.name&&(t=n.name,o.aliases[t]=n.placeholder)}i.push(t),n.meta?.kind===`type`&&a.push(t)}for(let e of a)i.includes(e)||i.push(e);return o.names=i,o.typeNames=a,o},u=(e,t)=>{e.aliases={...e.aliases,...t.aliases},t.defaultBinding!==void 0&&(e.defaultBinding=t.defaultBinding),e.names=[...new Set([...e.names??[],...t.names??[]])],t.namespaceBinding!==void 0&&(e.namespaceBinding=t.namespaceBinding),t.typeDefaultBinding!==void 0&&(e.typeDefaultBinding=t.typeDefaultBinding),e.typeNames=[...new Set([...e.typeNames??[],...t.typeNames??[]])],t.typeNamespaceBinding!==void 0&&(e.typeNamespaceBinding=t.typeNamespaceBinding)};var d=class{map=new Map;reverse=new Map;delete(e){let t=this.map.get(e);return t!==void 0&&this.reverse.delete(t),this.map.delete(e)}deleteValue(e){let t=this.reverse.get(e);return t!==void 0&&this.map.delete(t),this.reverse.delete(e)}entries(){return this.map.entries()}get(e){return this.map.get(e)}getKey(e){return this.reverse.get(e)}hasKey(e){return this.map.has(e)}hasValue(e){return this.reverse.has(e)}keys(){return this.map.keys()}set(e,t){let n=this.map.get(e);n!==void 0&&n!==t&&this.reverse.delete(n);let r=this.reverse.get(t);return r!==void 0&&r!==e&&this.map.delete(r),this.map.set(e,t),this.reverse.set(t,e),this}get size(){return this.map.size}values(){return this.map.values()}[Symbol.iterator](){return this.map[Symbol.iterator]()}},f=class{_id=0;referenceOrder=new Set;registerOrder=new Set;selectorToId=new Map;values=new Map;get(e){let t=this.idOrSelector(e);if(t.id!==void 0)return this.values.get(t.id);let n=t.selector===void 0?void 0:JSON.stringify(t.selector);if(n){let e=this.selectorToId.get(n);if(e!==void 0)return this.values.get(e)}}get id(){return this._id++}idOrSelector(e){return typeof e==`number`?{id:e}:{selector:e}}isRegistered(e){let t=this.get(e);return t?this.registerOrder.has(t.id):!1}reference(e){let t=this.idOrSelector(e);return this.register(t)}*referenced(){for(let e of this.referenceOrder.values())yield this.values.get(e)}register(e){if(e.id!==void 0){let t=this.values.get(e.id);if(!t)throw Error(`File with ID ${e.id} not found. To register a new file, leave the ID undefined.`);return t}let t=Object.keys(e).some(e=>![`id`,`selector`].includes(e)),n,r=e.selector===void 0?void 0:JSON.stringify(e.selector);if(r){let e=this.selectorToId.get(r);if(e!==void 0){if(n=this.values.get(e),!n)throw Error(`File with ID ${e} not found. The selector ${r} matched an ID, but there was no result. This is likely an issue with the application logic.`);if(!t)return n}}let i=n?.id===void 0?this.id:n.id;return n={...n,...e,id:i,resolvedNames:n?.resolvedNames??new d,symbols:n?.symbols??{body:[],exports:[],imports:[]}},this.values.set(i,n),t?(this.registerOrder.add(i),this.referenceOrder.has(i)&&this.referenceOrder.delete(i)):this.referenceOrder.add(i),r&&this.selectorToId.set(r,i),n}*registered(){for(let e of this.registerOrder.values())yield this.values.get(e)}};const p=e=>`_heyapi_${e}_`,m=e=>e.slice(8,-1),h=()=>new RegExp(p(`\\d+`),`g`),g=(e,t)=>e.replace(h(),e=>t(Number.parseInt(m(e),10))||e);var _=class{_id=0;nodes=new Map;registerOrder=new Set;selectorToId=new Map;values=new Map;get(e){let t=this.idOrSelector(e);if(t.id!==void 0)return this.values.get(t.id);let n=t.selector===void 0?void 0:JSON.stringify(t.selector);if(n){let e=this.selectorToId.get(n);if(e!==void 0)return this.values.get(e)}}getValue(e){return this.nodes.get(e)}hasValue(e){return this.nodes.has(e)}get id(){return this._id++}idOrSelector(e){return typeof e==`number`?{id:e}:{selector:e}}isRegistered(e){let t=this.get(e);return t?this.registerOrder.has(t.id):!1}reference(e){let t=this.idOrSelector(e);return this.register(t)}register(e){if(e.id!==void 0){let t=this.values.get(e.id);if(!t)throw Error(`Symbol with ID ${e.id} not found. To register a new symbol, leave the ID undefined.`);return t}let t=Object.keys(e).some(e=>![`id`,`selector`].includes(e)),n,r=e.selector===void 0?void 0:JSON.stringify(e.selector);if(r){let e=this.selectorToId.get(r);if(e!==void 0){if(n=this.values.get(e),!n)throw Error(`Symbol with ID ${e} not found. The selector ${r} matched an ID, but there was no result. This is likely an issue with the application logic.`);if(!t)return n}}let i=n?.id===void 0?this.id:n.id,a=n?.exportFrom?[...n.exportFrom]:[];return e.exportFrom&&a.push(...e.exportFrom),n={...n,...e,exportFrom:a,id:i,placeholder:n?.placeholder??e.placeholder??p(String(i))},this.values.set(i,n),t&&this.registerOrder.add(i),r&&this.selectorToId.set(r,i),n}*registered(){for(let e of this.registerOrder.values())yield this.values.get(e)}setValue(e,t){return this.nodes.set(e,t)}};const v=`@`;var y=class{symbolIdToFileIds=new Map;defaultFileName;files=new f;fileName;renderers={};root;symbols=new _;constructor({defaultFileName:e,fileName:t,renderers:n,root:r}){this.defaultFileName=e??`main`,this.fileName=typeof t==`string`?()=>t:t,this.renderers=n,this.root=r}getRenderer(e){return e.extension?this.renderers[e.extension]:void 0}prepareFiles(){for(let e of this.symbols.registered()){let t=this.symbolToFileSelector(e),n=this.files.reference(t);n.symbols.body.push(e.id);let r=this.symbolIdToFileIds.get(e.id)??new Set;r.add(n.id),this.symbolIdToFileIds.set(e.id,r);for(let t of e.exportFrom){let r=[t],i=this.files.reference(r);i.id!==n.id&&i.symbols.exports.push(e.id)}}for(let e of this.files.referenced()){if(!e.selector)continue;if(e.selector[0]===`@`){let t=e.selector[1];if(!t){this.files.register({external:!0,selector:e.selector});continue}let n=c.default.extname(t);if(!n){this.files.register({external:!0,path:t,selector:e.selector});continue}this.files.register({extension:n,external:!0,path:t,selector:e.selector});continue}let t=e.selector.slice(0,-1),n=e.selector[e.selector.length-1];n=this.fileName?.(n)||n,this.files.register({extension:`.ts`,name:n,path:c.default.resolve(this.root,...t,`${n}.ts`),selector:e.selector})}}render(e){this.prepareFiles();let t=new Map;for(let n of this.files.registered()){if(n.external||!n.path)continue;let r=this.getRenderer(n);r&&t.set(n.id,{content:r.renderSymbols(n,this,e),path:n.path})}for(let[n,r]of t.entries()){let i=this.files.get(n),a=this.getRenderer(i).renderFile(r.content,i,this,e);a?t.set(i.id,{...r,content:a}):t.delete(i.id)}return Array.from(t.values())}symbolIdToFiles(e){let t=this.symbolIdToFileIds.get(e);return Array.from(t??[]).map(e=>this.files.get(e))}symbolToFileSelector(e){if(e.external)return[`@`,e.external];let t=e.getFilePath?.(e);return t?t.split(`/`):[this.defaultFileName]}};exports.Project=y,exports.createBinding=l,exports.mergeBindings=u,exports.renderIds=g;
//# sourceMappingURL=index.cjs.map