{"version":3,"file":"index.js","names":["names: Array<string>","typeNames: Array<string>","binding: IBinding & Pick<Required<IBinding>, 'aliases' | 'from'>","result","result: IFileOut | undefined","id","result","result: ISymbolOut | undefined","id","exportFrom: Array<string>","extension","files: Map<number, IOutput>"],"sources":["../src/bindings/utils.ts","../src/bimap/bimap.ts","../src/files/registry.ts","../src/renderer/utils.ts","../src/symbols/registry.ts","../src/project/project.ts"],"sourcesContent":["import type { IFileOut } from '../files/types';\nimport type { ISymbolOut } from '../symbols/types';\nimport type { IBinding } from './types';\n\nexport const createBinding = ({\n  file,\n  modulePath,\n  symbol,\n  symbolFile,\n}: {\n  file: IFileOut;\n  modulePath: string;\n  symbol: ISymbolOut;\n  symbolFile: IFileOut;\n}): IBinding => {\n  const names: Array<string> = [];\n  const typeNames: Array<string> = [];\n  const binding: IBinding & Pick<Required<IBinding>, 'aliases' | 'from'> = {\n    aliases: {},\n    from: modulePath,\n  };\n  if (symbol.meta?.importKind) {\n    if (symbol.meta.importKind === 'default') {\n      binding.defaultBinding = symbol.placeholder;\n      if (symbol.meta.kind === 'type') {\n        binding.typeDefaultBinding = true;\n      }\n    } else if (symbol.meta.importKind === 'namespace') {\n      binding.namespaceBinding = symbol.placeholder;\n      if (symbol.meta.kind === 'type') {\n        binding.typeNamespaceBinding = true;\n      }\n    }\n  }\n  // default to named binding\n  if (\n    symbol.meta?.importKind === 'named' ||\n    (!names.length && !binding.defaultBinding && !binding.namespaceBinding)\n  ) {\n    let name = symbol.placeholder;\n    const fileResolvedName = file.resolvedNames.get(symbol.id);\n    if (fileResolvedName) {\n      const symbolFileResolvedName = symbolFile.resolvedNames.get(symbol.id);\n      if (symbolFileResolvedName) {\n        if (symbolFileResolvedName !== fileResolvedName) {\n          name = symbolFileResolvedName;\n          binding.aliases[name] = fileResolvedName;\n        }\n      } else if (symbol.name && fileResolvedName !== symbol.name) {\n        name = symbol.name;\n        binding.aliases[name] = symbol.placeholder;\n      }\n    }\n    names.push(name);\n    if (symbol.meta?.kind === 'type') {\n      typeNames.push(name);\n    }\n  }\n  // cast type names to names to allow for cleaner API,\n  // otherwise users would have to define the same values twice\n  for (const typeName of typeNames) {\n    if (!names.includes(typeName)) {\n      names.push(typeName);\n    }\n  }\n  binding.names = names;\n  binding.typeNames = typeNames;\n  return binding;\n};\n\nexport const mergeBindings = (target: IBinding, source: IBinding): void => {\n  target.aliases = { ...target.aliases, ...source.aliases };\n  if (source.defaultBinding !== undefined) {\n    target.defaultBinding = source.defaultBinding;\n  }\n  target.names = [\n    ...new Set([...(target.names ?? []), ...(source.names ?? [])]),\n  ];\n  if (source.namespaceBinding !== undefined) {\n    target.namespaceBinding = source.namespaceBinding;\n  }\n  if (source.typeDefaultBinding !== undefined) {\n    target.typeDefaultBinding = source.typeDefaultBinding;\n  }\n  target.typeNames = [\n    ...new Set([...(target.typeNames ?? []), ...(source.typeNames ?? [])]),\n  ];\n  if (source.typeNamespaceBinding !== undefined) {\n    target.typeNamespaceBinding = source.typeNamespaceBinding;\n  }\n};\n","import type { IBiMap } from './types';\n\nexport class BiMap<Key, Value> implements IBiMap<Key, Value> {\n  private map = new Map<Key, Value>();\n  private reverse = new Map<Value, Key>();\n\n  delete(key: Key): boolean {\n    const value = this.map.get(key);\n    if (value !== undefined) {\n      this.reverse.delete(value);\n    }\n    return this.map.delete(key);\n  }\n\n  deleteValue(value: Value): boolean {\n    const key = this.reverse.get(value);\n    if (key !== undefined) {\n      this.map.delete(key);\n    }\n    return this.reverse.delete(value);\n  }\n\n  entries(): IterableIterator<[Key, Value]> {\n    return this.map.entries();\n  }\n\n  get(key: Key): Value | undefined {\n    return this.map.get(key);\n  }\n\n  getKey(value: Value): Key | undefined {\n    return this.reverse.get(value);\n  }\n\n  hasKey(key: Key): boolean {\n    return this.map.has(key);\n  }\n\n  hasValue(value: Value): boolean {\n    return this.reverse.has(value);\n  }\n\n  keys(): IterableIterator<Key> {\n    return this.map.keys();\n  }\n\n  set(key: Key, value: Value): this {\n    const oldValue = this.map.get(key);\n    if (oldValue !== undefined && oldValue !== value) {\n      this.reverse.delete(oldValue);\n    }\n    const oldKey = this.reverse.get(value);\n    if (oldKey !== undefined && oldKey !== key) {\n      this.map.delete(oldKey);\n    }\n    this.map.set(key, value);\n    this.reverse.set(value, key);\n    return this;\n  }\n\n  get size(): number {\n    return this.map.size;\n  }\n\n  values(): IterableIterator<Value> {\n    return this.map.values();\n  }\n\n  [Symbol.iterator](): IterableIterator<[Key, Value]> {\n    return this.map[Symbol.iterator]();\n  }\n}\n","import { BiMap } from '../bimap/bimap';\nimport type { ISelector } from '../selectors/types';\nimport type { IFileIn, IFileOut, IFileRegistry } from './types';\n\nexport class FileRegistry implements IFileRegistry {\n  private _id: number = 0;\n  private referenceOrder: Set<number> = new Set();\n  private registerOrder: Set<number> = new Set();\n  private selectorToId: Map<string, number> = new Map();\n  private values: Map<number, IFileOut> = new Map();\n\n  get(fileIdOrSelector: number | ISelector): IFileOut | undefined {\n    const symbol = this.idOrSelector(fileIdOrSelector);\n\n    if (symbol.id !== undefined) {\n      return this.values.get(symbol.id);\n    }\n\n    const selector =\n      symbol.selector !== undefined\n        ? JSON.stringify(symbol.selector)\n        : undefined;\n\n    if (selector) {\n      const id = this.selectorToId.get(selector);\n      if (id !== undefined) {\n        return this.values.get(id);\n      }\n    }\n\n    return;\n  }\n\n  get id(): number {\n    return this._id++;\n  }\n\n  private idOrSelector(\n    symbolIdOrSelector: number | ISelector,\n  ): Pick<IFileIn, 'id' | 'selector'> {\n    return typeof symbolIdOrSelector === 'number'\n      ? { id: symbolIdOrSelector }\n      : { selector: symbolIdOrSelector };\n  }\n\n  isRegistered(fileIdOrSelector: number | ISelector): boolean {\n    const file = this.get(fileIdOrSelector);\n    return file ? this.registerOrder.has(file.id) : false;\n  }\n\n  reference(fileIdOrSelector: number | ISelector): IFileOut {\n    const file = this.idOrSelector(fileIdOrSelector);\n    return this.register(file);\n  }\n\n  *referenced(): IterableIterator<IFileOut> {\n    for (const id of this.referenceOrder.values()) {\n      yield this.values.get(id)!;\n    }\n  }\n\n  register(file: IFileIn): IFileOut {\n    if (file.id !== undefined) {\n      const result = this.values.get(file.id);\n      if (!result) {\n        throw new Error(\n          `File with ID ${file.id} not found. To register a new file, leave the ID undefined.`,\n        );\n      }\n      return result;\n    }\n\n    const hasOtherKeys = Object.keys(file).some(\n      (key) => !['id', 'selector'].includes(key),\n    );\n\n    let result: IFileOut | undefined;\n\n    const selector =\n      file.selector !== undefined ? JSON.stringify(file.selector) : undefined;\n    if (selector) {\n      const id = this.selectorToId.get(selector);\n      if (id !== undefined) {\n        result = this.values.get(id);\n        if (!result) {\n          throw new Error(\n            `File with ID ${id} not found. The selector ${selector} matched an ID, but there was no result. This is likely an issue with the application logic.`,\n          );\n        }\n        if (!hasOtherKeys) {\n          return result;\n        }\n      }\n    }\n\n    const id = result?.id !== undefined ? result.id : this.id;\n    result = {\n      ...result,\n      ...file, // clone to avoid mutation\n      id,\n      resolvedNames: result?.resolvedNames ?? new BiMap(),\n      symbols: result?.symbols ?? {\n        body: [],\n        exports: [],\n        imports: [],\n      },\n    };\n    this.values.set(id, result);\n\n    if (hasOtherKeys) {\n      this.registerOrder.add(id);\n      if (this.referenceOrder.has(id)) {\n        this.referenceOrder.delete(id);\n      }\n    } else {\n      this.referenceOrder.add(id);\n    }\n\n    if (selector) {\n      this.selectorToId.set(selector, id);\n    }\n\n    return result;\n  }\n\n  *registered(): IterableIterator<IFileOut> {\n    for (const id of this.registerOrder.values()) {\n      yield this.values.get(id)!;\n    }\n  }\n}\n","/**\n * Wraps an ID in namespace to avoid collisions when replacing it.\n *\n * @param symbolId Stringified symbol ID to use.\n * @returns The wrapped placeholder ID.\n */\nexport const wrapId = (symbolId: string): string => `_heyapi_${symbolId}_`;\n\n/**\n * Unwraps an ID from namespace.\n *\n * @param wrappedId The wrapped placeholder ID.\n * @returns Stringified ID to use.\n */\nconst unwrapId = (wrappedId: string): string =>\n  wrappedId.slice('_heyapi_'.length, -1);\n\n/**\n * Returns a RegExp instance to match ID placeholders.\n *\n * @returns RegExp instance to match ID placeholders.\n */\nconst createPlaceholderRegExp = (): RegExp => new RegExp(wrapId('\\\\d+'), 'g');\n\n/**\n *\n * @param source The source string to replace.\n * @param replacerFn Accepts a symbol ID, returns resolved symbol name.\n * @returns The replaced source string.\n */\nexport const renderIds = (\n  source: string,\n  replacerFn: (symbolId: number) => string | undefined,\n): string =>\n  source.replace(createPlaceholderRegExp(), (match) => {\n    const symbolId = Number.parseInt(unwrapId(match), 10);\n    return replacerFn(symbolId) || match;\n  });\n","import { wrapId } from '../renderer/utils';\nimport type { ISelector } from '../selectors/types';\nimport type { ISymbolIn, ISymbolOut, ISymbolRegistry } from './types';\n\nexport class SymbolRegistry implements ISymbolRegistry {\n  private _id: number = 0;\n  private nodes: Map<number, unknown> = new Map();\n  private registerOrder: Set<number> = new Set();\n  private selectorToId: Map<string, number> = new Map();\n  private values: Map<number, ISymbolOut> = new Map();\n\n  get(symbolIdOrSelector: number | ISelector): ISymbolOut | undefined {\n    const symbol = this.idOrSelector(symbolIdOrSelector);\n\n    if (symbol.id !== undefined) {\n      return this.values.get(symbol.id);\n    }\n\n    const selector =\n      symbol.selector !== undefined\n        ? JSON.stringify(symbol.selector)\n        : undefined;\n\n    if (selector) {\n      const id = this.selectorToId.get(selector);\n      if (id !== undefined) {\n        return this.values.get(id);\n      }\n    }\n\n    return;\n  }\n\n  getValue(symbolId: number): unknown {\n    return this.nodes.get(symbolId);\n  }\n\n  hasValue(symbolId: number): boolean {\n    return this.nodes.has(symbolId);\n  }\n\n  get id(): number {\n    return this._id++;\n  }\n\n  private idOrSelector(\n    symbolIdOrSelector: number | ISelector,\n  ): Pick<ISymbolIn, 'id' | 'selector'> {\n    return typeof symbolIdOrSelector === 'number'\n      ? { id: symbolIdOrSelector }\n      : { selector: symbolIdOrSelector };\n  }\n\n  isRegistered(symbolIdOrSelector: number | ISelector): boolean {\n    const symbol = this.get(symbolIdOrSelector);\n    return symbol ? this.registerOrder.has(symbol.id) : false;\n  }\n\n  reference(symbolIdOrSelector: number | ISelector): ISymbolOut {\n    const symbol = this.idOrSelector(symbolIdOrSelector);\n    return this.register(symbol);\n  }\n\n  register(symbol: ISymbolIn): ISymbolOut {\n    if (symbol.id !== undefined) {\n      const result = this.values.get(symbol.id);\n      if (!result) {\n        throw new Error(\n          `Symbol with ID ${symbol.id} not found. To register a new symbol, leave the ID undefined.`,\n        );\n      }\n      return result;\n    }\n\n    const hasOtherKeys = Object.keys(symbol).some(\n      (key) => !['id', 'selector'].includes(key),\n    );\n\n    let result: ISymbolOut | undefined;\n\n    const selector =\n      symbol.selector !== undefined\n        ? JSON.stringify(symbol.selector)\n        : undefined;\n    if (selector) {\n      const id = this.selectorToId.get(selector);\n      if (id !== undefined) {\n        result = this.values.get(id);\n        if (!result) {\n          throw new Error(\n            `Symbol with ID ${id} not found. The selector ${selector} matched an ID, but there was no result. This is likely an issue with the application logic.`,\n          );\n        }\n        if (!hasOtherKeys) {\n          return result;\n        }\n      }\n    }\n\n    const id = result?.id !== undefined ? result.id : this.id;\n    const exportFrom: Array<string> = result?.exportFrom\n      ? [...result.exportFrom]\n      : [];\n    if (symbol.exportFrom) {\n      exportFrom.push(...symbol.exportFrom);\n    }\n    result = {\n      ...result,\n      ...symbol, // clone to avoid mutation\n      exportFrom,\n      id,\n      placeholder:\n        result?.placeholder ?? symbol.placeholder ?? wrapId(String(id)),\n    };\n    this.values.set(id, result);\n\n    if (hasOtherKeys) {\n      this.registerOrder.add(id);\n    }\n\n    if (selector) {\n      this.selectorToId.set(selector, id);\n    }\n\n    return result;\n  }\n\n  *registered(): IterableIterator<ISymbolOut> {\n    for (const id of this.registerOrder.values()) {\n      yield this.values.get(id)!;\n    }\n  }\n\n  setValue(symbolId: number, value: unknown): Map<number, unknown> {\n    return this.nodes.set(symbolId, value);\n  }\n}\n","import path from 'node:path';\n\nimport type { IProjectRenderMeta } from '../extensions/types';\nimport { FileRegistry } from '../files/registry';\nimport type { IFileOut } from '../files/types';\nimport type { IOutput } from '../output/types';\nimport type { IRenderer } from '../renderer/types';\nimport type { ISelector } from '../selectors/types';\nimport { SymbolRegistry } from '../symbols/registry';\nimport type { ISymbolOut } from '../symbols/types';\nimport type { IProject } from './types';\n\nconst externalSourceSymbol = '@';\n\nexport class Project implements IProject {\n  private symbolIdToFileIds: Map<number, Set<number>> = new Map();\n\n  readonly defaultFileName: string;\n  readonly files = new FileRegistry();\n  readonly fileName?: (name: string) => string;\n  readonly renderers: Record<string, IRenderer> = {};\n  readonly root: string;\n  readonly symbols = new SymbolRegistry();\n\n  constructor({\n    defaultFileName,\n    fileName,\n    renderers,\n    root,\n  }: Pick<IProject, 'defaultFileName' | 'fileName' | 'renderers' | 'root'>) {\n    this.defaultFileName = defaultFileName ?? 'main';\n    this.fileName = typeof fileName === 'string' ? () => fileName : fileName;\n    this.renderers = renderers;\n    this.root = root;\n  }\n\n  private getRenderer(file: IFileOut): IRenderer | undefined {\n    return file.extension ? this.renderers[file.extension] : undefined;\n  }\n\n  private prepareFiles(): void {\n    // TODO: infer extension from symbols\n    const extension = '.ts';\n    for (const symbol of this.symbols.registered()) {\n      const selector = this.symbolToFileSelector(symbol);\n      const file = this.files.reference(selector);\n      file.symbols.body.push(symbol.id);\n      // update symbol->files map\n      const symbolIdToFileIds =\n        this.symbolIdToFileIds.get(symbol.id) ?? new Set();\n      symbolIdToFileIds.add(file.id);\n      this.symbolIdToFileIds.set(symbol.id, symbolIdToFileIds);\n      // update re-exports\n      for (const exportFrom of symbol.exportFrom) {\n        const exportSelector = [exportFrom];\n        const exportFile = this.files.reference(exportSelector);\n        if (exportFile.id !== file.id) {\n          exportFile.symbols.exports.push(symbol.id);\n        }\n      }\n    }\n    for (const file of this.files.referenced()) {\n      if (!file.selector) continue;\n      if (file.selector[0] === externalSourceSymbol) {\n        const filePath = file.selector[1];\n        if (!filePath) {\n          this.files.register({\n            external: true,\n            selector: file.selector,\n          });\n          continue;\n        }\n        const extension = path.extname(filePath);\n        if (!extension) {\n          this.files.register({\n            external: true,\n            path: filePath,\n            selector: file.selector,\n          });\n          continue;\n        }\n        this.files.register({\n          extension,\n          external: true,\n          path: filePath,\n          selector: file.selector,\n        });\n        continue;\n      }\n      const dirs = file.selector.slice(0, -1);\n      let name = file.selector[file.selector.length - 1]!;\n      name = this.fileName?.(name) || name;\n      this.files.register({\n        extension,\n        name,\n        path: path.resolve(this.root, ...dirs, `${name}${extension}`),\n        selector: file.selector,\n      });\n    }\n\n    // TODO: track symbol dependencies and inject imports into files\n    // based on symbol references so the render step can just render\n  }\n\n  render(meta?: IProjectRenderMeta): ReadonlyArray<IOutput> {\n    this.prepareFiles();\n    const files: Map<number, IOutput> = new Map();\n    for (const file of this.files.registered()) {\n      if (file.external || !file.path) continue;\n      const renderer = this.getRenderer(file);\n      if (!renderer) continue;\n      files.set(file.id, {\n        content: renderer.renderSymbols(file, this, meta),\n        path: file.path,\n      });\n    }\n    for (const [fileId, value] of files.entries()) {\n      const file = this.files.get(fileId)!;\n      const renderer = this.getRenderer(file)!;\n      const content = renderer.renderFile(value.content, file, this, meta);\n      if (content) {\n        files.set(file.id, { ...value, content });\n      } else {\n        files.delete(file.id);\n      }\n    }\n    return Array.from(files.values());\n  }\n\n  symbolIdToFiles(symbolId: number): ReadonlyArray<IFileOut> {\n    const fileIds = this.symbolIdToFileIds.get(symbolId);\n    return Array.from(fileIds ?? []).map((fileId) => this.files.get(fileId)!);\n  }\n\n  private symbolToFileSelector(symbol: ISymbolOut): ISelector {\n    if (symbol.external) {\n      return [externalSourceSymbol, symbol.external];\n    }\n    const filePath = symbol.getFilePath?.(symbol);\n    if (filePath) {\n      return filePath.split('/');\n    }\n    return [this.defaultFileName];\n  }\n}\n"],"mappings":"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"}